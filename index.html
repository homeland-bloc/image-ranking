<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <!-- PWA Configuration -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Peony">

    <!-- Favicon for browsers -->
    <link rel="icon" type="image/x-icon" href="favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">

    <!-- Apple Touch Icon for iOS home screen -->
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">

    <!-- Android Chrome Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="favicon/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="favicon/android-chrome-512x512.png">
    <!-- PWA Manifest -->
    <link rel="manifest" href="favicon/site.webmanifest">

    <!-- Canonical URL for GitHub Pages PWA -->
    <link rel="canonical" href="https://bicipikay.github.io/peony/">

    <!-- Theme color for mobile browsers -->
    <meta name="theme-color" content="#C77BA6">

    <title>Peony</title>

    <!-- Supabase JS Client for Realtime -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- SortableJS for drag-and-drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'mauve': {
                            300: '#D88FB8',
                            400: '#C77BA6',
                            500: '#B76E9E',
                            600: '#A86590',
                            700: '#995C82'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lilita+One&display=swap');
        
        @keyframes tickAppear {
            0% { transform: scale(0) rotate(-45deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(0deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        .tick-animation {
            animation: tickAppear 0.6s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal-overlay {
            animation: modalFadeIn 0.2s ease-out;
            background: rgba(0, 0, 0, 0.7);
        }
        @keyframes modalSlideIn {
            from { transform: scale(0.9) translateY(-20px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }
        .modal-content {
            animation: modalSlideIn 0.3s ease-out;
        }
        body {
            background: linear-gradient(to bottom,
                rgba(250, 232, 255, 0.3),
                rgba(220, 252, 231, 0.3)
            );
            min-height: 100vh;
        }
        body.modal-open {
            overflow: hidden;
        }
        .image-loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        @keyframes toastSlideIn {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes toastFadeOut {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-20px); opacity: 0; }
        }
        .toast-notification {
            animation: toastSlideIn 0.3s ease-out;
        }
        .toast-notification.fade-out {
            animation: toastFadeOut 0.3s ease-out;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        input[type="range"]::-webkit-slider-track {
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, rgb(199, 123, 166) 0%, rgb(34, 197, 94) 100%);
        }
        input[type="range"]::-moz-range-track {
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, rgb(199, 123, 166) 0%, rgb(34, 197, 94) 100%);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            border: 2px solid rgb(199, 123, 166);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            border: 2px solid rgb(199, 123, 166);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .upload-area {
            border: 3px dashed #C77BA6;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            border-color: #B76E9E;
            background: rgba(199, 123, 166, 0.05);
        }
        .upload-area.dragover {
            border-color: #22C55E;
            background: rgba(34, 197, 94, 0.1);
            transform: scale(1.02);
        }
        .score-text {
            font-family: 'Lilita One', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), -1px -1px 2px rgba(0,0,0,0.8), 1px -1px 2px rgba(0,0,0,0.8), -1px 1px 2px rgba(0,0,0,0.8);
        }
        .progress-segment {
            height: 8px;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .progress-segment:hover {
            transform: scaleY(1.3);
        }
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background-color: #ccc;
            border-radius: 30px;
            cursor: pointer;
            transition: background-color 0.3s;
            display: inline-block;
        }
        .toggle-switch.active {
            background-color: #C77BA6;
        }
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(30px);
        }
        .voting-image {
            max-height: 50vh;
        }
        @media (min-width: 640px) {
            .voting-image {
                max-height: min(40vh, 500px);
            }
        }
        /* PWA safe area support for iOS and Android fullscreen mode */
        .safe-header {
            padding-top: env(safe-area-inset-top);
        }
        /* Realtime toast notifications - slide in from right */
        @keyframes slideInRight {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background-color: #ccc;
            border-radius: 26px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .toggle-switch.active {
            background-color: #4CAF50;
        }
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="app"></div>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            // Emergency error handler to catch JavaScript errors
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e);
            const app = document.getElementById('app');
            if (app && !app.innerHTML) {
                app.innerHTML = `
                    <div style="padding: 2rem; font-family: sans-serif; max-width: 800px; margin: 0 auto;">
                        <h1 style="color: #ef4444; margin-bottom: 1rem;">‚ö†Ô∏è Error Loading App</h1>
                        <div style="background: #fee; border: 1px solid #fcc; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <p><strong>Error:</strong> ${e.message || 'Unknown error'}</p>
                            <p><strong>File:</strong> ${e.filename || 'Unknown'}</p>
                            <p><strong>Line:</strong> ${e.lineno || 'Unknown'}:${e.colno || 'Unknown'}</p>
                        </div>
                        <p style="margin-bottom: 0.5rem;"><strong>What to do:</strong></p>
                        <ol style="line-height: 1.6;">
                            <li>Open browser console (F12) for detailed error information</li>
                            <li>Check for JavaScript syntax errors in index.html</li>
                            <li>Verify Supabase is loading correctly</li>
                            <li>Clear browser cache and reload the page</li>
                        </ol>
                    </div>
                `;
            }
        });

        // Supabase Configuration
        const SUPABASE_URL = 'https://tbduuuzwbiidjgztupfp.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRiZHV1dXp3YmlpZGpnenR1cGZwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0NTI3NjcsImV4cCI6MjA4MDAyODc2N30.lMDbB1I7vNoMFCncGw7_i9hUtWp-mO9rsmFLgd3GMMQ';

        // Discord OAuth Configuration
        const DISCORD_CLIENT_ID = '1442282566810861568';  // Replace with your actual Discord Client ID
        const DISCORD_REDIRECT_URI = 'https://bicipikay.github.io/peony/auth/callback';  // Replace with YOUR actual GitHub Pages URL + /auth/callback

        // Admin Discord ID - Replace with your actual Discord user ID after first login
        const ADMIN_DISCORD_ID = '719271552247529571';

        // Initialize Supabase client (only if not already initialized to prevent duplicate declaration errors)
        if (typeof window.supabaseClient === 'undefined') {
            window.supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }
        const supabase = window.supabaseClient;

        let state = {
            isLoggedIn: false,
            user: null,
            view: 'home',
            contests: [],
            currentContest: null,
            currentImageIndex: 0,
            votes: {},
            userVotedContests: {},
            hasSubmitted: false,
            showBreakdownModal: null,
            showTickAnimation: false,
            isAnimating: false,
            modal: null,
            modalProcessing: false,
            imageScale: 100,
            results: null,
            scaleUpdateTimeout: null,
            newContest: { title: '', images: [], labelsEnabled: false },
            showMyVotes: false,  // Deprecated, use resultsView
            resultsView: 'average',  // 'average', 'userVotes', or 'byVoter'
            voterSortBy: 'scoreDesc',  // 'scoreDesc', 'scoreAsc', 'nameAsc', 'nameDesc' for byVoter view
            selectedVoterUserId: null,  // For user votes dropdown (null = current user)
            contestVoters: [],  // List of all users who voted in current contest(s)
            shuffledImages: [],
            nextContestId: 1,
            bannedUsers: [], // Array of user IDs who are banned from app
            allUsers: [], // Track all users who have logged in
            uploadProgress: null, // Upload progress tracking: { files: [{name, status, error, progress}], completed: false }
            compressionProgress: null, // Compression progress: { files: [{name, status, originalSize, compressedSize, progress, error, canCompressMore, file, previewUrl, currentQuality, currentMaxDimension}], allComplete: false }
            showUserList: false, // Show user list modal (admin only)
            showAdminDashboard: false, // Show admin dashboard modal
            showAppSettingsModal: false, // Show app settings modal (admin only)
            adminStats: { totalVotes: 0, totalUniqueVoters: 0 }, // Admin dashboard statistics
            filters: {
                createdBy: null,           // Username or null
                sortBy: 'withFolders',     // 'withFolders', 'newest', 'oldest', 'mostVoted', 'leastVoted', etc.
                searchQuery: ''            // Search term for contest titles
            },
            mergedResults: null, // Results from merged contests
            mergers: [], // Array of merger objects from database
            extracts: [], // Array of extract objects from database
            groups: [], // Array of group objects from database
            showCreateMergerModal: false, // Show create merger modal
            showCreateExtractModal: false, // Show create extract modal
            showManageFoldersModal: false, // Show manage folders modal
            newMergerName: '', // Name for new merger being created
            newExtractName: '', // Name for new extract being created
            extractSourceType: null, // 'contest', 'merger', or 'extract'
            extractSourceId: null, // ID of source contest/merger
            extractSelectedImages: [], // Array of image IDs selected for extract
            selectedFolderId: null, // Currently selected folder for viewing
            expandedFolderIds: [], // Array of folder IDs that are expanded
            appSettings: {}, // Global app settings (contest creation enabled, revoting enabled)
            view: 'home',
            viewingUserId: null, // User ID being viewed in profile
            showUserProfileModal: false, // Show user profile modal
            toast: null, // Toast notification { message, icon }
            isLoading: false,
            loadingMessage: '',
            showUserDropdown: false,  // User menu dropdown state
            showMergedContestsDropdown: false,  // Merged contests dropdown state
            currentMergerId: null,  // ID of current merger being voted on
            mergerContestIds: [],  // Array of contest IDs in current merger voting session
            selectedFolderItems: []  // Array of indices for multi-select in Add Item modal
        };

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function formatVoterCount(voterCount, voterCountMin, voterCountMax) {
            if (voterCountMin !== undefined && voterCountMax !== undefined && voterCountMin !== voterCountMax) {
                return `${voterCountMin}-${voterCountMax}`;
            }
            return voterCount;
        }

        function setLoading(message) {
            state.isLoading = true;
            state.loadingMessage = message;
            render();
        }

        function clearLoading() {
            state.isLoading = false;
            state.loadingMessage = '';
            render();
        }

        // ==================== HELPER FUNCTIONS ====================

        // Generic Supabase fetch with cache-busting headers
        async function fetchFromSupabase(endpoint, options = {}) {
            const defaultHeaders = {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                'Pragma': 'no-cache',
                'Expires': '0'
            };

            return fetch(`${SUPABASE_URL}${endpoint}`, {
                ...options,
                headers: { ...defaultHeaders, ...options.headers }
            });
        }

        // Format date as "day month year" (e.g., "30 Nov 2025")
        function formatDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
        }

        // Safely stringify JSON for HTML attributes
        function safeStringify(obj) {
            return JSON.stringify(obj).replace(/'/g, "&apos;");
        }

        // ==================== TOAST NOTIFICATIONS ====================

        /**
         * Show toast notification (lightweight, non-disruptive)
         * Used for user actions (ban/unban, vote submission, etc.)
         * @param {string} message - Message to display
         * @param {string} type - 'info', 'success', 'error', or 'warning'
         * @param {number} duration - Display duration in ms (default 3000)
         */
        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            const bgColors = {
                info: 'bg-blue-500',
                success: 'bg-green-500',
                error: 'bg-red-500',
                warning: 'bg-yellow-500'
            };

            toast.className = `fixed top-20 right-4 z-50 px-4 py-3 rounded-lg shadow-lg text-white text-sm font-medium transition-all transform translate-x-0 ${bgColors[type] || 'bg-gray-700'}`;
            toast.textContent = message;
            toast.style.animation = 'slideInRight 0.3s ease-out';

            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // ==================== END TOAST NOTIFICATIONS ====================

        function getScoreColor(score) {
            const colors = {
                1: 'rgb(220, 38, 38)',
                2: 'rgb(249, 115, 22)',
                3: 'rgb(234, 179, 8)',
                4: 'rgb(132, 204, 22)',
                5: 'rgb(34, 197, 94)'
            };
            return colors[score] || 'rgb(156, 163, 175)';
        }

        function getCategoryLabel(min, max, isMissing) {
            if (isMissing) return 'Votes Missing';
            if (min === 4.5) return '4.5 - 5.0';
            return `${min.toFixed(1)} - ${max.toFixed(2)}`;
        }

        function getCategoryColor(min, isMissing) {
            // Special styling for missing votes - black text on dark gray background
            if (isMissing) return { color: 'text-black', bg: 'bg-gray-400', textColor: 'rgb(0, 0, 0)', bgColor: 'rgb(156, 163, 175)' };

            // Strong blue (4.5-5.0) - highest scores
            if (min >= 4.5) return { color: 'text-blue-700', bg: 'bg-blue-100', textColor: 'rgb(29, 78, 216)', bgColor: 'rgb(219, 234, 254)' };
            // Saturated cyan (4.0-4.49) - very good scores
            if (min >= 4.0) return { color: 'text-cyan-700', bg: 'bg-cyan-100', textColor: 'rgb(14, 116, 144)', bgColor: 'rgb(207, 250, 254)' };
            // Bright green (3.5-3.99) - good scores
            if (min >= 3.5) return { color: 'text-green-700', bg: 'bg-green-100', textColor: 'rgb(21, 128, 61)', bgColor: 'rgb(220, 252, 231)' };
            // Lime-green (3.0-3.49) - above average, MUST be green
            if (min >= 3.0) return { color: 'text-lime-700', bg: 'bg-lime-100', textColor: 'rgb(77, 124, 15)', bgColor: 'rgb(236, 252, 203)' };
            // Bright yellow (2.5-2.99) - average, more saturated and brighter for distinction
            if (min >= 2.5) return { color: 'text-yellow-800', bg: 'bg-yellow-200', textColor: 'rgb(133, 77, 14)', bgColor: 'rgb(254, 240, 138)' };
            // Deep amber/orange (2.0-2.49) - below average, warmer and more orange for clear distinction
            if (min >= 2.0) return { color: 'text-orange-700', bg: 'bg-orange-100', textColor: 'rgb(194, 65, 12)', bgColor: 'rgb(255, 237, 213)' };
            // Deep orange (1.5-1.99) - low scores, darker orange between red and amber
            if (min >= 1.5) return { color: 'text-orange-800', bg: 'bg-orange-200', textColor: 'rgb(154, 52, 18)', bgColor: 'rgb(254, 215, 170)' };
            // Deep red (1.0-1.49) - lowest scores, much redder and darker
            if (min >= 1.0) return { color: 'text-red-800', bg: 'bg-red-300', textColor: 'rgb(153, 27, 27)', bgColor: 'rgb(252, 165, 165)' };
            // Fallback for any edge cases
            return { color: 'text-gray-600', bg: 'bg-gray-50', textColor: 'rgb(75, 85, 99)', bgColor: 'rgb(249, 250, 251)' };
        }


        async function loadResults() {
            setLoading('Loading results...');
            try {
                console.log('üîç DEBUG: Loading results for contest:', state.currentContest.id);
                console.log('üîç DEBUG: Current user:', state.user);

                // Fetch ALL votes with voter info including ban status for breakdown display with aggressive cache-busting
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?contest_id=eq.${state.currentContest.id}&limit=2000&select=*,voter:users!votes_user_id_fkey(username,avatar,is_banned)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const allVotes = await response.json();
                console.log('üîç DEBUG: Fetched votes:', allVotes);

                // Check if votes response is valid
                if (!Array.isArray(allVotes)) {
                    console.error('Invalid votes response:', allVotes);
                    showAlert('Error loading votes: ' + (allVotes.message || 'Invalid response'), '‚ùå');
                    return;
                }

                console.log('üîç DEBUG: Number of votes:', allVotes.length);

                // Warn if we hit the vote limit
                if (allVotes.length === 2000) {
                    console.warn('‚ö†Ô∏è Hit vote limit of 2000 - may be missing votes');
                }

                // Build list of unique voters for dropdown (exclude banned users)
                const votersMap = new Map();
                allVotes.forEach(vote => {
                    const voterIsBanned = vote.voter?.is_banned || false;
                    if (!votersMap.has(vote.user_id) && !voterIsBanned) {
                        votersMap.set(vote.user_id, {
                            userId: vote.user_id,
                            username: vote.voter.username,
                            avatar: vote.voter.avatar
                        });
                    }
                });
                state.contestVoters = Array.from(votersMap.values()).sort((a, b) =>
                    a.username.localeCompare(b.username)
                );

                const imageScores = {};
                allVotes.forEach(vote => {
                    console.log('üîç DEBUG: Processing vote:', vote);
                    if (!imageScores[vote.image_id]) {
                        imageScores[vote.image_id] = {
                            scores: [],
                            breakdown: []
                        };
                    }

                    const isBlocked = vote.is_blocked || false;
                    const voterIsBanned = vote.voter?.is_banned || false;

                    // Only include non-blocked AND non-banned votes in score calculations
                    if (!isBlocked && !voterIsBanned) {
                        imageScores[vote.image_id].scores.push(vote.score);
                    }

                    // Include ALL votes in breakdown (blocked, banned, and non-blocked)
                    imageScores[vote.image_id].breakdown.push({
                        userId: vote.user_id,
                        username: vote.voter.username,
                        avatar: vote.voter.avatar,
                        score: vote.score,
                        isCurrentUser: vote.user_id === state.user?.id,
                        isBlocked: isBlocked,
                        isBanned: voterIsBanned
                    });
                });

                console.log('üîç DEBUG: Image scores:', imageScores);
                console.log('üîç DEBUG: Contest images:', state.currentContest.images);

                // Map images with their scores
                state.results = state.currentContest.images.map(img => {
                    const scores = imageScores[img.id]?.scores || [];
                    const sum = scores.reduce((acc, s) => acc + s, 0);
                    const average = scores.length > 0 ? parseFloat((sum / scores.length).toFixed(2)) : 0;

                    console.log(`üîç DEBUG: Image ${img.id} - scores:`, scores, 'average:', average);

                    return {
                        ...img,
                        averageScore: average,
                        totalVotes: scores.length,
                        breakdown: imageScores[img.id]?.breakdown || []
                    };
                }).sort(compareWithTieBreaking);

                console.log('üîç DEBUG: Final results:', state.results);
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        async function loadMergedResults(contestIds) {
            setLoading('Loading merged results...');
            try {
                // Fetch contests with their images
                const contestsResponse = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=in.(${contestIds.join(',')})&select=*,images(*)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const contests = await contestsResponse.json();

                // Fetch ALL votes for these contests using pagination
                let allVotes = [];
                let offset = 0;
                const limit = 1000;
                let hasMore = true;

                while (hasMore) {
                    setLoading(`Loading votes... (${allVotes.length} loaded)`);

                    const votesResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?contest_id=in.(${contestIds.join(',')})&limit=${limit}&offset=${offset}&select=*,voter:users!votes_user_id_fkey(username,avatar,is_banned)`, {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    });
                    const votes = await votesResponse.json();

                    allVotes = allVotes.concat(votes);

                    // If we got fewer results than the limit, we've reached the end
                    if (votes.length < limit) {
                        hasMore = false;
                    } else {
                        offset += limit;
                    }
                }

                // Build image scores from votes
                const imageScores = {};
                allVotes.forEach(vote => {
                    if (!imageScores[vote.image_id]) {
                        imageScores[vote.image_id] = {
                            scores: [],
                            breakdown: []
                        };
                    }

                    const isBlocked = vote.is_blocked || false;
                    const voterIsBanned = vote.voter?.is_banned || false;

                    // Only include non-blocked AND non-banned votes in score calculations
                    if (!isBlocked && !voterIsBanned) {
                        imageScores[vote.image_id].scores.push(vote.score);
                    }

                    // Include ALL votes in breakdown
                    imageScores[vote.image_id].breakdown.push({
                        userId: vote.user_id,
                        username: vote.voter.username,
                        avatar: vote.voter.avatar,
                        score: vote.score,
                        isCurrentUser: vote.user_id === state.user?.id,
                        isBlocked: isBlocked,
                        isBanned: voterIsBanned
                    });
                });

                // Collect all images from all contests
                const allImages = [];
                const contestTitles = {};

                contests.forEach(contest => {
                    contestTitles[contest.id] = contest.title;
                    contest.images.forEach(img => {
                        const scores = imageScores[img.id]?.scores || [];
                        const sum = scores.reduce((acc, s) => acc + s, 0);
                        const average = scores.length > 0 ? parseFloat((sum / scores.length).toFixed(2)) : 0;

                        allImages.push({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            contestId: contest.id,
                            contestTitle: contest.title,
                            averageScore: average,
                            totalVotes: scores.length,
                            voteBreakdown: imageScores[img.id]?.breakdown || []
                        });
                    });
                });

                // Set merged results
                state.mergedResults = {
                    contestIds: contestIds,
                    contestTitles: contestTitles,
                    images: allImages.sort(compareWithTieBreaking)
                };

            } catch (error) {
                console.error('Error loading merged results:', error);
                showAlert('Error loading merged results: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        // Temporary stub for merge functionality - returns empty results
        // TODO: Implement proper async merge functionality with database queries
        // Tie-breaking logic: when scores are equal, count 5s, 4s, 3s, 2s, 1s
        function compareWithTieBreaking(a, b) {
            // First, compare by average score
            const scoreDiff = b.averageScore - a.averageScore;
            if (Math.abs(scoreDiff) > 0.001) return scoreDiff; // Not a tie

            // Tie detected - count votes by score level
            const getVoteCounts = (item) => {
                const counts = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
                if (item.breakdown && Array.isArray(item.breakdown)) {
                    item.breakdown.forEach(vote => {
                        if (!vote.isBlocked && counts[vote.score] !== undefined) {
                            counts[vote.score]++;
                        }
                    });
                }
                return counts;
            };

            const countsA = getVoteCounts(a);
            const countsB = getVoteCounts(b);

            // Compare 5s, then 4s, then 3s, etc.
            for (let score = 5; score >= 1; score--) {
                if (countsB[score] !== countsA[score]) {
                    return countsB[score] - countsA[score];
                }
            }

            // If still equal, use total vote count
            const totalA = a.breakdown?.filter(v => !v.isBlocked).length || 0;
            const totalB = b.breakdown?.filter(v => !v.isBlocked).length || 0;
            if (totalB !== totalA) return totalB - totalA;

            // If still equal, maintain original order
            return 0;
        }

        function groupByScoreRange(results) {
            const ranges = [
                { min: 4.5, max: 5.0 },
                { min: 4.0, max: 4.49 },
                { min: 3.5, max: 3.99 },
                { min: 3.0, max: 3.49 },
                { min: 2.5, max: 2.99 },
                { min: 2.0, max: 2.49 },
                { min: 1.5, max: 1.99 },
                { min: 1.0, max: 1.49 }
            ];

            const grouped = {};

            // Check for images with missing votes (averageScore === 0 or null)
            const missingVotes = results.filter(r => !r.averageScore || r.averageScore === 0);
            if (missingVotes.length > 0) {
                grouped['missing'] = {
                    items: missingVotes,
                    min: 0,
                    max: 0,
                    isMissing: true
                };
            }

            // Group images by score ranges (only those with actual votes)
            ranges.forEach(range => {
                const key = `${range.min}-${range.max}`;
                const items = results.filter(r => r.averageScore > 0 && r.averageScore >= range.min && r.averageScore <= range.max);
                if (items.length > 0) {
                    grouped[key] = {
                        items: items.sort(compareWithTieBreaking),
                        min: range.min,
                        max: range.max
                    };
                }
            });

            return grouped;
        }

        function groupMyVotesByScore(results) {
            const grouped = {};

            [5, 4, 3, 2, 1].forEach(score => {
                const items = results.filter(r => r.averageScore === score);
                if (items.length > 0) {
                    grouped[score] = {
                        items: items,
                        score: score
                    };
                }
            });

            return grouped;
        }

        /**
         * Generate voter statistics from loaded results
         * Calculates each voter's average score across all images they voted on
         * Uses only data from state.results (already loaded from database)
         *
         * @returns {Array} Array of voter objects with calculated averages, sorted by average score (highest first)
         */
        function generateVoterStats() {
            if (!state.results) return [];

            // Accumulator for voter data
            // Structure: { userId: { votes: [], totalScore: 0, totalImages: 0, username, avatar, etc. } }
            const voterVotes = {};

            // Collect votes from all images in loaded results
            state.results.forEach(imageResult => {
                if (!imageResult.breakdown) return;

                imageResult.breakdown.forEach(vote => {
                    // Skip blocked votes
                    if (vote.isBlocked) return;

                    if (!voterVotes[vote.userId]) {
                        voterVotes[vote.userId] = {
                            userId: vote.userId,
                            username: vote.username,
                            avatar: vote.avatar,
                            isCurrentUser: vote.isCurrentUser || false,
                            votes: [],
                            totalScore: 0,
                            totalImages: 0
                        };
                    }

                    voterVotes[vote.userId].votes.push(vote.score);
                    voterVotes[vote.userId].totalScore += vote.score;
                    voterVotes[vote.userId].totalImages++;
                });
            });

            // Calculate averages and sort based on state.voterSortBy
            const voters = Object.values(voterVotes)
                .map(voter => ({
                    ...voter,
                    averageScore: voter.totalImages > 0
                        ? parseFloat((voter.totalScore / voter.totalImages).toFixed(2))
                        : 0
                }));

            // Apply sorting based on state.voterSortBy
            switch (state.voterSortBy) {
                case 'scoreAsc':
                    return voters.sort((a, b) => a.averageScore - b.averageScore);
                case 'nameAsc':
                    return voters.sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
                case 'nameDesc':
                    return voters.sort((a, b) => b.username.toLowerCase().localeCompare(a.username.toLowerCase()));
                case 'scoreDesc':
                default:
                    return voters.sort((a, b) => b.averageScore - a.averageScore);
            }
        }

        function showModal(config) {
            if (state.modalProcessing) return;
            state.modal = config;
            document.body.classList.add('modal-open');
            render();
        }

        function closeModal() {
            if (state.modalProcessing) return;
            state.modal = null;
            state.modalProcessing = false;
            document.body.classList.remove('modal-open');
            render();
        }

        function showAlert(message, icon = 'üö®') {
            showModal({
                type: 'alert',
                icon,
                message,
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showContestCreationDisabledModal() {
            showModal({
                type: 'alert',
                icon: 'üîí',
                message: 'Contest creation is temporarily disabled. Contact admin for more information.',
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showRevotingDisabledModal() {
            showModal({
                type: 'alert',
                icon: 'üîí',
                message: 'Revoting is temporarily disabled. Contact admin for more information.',
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showConfirm(message, onConfirmName, icon = 'üö®') {
            showModal({
                type: 'confirm',
                icon,
                message,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Confirm', action: onConfirmName, primary: true }
                ]
            });
        }

        function showToast(message, icon = '‚úÖ') {
            state.toast = { message, icon };
            render();

            // Auto-dismiss after 2.5 seconds
            setTimeout(() => {
                const toastEl = document.querySelector('.toast-notification');
                if (toastEl) {
                    toastEl.classList.add('fade-out');
                }
                setTimeout(() => {
                    state.toast = null;
                    render();
                }, 300);
            }, 2500);
        }

        function showInputModal(title, placeholder, onConfirmAction, allowEmpty = false) {
            showModal({
                type: 'input',
                icon: '‚úèÔ∏è',
                title,
                placeholder,
                allowEmpty,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Continue', action: onConfirmAction, primary: true }
                ]
            });
        }

        async function confirmSubmitVotes() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            render(); // Close modal immediately before async work

            setLoading('Submitting votes...');

            // Timeout fallback: force clear loading and show error if submission takes >10 seconds
            const timeoutId = setTimeout(() => {
                if (state.isLoading) {
                    clearLoading();
                    showAlert('Vote submission timed out. Please try again.', '‚ùå');
                    state.modalProcessing = false;
                    render();
                }
            }, 10000);

            // Check if we're in merger voting mode
            const isMergerVoting = state.currentMergerId && state.mergerContestIds.length > 0;

            const votesToSubmit = [];
            state.shuffledImages.forEach(img => {
                if (state.votes[img.id]) {
                    // Find which contest this image belongs to
                    let contestId;
                    if (isMergerVoting) {
                        // In merger mode, find the original contest for each image
                        const contest = state.contests.find(c =>
                            state.mergerContestIds.includes(c.id) &&
                            c.images.some(i => i.id === img.id)
                        );
                        contestId = contest ? contest.id : state.mergerContestIds[0];
                    } else {
                        contestId = state.currentContest.id;
                    }

                    votesToSubmit.push({
                        user_id: state.user.id,
                        image_id: img.id,
                        contest_id: contestId,
                        score: state.votes[img.id]
                    });
                }
            });

            try {
                // Group votes by contest for checking existing votes
                const votesByContest = {};
                votesToSubmit.forEach(vote => {
                    if (!votesByContest[vote.contest_id]) {
                        votesByContest[vote.contest_id] = [];
                    }
                    votesByContest[vote.contest_id].push(vote);
                });

                // Process votes for each contest
                for (const contestId of Object.keys(votesByContest)) {
                    const contestVotes = votesByContest[contestId];

                    // Check if votes already exist for this user and contest
                    const existingVotesResponse = await fetch(
                        `${SUPABASE_URL}/rest/v1/votes?user_id=eq.${state.user.id}&contest_id=eq.${contestId}&select=*`,
                        {
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Cache-Control': 'no-cache'
                            }
                        }
                    );

                    if (!existingVotesResponse.ok) {
                        throw new Error('Failed to check existing votes');
                    }

                    const existingVotes = await existingVotesResponse.json();

                    if (existingVotes.length > 0) {
                        // Votes exist - update them using PATCH
                        const updatePromises = contestVotes.map(async (vote) => {
                            const response = await fetch(
                                `${SUPABASE_URL}/rest/v1/votes?user_id=eq.${vote.user_id}&contest_id=eq.${vote.contest_id}&image_id=eq.${vote.image_id}`,
                                {
                                    method: 'PATCH',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'apikey': SUPABASE_ANON_KEY,
                                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                        'Prefer': 'return=minimal',
                                        'Cache-Control': 'no-cache'
                                    },
                                    body: JSON.stringify({ score: vote.score })
                                }
                            );

                            if (!response.ok) {
                                throw new Error(`Failed to update vote for image ${vote.image_id}`);
                            }
                        });

                        await Promise.all(updatePromises);
                    } else {
                        // No existing votes - insert new ones using POST
                        const response = await fetch(`${SUPABASE_URL}/rest/v1/votes`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Prefer': 'return=minimal',
                                'Cache-Control': 'no-cache'
                            },
                            body: JSON.stringify(contestVotes)
                        });

                        if (!response.ok) {
                            throw new Error('Failed to submit votes');
                        }
                    }
                }

                await loadUserVotes();
                state.hasSubmitted = true;

                // Navigate to appropriate results view
                if (isMergerVoting) {
                    // Load merged results and display
                    const merger = state.mergers.find(m => m.id === state.currentMergerId);
                    if (merger) {
                        await loadMergedResults(merger.contestIds);
                        state.view = 'mergedResults';
                        state.resultsView = 'average';
                        state.showMyVotes = false;

                        // Update URL hash
                        window.location.hash = `merge=${state.currentMergerId}`;
                    }
                } else {
                    // Switch to single contest results view
                    state.view = 'results';
                    await loadResults();

                    // Update URL hash
                    window.location.hash = `contest=${state.currentContest.id}`;
                }

                // Update voter counts for affected contests
                const contestIdsToUpdate = isMergerVoting
                    ? state.mergerContestIds
                    : [state.currentContest.id];

                for (const contestId of contestIdsToUpdate) {
                    try {
                        // Fetch all non-blocked votes for this contest
                        const votesResponse = await fetch(
                            `${SUPABASE_URL}/rest/v1/votes?contest_id=eq.${contestId}&is_blocked=eq.false&select=user_id`,
                            {
                                headers: {
                                    'apikey': SUPABASE_ANON_KEY,
                                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                    'Cache-Control': 'no-cache'
                                }
                            }
                        );

                        if (votesResponse.ok) {
                            const votes = await votesResponse.json();
                            const uniqueVoters = new Set(votes.map(v => v.user_id)).size;

                            // Update contest with voter counts
                            await fetch(
                                `${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}`,
                                {
                                    method: 'PATCH',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'apikey': SUPABASE_ANON_KEY,
                                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                        'Prefer': 'return=minimal'
                                    },
                                    body: JSON.stringify({
                                        voter_count_min: uniqueVoters,
                                        voter_count_max: uniqueVoters
                                    })
                                }
                            );
                        }
                    } catch (error) {
                        console.error(`Error updating voter count for contest ${contestId}:`, error);
                    }
                }

                // Update merger voter counts if applicable
                if (isMergerVoting && state.currentMergerId) {
                    try {
                        const merger = state.mergers.find(m => m.id === state.currentMergerId);
                        if (merger && merger.contestIds) {
                            // Calculate min/max across all contests in merger
                            const voterCounts = [];
                            for (const contestId of merger.contestIds) {
                                const votesResponse = await fetch(
                                    `${SUPABASE_URL}/rest/v1/votes?contest_id=eq.${contestId}&is_blocked=eq.false&select=user_id`,
                                    {
                                        headers: {
                                            'apikey': SUPABASE_ANON_KEY,
                                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                            'Cache-Control': 'no-cache'
                                        }
                                    }
                                );
                                if (votesResponse.ok) {
                                    const votes = await votesResponse.json();
                                    voterCounts.push(new Set(votes.map(v => v.user_id)).size);
                                }
                            }

                            if (voterCounts.length > 0) {
                                const voterCountMin = Math.min(...voterCounts);
                                const voterCountMax = Math.max(...voterCounts);

                                await fetch(
                                    `${SUPABASE_URL}/rest/v1/mergers?id=eq.${state.currentMergerId}`,
                                    {
                                        method: 'PATCH',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'apikey': SUPABASE_ANON_KEY,
                                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                            'Prefer': 'return=minimal'
                                        },
                                        body: JSON.stringify({
                                            voter_count_min: voterCountMin,
                                            voter_count_max: voterCountMax
                                        })
                                    }
                                );
                            }
                        }
                    } catch (error) {
                        console.error('Error updating merger voter counts:', error);
                    }
                }

                // Refresh contest list to update voter counts
                await loadContests();

                // Clear processing state and clear loading before final render
                state.modalProcessing = false;
                clearTimeout(timeoutId);
                clearLoading();

                // Final render to show results view
                render();
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);

                // Ensure loading is cleared and modal processing is reset
                clearTimeout(timeoutId);
                clearLoading();
                state.modalProcessing = false;

                // Show error to user
                showAlert('Failed to submit votes: ' + error.message, '‚ùå');
                render();
            }
        }

        function confirmCancelVoting() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.view = 'home';
            state.currentContest = null;
            state.modalProcessing = false;
            render();
        }

        function canDeleteContest(contest) {
            if (!state.user) return false;

            // Check if user is contest creator
            if (contest.createdBy === state.user.id) return true;

            // Admin check
            return state.user.id === ADMIN_DISCORD_ID;
        }

        function deleteContest(contestId) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) return;

            // Store contest info for validation
            state.contestToDelete = contest;

            showInputModal(
                `Type "${contest.title}" to confirm deletion`,
                'Enter contest title exactly...',
                'handleDeleteContestConfirmation',
                false
            );
        }

        function handleDeleteContestConfirmation() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const enteredTitle = input ? input.value.trim() : '';

            if (!state.contestToDelete) {
                showAlert('Contest information not found.', '‚ùå');
                return;
            }

            if (enteredTitle !== state.contestToDelete.title) {
                showAlert('Title does not match. Deletion cancelled.', '‚ùå');
                return;
            }

            // Title matches, proceed with deletion
            confirmDeleteContest(state.contestToDelete.id);
        }

        async function confirmDeleteContest(contestId) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            setLoading('Deleting contest...');

            try {
                // First, fetch contest images to clean up storage
                const contest = state.contests.find(c => c.id === contestId);
                if (contest && contest.images) {
                    const filesToDelete = [];

                    for (const image of contest.images) {
                        // Only delete images that were uploaded to storage (not external URLs)
                        if (image.isFileUpload && image.url) {
                            // Extract file path from Supabase storage URL
                            // URL format: https://{project}.supabase.co/storage/v1/object/public/contest-images/{fileName}
                            const urlParts = image.url.split('/contest-images/');
                            if (urlParts.length === 2) {
                                filesToDelete.push(urlParts[1]);
                            }
                        }
                    }

                    // Delete files from storage if there are any
                    if (filesToDelete.length > 0) {
                        console.log('Deleting files from storage:', filesToDelete);
                        const { data, error } = await supabase.storage
                            .from('contest-images')
                            .remove(filesToDelete);

                        if (error) {
                            console.warn('Storage cleanup error:', error);
                            // Don't fail the entire deletion if storage cleanup fails
                        } else {
                            console.log('Successfully deleted files from storage:', data);
                        }
                    }
                }

                // Now delete the contest from database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete contest');
                }

                await loadContests();
                delete state.userVotedContests[contestId];
                state.modalProcessing = false;
                showAlert('Contest deleted successfully!', '‚úÖ');
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Failed to delete contest: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            } finally {
                clearLoading();
            }
        }

        function startCreateContest() {
            showInputModal('Contest Title', 'Enter contest title...', 'handleContestTitle', false);
        }

        function handleContestTitle() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const title = input ? input.value.trim() : '';

            if (!title || title.length === 0) {
                showAlert('Contest title cannot be empty.', '‚ùå');
                return;
            }
            if (title.length > 100) {
                showAlert('Contest title is too long (max 100 characters).', '‚ùå');
                return;
            }

            // Check for duplicate title - BLOCK creation entirely
            const existingContest = state.contests.find(c => c.title.toLowerCase() === title.toLowerCase());
            if (existingContest) {
                showAlert('A contest with this title already exists. Please choose a different title.', '‚ùå');
                return;
            }

            state.modalProcessing = true;
            state.newContest.title = title;
            state.newContest.images = [];
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.view = 'createContest';
            state.modalProcessing = false;
            render();
        }

        function confirmCreateWithDuplicateTitle() {
            state.modalProcessing = true;
            const title = state.tempContestTitle;
            state.tempContestTitle = null;
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.newContest.title = title;
            state.newContest.images = [];
            state.view = 'createContest';
            state.modalProcessing = false;
            render();
        }

        function cancelCreateContest() {
            showConfirm(
                'Your progress will be lost if you proceed. Are you sure?',
                'confirmCancelCreate',
                'üö®'
            );
        }

        function confirmCancelCreate() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URLs to free memory
            state.newContest.images.forEach(img => {
                if (img.isLocalFile && img.url.startsWith('blob:')) {
                    URL.revokeObjectURL(img.url);
                }
            });

            state.view = 'home';
            state.newContest = { title: '', images: [] };
            state.modalProcessing = false;
            render();
        }

        async function addImageFromUrl(urlInputId) {
            const input = document.getElementById(urlInputId);
            let url = input.value.trim();

            if (!url) {
                showAlert('Please enter an image URL!', '‚ùå');
                return;
            }

            // Convert Discord CDN URLs to media.discordapp.net for compatibility
            url = url.replace(/cdn\.discordapp\.com/g, 'media.discordapp.net');
            url = url.replace(/images-ext-\d+\.discordapp\.net/g, 'media.discordapp.net');

            // Check for duplicate URL
            const isDuplicate = state.newContest.images.some(img => img.url === url);

            if (isDuplicate) {
                console.log('‚ö†Ô∏è Duplicate image URL detected:', url);
                state.tempDuplicateUrl = url;
                state.tempDuplicateUrlInputId = urlInputId;
                showConfirm(
                    '‚ö†Ô∏è This image URL already exists in the contest. Do you want to add it anyway?',
                    'confirmAddDuplicateImage',
                    '‚ö†Ô∏è'
                );
                return;
            }

            // Admin can bypass 50-image limit
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (state.newContest.images.length >= 50 && !isAdmin) {
                showAlert('Maximum 50 images per contest!', '‚ùå');
                return;
            }

            try {
                const img = await loadImageFromUrl(url);
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random(),
                    url,
                    author: null,
                    isFileUpload: false,
                    label: `${imageCount}`
                });
                input.value = '';
                showToast('Image added successfully!', '‚úÖ');
                render();
            } catch (error) {
                showAlert(`Failed to load image: ${error.message}`, '‚ùå');
            }
        }

        async function confirmAddDuplicateImage() {
            const url = state.tempDuplicateUrl;
            const urlInputId = state.tempDuplicateUrlInputId;

            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            if (!url) {
                state.modalProcessing = false;
                return;
            }

            console.log('‚úÖ User confirmed adding duplicate URL:', url);

            // Admin can bypass 50-image limit
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (state.newContest.images.length >= 50 && !isAdmin) {
                showAlert('Maximum 50 images per contest!', '‚ùå');
                state.tempDuplicateUrl = null;
                state.tempDuplicateUrlInputId = null;
                state.modalProcessing = false;
                return;
            }

            try {
                const img = await loadImageFromUrl(url);
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random(),
                    url,
                    author: null,
                    isFileUpload: false,
                    label: `${imageCount}`
                });

                const input = document.getElementById(urlInputId);
                if (input) {
                    input.value = '';
                }

                showToast('Duplicate image added!', '‚úÖ');
            } catch (error) {
                showAlert(`Failed to load image: ${error.message}`, '‚ùå');
            }

            state.tempDuplicateUrl = null;
            state.tempDuplicateUrlInputId = null;
            state.modalProcessing = false;
            render();
        }

        function clearUrlInput() {
            const input = document.getElementById('contestUrlInput');
            if (input) {
                input.value = '';
            }
        }

        // Format file size in human-readable format
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Comprehensive image compression targeting 500 KB
        async function compressImage(file, maxSizeKB = 500, progressCallback = null, currentQuality = null, currentMaxDimension = null) {
            const maxSizeBytes = maxSizeKB * 1024; // 500 KB = 512000 bytes

            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = (e) => {
                    const img = new Image();

                    img.onload = async () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // Preserve original file type (important for PNG transparency)
                        const outputType = file.type || 'image/jpeg';
                        const supportsQuality = outputType === 'image/jpeg' || outputType === 'image/webp';

                        // Helper to resize and draw
                        const drawResized = (maxSize) => {
                            let w = img.width;
                            let h = img.height;

                            if (maxSize && (w > maxSize || h > maxSize)) {
                                if (w > h) {
                                    h = (h * maxSize) / w;
                                    w = maxSize;
                                } else {
                                    w = (w * maxSize) / h;
                                    h = maxSize;
                                }
                            }

                            canvas.width = w;
                            canvas.height = h;
                            ctx.drawImage(img, 0, 0, w, h);
                            return { w, h };
                        };

                        // Helper to try compression with specific quality and size
                        const tryCompress = (quality, maxDimension) => {
                            return new Promise((res) => {
                                drawResized(maxDimension);
                                // Only use quality parameter for formats that support it
                                const blobOptions = supportsQuality ? quality : undefined;
                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        res({ blob, quality, maxDimension });
                                    } else {
                                        res(null);
                                    }
                                }, outputType, blobOptions);
                            });
                        };

                        let result = null;
                        let finalQuality = currentQuality || 0.8;
                        let finalMaxDimension = currentMaxDimension || null;

                        // If specific parameters provided (for "Compress More"), use them
                        if (currentQuality !== null || currentMaxDimension !== null) {
                            result = await tryCompress(finalQuality, finalMaxDimension);
                        } else {
                            // Step 1: Try quality reduction first (no resizing)
                            const qualityLevels = [0.8, 0.7, 0.6, 0.5];
                            for (const quality of qualityLevels) {
                                if (progressCallback) progressCallback(20 + (quality - 0.5) * 20);
                                result = await tryCompress(quality, null);
                                if (result && result.blob.size <= maxSizeBytes) {
                                    finalQuality = quality;
                                    finalMaxDimension = null;
                                    break;
                                }
                            }

                            // Step 2: If quality reduction insufficient, try resizing
                            if (!result || result.blob.size > maxSizeBytes) {
                                const resizeStrategies = [
                                    { maxDim: 2000, quality: 0.6 },
                                    { maxDim: 1500, quality: 0.5 },
                                    { maxDim: 1200, quality: 0.5 },
                                    { maxDim: 1000, quality: 0.4 },
                                    { maxDim: 800, quality: 0.4 }
                                ];

                                for (const strategy of resizeStrategies) {
                                    if (progressCallback) progressCallback(50 + resizeStrategies.indexOf(strategy) * 10);
                                    result = await tryCompress(strategy.quality, strategy.maxDim);
                                    if (result && result.blob.size <= maxSizeBytes) {
                                        finalQuality = strategy.quality;
                                        finalMaxDimension = strategy.maxDim;
                                        break;
                                    }
                                }
                            }
                        }

                        if (progressCallback) progressCallback(100);

                        // Check final result
                        if (result && result.blob.size <= maxSizeBytes) {
                            const compressedFile = new File([result.blob], file.name, {
                                type: outputType,
                                lastModified: Date.now()
                            });
                            const savingsPercent = Math.round((1 - result.blob.size / file.size) * 100);
                            resolve({
                                file: compressedFile,
                                originalSize: file.size,
                                compressedSize: result.blob.size,
                                savingsPercent,
                                currentQuality: finalQuality,
                                currentMaxDimension: finalMaxDimension,
                                success: true
                            });
                        } else {
                            // Failed to compress under limit
                            const finalSize = result ? result.blob.size : file.size;
                            reject({
                                message: `${file.name}: ${formatFileSize(finalSize)} - too large even after compression (max ${maxSizeKB} KB)`,
                                file: result ? new File([result.blob], file.name, { type: outputType, lastModified: Date.now() }) : file,
                                originalSize: file.size,
                                compressedSize: finalSize,
                                success: false,
                                currentQuality: finalQuality,
                                currentMaxDimension: finalMaxDimension
                            });
                        }
                    };

                    img.onerror = () => reject({ message: 'Failed to load image for compression', success: false });
                    img.src = e.target.result;
                };

                reader.onerror = () => reject({ message: 'Failed to read image file', success: false });
                reader.readAsDataURL(file);
            });
        }

        async function handleFileSelect(fileInput) {
            const files = Array.from(fileInput.files);
            if (files.length === 0) return;

            const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            const maxSizeBeforeCompression = 500 * 1024 * 1024; // 500MB - reject if too large even before compression

            // Validate file types
            const invalidTypeFiles = files.filter(file => !validTypes.includes(file.type));
            if (invalidTypeFiles.length > 0) {
                showAlert(`${invalidTypeFiles.length} file(s) are not valid image types (JPG, PNG, GIF, or WebP)`, '‚ùå');
                fileInput.value = '';
                return;
            }

            // Check for files that are too large even before compression
            const tooLargeFiles = files.filter(file => file.size > maxSizeBeforeCompression);
            if (tooLargeFiles.length > 0) {
                showAlert(`${tooLargeFiles.length} file(s) exceed 500MB. Please use smaller images.`, '‚ùå');
                fileInput.value = '';
                return;
            }

            // Check if adding all files would exceed the 50 image limit (admin can bypass)
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const totalImages = state.newContest.images.length + files.length;
            if (totalImages > 50 && !isAdmin) {
                const availableSlots = 50 - state.newContest.images.length;
                showAlert(`Cannot add ${files.length} images. Only ${availableSlots} slot(s) remaining (max 50 total)`, '‚ùå');
                fileInput.value = '';
                return;
            }

            fileInput.value = '';

            // Initialize compression progress state
            state.compressionProgress = {
                files: files.map(file => ({
                    name: file.name,
                    status: 'compressing', // 'compressing', 'complete', 'failed'
                    originalSize: file.size,
                    compressedSize: null,
                    progress: 0,
                    error: null,
                    canCompressMore: false,
                    file: null,
                    previewUrl: null,
                    savingsPercent: 0,
                    currentQuality: null,
                    currentMaxDimension: null,
                    originalFile: file
                })),
                allComplete: false
            };

            render();

            // Compress all files
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const fileState = state.compressionProgress.files[i];

                try {
                    const result = await compressImage(file, 500, (progress) => {
                        fileState.progress = progress;
                        render();
                    });

                    // Success
                    fileState.status = 'complete';
                    fileState.compressedSize = result.compressedSize;
                    fileState.file = result.file;
                    fileState.previewUrl = URL.createObjectURL(result.file);
                    fileState.savingsPercent = result.savingsPercent;
                    fileState.currentQuality = result.currentQuality;
                    fileState.currentMaxDimension = result.currentMaxDimension;
                    fileState.canCompressMore = result.currentQuality > 0.3 || result.currentMaxDimension === null || result.currentMaxDimension > 800;
                    fileState.progress = 100;
                } catch (error) {
                    // Failed
                    fileState.status = 'failed';
                    fileState.error = error.message || 'Compression failed';
                    fileState.compressedSize = error.compressedSize || file.size;
                    fileState.currentQuality = error.currentQuality;
                    fileState.currentMaxDimension = error.currentMaxDimension;
                    // Store the best attempt even if it failed
                    if (error.file) {
                        fileState.file = error.file;
                        fileState.previewUrl = URL.createObjectURL(error.file);
                    }
                    fileState.progress = 100;
                }

                render();
            }

            // All files processed
            state.compressionProgress.allComplete = true;
            render();
        }

        async function uploadImageFile(file, progressCallback) {
            // Always use .jpg extension for compressed images
            const fileExt = 'jpg';

            // Generate unique filename
            const fileName = `contest-${Date.now()}-${Math.random().toString(36).substring(2, 9)}.${fileExt}`;

            // Simulate progress updates (Supabase doesn't provide native progress)
            let progressInterval;
            if (progressCallback) {
                let simulatedProgress = 10;
                progressInterval = setInterval(() => {
                    if (simulatedProgress < 90) {
                        simulatedProgress += 10;
                        progressCallback(simulatedProgress);
                    }
                }, 200);
            }

            try {
                // Upload to Supabase Storage
                const { data, error } = await supabase.storage
                    .from('contest-images')
                    .upload(fileName, file, {
                        cacheControl: '3600',
                        upsert: false
                    });

                if (progressInterval) clearInterval(progressInterval);

                if (error) {
                    console.error('Supabase storage error:', error);
                    throw new Error(error.message || 'Failed to upload image to storage');
                }

                if (progressCallback) progressCallback(95);

                // Get public URL
                const { data: urlData } = supabase.storage
                    .from('contest-images')
                    .getPublicUrl(fileName);

                if (!urlData || !urlData.publicUrl) {
                    throw new Error('Failed to get public URL for uploaded image');
                }

                if (progressCallback) progressCallback(100);

                return urlData.publicUrl;
            } catch (error) {
                if (progressInterval) clearInterval(progressInterval);
                console.error('Upload error:', error);
                throw error;
            }
        }

        async function uploadImageFileWithRetry(file, fileIndex, maxRetries = 3) {
            const updateProgress = (progress) => {
                if (state.uploadProgress && state.uploadProgress.files[fileIndex]) {
                    state.uploadProgress.files[fileIndex].progress = progress;
                    render();
                }
            };

            let lastError;
            const retryCount = state.uploadProgress?.files[fileIndex]?.retryCount || 0;

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    // Exponential backoff: wait before retry (0ms, 1s, 2s, 4s)
                    if (attempt > 0) {
                        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 4000);
                        console.log(`Retrying upload for ${file.name} after ${delay}ms (attempt ${attempt + 1}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        updateProgress(5);
                    }

                    const imageUrl = await uploadImageFile(file, updateProgress);
                    return imageUrl;
                } catch (error) {
                    lastError = error;
                    console.error(`Upload attempt ${attempt + 1} failed for ${file.name}:`, error);

                    // Don't retry on certain errors
                    const errorMsg = error.message || String(error);
                    if (errorMsg.includes('413') || errorMsg.includes('Payload Too Large') ||
                        errorMsg.includes('401') || errorMsg.includes('403')) {
                        throw error; // Don't retry auth or size errors
                    }

                    // Continue to next retry if available
                    if (attempt < maxRetries - 1) {
                        updateProgress(0);
                    }
                }
            }

            // All retries failed
            throw lastError || new Error('Upload failed after multiple attempts');
        }

        // Upload progress modal helper functions
        function closeUploadProgress() {
            // Add successfully uploaded images to the contest
            const successfulUploads = state.uploadProgress.files.filter(f => f.status === 'success' && f.imageUrl);
            successfulUploads.forEach((file, index) => {
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random() + index,
                    url: file.imageUrl,
                    author: null,
                    isFileUpload: true,
                    label: `${imageCount}`
                });
            });

            state.uploadProgress = null;
            render();

            if (successfulUploads.length > 0) {
                showToast(`${successfulUploads.length} image${successfulUploads.length > 1 ? 's' : ''} added to contest!`, '‚úÖ');
            }
        }

        async function retryUpload(fileIndex) {
            const fileData = state.uploadProgress.files[fileIndex];
            if (!fileData || !fileData.originalFile) return;

            // Reset file status
            fileData.status = 'pending';
            fileData.progress = 0;
            fileData.error = null;
            fileData.retryCount = (fileData.retryCount || 0) + 1;
            render();

            try {
                // Re-compress if needed (using original file)
                if (fileData.needsCompression) {
                    fileData.status = 'compressing';
                    fileData.progress = 5;
                    render();

                    const compressed = await compressImage(fileData.originalFile);
                    fileData.file = compressed.file;
                    fileData.compressedSize = compressed.compressedSize;
                    fileData.progress = 10;
                    render();
                } else {
                    fileData.file = fileData.originalFile;
                    fileData.compressedSize = fileData.originalFile.size;
                }

                // Upload the file
                fileData.status = 'uploading';
                fileData.progress = 15;
                render();

                const imageUrl = await uploadImageFileWithRetry(fileData.file, fileIndex);
                fileData.status = 'success';
                fileData.imageUrl = imageUrl;
                fileData.progress = 100;
            } catch (error) {
                fileData.status = 'failed';
                fileData.error = getFriendlyErrorMessage(error);
            }

            render();
        }

        function cancelAllUploads() {
            // Mark all pending/uploading files as cancelled
            state.uploadProgress.files.forEach(file => {
                if (file.status === 'pending' || file.status === 'uploading') {
                    file.status = 'failed';
                    file.error = 'Cancelled by user';
                }
            });
            render();
        }

        function getFriendlyErrorMessage(error) {
            const errorMsg = error.message || String(error);

            if (errorMsg.includes('Failed to fetch') || errorMsg.includes('ERR_HTTP2_PROTOCOL_ERROR')) {
                return 'Network error - please check your connection and try again';
            } else if (errorMsg.includes('timeout') || errorMsg.includes('timed out')) {
                return 'Upload timed out - file may be too large or connection too slow';
            } else if (errorMsg.includes('413') || errorMsg.includes('Payload Too Large')) {
                return 'File is too large for upload';
            } else if (errorMsg.includes('401') || errorMsg.includes('403')) {
                return 'Authentication error - please try logging in again';
            } else if (errorMsg.includes('storage')) {
                return 'Storage error: ' + errorMsg;
            }

            return errorMsg;
        }

        // Compression modal helper functions
        function closeCompressionModal() {
            if (!state.compressionProgress || !state.compressionProgress.allComplete) return;

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

            // Add successfully compressed images to contest
            state.compressionProgress.files.forEach((fileState, index) => {
                if (fileState.status === 'complete' || (fileState.status === 'failed' && isAdmin && fileState.adminBypass)) {
                    const imageCount = state.newContest.images.length + 1;
                    state.newContest.images.push({
                        id: Date.now() + Math.random() + index,
                        url: fileState.previewUrl,
                        localFile: fileState.file,
                        isLocalFile: true,
                        author: null,
                        isFileUpload: true,
                        label: `${imageCount}`,
                        compressedSize: fileState.compressedSize
                    });
                }
            });

            const successCount = state.compressionProgress.files.filter(f =>
                f.status === 'complete' || (f.status === 'failed' && f.adminBypass)
            ).length;

            state.compressionProgress = null;
            render();

            if (successCount > 0) {
                showToast(`${successCount} image${successCount > 1 ? 's' : ''} added to contest!`, '‚úÖ');
            }
        }

        async function compressMoreImage(fileIndex) {
            const fileState = state.compressionProgress.files[fileIndex];
            if (!fileState || !fileState.originalFile) return;

            // Determine next compression level
            let newQuality = fileState.currentQuality;
            let newMaxDimension = fileState.currentMaxDimension;

            if (newQuality > 0.3) {
                // Try lower quality
                newQuality = Math.max(0.3, newQuality - 0.1);
            } else if (newMaxDimension === null || newMaxDimension > 800) {
                // Start resizing or go smaller
                if (newMaxDimension === null) {
                    newMaxDimension = 2000;
                } else if (newMaxDimension > 1500) {
                    newMaxDimension = 1500;
                } else if (newMaxDimension > 1200) {
                    newMaxDimension = 1200;
                } else if (newMaxDimension > 1000) {
                    newMaxDimension = 1000;
                } else {
                    newMaxDimension = 800;
                }
                newQuality = 0.4;
            } else {
                // Already at minimum
                showToast('Already at minimum compression settings', 'info');
                return;
            }

            // Reset state for recompression
            fileState.status = 'compressing';
            fileState.progress = 0;
            render();

            try {
                const result = await compressImage(fileState.originalFile, 500, (progress) => {
                    fileState.progress = progress;
                    render();
                }, newQuality, newMaxDimension);

                // Success
                fileState.status = 'complete';
                fileState.compressedSize = result.compressedSize;
                fileState.file = result.file;
                if (fileState.previewUrl) URL.revokeObjectURL(fileState.previewUrl);
                fileState.previewUrl = URL.createObjectURL(result.file);
                fileState.savingsPercent = result.savingsPercent;
                fileState.currentQuality = result.currentQuality;
                fileState.currentMaxDimension = result.currentMaxDimension;
                fileState.canCompressMore = result.currentQuality > 0.3 || result.currentMaxDimension === null || result.currentMaxDimension > 800;
                fileState.progress = 100;
            } catch (error) {
                // Failed
                fileState.status = 'failed';
                fileState.error = error.message || 'Compression failed';
                fileState.compressedSize = error.compressedSize || fileState.originalFile.size;
                fileState.currentQuality = error.currentQuality;
                fileState.currentMaxDimension = error.currentMaxDimension;
                if (error.file) {
                    if (fileState.previewUrl) URL.revokeObjectURL(fileState.previewUrl);
                    fileState.file = error.file;
                    fileState.previewUrl = URL.createObjectURL(error.file);
                }
                fileState.progress = 100;
            }

            render();
        }

        function cancelCompressionImage(fileIndex) {
            if (!state.compressionProgress) return;

            // Remove the file from compression progress
            state.compressionProgress.files.splice(fileIndex, 1);

            // Check if all remaining files are complete
            if (state.compressionProgress.files.length === 0) {
                state.compressionProgress = null;
            } else {
                state.compressionProgress.allComplete = state.compressionProgress.files.every(
                    f => f.status === 'complete' || f.status === 'failed'
                );
            }

            render();
        }

        function addOversizedImageAnyway(fileIndex) {
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin || !state.compressionProgress) return;

            const fileState = state.compressionProgress.files[fileIndex];
            if (!fileState || fileState.status !== 'failed') return;

            // Mark as admin bypass
            fileState.adminBypass = true;
            render();
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.add('border-blue-500', 'bg-blue-100');
                dropZone.classList.remove('border-gray-300', 'bg-gray-50');
            }
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-100');
                dropZone.classList.add('border-gray-300', 'bg-gray-50');
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();

            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-100');
                dropZone.classList.add('border-gray-300', 'bg-gray-50');
            }

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                // Create a mock file input object to reuse handleFileSelect logic
                const mockInput = {
                    files: files,
                    value: ''
                };
                handleFileSelect(mockInput);
            }
        }

        function removeContestImage(index) {
            showConfirm(
                'Delete this image from the contest?',
                `confirmRemoveImage_${index}`,
                'üö®'
            );
        }

        function confirmRemoveImage(index) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URL if it's a local file
            const img = state.newContest.images[index];
            if (img && img.isLocalFile && img.url.startsWith('blob:')) {
                URL.revokeObjectURL(img.url);
            }

            state.newContest.images.splice(index, 1);
            state.modalProcessing = false;
            render();

            // Show success message
            showAlert('Image successfully removed!', '‚úÖ');
        }

        function toggleImageLabels() {
            state.newContest.labelsEnabled = !state.newContest.labelsEnabled;
            render();
        }

        function toggleUserDropdown() {
            state.showUserDropdown = !state.showUserDropdown;
            render();
        }

        function toggleMergedContestsDropdown() {
            state.showMergedContestsDropdown = !state.showMergedContestsDropdown;
            render();
        }

        async function shareContest(contestId) {
            try {
                const shareUrl = `${window.location.origin}${window.location.pathname}#contest=${contestId}`;

                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                showToast('üîó Contest link copied!', 'success');
            } catch (error) {
                console.error('Failed to copy link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        async function showContestInfoModal(item, itemType) {
            try {
                // Fetch voters for this contest/merger/extract
                const contestId = item.id;
                let voters = [];

                // Query for voters who have completed voting
                const votesResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?contest_id=eq.${contestId}&select=user_id,users!inner(id,username,avatar)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const votesData = await votesResponse.json();

                // Deduplicate voters and sort by username
                if (Array.isArray(votesData)) {
                    const uniqueVotersMap = new Map();
                    votesData.forEach(vote => {
                        if (vote.users) {
                            uniqueVotersMap.set(vote.user_id, vote.users);
                        }
                    });
                    voters = Array.from(uniqueVotersMap.values())
                        .sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
                }

                // Set state for modal
                state.contestInfoModal = {
                    item,
                    itemType,
                    voters
                };

                render();
            } catch (error) {
                console.error('Error loading contest info:', error);
                showAlert('Failed to load contest info: ' + error.message, '‚ùå');
            }
        }

        function closeContestInfoModal() {
            state.contestInfoModal = null;
            render();
        }

        async function shareContestFromModal() {
            if (!state.contestInfoModal) return;
            await shareContest(state.contestInfoModal.item.id);
        }

        function showBreakdownMerged(imageId) {
            state.showBreakdownModal = imageId;
            render();
        }

        function renderBreakdownModalMerged() {
            if (!state.mergedResults || !state.mergedResults.images) return '';

            const item = state.mergedResults.images.find(img => img.id === state.showBreakdownModal);
            if (!item) return '';

            const votesByScore = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            (item.voteBreakdown || []).forEach(vote => {
                if (votesByScore[vote.score]) {
                    votesByScore[vote.score].push(vote);
                }
            });

            Object.keys(votesByScore).forEach(score => {
                votesByScore[score].sort((a, b) => a.username.localeCompare(b.username));
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[85vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Vote Breakdown</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="overflow-y-auto flex-1 p-4">

                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 400px;">
                                <img
                                    src="${item.url}"
                                    alt="Image"
                                    class="max-w-full max-h-[400px] object-contain"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                            </div>

                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-gray-800">${item.averageScore}</div>
                                    <div class="text-xs text-gray-600">Average Score</div>
                                    <div class="text-xs text-gray-500 mt-1">${item.totalVotes} total votes</div>
                                </div>
                            </div>

                            <div class="space-y-3">
                                ${[5, 4, 3, 2, 1].map(score => {
                                    const votes = votesByScore[score] || [];
                                    return `
                                    <div>
                                        <h4 class="text-sm font-bold mb-2 px-3 py-1 rounded-lg inline-block" style="color: ${getScoreColor(score)}; background-color: ${getScoreColor(score)}20;">
                                            Score ${score} (${votes.length} ${votes.length === 1 ? 'vote' : 'votes'})
                                        </h4>
                                        ${votes.length > 0 ? `
                                            <div class="grid grid-cols-1 gap-2 mt-2">
                                                ${votes.map(vote => `
                                                    <div class="flex items-center gap-2 p-2 rounded-lg ${
                                                        vote.isBlocked ? 'bg-gray-300' :
                                                        vote.isCurrentUser ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'
                                                    }">
                                                        <img src="${vote.avatar}" alt="${vote.username}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');" />
                                                        <span class="text-sm flex-1 truncate cursor-pointer ${
                                                            vote.isBlocked ? 'line-through text-gray-700' : 'text-gray-700 hover:text-mauve-600'
                                                        }" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');">
                                                            ${vote.username}${vote.isCurrentUser ? ' (You)' : ''}
                                                        </span>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        ` : `
                                            <div class="text-gray-400 italic text-sm mt-2 ml-3">No votes</div>
                                        `}
                                    </div>
                                `}).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        async function shareMerge() {
            if (state.selectedContestsForMerge.length < 2) {
                showAlert('Please select at least 2 contests to merge', '‚ùå');
                return;
            }

            try {
                // Convert contest IDs to contest numbers for shorter URLs
                const contestNumbers = state.selectedContestsForMerge.map(id => {
                    const contest = state.contests.find(c => c.id === id);
                    return contest ? contest.contestNumber : null;
                }).filter(n => n !== null);

                const shareUrl = `${window.location.origin}${window.location.pathname}#merge=${contestNumbers.join(',')}`;

                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                showToast('üîó Merge link copied!', 'success');
            } catch (error) {
                console.error('Failed to copy merge link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        async function loadSharedContest(contestId) {
            try {
                console.log('Loading shared contest:', contestId);

                // Fetch contest from database with aggressive cache-busting
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}&select=*,images(*),creator:users!contests_created_by_fkey(username,avatar)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const contests = await response.json();

                if (!contests || contests.length === 0) {
                    showAlert('Contest not found. It may have been deleted.', '‚ùå');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                const contestData = contests[0];
                const contest = {
                    id: contestData.id,
                    title: contestData.title,
                    isLocked: contestData.is_locked,
                    resultsPublic: contestData.results_public,
                    createdBy: contestData.created_by,
                    creatorName: contestData.creator.username,
                    creatorAvatar: contestData.creator.avatar,
                    createdAt: contestData.created_at,
                    images: contestData.images
                        .sort((a, b) => a.image_order - b.image_order)
                        .map(img => ({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            isFileUpload: img.is_file_upload
                        }))
                };

                // Check if user is banned
                if (state.bannedUsers.includes(state.user?.id)) {
                    showAlert('Your account has been restricted. You cannot access this contest.', 'üö´');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Check if user has already voted
                const hasVoted = state.userVotedContests[contest.id];

                if (hasVoted || contest.isLocked) {
                    // Show results
                    await viewResults(contest);
                } else {
                    // Start voting
                    startVoting(contest);
                }
            } catch (error) {
                console.error('Error loading shared contest:', error);
                showAlert('Failed to load contest: ' + error.message, '‚ùå');
                window.location.hash = '';
                state.view = 'home';
                render();
            }
        }


        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove '#'

            console.log('üîó [NAVIGATION] Hash changed:', hash);

            // Check for single contest share: #contest={uuid}
            const params = new URLSearchParams(hash);
            const contestId = params.get('contest');
            if (contestId && state.isLoggedIn) {
                console.log('üîó [NAVIGATION] Detected contest share link');
                loadSharedContest(contestId);
            }
        }

        function updateImageLabel(index, label) {
            if (state.newContest.images[index]) {
                // Convert Discord CDN URLs to media.discordapp.net for compatibility
                label = label.replace(/cdn\.discordapp\.com/g, 'media.discordapp.net');
                label = label.replace(/images-ext-\d+\.discordapp\.net/g, 'media.discordapp.net');
                state.newContest.images[index].label = label;
            }
        }

        function finishCreateContest() {
            if (state.newContest.images.length === 0) {
                showAlert('Add at least one image!', '‚ùå');
                return;
            }

            // Check for duplicate title
            const duplicateTitle = state.contests.some(c =>
                c.title.toLowerCase().trim() === state.newContest.title.toLowerCase().trim()
            );

            if (duplicateTitle) {
                showAlert('A contest with this title already exists. Please choose a different title.', '‚ùå');
                return;
            }

            // Show confirmation popup
            showConfirm(
                `Create contest "${state.newContest.title}" with ${state.newContest.images.length} images?`,
                'confirmFinishCreateContest',
                'üö®'
            );
        }

        async function confirmFinishCreateContest() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const uploadedUrls = [];
            const localFilesToUpload = state.newContest.images.filter(img => img.isLocalFile);

            try {
                // Step 1: Upload all local files first
                if (localFilesToUpload.length > 0) {
                    setLoading(`Uploading images (0/${localFilesToUpload.length})...`);

                    for (let i = 0; i < localFilesToUpload.length; i++) {
                        const img = localFilesToUpload[i];
                        setLoading(`Uploading images (${i + 1}/${localFilesToUpload.length})...`);

                        // Images are already compressed during upload phase
                        // Upload to storage
                        const uploadedUrl = await uploadImageFile(img.localFile);
                        uploadedUrls.push(uploadedUrl);

                        // Update the image URL in state
                        img.url = uploadedUrl;
                        img.isLocalFile = false;
                        delete img.localFile;
                    }
                }

                // Step 2: Insert contest - database auto-generates UUID
                setLoading('Creating contest...');
                const contestResponse = await fetch(`${SUPABASE_URL}/rest/v1/contests`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        title: state.newContest.title,
                        created_by: state.user.id
                    })
                });

                if (!contestResponse.ok) {
                    const errorData = await contestResponse.json();
                    console.error('Contest creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create contest');
                }

                const createdContests = await contestResponse.json();
                const contestId = createdContests[0].id;

                // Step 3: Insert images
                const imagesToInsert = state.newContest.images.map((img, i) => ({
                    contest_id: contestId,
                    url: img.url,
                    is_file_upload: img.isFileUpload,
                    author: img.author,
                    image_order: i
                }));

                const imagesResponse = await fetch(`${SUPABASE_URL}/rest/v1/images`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify(imagesToInsert)
                });

                if (!imagesResponse.ok) {
                    const errorData = await imagesResponse.json();
                    console.error('Image insertion failed:', errorData);
                    throw new Error(errorData.message || 'Failed to add images');
                }

                // Revoke all Object URLs after successful creation
                state.newContest.images.forEach(img => {
                    if (img.url.startsWith('blob:')) {
                        URL.revokeObjectURL(img.url);
                    }
                });

                state.newContest = { title: '', images: [] };
                await loadContests();
                state.view = 'home';
                state.modalProcessing = false;

                // Show success message
                showAlert('Contest created successfully!', '‚ú®');

            } catch (error) {
                console.error('Full contest creation error:', error);

                // Clean up uploaded files if contest creation failed
                if (uploadedUrls.length > 0) {
                    console.log('Cleaning up uploaded files due to error...');
                    for (const url of uploadedUrls) {
                        try {
                            const fileName = url.split('/').pop();
                            await supabase.storage
                                .from('contest-images')
                                .remove([fileName]);
                        } catch (cleanupError) {
                            console.error('Failed to cleanup file:', cleanupError);
                        }
                    }
                }

                state.modalProcessing = false;
                showAlert('Failed to create contest: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        async function loadImageFromUrl(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                let timedOut = false;

                // Network timeout with specific message
                const timeoutId = setTimeout(() => {
                    timedOut = true;
                    reject(new Error('‚è±Ô∏è Network timeout: Image took too long to load. Possible causes: slow connection, large file size, or server issues. Try a different image or check your internet connection.'));
                }, 10000);

                img.onload = () => {
                    if (!timedOut) {
                        clearTimeout(timeoutId);
                        resolve(img);
                    }
                };

                img.onerror = () => {
                    if (timedOut) return; // Already handled by timeout
                    clearTimeout(timeoutId);

                    // Provide specific error details
                    let errorMsg = '‚ùå Failed to load image.\n\n';

                    // Check URL validity
                    try {
                        new URL(url);
                    } catch {
                        reject(new Error(errorMsg + 'üîó Invalid URL format. Please enter a valid image URL.'));
                        return;
                    }

                    // Check file extension
                    const extension = url.split('?')[0].split('.').pop().toLowerCase();
                    const validExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'];

                    // Provide likely causes based on URL analysis
                    if (url.includes('discord')) {
                        errorMsg += 'üí¨ Discord CDN issue: The link may be expired, deleted, or have restricted access. Try re-uploading the image to Discord and getting a fresh link.';
                    } else if (url.startsWith('http://')) {
                        errorMsg += 'üîí CORS/Security issue: HTTP URLs often have cross-origin restrictions. Try using an HTTPS URL instead, or upload the image to a public image host.';
                    } else if (!validExtensions.includes(extension)) {
                        errorMsg += 'üìÅ Unsupported format: The URL doesn\'t end with a recognized image extension (.jpg, .png, .gif, .webp). Make sure you\'re linking directly to an image file.';
                    } else if (url.includes('imgur') && !url.includes('i.imgur')) {
                        errorMsg += 'üñºÔ∏è Imgur link issue: Use direct image links (i.imgur.com) instead of gallery links. Right-click the image and select "Copy image address".';
                    } else {
                        errorMsg += 'üåê Possible causes:\n‚Ä¢ CORS restrictions from the image host\n‚Ä¢ Broken or expired link\n‚Ä¢ Image was deleted or moved\n‚Ä¢ Server is down or blocking requests\n‚Ä¢ Private/restricted access image\n\nTry uploading to a public image host like Imgur or Discord.';
                    }

                    reject(new Error(errorMsg));
                };

                img.src = url;
            });
        }

        function login() {
            const authUrl = `https://discord.com/oauth2/authorize?client_id=${DISCORD_CLIENT_ID}&redirect_uri=${encodeURIComponent(DISCORD_REDIRECT_URI)}&response_type=token&scope=identify`;
            window.location.href = authUrl;
        }

        function logout() {
            localStorage.removeItem('peony_user');
            state.isLoggedIn = false;
            state.user = null;
            state.view = 'home';
            render();
        }

        async function loadContests() {
            setLoading('Loading contests...');
            try {
                const response = await fetchFromSupabase('/rest/v1/contests?select=*,images(*),creator:users!contests_created_by_fkey(username,avatar)&order=created_at.desc');

                const contests = await response.json();

                // Check if contests response is valid
                if (!Array.isArray(contests)) {
                    console.error('Invalid contests response:', contests);
                    throw new Error(contests.message || 'Failed to load contests');
                }

                // Map contests with their voter counts from database fields
                state.contests = contests.map(contest => ({
                    id: contest.id,
                    contestNumber: contest.contest_number,
                    title: contest.title,
                    isLocked: contest.is_locked,
                    resultsPublic: contest.results_public,
                    createdBy: contest.created_by,
                    creatorName: contest.creator.username,
                    creatorAvatar: contest.creator.avatar,
                    createdAt: contest.created_at,
                    voterCountMin: contest.voter_count_min || 0,
                    voterCountMax: contest.voter_count_max || 0,
                    images: contest.images
                        .sort((a, b) => a.image_order - b.image_order)
                        .map(img => ({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            isFileUpload: img.is_file_upload
                        }))
                }));

                render();
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        async function loadMergers() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?select=*,creator:users!mergers_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const mergers = await response.json();
                if (Array.isArray(mergers)) {
                    state.mergers = mergers.map(m => ({
                        id: m.id,
                        name: m.name,
                        createdBy: m.created_by,
                        creatorName: m.creator.username,
                        creatorAvatar: m.creator.avatar,
                        createdAt: m.created_at,
                        contestIds: m.contest_ids,
                        voterCountMin: m.voter_count_min,
                        voterCountMax: m.voter_count_max,
                        isLocked: m.is_locked || false,
                        resultsPublic: m.results_public !== false,
                        type: 'merger'
                    }));
                }
            } catch (error) {
                console.error('Error loading mergers:', error);
            }
        }

        async function loadExtracts() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?select=*,creator:users!extracts_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const extracts = await response.json();
                if (Array.isArray(extracts)) {
                    state.extracts = extracts.map(e => ({
                        id: e.id,
                        name: e.name,
                        createdBy: e.created_by,
                        creatorName: e.creator.username,
                        creatorAvatar: e.creator.avatar,
                        createdAt: e.created_at,
                        sourceContestId: e.source_type === 'contest' ? e.source_contest_id : (e.source_type === 'extract' ? e.source_contest_id : null),
                        sourceMergerId: e.source_type === 'merger' ? e.source_contest_id : null,
                        sourceType: e.source_type,
                        imageIds: e.image_ids,
                        isLocked: e.is_locked || false,
                        resultsPublic: e.results_public !== false,
                        type: 'extract'
                    }));
                }
            } catch (error) {
                console.error('Error loading extracts:', error);
            }
        }

        async function ensurePinnedFolder() {
            const PINNED_FOLDER_ID = 'd88c5bcc-8b54-44ab-bca9-ed186124bcd2';

            try {
                // Check if pinned folder exists
                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?id=eq.${PINNED_FOLDER_ID}&select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const existing = await response.json();

                // If doesn't exist, create it
                if (!existing || existing.length === 0) {
                    console.log('Creating Pinned folder...');
                    await fetch(`${SUPABASE_URL}/rest/v1/groups`, {
                        method: 'POST',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Content-Type': 'application/json',
                            'Prefer': 'return=minimal'
                        },
                        body: JSON.stringify({
                            id: PINNED_FOLDER_ID,
                            name: 'Pinned',
                            display_order: 0
                        })
                    });
                    console.log('Pinned folder created successfully');
                }
            } catch (error) {
                console.error('Error ensuring pinned folder:', error);
            }
        }

        async function loadGroups() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?select=*,items:contest_groups(*)&order=display_order.asc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const groups = await response.json();
                if (Array.isArray(groups)) {
                    state.groups = groups;
                }
            } catch (error) {
                console.error('Error loading groups:', error);
            }
        }

        async function loadAppSettings() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const settings = await response.json();
                if (Array.isArray(settings)) {
                    settings.forEach(s => {
                        state.appSettings[s.setting_name] = s.value;
                    });
                }
            } catch (error) {
                console.error('Error loading app settings:', error);
            }
        }

        async function loadUserVotes() {
            if (!state.user) return;

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${state.user.id}&select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const votes = await response.json();

                state.userVotedContests = {};
                votes.forEach(vote => {
                    if (!state.userVotedContests[vote.contest_id]) {
                        state.userVotedContests[vote.contest_id] = {};
                    }
                    state.userVotedContests[vote.contest_id][vote.image_id] = vote.score;
                });
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            }
        }

        // --- ADD: ensureLocalUser (insert this near other helper functions) ---
        function ensureLocalUser(user) {
            // returns a Promise that resolves when the user exists (or after insertion)
            console.log('üë§ Ensuring user exists in database:', user.id, user.username);
            return fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${user.id}`, {
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'Cache-Control': 'no-cache'
                }
            })
            .then(r => r.json())
            .then(rows => {
                if (rows.length === 0) {
                    console.log('üë§ User not found in database, creating new user');
                    // create the user row in public.users
                    return fetch(`${SUPABASE_URL}/rest/v1/users`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify({
                            id: user.id,
                            username: user.username,
                            avatar: user.avatar
                        })
                    }).then(resp => {
                        // If the insert fails, still let caller continue but log error
                        if (!resp.ok) {
                            return resp.text().then(t => {
                                console.error('‚ùå Failed to insert local user:', t);
                                console.error('‚ùå Response status:', resp.status);
                                console.error('‚ùå User data:', { id: user.id, username: user.username, avatar: user.avatar });
                                // swallow error to avoid locking login flow; caller can handle later
                                return;
                            });
                        } else {
                            console.log('‚úÖ User successfully created in database');
                        }
                    });
                } else {
                    console.log('‚úÖ User already exists in database');
                }
                // user already exists: resolve immediately
                return;
            })
            .catch(err => {
                console.error('‚ùå ensureLocalUser error:', err);
                // resolve anyway so login flow continues; caller may show an error later
                return;
            });
        }
        // --- END ADD ---


        function startVoting(contest) {
            state.currentContest = contest;
            state.shuffledImages = shuffleArray(contest.images);
            state.votes = {};
            state.currentImageIndex = 0;
            state.hasSubmitted = false;
            state.results = null;
            state.view = 'vote';

            // Clear merger context (we're voting on a single contest)
            state.currentMergerId = null;
            state.mergerContestIds = [];

            // Update URL hash for shareable link
            window.location.hash = `contest=${contest.id}`;

            render();
        }

        async function viewResults(contest) {
            // Check if contest still exists in the database
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contest.id}&select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                const contests = await response.json();

                // If contest doesn't exist (deleted), refresh the page
                if (!contests || contests.length === 0) {
                    console.log('Contest no longer exists, refreshing...');
                    showAlert('Contest was deleted. Refreshing...', 'üîÑ');
                    setTimeout(() => location.reload(), 1500);
                    return;
                }

                // Check if results are public
                const contestData = contests[0];
                const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                const isCreator = state.user && state.user.id === contestData.created_by;
                const resultsPublic = contestData.results_public !== false;

                if (!resultsPublic && !isAdmin && !isCreator) {
                    showAlert('Results are private. Only the creator or admin can view them.', 'üîí');
                    return;
                }

                state.currentContest = contest;
                const userVotes = state.userVotedContests[contest.id] || {};
                state.votes = userVotes;
                await loadResults();
                state.showMyVotes = false;
                state.view = 'results';

                // Update URL hash for shareable link
                window.location.hash = `contest=${contest.id}`;

                render();
            } catch (error) {
                console.error('Error checking contest existence:', error);
                showAlert('Error loading results: ' + error.message, '‚ùå');
            }
        }

        async function viewLockedResults(contest) {
            // Check if results are public
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === contest.createdBy;
            const resultsPublic = contest.resultsPublic !== false;

            if (!resultsPublic && !isAdmin && !isCreator) {
                showAlert('Results are private. Only the creator or admin can view them.', 'üîí');
                return;
            }

            state.currentContest = contest;
            state.votes = {};
            await loadResults();
            state.showMyVotes = false;
            state.view = 'results';
            render();
        }

        function startRevote() {
            // Show confirmation modal
            state.modal = {
                type: 'confirm',
                icon: 'üîÑ',
                message: 'Re-vote from scratch? Your new votes will replace your old ones when submitted.',
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Start Revote', action: 'confirmRevote', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function confirmRevote() {
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Reset voting state with clean slate
            state.votes = {};
            state.hasSubmitted = false;
            state.shuffledImages = shuffleArray(state.currentContest.images);
            state.currentImageIndex = 0;
            state.view = 'vote';

            render();
        }

        async function toggleContestLock(itemId) {
            // Find item across all types
            let item = state.contests.find(c => c.id === itemId);
            let itemType = 'contest';
            let tableName = 'contests';

            if (!item) {
                item = state.mergers.find(m => m.id === itemId);
                itemType = 'merger';
                tableName = 'mergers';
            }
            if (!item) {
                item = state.extracts.find(e => e.id === itemId);
                itemType = 'extract';
                tableName = 'extracts';
            }
            if (!item) return;

            // Only the creator or admin can lock/unlock
            if (item.createdBy !== state.user.id && state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Only the creator or admin can lock/unlock this item.', 'üîí');
                return;
            }

            const newLockStatus = !item.isLocked;

            try {
                // Update database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/${tableName}?id=eq.${itemId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_locked: newLockStatus
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Lock status update failed:', errorData);
                    throw new Error(errorData.message || 'Failed to update lock status');
                }

                // Update local state only if database update succeeded
                item.isLocked = newLockStatus;
                const itemLabel = itemType.charAt(0).toUpperCase() + itemType.slice(1);
                showAlert(item.isLocked ? `üîí ${itemLabel} locked - Users cannot vote` : `üîì ${itemLabel} unlocked - Users can now vote`, item.isLocked ? 'üö®' : '‚úÖ');
                render();
            } catch (error) {
                console.error('Full lock toggle error:', error);
                showAlert('Failed to update lock status: ' + error.message, '‚ùå');
            }
        }

        async function toggleResultsPublic(itemId) {
            try {
                // Find item across all types
                let item = state.contests.find(c => c.id === itemId);
                let tableName = 'contests';

                if (!item) {
                    item = state.mergers.find(m => m.id === itemId);
                    tableName = 'mergers';
                }
                if (!item) {
                    item = state.extracts.find(e => e.id === itemId);
                    tableName = 'extracts';
                }

                if (!item) {
                    throw new Error('Item not found');
                }

                // Check if user is creator or admin
                const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                const isCreator = state.user && state.user.id === item.createdBy;

                if (!isAdmin && !isCreator) {
                    showAlert('Only the creator or admin can toggle results visibility', '‚ùå');
                    return;
                }

                const newPublicStatus = !item.resultsPublic;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/${tableName}?id=eq.${itemId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        results_public: newPublicStatus
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Results public update failed:', errorData);
                    throw new Error(errorData.message || 'Failed to update results visibility');
                }

                // Update local state only if database update succeeded
                item.resultsPublic = newPublicStatus;
                showAlert(item.resultsPublic ? 'üëÅÔ∏è Results public - Everyone can view' : 'üîí Results hidden - Only you can view', item.resultsPublic ? 'üëÅÔ∏è' : 'üîí');
                render();
            } catch (error) {
                console.error('Results public toggle error:', error);
                showAlert('Failed to update results visibility: ' + error.message, '‚ùå');
            }
        }

        // ==================== MERGER SYSTEM FUNCTIONS ====================

        function openCreateMergerModal() {
            state.showCreateMergerModal = true;
            state.selectedContestsForMerge = [];
            state.newMergerName = '';
            document.body.classList.add('modal-open');
            render();
        }

        function closeCreateMergerModal() {
            state.showCreateMergerModal = false;
            state.selectedContestsForMerge = [];
            state.newMergerName = '';
            document.body.classList.remove('modal-open');
            render();
        }

        function toggleContestForMerger(contestId) {
            if (!state.selectedContestsForMerge) {
                state.selectedContestsForMerge = [];
            }

            const index = state.selectedContestsForMerge.indexOf(contestId);
            if (index > -1) {
                state.selectedContestsForMerge.splice(index, 1);
            } else {
                state.selectedContestsForMerge.push(contestId);
            }

            // Preserve scroll position
            const modalContent = document.querySelector('.modal-content .overflow-y-auto');
            const scrollTop = modalContent ? modalContent.scrollTop : 0;

            render();

            // Restore scroll position after render
            setTimeout(() => {
                const newModalContent = document.querySelector('.modal-content .overflow-y-auto');
                if (newModalContent && scrollTop > 0) {
                    newModalContent.scrollTop = scrollTop;
                }
            }, 0);
        }

        function setMergerName(name) {
            state.newMergerName = name;
            // Don't render to avoid input blur - button state will be updated on blur
        }

        function updateMergerNameOnBlur() {
            const input = document.getElementById('merger-name-input');
            if (input) {
                state.newMergerName = input.value;
                render();
            }
        }

        async function saveMerger() {
            if (state.selectedContestsForMerge.length < 2) {
                showToast('Please select at least 2 contests', 'error');
                return;
            }

            if (!state.newMergerName || state.newMergerName.trim() === '') {
                showToast('Please enter a name for the merger', 'error');
                return;
            }

            setLoading('Creating merger...');

            try {
                // Calculate voter count min/max across selected contests
                const selectedContests = state.contests.filter(c => state.selectedContestsForMerge.includes(c.id));
                const voterCounts = selectedContests.map(c => c.voterCount || 0);
                const voterCountMin = Math.min(...voterCounts);
                const voterCountMax = Math.max(...voterCounts);

                // Save to mergers table
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify({
                        name: state.newMergerName.trim(),
                        created_by: state.user.id,
                        contest_ids: state.selectedContestsForMerge,
                        voter_count_min: voterCountMin,
                        voter_count_max: voterCountMax
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Merger creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create merger');
                }

                // Reload mergers
                await loadMergers();

                showToast('Merger created successfully!', 'success');
                closeCreateMergerModal();
            } catch (error) {
                console.error('Error creating merger:', error);
                showToast('Failed to create merger: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        function confirmDeleteMerger(mergerId) {
            state.mergerToDelete = mergerId;
            showConfirm(
                'Are you sure you want to delete this merger? This action cannot be undone.',
                'executeDeleteMerger',
                'üóëÔ∏è'
            );
        }

        async function executeDeleteMerger() {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const mergerId = state.mergerToDelete;
            state.mergerToDelete = null;

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?id=eq.${mergerId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Merger deletion failed:', errorData);
                    throw new Error(errorData.message || 'Failed to delete merger');
                }

                // Reload mergers
                await loadMergers();

                showToast('Merger deleted successfully', 'success');
            } catch (error) {
                console.error('Error deleting merger:', error);
                showToast('Failed to delete merger: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                render();
            }
        }

        // Legacy function name for backwards compatibility
        async function deleteMerger(mergerId) {
            confirmDeleteMerger(mergerId);
        }

        async function viewMergerResults(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Check if user has voted on ALL contests (unless admin/creator)
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === merger.createdBy;

            if (!isAdmin && !isCreator) {
                // Check if user has voted on all contests
                const votedContests = mergedContests.filter(c => state.userVotedContests[c.id]);
                const unvotedContests = mergedContests.filter(c => !state.userVotedContests[c.id]);

                if (unvotedContests.length > 0) {
                    const contestTitles = unvotedContests.map(c => `‚Ä¢ ${c.title}`).join('\n');
                    showAlert(
                        `You must vote on all ${mergedContests.length} contests before viewing merge results.\n\nRemaining contests:\n${contestTitles}`,
                        'üó≥Ô∏è'
                    );
                    return;
                }

                // Check if all source contests have public results
                const hasPrivateContest = mergedContests.some(c => c.resultsPublic === false && c.createdBy !== state.user.id);
                if (hasPrivateContest) {
                    showAlert('Some contests in this merger have private results. Only the creator or admin can view them.', 'üîí');
                    return;
                }
            }

            // Store current merger for revote functionality
            state.currentMergerId = mergerId;

            // Load merged results and display
            await loadMergedResults(merger.contestIds);
            state.view = 'mergedResults';
            state.resultsView = 'average';
            state.showMyVotes = false;
            render();
        }

        async function startMergerVoting(mergerId, revoteAll = false) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Filter out locked contests (unless revoting all)
            const unlockedContests = mergedContests.filter(c => !c.isLocked);

            if (unlockedContests.length === 0) {
                showToast('All contests in this merger are locked', 'error');
                return;
            }

            // Determine which contests to vote on based on user's vote status
            let contestsToVote;
            if (revoteAll) {
                // Revote all unlocked contests
                contestsToVote = unlockedContests;
            } else {
                // Check which contests user hasn't voted in yet
                const unvotedContests = unlockedContests.filter(c => !state.userVotedContests[c.id]);
                contestsToVote = unvotedContests.length > 0 ? unvotedContests : unlockedContests;
            }

            // Collect all images from the contests to vote on
            const allImages = contestsToVote.flatMap(c => c.images);

            if (allImages.length === 0) {
                showToast('No images available to vote on', 'error');
                return;
            }

            // Store merger context
            state.currentMergerId = mergerId;
            state.mergerContestIds = contestsToVote.map(c => c.id);

            // Shuffle all images together
            state.shuffledImages = shuffleArray(allImages);
            state.votes = {};
            state.currentImageIndex = 0;
            state.hasSubmitted = false;
            state.results = null;
            state.view = 'vote';

            // Set currentContest to null to indicate merger voting mode
            state.currentContest = null;

            // Update URL hash for shareable link
            window.location.hash = `merge=${mergerId}`;

            render();
        }

        function revoteMerge() {
            if (!state.currentMergerId) {
                showToast('No merger context found', 'error');
                return;
            }

            // Restart merger voting with revote all flag
            startMergerVoting(state.currentMergerId, true);
        }

        function showMergerVoteModal(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Find which contests user hasn't voted in (excluding locked ones)
            const unlockedContests = mergedContests.filter(c => !c.isLocked);
            const unvotedContests = unlockedContests.filter(c => !state.userVotedContests[c.id]);
            const votedContests = unlockedContests.filter(c => state.userVotedContests[c.id]);

            // Show modal with options
            const message = `You've voted in ${votedContests.length} out of ${unlockedContests.length} unlocked contests.\n\nUnvoted contests:\n${unvotedContests.map(c => '‚Ä¢ ' + c.title).join('\n')}\n\nWhat would you like to do?`;

            // Store the mergerId for the action functions
            state.pendingMergerId = mergerId;

            state.modal = {
                icon: 'üîÑ',
                title: 'Complete Voting - ' + merger.name,
                message: message,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Vote Missing Only', action: 'confirmVoteMissingOnly', primary: true },
                    { text: 'Revote All', action: 'confirmRevoteAll', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function confirmVoteMissingOnly() {
            const mergerId = state.pendingMergerId;
            state.modal = null;
            state.pendingMergerId = null;
            document.body.classList.remove('modal-open');
            startMergerVoting(mergerId, false);
        }

        function confirmRevoteAll() {
            const mergerId = state.pendingMergerId;
            state.modal = null;
            state.pendingMergerId = null;
            document.body.classList.remove('modal-open');
            startMergerVoting(mergerId, true);
        }

        async function shareMerger(mergerId) {
            try {
                const shareUrl = `${window.location.origin}${window.location.pathname}#merge=${mergerId}`;

                if (navigator.share) {
                    await navigator.share({
                        title: 'Peony - Merger',
                        text: 'Check out this merged contest!',
                        url: shareUrl
                    });
                    showToast('Share successful!', 'success');
                } else {
                    await navigator.clipboard.writeText(shareUrl);
                    showToast('Link copied to clipboard!', 'success');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Share error:', error);
                    showToast('Failed to share', 'error');
                }
            }
        }

        // ==================== END MERGER SYSTEM FUNCTIONS ====================

        // ==================== EXTRACT SYSTEM FUNCTIONS ====================

        function openCreateExtractModal() {
            state.showCreateExtractModal = true;
            state.extractSourceType = null;
            state.extractSourceId = null;
            state.extractSelectedImages = [];
            state.newExtractName = '';
            document.body.classList.add('modal-open');
            render();
        }

        function closeCreateExtractModal() {
            state.showCreateExtractModal = false;
            state.extractSourceType = null;
            state.extractSourceId = null;
            state.extractSelectedImages = [];
            state.newExtractName = '';
            document.body.classList.remove('modal-open');
            render();
        }

        function selectExtractSource(sourceType, sourceId) {
            state.extractSourceType = sourceType;
            state.extractSourceId = sourceId;
            state.extractSelectedImages = [];
            render();
        }

        function toggleExtractImage(imageId) {
            if (!state.extractSelectedImages) {
                state.extractSelectedImages = [];
            }

            const index = state.extractSelectedImages.indexOf(imageId);
            if (index > -1) {
                state.extractSelectedImages.splice(index, 1);
            } else {
                state.extractSelectedImages.push(imageId);
            }

            // Update the count display and button state without full re-render to prevent blink
            const countDisplay = document.querySelector('[data-extract-count]');
            if (countDisplay) {
                countDisplay.textContent = `From: ${state.extractSourceType === 'contest' ? state.contests.find(c => c.id === state.extractSourceId)?.title : state.extractSourceType === 'merger' ? state.mergers.find(m => m.id === state.extractSourceId)?.name : state.extracts.find(e => e.id === state.extractSourceId)?.name} (${state.extractSelectedImages.length} selected)`;
            }

            // Update save button state
            const saveButton = document.querySelector('[data-extract-save]');
            if (saveButton) {
                const canSave = state.extractSelectedImages.length > 0 && state.newExtractName;
                saveButton.disabled = !canSave;
                if (canSave) {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700';
                } else {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-300 text-gray-500 cursor-not-allowed';
                }
            }

            // Update the specific checkbox visual
            const imageElement = event?.target?.closest('[data-image-id]');
            if (imageElement) {
                const isSelected = state.extractSelectedImages.includes(imageId);
                const borderDiv = imageElement.querySelector('.relative.cursor-pointer');
                const checkboxDiv = imageElement.querySelector('.absolute.top-2');

                if (borderDiv) {
                    if (isSelected) {
                        borderDiv.className = 'relative cursor-pointer rounded-lg overflow-hidden border-4 border-blue-500 bg-blue-50';
                    } else {
                        borderDiv.className = 'relative cursor-pointer rounded-lg overflow-hidden border-4 border-transparent hover:border-blue-300';
                    }
                }

                if (checkboxDiv) {
                    if (isSelected) {
                        checkboxDiv.innerHTML = `
                            <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                            </svg>
                        `;
                        checkboxDiv.className = 'absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 border-blue-500';
                    } else {
                        checkboxDiv.innerHTML = '<div class="w-4 h-4 border-2 border-gray-400 rounded"></div>';
                        checkboxDiv.className = 'absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 border-gray-300';
                    }
                }
            }
        }

        function setExtractName(name) {
            state.newExtractName = name;
            // Update button state without full render
            updateExtractSaveButtonState();
        }

        function updateExtractNameOnBlur() {
            const input = document.getElementById('extract-name-input');
            if (input) {
                state.newExtractName = input.value;
                // Update save button state without full re-render to preserve selection visual state
                updateExtractSaveButtonState();
            }
        }

        function updateExtractSaveButtonState() {
            // Update save button state without full re-render
            const saveButton = document.querySelector('[data-extract-save]');
            if (saveButton) {
                const canSave = state.extractSelectedImages.length > 0 && state.newExtractName && state.newExtractName.trim() !== '';
                saveButton.disabled = !canSave;
                if (canSave) {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700';
                } else {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-300 text-gray-500 cursor-not-allowed';
                }
            }
        }

        async function saveExtract() {
            if (!state.extractSelectedImages || state.extractSelectedImages.length === 0) {
                showToast('Please select at least one image', 'error');
                return;
            }

            if (!state.newExtractName || state.newExtractName.trim() === '') {
                showToast('Please enter a name for the extract', 'error');
                return;
            }

            setLoading('Creating extract...');

            try {
                // Image IDs are integers in the database
                const extractData = {
                    name: state.newExtractName.trim(),
                    created_by: state.user.id,
                    source_type: state.extractSourceType,
                    image_ids: state.extractSelectedImages
                };

                // Only set source_contest_id for contest sources (UUID field)
                // For other sources, set to null to avoid UUID type errors
                if (state.extractSourceType === 'contest') {
                    // Ensure we're using the UUID, not contest number
                    const contest = state.contests.find(c => c.id === state.extractSourceId);
                    if (contest) {
                        extractData.source_contest_id = contest.id;
                    } else {
                        throw new Error('Contest not found');
                    }
                } else {
                    // For mergers and extracts, set source_contest_id to null
                    // The source type is already stored in source_type field
                    extractData.source_contest_id = null;
                }

                // Save to extracts table
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify(extractData)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create extract');
                }

                // Reload extracts
                await loadExtracts();

                showToast('Extract created successfully!', 'success');
                closeCreateExtractModal();
            } catch (error) {
                console.error('Error creating extract:', error);
                showToast('Failed to create extract: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        function confirmDeleteExtract(extractId) {
            state.extractToDelete = extractId;
            showConfirm(
                'Are you sure you want to delete this extract? This action cannot be undone.',
                'executeDeleteExtract',
                'üóëÔ∏è'
            );
        }

        async function executeDeleteExtract() {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const extractId = state.extractToDelete;
            state.extractToDelete = null;

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?id=eq.${extractId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract deletion failed:', errorData);
                    throw new Error(errorData.message || 'Failed to delete extract');
                }

                // Reload extracts
                await loadExtracts();

                showToast('Extract deleted successfully', 'success');
            } catch (error) {
                console.error('Error deleting extract:', error);
                showToast('Failed to delete extract: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                render();
            }
        }

        // Legacy function name for backwards compatibility
        async function deleteExtract(extractId) {
            confirmDeleteExtract(extractId);
        }

        async function startExtractVoting(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Get source contest to find the images
            let sourceContest = null;
            if (extract.sourceType === 'contest') {
                sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
            } else if (extract.sourceType === 'merger') {
                // For mergers, we need to get all images from all merged contests
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    // Create a temporary contest object with all merged images
                    const allImages = mergedContests.flatMap(c => c.images);
                    sourceContest = {
                        id: 'extract_' + extractId,
                        title: extract.name,
                        images: allImages.filter(img => extract.imageIds.includes(img.id)),
                        createdBy: extract.createdBy,
                        creatorName: extract.creatorName,
                        creatorAvatar: extract.creatorAvatar
                    };
                }
            } else if (extract.sourceType === 'extract') {
                // Get images from source extract
                const sourceExtract = state.extracts.find(e => e.id === extract.sourceContestId);
                if (sourceExtract && sourceExtract.sourceType === 'contest') {
                    const originalContest = state.contests.find(c => c.id === sourceExtract.sourceContestId);
                    if (originalContest) {
                        const filteredImages = originalContest.images.filter(img => extract.imageIds.includes(img.id));
                        sourceContest = {
                            id: 'extract_' + extractId,
                            title: extract.name,
                            images: filteredImages,
                            createdBy: extract.createdBy,
                            creatorName: extract.creatorName,
                            creatorAvatar: extract.creatorAvatar
                        };
                    }
                }
            }

            if (!sourceContest) {
                showToast('Source not found', 'error');
                return;
            }

            // Filter images to only those in the extract
            const extractImages = sourceContest.images.filter(img => extract.imageIds.includes(img.id));

            // Create a temporary contest object for voting
            const extractContest = {
                ...sourceContest,
                images: extractImages,
                title: extract.name,
                id: extract.sourceContestId || sourceContest.id
            };

            startVoting(extractContest);
        }

        async function viewExtractResults(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Check if user can view results (admin, creator, or source has public results)
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === extract.createdBy;

            if (!isAdmin && !isCreator) {
                // Check source contest/merger results_public
                if (extract.sourceType === 'contest') {
                    const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                    if (sourceContest && sourceContest.resultsPublic === false && sourceContest.createdBy !== state.user.id) {
                        showAlert('The source contest has private results. Only the creator or admin can view them.', 'üîí');
                        return;
                    }
                } else if (extract.sourceType === 'merger') {
                    const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (merger) {
                        const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                        const hasPrivateContest = mergedContests.some(c => c.resultsPublic === false && c.createdBy !== state.user.id);
                        if (hasPrivateContest) {
                            showAlert('Some contests in the source merger have private results. Only the creator or admin can view them.', 'üîí');
                            return;
                        }
                    }
                }
            }

            // Get source contest
            let sourceContest = null;
            if (extract.sourceType === 'contest') {
                sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
            } else if (extract.sourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    const allImages = mergedContests.flatMap(c => c.images);
                    sourceContest = {
                        id: 'extract_' + extractId,
                        title: extract.name,
                        images: allImages.filter(img => extract.imageIds.includes(img.id)),
                        createdBy: extract.createdBy,
                        creatorName: extract.creatorName,
                        creatorAvatar: extract.creatorAvatar
                    };
                }
            }

            if (!sourceContest) {
                showToast('Source not found', 'error');
                return;
            }

            // Filter images to only those in the extract
            const extractImages = sourceContest.images.filter(img => extract.imageIds.includes(img.id));

            // Create a temporary contest object for results
            const extractContest = {
                ...sourceContest,
                images: extractImages,
                title: extract.name,
                id: extract.sourceContestId || sourceContest.id
            };

            viewResults(extractContest);
        }

        // ==================== END EXTRACT SYSTEM FUNCTIONS ====================

        function handleVote(score) {
            if (state.isAnimating) return;
            
            state.isAnimating = true;
            const currentImage = state.shuffledImages[state.currentImageIndex];
            state.votes[currentImage.id] = score;
            state.showTickAnimation = true;
            
            render();

            setTimeout(() => {
                state.showTickAnimation = false;
                state.isAnimating = false;
                if (state.currentImageIndex < state.shuffledImages.length - 1) {
                    state.currentImageIndex++;
                }
                render();
            }, 500);
        }

        function navigateImage(direction) {
            if (direction === 'next') {
                if (state.currentImageIndex < state.shuffledImages.length - 1) {
                    state.currentImageIndex++;
                }
            } else if (direction === 'prev' && state.currentImageIndex > 0) {
                state.currentImageIndex--;
            }
            render();
        }

        function jumpToImage(index) {
            if (state.isAnimating) return;
            state.currentImageIndex = index;
            render();
        }

        function cancelVoting() {
            showConfirm(
                'Your progress will be lost if you proceed. Are you sure?',
                'confirmCancelVoting',
                'üö®'
            );
        }

        function submitVotes() {
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);
            if (!allVoted) {
                showAlert('Please vote on all images before submitting!', '‚ùå');
                return;
            }
            showConfirm(
                'Your votes cannot be changed after submission. If you made a mistake, you can contact me.',
                'confirmSubmitVotes',
                'üó≥Ô∏è'
            );
        }

        function showBreakdown(imageId) {
            state.showBreakdownModal = imageId;
            document.body.classList.add('modal-open');
            render();
        }

        function showVoterVotes(username) {
            // Set viewing specific user
            state.viewingSpecificUser = username;
            state.showMyVotes = false;
            state.showVoterBreakdown = false;

            // Filter mockResults to show only images with this user's votes
            // and update the results to show this user's score as the primary score
            state.results = state.results.map(img => {
                const vote = img.breakdown.find(v => v.username === username);
                if (vote) {
                    return {
                        ...img,
                        averageScore: vote.score,
                        userSpecificScore: vote.score
                    };
                }
                return null;
            }).filter(img => img !== null)
            .sort(compareWithTieBreaking);

            render();
        }

        function viewUserVotes(username) {
            // Alias for showVoterVotes for clarity
            showVoterVotes(username);
        }

        async function clearUserVotesView() {
            state.viewingSpecificUser = null;
            state.showVoterBreakdown = true;
            // Regenerate full results
            if (state.currentContest) {
                await loadResults();
            }
            render();
        }

        function closeBreakdown() {
            state.showBreakdownModal = null;
            document.body.classList.remove('modal-open');
            render();
        }

        // Admin vote editing
        async function adminEditVote(userId, imageId, currentScore) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Admin access required', 'üîí');
                return;
            }

            // Show modal with score buttons
            const voteData = state.results.find(r => r.id === imageId)?.breakdown.find(v => v.userId === userId);
            if (!voteData) return;

            showModal({
                type: 'custom',
                title: `Edit ${voteData.username}'s Vote`,
                icon: '‚úèÔ∏è',
                message: `Current score: ${currentScore}\nSelect new score:`,
                buttons: [1, 2, 3, 4, 5].map(score => ({
                    text: score.toString(),
                    primary: false,
                    action: `confirmEditVote_${userId}_${imageId}_${currentScore}_${score}`
                })).concat([{
                    text: 'Cancel',
                    primary: false,
                    action: 'closeModal'
                }])
            });
        }

        async function confirmEditVote(userId, imageId, oldScore, newScore) {
            try {
                // Close modal FIRST before setting modalProcessing
                state.modal = null;
                document.body.classList.remove('modal-open');
                render();

                state.modalProcessing = true;
                setLoading('Updating vote...');

                // Find the contest ID for this image
                const contestId = state.currentContest.id;

                // Update vote in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&image_id=eq.${imageId}&contest_id=eq.${contestId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({ score: parseInt(newScore) })
                });

                if (!response.ok) {
                    throw new Error('Failed to update vote');
                }

                showToast(`Vote updated from ${oldScore} to ${newScore}`, 'success');

                // Reload results to get fresh data
                await loadResults();
                clearLoading();

            } catch (error) {
                console.error('Error updating vote:', error);
                clearLoading();
                showAlert('Failed to update vote: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            }
        }

        // Admin vote blocking
        async function adminToggleBlockVote(userId, imageId, currentlyBlocked) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Admin access required', 'üîí');
                return;
            }

            const voteData = state.results.find(r => r.id === imageId)?.breakdown.find(v => v.userId === userId);
            if (!voteData) return;

            const action = currentlyBlocked ? 'unblock' : 'block';
            showConfirm(
                `Are you sure you want to ${action} ${voteData.username}'s vote?`,
                `executeToggleBlockVote_${userId}_${imageId}_${!currentlyBlocked}`,
                'üö´'
            );
        }

        async function executeToggleBlockVote(userId, imageId, shouldBlock) {
            try {
                // Close modal FIRST before setting modalProcessing
                state.modal = null;
                document.body.classList.remove('modal-open');
                render();

                state.modalProcessing = true;
                setLoading(shouldBlock ? 'Blocking vote...' : 'Unblocking vote...');

                // Find the contest ID for this image
                const contestId = state.currentContest.id;

                // Update vote in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&image_id=eq.${imageId}&contest_id=eq.${contestId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({ is_blocked: shouldBlock })
                });

                if (!response.ok) {
                    throw new Error('Failed to update vote block status');
                }

                showToast(`Vote ${shouldBlock ? 'blocked' : 'unblocked'}`, 'success');

                // Reload results to get fresh data with updated ban status
                await loadResults();

                // Re-render to refresh the breakdown modal
                render();

            } catch (error) {
                console.error('Error toggling vote block:', error);
                showAlert('Failed to toggle vote block: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
                state.modalProcessing = false;
            }
        }


        async function backToHome() {
            console.log('üè† [NAVIGATION] Returning to home from view:', state.view);

            // Check for both contest and merge voting in progress
            const isContestVoting = state.view === 'vote' && !state.hasSubmitted && state.currentContest && state.currentContest.images;
            const isMergeVoting = state.view === 'vote' && !state.hasSubmitted && state.currentMergerId && state.mergerContestIds && state.mergerContestIds.length > 0;

            if (isContestVoting || isMergeVoting) {
                showConfirm(
                    'Your progress will be lost if you proceed. Are you sure?',
                    'confirmBackToHome',
                    'üö®'
                );
                return;
            }

            // Refresh contest list (this now includes fresh voter counts)
            console.log('üîÑ [CLEANUP] Refreshing contest list');
            await loadContests();

            // Reset all contest-related state
            state.view = 'home';
            state.currentContest = null;
            state.showBreakdownModal = null;
            state.results = null;
            state.mergedResults = null;
            state.showMyVotes = false;
            state.resultsView = 'average';
            state.selectedVoterUserId = null;
            state.contestVoters = [];

            // Clear URL hash
            window.location.hash = '';

            console.log('‚úÖ [NAVIGATION] Successfully returned to home');

            render();
        }

        function confirmBackToHome() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Reset all contest-related state with null checks
            state.view = 'home';
            state.currentContest = null;
            state.showBreakdownModal = null;
            state.results = null;
            state.showMyVotes = false;
            state.resultsView = 'average';
            state.selectedVoterUserId = null;
            state.contestVoters = [];

            state.modalProcessing = false;
            render();
        }

        function toggleVoteView() {
            state.showMyVotes = !state.showMyVotes;
            render();
        }

        function setResultsView(view, userId = null) {
            state.resultsView = view;
            state.showMyVotes = view === 'userVotes';  // Backwards compatibility

            // Reset selected voter when changing views
            if (view !== 'userVotes') {
                state.selectedVoterUserId = null;
            } else if (userId !== null) {
                // If userId provided, select that user
                state.selectedVoterUserId = userId;
            } else if (state.selectedVoterUserId === null) {
                // Default to current user if not already selected
                state.selectedVoterUserId = state.user?.id || null;
            }

            render();
        }

        function setVoterSortBy(sortBy) {
            state.voterSortBy = sortBy;
            render();
        }

        function updateScale(value) {
            clearTimeout(state.scaleUpdateTimeout);
            state.scaleUpdateTimeout = setTimeout(() => {
                state.imageScale = parseInt(value);
                render();
            }, 200);
        }

        function adjustScale(delta) {
            const newScale = Math.max(40, Math.min(200, state.imageScale + delta));
            state.imageScale = newScale;
            render();
        }

        async function showAdminDashboard() {
            try {
                // Load all users from database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?select=*&order=username.asc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Failed to load users:', errorData);
                    throw new Error(errorData.message || 'Failed to load users');
                }

                const users = await response.json();
                console.log('üìä Loaded users from database:', users);

                // Update state with all users (including current user, banned users, etc.)
                state.allUsers = users.map(user => ({
                    id: user.id,
                    username: user.username,
                    avatar: user.avatar,
                    isBanned: user.is_banned || false
                }));

                console.log('üìä All users in state:', state.allUsers);

                // Fetch admin statistics from database with aggressive cache-busting
                const voterResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?select=user_id`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const votes = await voterResponse.json();

                // Check if votes response is valid
                if (!Array.isArray(votes)) {
                    console.error('Invalid votes response:', votes);
                    throw new Error(votes.message || 'Failed to load voter statistics');
                }

                // Count unique voters from users table
                const totalUniqueVoters = users.length;

                // Count total votes using COUNT(*)
                const votesCountResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'count=exact',
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                // Parse count from Content-Range header (e.g., "0-99/150" means 150 total)
                const contentRange = votesCountResponse.headers.get('Content-Range');
                const totalVotes = contentRange ? parseInt(contentRange.split('/')[1]) : 0;

                state.adminStats = { totalVotes, totalUniqueVoters };

                state.showAdminDashboard = true;
                document.body.classList.add('modal-open');
                render();
            } catch (error) {
                console.error('Error loading admin dashboard:', error);
                showAlert('Failed to load admin dashboard: ' + error.message, '‚ùå');
            }
        }

        function closeAdminDashboard() {
            state.showAdminDashboard = false;
            document.body.classList.remove('modal-open');
            render();
        }

        async function showAppSettings() {
            state.showAppSettingsModal = true;
            state.showUserDropdown = false;
            document.body.classList.add('modal-open');
            render();
        }

        function closeAppSettings() {
            state.showAppSettingsModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        async function toggleAppSetting(settingName) {
            try {
                // Get current value (default to true if not set)
                const currentValue = state.appSettings[settingName] !== false;
                const newValue = !currentValue;

                // Update in database
                // First, check if setting exists
                const checkResponse = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                const existingSettings = await checkResponse.json();

                if (existingSettings.length > 0) {
                    // Update existing setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update setting');
                    }
                } else {
                    // Insert new setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            setting_name: settingName,
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create setting');
                    }
                }

                // Update local state
                state.appSettings[settingName] = newValue;

                // Format setting name properly
                const formattedName = settingName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                showToast(
                    `‚úÖ ${formattedName} ${newValue ? 'enabled' : 'disabled'}`
                );
                render();
            } catch (error) {
                console.error('Error toggling app setting:', error);
                showToast('Failed to update setting: ' + error.message, 'error');
            }
        }

        async function updateAppSetting(settingName, newValue) {
            try {
                // Update in database
                // First, check if setting exists
                const checkResponse = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                const existingSettings = await checkResponse.json();

                if (existingSettings.length > 0) {
                    // Update existing setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update setting');
                    }
                } else {
                    // Insert new setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            setting_name: settingName,
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create setting');
                    }
                }

                // Update local state
                state.appSettings[settingName] = newValue;
            } catch (error) {
                console.error('Error updating app setting:', error);
                throw error;
            }
        }

        // ==================== FOLDER MANAGEMENT ====================

        function initializeFolderSortable() {
            const foldersList = document.getElementById('folders-list');
            if (!foldersList || typeof Sortable === 'undefined') return;

            // Initialize folder reordering
            new Sortable(foldersList, {
                animation: 150,
                handle: '.cursor-move',
                ghostClass: 'bg-blue-100',
                onEnd: async (evt) => {
                    // Skip if dropped at the same position
                    if (evt.oldIndex === evt.newIndex) {
                        return;
                    }

                    // Save scroll position before re-render
                    const modalContent = document.querySelector('.overflow-y-auto');
                    const scrollPos = modalContent ? modalContent.scrollTop : 0;

                    try {
                        // Get all children to determine what was moved
                        const children = Array.from(foldersList.children);
                        const movedElement = evt.item;
                        const isUnfolderedMoved = movedElement.hasAttribute('data-unfoldered');

                        // Get current unfoldered position
                        const currentUnfolderedPos = state.appSettings.unfoldered_items_position !== undefined
                            ? parseInt(state.appSettings.unfoldered_items_position)
                            : state.groups.length;

                        if (isUnfolderedMoved) {
                            // Unfoldered items meta-item was moved
                            // The new index IS the new position (since it's in the combined list)
                            const newUnfolderedPos = evt.newIndex;
                            await updateAppSetting('unfoldered_items_position', newUnfolderedPos);
                        } else {
                            // A folder was moved
                            // Need to adjust folder positions and possibly unfoldered position

                            // Count folders before and after unfoldered in the NEW layout
                            let newUnfolderedPos = currentUnfolderedPos;
                            const unfolderedElement = children.find(c => c.hasAttribute('data-unfoldered'));
                            if (unfolderedElement) {
                                newUnfolderedPos = Array.from(foldersList.children).indexOf(unfolderedElement);
                            }

                            // Build mapping of folder IDs to new positions (excluding unfoldered item)
                            const folderPositions = [];
                            children.forEach((child, visualIndex) => {
                                if (!child.hasAttribute('data-unfoldered')) {
                                    const folderId = child.getAttribute('data-folder-id');
                                    if (folderId) {
                                        // Calculate actual folder position (excluding unfoldered item)
                                        const actualPosition = visualIndex < newUnfolderedPos ? visualIndex : visualIndex - 1;
                                        folderPositions.push({ folderId, position: actualPosition });
                                    }
                                }
                            });

                            // Reorder state.groups to match new positions
                            const reorderedGroups = folderPositions
                                .sort((a, b) => a.position - b.position)
                                .map(fp => state.groups.find(g => g.id === fp.folderId))
                                .filter(Boolean);

                            state.groups = reorderedGroups;

                            // Save all folder positions
                            const updatePromises = state.groups.map((group, index) =>
                                saveFolderOrder(group.id, index)
                            );

                            await Promise.all(updatePromises);

                            // Update unfoldered position if it changed
                            if (newUnfolderedPos !== currentUnfolderedPos) {
                                await updateAppSetting('unfoldered_items_position', newUnfolderedPos);
                            }
                        }

                        // Only reload and re-render after successful save
                        await loadGroups();
                        render();

                        // Restore scroll position after render
                        setTimeout(() => {
                            const newModalContent = document.querySelector('.overflow-y-auto');
                            if (newModalContent) newModalContent.scrollTop = scrollPos;
                            initializeFolderSortable();
                        }, 100);
                    } catch (error) {
                        console.error('Failed to save folder order:', error);
                        showToast('Failed to save folder order', 'error');
                        // Reload to revert visual state
                        await loadGroups();
                        render();

                        // Restore scroll position after render
                        setTimeout(() => {
                            const newModalContent = document.querySelector('.overflow-y-auto');
                            if (newModalContent) newModalContent.scrollTop = scrollPos;
                            initializeFolderSortable();
                        }, 100);
                    }
                }
            });

            // Initialize item reordering within each folder
            state.groups.forEach(group => {
                const itemsList = document.getElementById(`folder-items-${group.id}`);
                if (itemsList) {
                    new Sortable(itemsList, {
                        animation: 150,
                        handle: '.cursor-move',
                        ghostClass: 'bg-blue-100',
                        onEnd: async (evt) => {
                            // Skip if dropped at the same position
                            if (evt.oldIndex === evt.newIndex) {
                                return;
                            }

                            // Save scroll position before re-render
                            const modalContent = document.querySelector('.overflow-y-auto');
                            const scrollPos = modalContent ? modalContent.scrollTop : 0;

                            try {
                                const folderId = itemsList.dataset.folderId;
                                const folder = state.groups.find(g => g.id === folderId);
                                if (!folder) return;

                                // Reorder the items array
                                const movedItem = folder.items.splice(evt.oldIndex, 1)[0];
                                folder.items.splice(evt.newIndex, 0, movedItem);

                                // Collect all update promises and execute in parallel
                                const updatePromises = folder.items.map((item, index) =>
                                    saveItemOrder(folderId, item.item_id, item.item_type, index)
                                );

                                // Wait for all saves to complete before proceeding
                                await Promise.all(updatePromises);

                                // Only reload and re-render after successful save
                                await loadGroups();
                                render();

                                // Restore scroll position after render
                                setTimeout(() => {
                                    const newModalContent = document.querySelector('.overflow-y-auto');
                                    if (newModalContent) newModalContent.scrollTop = scrollPos;
                                    initializeFolderSortable();
                                }, 100);
                            } catch (error) {
                                console.error('Failed to save item order:', error);
                                showToast('Failed to save item order', 'error');
                                // Reload to revert visual state
                                await loadGroups();
                                render();

                                // Restore scroll position after render
                                setTimeout(() => {
                                    const newModalContent = document.querySelector('.overflow-y-auto');
                                    if (newModalContent) newModalContent.scrollTop = scrollPos;
                                    initializeFolderSortable();
                                }, 100);
                            }
                        }
                    });
                }
            });
        }

        async function openManageFoldersModal() {
            state.showManageFoldersModal = true;
            state.showUserDropdown = false;
            document.body.classList.add('modal-open');
            await loadGroups();
            render();
            // Initialize SortableJS after render
            setTimeout(initializeFolderSortable, 100);
        }

        function closeManageFoldersModal() {
            state.showManageFoldersModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        function showCreateFolderModal() {
            state.modal = {
                icon: 'üìÅ',
                title: 'Create New Folder',
                type: 'input',
                placeholder: 'Enter folder name...',
                inputValue: '',
                buttons: [
                    {
                        text: 'Cancel',
                        primary: false,
                        action: 'cancelCreateFolder'
                    },
                    {
                        text: 'Create',
                        primary: true,
                        action: 'confirmCreateFolder'
                    }
                ]
            };
            document.body.classList.add('modal-open');
            render();
            // Focus the input after render
            setTimeout(() => {
                const input = document.getElementById('modal-input');
                if (input) input.focus();
            }, 100);
        }

        function cancelCreateFolder() {
            state.modal = null;
            document.body.classList.remove('modal-open');
            render();
        }

        async function confirmCreateFolder() {
            const folderName = document.getElementById('modal-input')?.value;
            if (!folderName || !folderName.trim()) {
                showToast('‚ùå Please enter a folder name');
                return;
            }
            state.modal = null;
            document.body.classList.remove('modal-open');
            await createFolder(folderName.trim());
        }

        async function createFolder(folderName) {
            try {
                setLoading('Creating folder...');
                const maxOrder = state.groups.length > 0 ? Math.max(...state.groups.map(g => g.display_order || 0)) : 0;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        name: folderName,
                        display_order: maxOrder + 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to create folder');
                }

                await loadGroups();
                showToast('‚úÖ Folder created successfully');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error creating folder:', error);
                showToast('‚ùå Failed to create folder: ' + error.message);
                clearLoading();
            }
        }

        function confirmDeleteFolder(folderId) {
            state.folderToDelete = folderId;
            showConfirm(
                'Delete this folder? Items will not be deleted, only ungrouped.',
                'executeDeleteFolder',
                'üóëÔ∏è'
            );
        }

        async function executeDeleteFolder() {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const folderId = state.folderToDelete;
            state.folderToDelete = null;

            try {
                setLoading('Deleting folder...');

                // First delete all contest_groups entries for this folder
                await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${folderId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                // Then delete the group itself
                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?id=eq.${folderId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete folder');
                }

                await loadGroups();
                showToast('Folder deleted successfully', 'success');
            } catch (error) {
                console.error('Error deleting folder:', error);
                showToast('Failed to delete folder: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                clearLoading();
                render();
            }
        }

        // Legacy function name for backwards compatibility
        async function deleteFolder(folderId) {
            confirmDeleteFolder(folderId);
        }

        async function addItemToFolder(folderId) {
            // Get all available items
            const allItems = [
                ...state.contests.map(c => ({ id: c.id, type: 'contest', title: c.title })),
                ...state.mergers.map(m => ({ id: m.id, type: 'merger', title: m.name })),
                ...state.extracts.map(e => ({ id: e.id, type: 'extract', title: e.name }))
            ];

            // Filter out items already in this folder
            const folder = state.groups.find(g => g.id === folderId);
            const folderItemIds = folder?.items?.map(i => `${i.item_type}:${i.item_id}`) || [];
            const availableItems = allItems.filter(item => !folderItemIds.includes(`${item.type}:${item.id}`));

            if (availableItems.length === 0) {
                showToast('No items available to add', 'info');
                return;
            }

            // Store data in state for the modal
            state.folderItemsToAdd = availableItems;
            state.targetFolderId = folderId;
            state.selectedFolderItems = []; // Reset selections

            // Show custom selection modal
            state.modal = {
                type: 'selectItem',
                icon: 'üìÅ',
                title: 'Add Items to Folder',
                message: 'Select one or more items to add to this folder:',
                items: availableItems,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Add Selected Items', action: 'confirmAddMultipleItemsToFolder', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function toggleFolderItemSelection(itemIndex) {
            const index = state.selectedFolderItems.indexOf(itemIndex);
            if (index > -1) {
                state.selectedFolderItems.splice(index, 1);
            } else {
                state.selectedFolderItems.push(itemIndex);
            }

            // Update the visual state of checkboxes without full re-render
            const checkbox = document.querySelector(`[data-folder-item-index="${itemIndex}"]`);
            if (checkbox) {
                const isSelected = state.selectedFolderItems.includes(itemIndex);
                const checkboxIcon = checkbox.querySelector('.checkbox-icon');
                if (checkboxIcon) {
                    if (isSelected) {
                        checkboxIcon.innerHTML = `
                            <svg class="w-5 h-5 text-mauve-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                            </svg>
                        `;
                        checkbox.classList.add('border-mauve-400', 'bg-mauve-50');
                        checkbox.classList.remove('border-gray-200');
                    } else {
                        checkboxIcon.innerHTML = '<div class="w-4 h-4 border-2 border-gray-400 rounded"></div>';
                        checkbox.classList.remove('border-mauve-400', 'bg-mauve-50');
                        checkbox.classList.add('border-gray-200');
                    }
                }
            }

            // Update button state
            const addButton = document.querySelector('[data-add-items-button]');
            if (addButton) {
                if (state.selectedFolderItems.length > 0) {
                    addButton.disabled = false;
                    addButton.className = 'px-5 py-2 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700';
                    addButton.textContent = `Add Selected Items (${state.selectedFolderItems.length})`;
                } else {
                    addButton.disabled = true;
                    addButton.className = 'px-5 py-2 rounded-lg font-semibold transition text-sm bg-gray-300 text-gray-500 cursor-not-allowed';
                    addButton.textContent = 'Add Selected Items';
                }
            }
        }

        async function confirmAddMultipleItemsToFolder() {
            if (state.modalProcessing) return;
            if (state.selectedFolderItems.length === 0) {
                showToast('Please select at least one item', 'error');
                return;
            }

            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const folderId = state.targetFolderId;

            try {
                setLoading(`Adding ${state.selectedFolderItems.length} item(s) to folder...`);
                const folder = state.groups.find(g => g.id === folderId);
                const maxOrder = folder?.items?.length > 0 ? Math.max(...folder.items.map(i => i.display_order || 0)) : -1;

                // Prepare batch of items to insert
                const itemsToInsert = state.selectedFolderItems.map((itemIndex, idx) => {
                    const selectedItem = state.folderItemsToAdd[itemIndex];
                    return {
                        group_id: folderId,
                        item_id: selectedItem.id,
                        item_type: selectedItem.type,
                        display_order: maxOrder + idx + 1
                    };
                });

                // Batch insert all items
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify(itemsToInsert)
                });

                if (!response.ok) {
                    throw new Error('Failed to add items to folder');
                }

                await loadGroups();
                showToast(`Added ${state.selectedFolderItems.length} item(s) successfully`, 'success');
                state.selectedFolderItems = [];
                render();
                setTimeout(initializeFolderSortable, 100);
            } catch (error) {
                console.error('Error adding items to folder:', error);
                showToast('Failed to add items: ' + error.message, 'error');
                render();
            } finally {
                state.modalProcessing = false;
                clearLoading();
            }
        }

        async function selectFolderItem(itemIndex) {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const selectedItem = state.folderItemsToAdd[itemIndex];
            const folderId = state.targetFolderId;

            try {
                setLoading('Adding item to folder...');
                const folder = state.groups.find(g => g.id === folderId);
                const maxOrder = folder?.items?.length > 0 ? Math.max(...folder.items.map(i => i.display_order || 0)) : 0;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        group_id: folderId,
                        item_id: selectedItem.id,
                        item_type: selectedItem.type,
                        display_order: maxOrder + 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to add item to folder');
                }

                await loadGroups();
                showToast('Item added to folder successfully', 'success');
            } catch (error) {
                console.error('Error adding item to folder:', error);
                showToast('Failed to add item to folder: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                clearLoading();
                render();
            }
        }

        async function removeItemFromFolder(groupId, itemId, itemType) {
            try {
                setLoading('Removing item from folder...');

                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${groupId}&item_id=eq.${itemId}&item_type=eq.${itemType}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to remove item from folder');
                }

                await loadGroups();
                showToast('Item removed from folder', 'success');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error removing item from folder:', error);
                showToast('Failed to remove item: ' + error.message, 'error');
                clearLoading();
            }
        }

        async function saveFolderOrder(folderId, newOrder) {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?id=eq.${folderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                },
                body: JSON.stringify({
                    display_order: newOrder
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(`Failed to update folder order: ${error.message || response.statusText}`);
            }
        }

        async function saveItemOrder(groupId, itemId, itemType, newOrder) {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${groupId}&item_id=eq.${itemId}&item_type=eq.${itemType}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                },
                body: JSON.stringify({
                    display_order: newOrder
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(`Failed to update item order: ${error.message || response.statusText}`);
            }
        }

        function toggleFolderExpanded(folderId) {
            const PINNED_FOLDER_ID = 'd88c5bcc-8b54-44ab-bca9-ed186124bcd2';

            // Pinned folder cannot be collapsed
            if (folderId === PINNED_FOLDER_ID) {
                return;
            }

            const index = state.expandedFolderIds.indexOf(folderId);
            if (index > -1) {
                state.expandedFolderIds.splice(index, 1);
            } else {
                state.expandedFolderIds.push(folderId);
            }
            render();
        }


        function viewAllByCreator(userId) {
            state.filters.createdBy = userId;
            state.view = 'home';
            render();
        }

        async function viewUserProfile(userId) {
            // Close other modals first to prevent stacking
            state.contestInfoModal = null;
            state.modal = null;

            state.viewingUserId = userId;
            state.showUserProfileModal = true;
            document.body.classList.add('modal-open');

            // Ensure allUsers is loaded
            if (!state.allUsers || state.allUsers.length === 0) {
                try {
                    const usersResponse = await fetch(`${SUPABASE_URL}/rest/v1/users?select=*`, {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    });

                    if (usersResponse.ok) {
                        const users = await usersResponse.json();
                        state.allUsers = users.map(user => ({
                            id: user.id,
                            username: user.username,
                            avatar: user.avatar,
                            isBanned: user.is_banned || false
                        }));
                    }
                } catch (error) {
                    console.error('Error loading users:', error);
                    state.allUsers = [];
                }
            }

            // Fetch user's voting history
            try {
                const votesResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&select=contest_id`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const userVotes = await votesResponse.json();

                // Store unique contest IDs this user has voted on
                state.userProfileVotedContests = [...new Set(userVotes.map(v => v.contest_id))];
            } catch (error) {
                console.error('Error loading user voting history:', error);
                state.userProfileVotedContests = [];
            }

            render();
        }

        function closeUserProfileModal() {
            state.showUserProfileModal = false;
            state.viewingUserId = null;
            state.userProfileVotedContests = [];
            document.body.classList.remove('modal-open');
            render();
        }

        async function banUser(userId, banReason) {
            try {
                // Update database with ban status and reason
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${userId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_banned: true,
                        ban_reason: banReason
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to ban user in database');
                }

                // Update local state
                if (!state.bannedUsers.includes(userId)) {
                    state.bannedUsers.push(userId);
                }

                // Update allUsers state
                const userIndex = state.allUsers.findIndex(u => u.id === userId);
                if (userIndex !== -1) {
                    state.allUsers[userIndex].isBanned = true;
                    state.allUsers[userIndex].banReason = banReason;
                }

                // Reload results to refresh vote data with updated ban status
                if (state.view === 'results' && state.currentContest) {
                    await loadResults();
                }

                showAlert('User has been banned.', '‚úÖ');
                render();
            } catch (error) {
                console.error('Error banning user:', error);
                showAlert('Failed to ban user: ' + error.message, '‚ùå');
            }
        }

        async function unbanUser(userId) {
            try {
                // Update database - clear ban status and reason
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${userId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_banned: false,
                        ban_reason: null
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to unban user in database');
                }

                // Update local state
                state.bannedUsers = state.bannedUsers.filter(id => id !== userId);

                // Update allUsers state
                const userIndex = state.allUsers.findIndex(u => u.id === userId);
                if (userIndex !== -1) {
                    state.allUsers[userIndex].isBanned = false;
                    state.allUsers[userIndex].banReason = null;
                }

                // Reload results to refresh vote data with updated ban status
                if (state.view === 'results' && state.currentContest) {
                    await loadResults();
                }

                showAlert('User has been unbanned. Their votes will now be included in results.', '‚úÖ');
                render();
            } catch (error) {
                console.error('Error unbanning user:', error);
                showAlert('Failed to unban user: ' + error.message, '‚ùå');
            }
        }

        function confirmBanUser(userId) {
            // Store userId for later use
            state.userToBan = userId;
            showInputModal(
                'Ban User - Enter Reason',
                'e.g., spam, inappropriate content, etc.',
                'handleBanUserReason',
                false
            );
        }

        function handleBanUserReason() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const banReason = input ? input.value.trim() : '';

            if (!banReason || banReason.length === 0) {
                showAlert('Ban reason cannot be empty.', '‚ùå');
                return;
            }
            if (banReason.length > 500) {
                showAlert('Ban reason is too long (max 500 characters).', '‚ùå');
                return;
            }

            // Proceed with ban
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            banUser(state.userToBan, banReason);
            state.userToBan = null;
            state.modalProcessing = false;
        }

        function executeBanUser(userId) {
            // This function is no longer used, but kept for backwards compatibility
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            banUser(userId, 'No reason provided');
            state.modalProcessing = false;
        }


        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (state.showBreakdownModal) {
                    closeBreakdown();
                } else if (state.modal) {
                    closeModal();
                }
            }
        });

        function renderToast() {
            if (!state.toast) return '';

            return `
                <div class="fixed top-4 left-1/2 transform -translate-x-1/2 z-[70] toast-notification">
                    <div class="bg-white rounded-lg shadow-2xl px-6 py-3 flex items-center gap-3 border-2 border-green-500">
                        <span class="text-2xl">${state.toast.icon}</span>
                        <span class="text-sm font-semibold text-gray-800">${state.toast.message}</span>
                    </div>
                </div>
            `;
        }

        function renderModal() {
            if (!state.modal) return '';

            const isInput = state.modal.type === 'input';
            const isSelectItem = state.modal.type === 'selectItem';

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-${isSelectItem ? '2xl' : 'md'} w-full ${isSelectItem ? 'max-h-[80vh]' : ''} p-6 modal-content ${isSelectItem ? 'flex flex-col' : ''}" onclick="event.stopPropagation()">
                        <div class="text-center mb-2 ${isSelectItem ? 'flex-shrink-0' : ''}">
                            <div class="text-5xl mb-2">${state.modal.icon}</div>
                            ${isInput ? `
                                <h3 class="text-xl font-bold text-gray-800 mb-2">${state.modal.title}</h3>
                                <input id="modal-input" type="text" value="${state.modal.inputValue || ''}" class="modal-input w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-mauve-400 focus:outline-none" placeholder="${state.modal.placeholder}" />
                            ` : isSelectItem ? `
                                <h3 class="text-xl font-bold text-gray-800 mb-2">${state.modal.title}</h3>
                                <p class="text-sm text-gray-600 mb-2">${state.modal.message}</p>
                            ` : `
                                <p class="text-base font-bold text-gray-800 whitespace-pre-line">${state.modal.message}</p>
                            `}
                        </div>
                        ${isSelectItem ? `
                            <div class="flex-1 overflow-y-auto mb-4">
                                <div class="space-y-2">
                                    ${state.modal.items.map((item, idx) => {
                                        const typeColor = item.type === 'contest' ? 'mauve' : item.type === 'merger' ? 'blue' : 'yellow';
                                        const isSelected = state.selectedFolderItems.includes(idx);
                                        return `
                                            <div data-folder-item-index="${idx}" class="border-2 ${isSelected ? 'border-mauve-400 bg-mauve-50' : 'border-gray-200'} rounded-lg p-3 cursor-pointer hover:border-${typeColor}-400 hover:bg-${typeColor}-50 transition"
                                                 onclick="toggleFolderItemSelection(${idx})">
                                                <div class="flex items-center gap-3">
                                                    <div class="checkbox-icon flex-shrink-0 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-md border-2 ${isSelected ? 'border-mauve-500' : 'border-gray-300'}">
                                                        ${isSelected ? `
                                                            <svg class="w-5 h-5 text-mauve-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                            </svg>
                                                        ` : `
                                                            <div class="w-4 h-4 border-2 border-gray-400 rounded"></div>
                                                        `}
                                                    </div>
                                                    <div class="flex-1">
                                                        <div class="font-semibold text-gray-800">${item.title}</div>
                                                        <div class="text-xs text-gray-500 uppercase">${item.type}</div>
                                                    </div>
                                                    <div class="text-2xl flex-shrink-0">
                                                        ${item.type === 'contest' ? 'üé®' : item.type === 'merger' ? 'üîÄ' : '‚≠ê'}
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        ` : ''}
                        <div class="flex gap-2 justify-center ${isSelectItem ? 'flex-shrink-0' : ''}">
                            ${(state.modal.buttons || []).map(btn => {
                                const deleteContestMatch = btn.action.match(/confirmDeleteContest_(.+)/);
                                const banUserMatch = btn.action.match(/executeBanUser_(.+)/);
                                const removeImageMatch = btn.action.match(/confirmRemoveImage_(.+)/);
                                const editVoteMatch = btn.action.match(/confirmEditVote_(.+)_(.+)_(.+)_(.+)/);
                                const toggleBlockMatch = btn.action.match(/executeToggleBlockVote_(.+)_(.+)_(true|false)/);
                                let onclick;
                                if (deleteContestMatch) {
                                    onclick = `confirmDeleteContest('${deleteContestMatch[1]}')`;
                                } else if (banUserMatch) {
                                    onclick = `executeBanUser('${banUserMatch[1]}')`;
                                } else if (removeImageMatch) {
                                    onclick = `confirmRemoveImage(${removeImageMatch[1]})`;
                                } else if (editVoteMatch) {
                                    onclick = `confirmEditVote('${editVoteMatch[1]}', ${editVoteMatch[2]}, ${editVoteMatch[3]}, ${editVoteMatch[4]})`;
                                } else if (toggleBlockMatch) {
                                    onclick = `executeToggleBlockVote('${toggleBlockMatch[1]}', ${toggleBlockMatch[2]}, ${toggleBlockMatch[3]})`;
                                } else {
                                    onclick = `${btn.action}()`;
                                }

                                const isAddButton = btn.action === 'confirmAddMultipleItemsToFolder';
                                const isDisabled = isAddButton && state.selectedFolderItems.length === 0;

                                return `
                                    <button
                                        ${isAddButton ? 'data-add-items-button' : ''}
                                        ${isDisabled ? 'disabled' : ''}
                                        onclick="${onclick}"
                                        class="px-5 py-2 rounded-lg font-semibold transition text-sm ${
                                            btn.primary
                                                ? isDisabled
                                                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                                    : 'bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700'
                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                        }"
                                    >
                                        ${btn.text}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCreateExtractModal() {
            if (!state.showCreateExtractModal) return '';

            // Step 1: Select source (contest or merger)
            if (!state.extractSourceType) {
                return `
                    <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeCreateExtractModal()">
                        <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                            <!-- Header -->
                            <div class="p-6 border-b border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <h3 class="text-xl font-bold text-gray-800">Create Extract - Select Source</h3>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Choose a contest or merger to extract images from
                                        </p>
                                    </div>
                                    <button onclick="closeCreateExtractModal()" class="text-gray-500 hover:text-gray-700">
                                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>

                            <!-- Source Selection -->
                            <div class="flex-1 overflow-y-auto p-6">
                                <div class="mb-4">
                                    <h4 class="font-semibold text-gray-700 mb-2">Contests</h4>
                                    <div class="space-y-2">
                                        ${state.contests.map(contest => `
                                            <div class="border border-gray-200 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-yellow-400 hover:bg-yellow-50"
                                                 onclick="selectExtractSource('contest', '${contest.id}')">
                                                <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                <div class="flex-1 min-w-0">
                                                    <h5 class="font-semibold text-gray-800 truncate">${contest.title}</h5>
                                                    <p class="text-xs text-gray-500">
                                                        ${contest.creatorName} ‚Ä¢ ${contest.images.length} images
                                                    </p>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>

                                ${state.mergers.length > 0 ? `
                                    <div class="mb-4">
                                        <h4 class="font-semibold text-gray-700 mb-2">Mergers</h4>
                                        <div class="space-y-2">
                                            ${state.mergers.map(merger => {
                                                const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                                                const totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);
                                                return `
                                                    <div class="border border-gray-200 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-yellow-400 hover:bg-yellow-50"
                                                         onclick="selectExtractSource('merger', '${merger.id}')">
                                                        <img src="${merger.creatorAvatar}" alt="${merger.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                        <div class="flex-1 min-w-0">
                                                            <h5 class="font-semibold text-gray-800 truncate">${merger.name}</h5>
                                                            <p class="text-xs text-gray-500">
                                                                ${merger.creatorName} ‚Ä¢ ${totalImages} images from ${mergedContests.length} contests
                                                            </p>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}

                                ${state.extracts.length > 0 ? `
                                    <div>
                                        <h4 class="font-semibold text-gray-700 mb-2">Extracts</h4>
                                        <div class="space-y-2">
                                            ${state.extracts.map(extract => `
                                                <div class="border border-gray-200 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-yellow-400 hover:bg-yellow-50"
                                                     onclick="selectExtractSource('extract', '${extract.id}')">
                                                    <img src="${extract.creatorAvatar}" alt="${extract.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                    <div class="flex-1 min-w-0">
                                                        <h5 class="font-semibold text-gray-800 truncate">${extract.name}</h5>
                                                        <p class="text-xs text-gray-500">
                                                            ${extract.creatorName} ‚Ä¢ ${extract.imageIds.length} images
                                                        </p>
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }

            // Step 2: Visual image picker
            let sourceImages = [];
            let sourceName = '';

            if (state.extractSourceType === 'contest') {
                const contest = state.contests.find(c => c.id === state.extractSourceId);
                if (contest) {
                    sourceImages = contest.images;
                    sourceName = contest.title;
                }
            } else if (state.extractSourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === state.extractSourceId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceImages = mergedContests.flatMap(c => c.images);
                    sourceName = merger.name;
                }
            } else if (state.extractSourceType === 'extract') {
                const extract = state.extracts.find(e => e.id === state.extractSourceId);
                if (extract) {
                    // Get images from the extract's source
                    if (extract.sourceType === 'contest') {
                        const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                        if (sourceContest) {
                            sourceImages = sourceContest.images.filter(img => extract.imageIds.includes(img.id));
                        }
                    } else if (extract.sourceType === 'merger') {
                        const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                        if (sourceMerger) {
                            const mergedContests = state.contests.filter(c => sourceMerger.contestIds.includes(c.id));
                            const allImages = mergedContests.flatMap(c => c.images);
                            sourceImages = allImages.filter(img => extract.imageIds.includes(img.id));
                        }
                    } else if (extract.sourceType === 'extract') {
                        // Recursively get images from source extract
                        const sourceExtract = state.extracts.find(e => e.id === extract.sourceContestId);
                        if (sourceExtract) {
                            // For now, just get the IDs - in practice we'd need to resolve the full image objects
                            sourceImages = extract.imageIds.map(id => ({ id, url: '' }));
                        }
                    }
                    sourceName = extract.name;
                }
            }

            const selectedCount = (state.extractSelectedImages || []).length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeCreateExtractModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">Create Extract - Select Images</h3>
                                    <p class="text-sm text-gray-600 mt-1" data-extract-count>
                                        From: ${sourceName} (${selectedCount} selected)
                                    </p>
                                </div>
                                <button onclick="closeCreateExtractModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Image Grid -->
                        <div class="flex-1 overflow-y-auto p-6">
                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                                ${sourceImages.map(image => {
                                    const isSelected = (state.extractSelectedImages || []).includes(image.id);
                                    return `
                                        <div data-image-id="${image.id}">
                                            <div
                                                class="relative cursor-pointer rounded-lg overflow-hidden border-4 ${isSelected ? 'border-blue-500 bg-blue-50' : 'border-transparent hover:border-blue-300'}"
                                                onclick="toggleExtractImage(${image.id})"
                                            >
                                            <img src="${image.url}" alt="${image.label || ''}" class="w-full h-32 object-cover" />
                                            ${image.label ? `
                                                <div class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-70 text-white text-xs p-1 truncate">
                                                    ${image.label}
                                                </div>
                                            ` : ''}
                                            <div class="absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 ${isSelected ? 'border-blue-500' : 'border-gray-300'}">
                                                ${isSelected ? `
                                                    <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                    </svg>
                                                ` : `
                                                    <div class="w-4 h-4 border-2 border-gray-400 rounded"></div>
                                                `}
                                            </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Name Input and Footer -->
                        <div class="p-6 border-t border-gray-200">
                            <div class="mb-4">
                                <label class="text-sm font-medium text-gray-700 mb-1 block">Extract Name</label>
                                <input
                                    id="extract-name-input"
                                    type="text"
                                    value="${state.newExtractName || ''}"
                                    oninput="setExtractName(this.value)"
                                    onblur="updateExtractNameOnBlur()"
                                    placeholder="Enter name for this extract..."
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-yellow-400 focus:outline-none"
                                />
                            </div>
                            <div class="flex gap-3">
                                <button
                                    onclick="closeCreateExtractModal()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                                >
                                    Cancel
                                </button>
                                <button
                                    data-extract-save
                                    onclick="saveExtract()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedCount > 0 && state.newExtractName ? 'bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedCount === 0 || !state.newExtractName ? 'disabled' : ''}
                                >
                                    Create Extract
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCreateMergerModal() {
            if (!state.showCreateMergerModal) return '';

            // State for selected contests for merging
            const selectedContests = state.selectedContestsForMerge || [];

            // Check if any selected contest has an extract that includes it
            // This prevents duplicate images (extract + source contest)
            const hasExtractConflict = selectedContests.some(contestId => {
                const contest = state.contests.find(c => c.id === contestId);
                if (!contest) return false;

                // Check if any extract uses this contest as a source
                return state.extracts.some(extract => {
                    if (extract.sourceType === 'contest' && extract.sourceContestId === contestId) {
                        // Check if any selected contest is in the extract's images
                        return selectedContests.some(otherContestId => {
                            if (otherContestId === contestId) return false;
                            const otherContest = state.contests.find(c => c.id === otherContestId);
                            if (!otherContest) return false;
                            // Check if any image from other contest is in the extract
                            return otherContest.images.some(img => extract.imageIds.includes(img.id));
                        });
                    }
                    return false;
                });
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeCreateMergerModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">Create Merge</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        Select contests to merge together (${selectedContests.length} selected, min 2 required)
                                    </p>
                                </div>
                                <button onclick="closeCreateMergerModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Contest List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-2">
                            ${state.contests.map(contest => {
                                const isSelected = selectedContests.includes(contest.id);

                                return `
                                    <div class="border ${isSelected ? 'border-blue-400 bg-blue-50' : 'border-gray-200'} rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-blue-300"
                                         onclick="toggleContestForMerger('${contest.id}')">
                                        <input
                                            type="checkbox"
                                            ${isSelected ? 'checked' : ''}
                                            class="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
                                            onclick="event.stopPropagation()"
                                            onchange="toggleContestForMerger('${contest.id}')"
                                        />
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h4 class="font-semibold text-gray-800 truncate">${contest.title}</h4>
                                            </div>
                                            <p class="text-xs text-gray-500">
                                                ${contest.creatorName} ‚Ä¢ ${contest.images.length} images ‚Ä¢ ${contest.voterCount || 0} voters
                                            </p>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <!-- Name Input and Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${hasExtractConflict ? `
                                <div class="mb-4 bg-red-50 border border-red-300 text-red-700 p-3 rounded-lg text-sm">
                                    ‚ö†Ô∏è Warning: You've selected a contest and an extract that includes images from that contest. This will create duplicates.
                                </div>
                            ` : ''}
                            <div class="mb-4">
                                <label class="text-sm font-medium text-gray-700 mb-1 block">Merger Name</label>
                                <input
                                    id="merger-name-input"
                                    type="text"
                                    value="${state.newMergerName || ''}"
                                    oninput="setMergerName(this.value)"
                                    onblur="updateMergerNameOnBlur()"
                                    placeholder="Enter name for this merger..."
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-blue-400 focus:outline-none"
                                />
                            </div>
                            <div class="flex gap-3">
                                <button
                                    onclick="closeCreateMergerModal()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                                >
                                    Cancel
                                </button>
                                <button
                                    onclick="saveMerger()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedContests.length >= 2 && state.newMergerName && !hasExtractConflict ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedContests.length < 2 || !state.newMergerName || hasExtractConflict ? 'disabled' : ''}
                                >
                                    Create Merger
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderUploadProgressModal() {
            if (!state.uploadProgress) return '';

            const allCompleted = state.uploadProgress.files.every(f => f.status === 'success' || f.status === 'failed');
            const successCount = state.uploadProgress.files.filter(f => f.status === 'success').length;
            const failedCount = state.uploadProgress.files.filter(f => f.status === 'failed').length;
            const uploadingCount = state.uploadProgress.files.filter(f => f.status === 'uploading' || f.status === 'compressing').length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">
                                        ${allCompleted ? 'Upload Complete' : 'Uploading Images...'}
                                    </h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        ${successCount} succeeded, ${failedCount} failed, ${uploadingCount} in progress
                                    </p>
                                </div>
                                <div class="text-3xl">
                                    ${allCompleted ? (failedCount > 0 ? '‚ö†Ô∏è' : '‚úÖ') : '‚è≥'}
                                </div>
                            </div>
                        </div>

                        <!-- File List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-3">
                            ${state.uploadProgress.files.map((file, index) => `
                                <div class="border border-gray-200 rounded-lg p-4 ${
                                    file.status === 'success' ? 'bg-green-50 border-green-200' :
                                    file.status === 'failed' ? 'bg-red-50 border-red-200' :
                                    'bg-blue-50 border-blue-200'
                                }">
                                    <div class="flex items-start justify-between mb-2">
                                        <div class="flex-1 min-w-0">
                                            <p class="font-medium text-gray-800 truncate" title="${file.name}">
                                                ${file.name}
                                            </p>
                                            ${file.needsCompression ? `
                                                <p class="text-xs text-gray-600 mt-1">
                                                    Original: ${(file.originalSize / 1024).toFixed(0)}KB
                                                    ${file.compressedSize ? `‚Üí Compressed: ${(file.compressedSize / 1024).toFixed(0)}KB (${Math.round((1 - file.compressedSize / file.originalSize) * 100)}% smaller)` : '‚Üí Compressing...'}
                                                </p>
                                            ` : file.originalSize ? `
                                                <p class="text-xs text-gray-600 mt-1">Size: ${(file.originalSize / 1024).toFixed(0)}KB</p>
                                            ` : ''}
                                            ${file.status === 'compressing' ? `
                                                <p class="text-xs text-blue-600 mt-1">üîÑ Compressing...</p>
                                            ` : ''}
                                            ${file.error ? `
                                                <p class="text-xs text-red-600 mt-1">${file.error}</p>
                                            ` : ''}
                                        </div>
                                        <div class="ml-3 text-2xl flex-shrink-0">
                                            ${file.status === 'success' ? '‚úÖ' :
                                              file.status === 'failed' ? '‚ùå' :
                                              file.status === 'compressing' ? 'üîÑ' :
                                              file.status === 'uploading' ? '‚è≥' : '‚è±Ô∏è'}
                                        </div>
                                    </div>

                                    <!-- Progress Bar -->
                                    ${file.status === 'uploading' || file.status === 'compressing' || file.status === 'pending' ? `
                                        <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                                            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300"
                                                 style="width: ${file.progress || 0}%"></div>
                                        </div>
                                        <p class="text-xs text-gray-600">
                                            ${file.status === 'compressing' ? 'Compressing...' : `${file.progress || 0}%`}
                                        </p>
                                    ` : ''}

                                    <!-- Retry Button -->
                                    ${file.status === 'failed' ? `
                                        <button onclick="retryUpload(${index})"
                                                class="mt-2 px-3 py-1 text-xs bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">
                                            üîÑ Retry Upload
                                        </button>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>

                        <!-- Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${allCompleted ? `
                                <button onclick="closeUploadProgress()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700">
                                    Done
                                </button>
                            ` : `
                                <button onclick="cancelAllUploads()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300">
                                    Cancel Remaining Uploads
                                </button>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCompressionModal() {
            if (!state.compressionProgress) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const allCompleted = state.compressionProgress.allComplete;
            const completeCount = state.compressionProgress.files.filter(f => f.status === 'complete').length;
            const failedCount = state.compressionProgress.files.filter(f => f.status === 'failed' && !f.adminBypass).length;
            const compressingCount = state.compressionProgress.files.filter(f => f.status === 'compressing').length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-3xl w-full max-h-[85vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">
                                        ${allCompleted ? 'Compression Complete' : 'Compressing Images...'}
                                    </h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        ${completeCount} completed, ${failedCount} failed, ${compressingCount} in progress
                                    </p>
                                </div>
                                <div class="text-3xl">
                                    ${allCompleted ? (failedCount > 0 ? '‚ö†Ô∏è' : '‚úÖ') : 'üîÑ'}
                                </div>
                            </div>
                        </div>

                        <!-- File List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-4">
                            ${state.compressionProgress.files.map((fileState, index) => {
                                const isOversized = fileState.status === 'failed' && fileState.compressedSize > 500 * 1024;
                                const bgColor = fileState.status === 'complete' || fileState.adminBypass ? 'bg-green-50 border-green-200' :
                                                fileState.status === 'failed' ? 'bg-red-50 border-red-200' :
                                                'bg-blue-50 border-blue-200';

                                return `
                                    <div class="border border-gray-200 rounded-lg p-4 ${bgColor}">
                                        <div class="flex items-start justify-between mb-2">
                                            <div class="flex-1 min-w-0">
                                                <p class="font-medium text-gray-800 truncate" title="${fileState.name}">
                                                    ${fileState.name}
                                                </p>
                                                <div class="flex flex-wrap gap-3 mt-2 text-xs text-gray-600">
                                                    <span><strong>Original:</strong> ${formatFileSize(fileState.originalSize)}</span>
                                                    ${fileState.compressedSize ? `
                                                        <span><strong>Compressed:</strong> ${formatFileSize(fileState.compressedSize)}</span>
                                                    ` : ''}
                                                    ${fileState.savingsPercent > 0 ? `
                                                        <span class="text-green-600 font-semibold">Saved ${fileState.savingsPercent}%</span>
                                                    ` : ''}
                                                </div>
                                                ${fileState.status === 'compressing' ? `
                                                    <p class="text-xs text-blue-600 mt-1">üîÑ Compressing...</p>
                                                ` : ''}
                                                ${fileState.status === 'complete' ? `
                                                    <p class="text-xs text-green-600 mt-1">‚úÖ Complete</p>
                                                ` : ''}
                                                ${fileState.status === 'failed' && !fileState.adminBypass ? `
                                                    <p class="text-xs text-red-600 mt-1">‚ùå ${fileState.error}</p>
                                                ` : ''}
                                                ${fileState.adminBypass ? `
                                                    <p class="text-xs text-orange-600 mt-1 font-semibold">‚ö†Ô∏è Admin override: Adding image exceeding 500 KB limit</p>
                                                ` : ''}
                                            </div>
                                            <div class="ml-3 text-2xl flex-shrink-0">
                                                ${fileState.status === 'complete' || fileState.adminBypass ? '‚úÖ' :
                                                  fileState.status === 'failed' ? '‚ùå' :
                                                  'üîÑ'}
                                            </div>
                                        </div>

                                        <!-- Progress Bar -->
                                        ${fileState.status === 'compressing' ? `
                                            <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                                                <div class="bg-blue-500 h-2 rounded-full transition-all duration-300"
                                                     style="width: ${fileState.progress || 0}%"></div>
                                            </div>
                                            <p class="text-xs text-gray-600">${fileState.progress || 0}%</p>
                                        ` : ''}

                                        <!-- Action Buttons -->
                                        <div class="flex gap-2 mt-3">
                                            ${fileState.status === 'complete' && fileState.canCompressMore ? `
                                                <button onclick="compressMoreImage(${index})"
                                                        class="px-3 py-1.5 text-xs bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition font-medium">
                                                    üîΩ Compress More
                                                </button>
                                            ` : ''}
                                            ${fileState.status === 'failed' && isAdmin && isOversized && !fileState.adminBypass ? `
                                                <button onclick="addOversizedImageAnyway(${index})"
                                                        class="px-3 py-1.5 text-xs bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition font-medium">
                                                    ‚ö†Ô∏è Add Anyway
                                                </button>
                                            ` : ''}
                                            ${(fileState.status === 'complete' || fileState.status === 'failed') && !fileState.adminBypass ? `
                                                <button onclick="cancelCompressionImage(${index})"
                                                        class="px-3 py-1.5 text-xs bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition font-medium">
                                                    ‚úñ Cancel Image
                                                </button>
                                            ` : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <!-- Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${allCompleted ? `
                                <button onclick="closeCompressionModal()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-green-500 to-green-700 text-white hover:from-green-600 hover:to-green-800">
                                    Done (${completeCount + (isAdmin ? state.compressionProgress.files.filter(f => f.adminBypass).length : 0)} images will be added)
                                </button>
                            ` : `
                                <p class="text-sm text-gray-600 text-center">
                                    Please wait for compression to complete...
                                </p>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderLoadingOverlay() {
            if (!state.isLoading) return '';
            return `<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100]">
                <div class="bg-white rounded-lg p-6 flex flex-col items-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-mauve-500 mb-3"></div>
                    <p class="text-gray-700 font-semibold">${state.loadingMessage}</p>
                </div>
            </div>`;
        }

        function renderHeader() {
            const showBackButton = state.view === 'results' || state.view === 'vote' || state.view === 'mergedResults';
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

            return `
                <header class="safe-header bg-gradient-to-r from-mauve-600 via-mauve-300 to-green-700 text-white shadow-lg">
                    <div class="max-w-7xl mx-auto px-3 py-2 sm:py-3 flex justify-between items-center gap-2">
                        <div class="flex items-center gap-2">
                            <div onclick="backToHome()" class="w-8 h-8 rounded-full flex items-center justify-center bg-gradient-to-br from-mauve-300 to-mauve-500 cursor-pointer hover:opacity-80 transition">
                                <span class="text-xl">üå∫</span>
                            </div>
                            <h1 onclick="backToHome()" class="text-xl font-bold cursor-pointer hover:opacity-80 transition">Peony</h1>
                            ${showBackButton ? `
                                <button onclick="backToHome()" class="ml-2 bg-white/20 hover:bg-white/30 text-white px-3 py-1.5 sm:py-1 rounded-lg font-semibold transition text-sm flex items-center gap-1 min-h-[36px] sm:min-h-0">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                                    </svg>
                                    Back
                                </button>
                            ` : ''}
                        </div>
                        
                        ${!state.isLoggedIn ? `
                            <button onclick="login()" class="bg-white text-mauve-500 px-4 py-2 rounded-lg font-semibold hover:bg-pink-50 transition text-sm min-h-[36px]">
                                Login with Discord
                            </button>
                        ` : `
                            <div class="flex items-center gap-2">
                                <div class="relative">
                                    <button onclick="toggleUserDropdown()" class="flex items-center gap-2 cursor-pointer hover:opacity-80 focus:outline-none">
                                        <img src="${state.user.avatar}" alt="Avatar" class="w-7 h-7 rounded-full" />
                                        <span class="font-medium text-sm hidden sm:inline">${state.user.username}</span>
                                        <svg class="w-4 h-4 transition-transform ${state.showUserDropdown ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                                        </svg>
                                    </button>
                                    ${state.showUserDropdown ? `
                                        <div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg py-1 z-50">
                                            ${isAdmin ? `
                                                <button onclick="showAdminDashboard()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    ‚öôÔ∏è Admin Dashboard
                                                </button>
                                                <button onclick="showAppSettings()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    üîß App Settings
                                                </button>
                                                <button onclick="openManageFoldersModal()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    üìÅ Manage Folders
                                                </button>
                                            ` : ''}
                                            <button onclick="logout()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 ${isAdmin ? 'border-t border-gray-200' : ''}">
                                                Logout
                                            </button>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `}
                    </div>
                </header>
            `;
        }

        function renderLoginScreen() {
            return `
                <div class="max-w-md mx-auto mt-20 p-6 bg-white rounded-2xl shadow-xl fade-in">
                    <div class="text-center mb-6">
                        <div class="w-16 h-16 bg-gradient-to-br from-mauve-300 to-mauve-500 rounded-full flex items-center justify-center mx-auto mb-4">
                            <span class="text-3xl">üå∫</span>
                        </div>
                        <h2 class="text-2xl font-bold text-gray-800 mb-2">Welcome to Peony</h2>
                        <p class="text-gray-600 text-sm">Create and vote on image contests</p>
                    </div>
                    
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
                        <p class="text-xs text-blue-800">
                            <strong>Privacy Notice:</strong> This app only accesses your Discord username and avatar. Contact me if you have any questions.
                        </p>
                    </div>
                    
                    <button onclick="login()" class="w-full bg-gradient-to-r from-indigo-600 to-indigo-700 text-white py-3 rounded-lg font-semibold hover:from-indigo-700 hover:to-indigo-800 transition flex items-center justify-center gap-2 text-sm">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                        Login with Discord
                    </button>
                </div>
            `;
        }

        function setSortBy(sortBy) {
            state.filters.sortBy = sortBy;
            render();
        }

        function setFilterCreator(creatorId) {
            state.filters.createdBy = creatorId === 'all' ? null : creatorId;
            render();
        }

        function setSearchQuery(query) {
            state.filters.searchQuery = query;
            // Update URL parameter
            const url = new URL(window.location);
            if (query) {
                url.searchParams.set('search', query);
            } else {
                url.searchParams.delete('search');
            }
            window.history.replaceState({}, '', url);
            render();
        }

        function applySearch() {
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                setSearchQuery(searchInput.value);
            }
        }

        function clearAllFilters() {
            state.filters.createdBy = null;
            state.filters.sortBy = 'withFolders';
            state.filters.searchQuery = '';
            // Clear URL parameter
            const url = new URL(window.location);
            url.searchParams.delete('search');
            window.history.replaceState({}, '', url);
            render();
        }

        function renderHome() {
            // Get unique creators
            const creators = [...new Set(state.contests.map(c => ({ id: c.createdBy, name: c.creatorName })))];
            const uniqueCreators = Array.from(new Map(creators.map(c => [c.id, c])).values());

            // Filter contests
            let filteredContests = state.contests;
            let filteredMergers = state.mergers;
            let filteredExtracts = state.extracts;

            // Filter by creator
            if (state.filters.createdBy) {
                filteredContests = filteredContests.filter(c => c.createdBy === state.filters.createdBy);
                filteredMergers = filteredMergers.filter(m => m.createdBy === state.filters.createdBy);
                filteredExtracts = filteredExtracts.filter(e => e.createdBy === state.filters.createdBy);
            }

            // Filter by search query
            if (state.filters.searchQuery) {
                const searchLower = state.filters.searchQuery.toLowerCase();
                filteredContests = filteredContests.filter(c =>
                    c.title.toLowerCase().includes(searchLower) ||
                    (c.creatorName && c.creatorName.toLowerCase().includes(searchLower))
                );
                filteredMergers = filteredMergers.filter(m =>
                    m.name.toLowerCase().includes(searchLower) ||
                    (m.creatorName && m.creatorName.toLowerCase().includes(searchLower))
                );
                filteredExtracts = filteredExtracts.filter(e =>
                    e.name.toLowerCase().includes(searchLower) ||
                    (e.creatorName && e.creatorName.toLowerCase().includes(searchLower))
                );
            }

            // Sort contests
            filteredContests = [...filteredContests].sort((a, b) => {
                const voterCountA = a.voterCount || 0;
                const voterCountB = b.voterCount || 0;

                switch (state.filters.sortBy) {
                    case 'newest':
                    case 'dateDesc':
                        return (b.createdAt || 0) - (a.createdAt || 0);
                    case 'oldest':
                    case 'dateAsc':
                        return (a.createdAt || 0) - (b.createdAt || 0);
                    case 'titleAsc':
                        return a.title.toLowerCase().localeCompare(b.title.toLowerCase());
                    case 'titleDesc':
                        return b.title.toLowerCase().localeCompare(a.title.toLowerCase());
                    case 'mostVoted':
                    case 'votersDesc':
                        return voterCountB - voterCountA;
                    case 'leastVoted':
                    case 'votersAsc':
                        return voterCountA - voterCountB;
                    case 'imagesDesc':
                        return b.images.length - a.images.length;
                    case 'imagesAsc':
                        return a.images.length - b.images.length;
                    default:
                        return 0;
                }
            });

            const isBanned = state.bannedUsers.includes(state.user.id);

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="flex justify-between items-center mb-4 gap-2 flex-wrap">
                        <h2 class="text-2xl font-bold text-gray-800">All Contests</h2>
                        <div class="flex gap-2 flex-wrap">
                            ${isBanned ? `
                                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded-lg text-sm">
                                    üö´ Your account has been restricted. Contact admin.
                                </div>
                            ` : (() => {
                                const contestCreationEnabled = state.appSettings.contest_creation_enabled !== false;
                                const isAdmin = state.user.id === ADMIN_DISCORD_ID;

                                if (!contestCreationEnabled && !isAdmin) {
                                    return `
                                        <button onclick="showContestCreationDisabledModal()" class="bg-gray-400 text-gray-200 px-2 sm:px-4 py-2 rounded-lg font-semibold cursor-not-allowed opacity-50 text-xs sm:text-sm whitespace-nowrap">
                                            + Create Contest
                                        </button>
                                    `;
                                }

                                return `
                                    <button onclick="startCreateContest()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-2 sm:px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg text-xs sm:text-sm whitespace-nowrap">
                                        + Create Contest
                                    </button>
                                `;
                            })()}
                            ${state.user.id === ADMIN_DISCORD_ID ? `
                                <button onclick="openCreateMergerModal()" class="bg-gradient-to-r from-purple-500 to-purple-700 text-white px-2 sm:px-4 py-2 rounded-lg font-semibold hover:from-purple-600 hover:to-purple-800 transition shadow-lg text-xs sm:text-sm whitespace-nowrap">
                                    + Create Merge
                                </button>
                                <button onclick="openCreateExtractModal()" class="bg-gradient-to-r from-yellow-500 to-yellow-700 text-white px-2 sm:px-4 py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-800 transition shadow-lg text-xs sm:text-sm whitespace-nowrap">
                                    + Create Extract
                                </button>
                            ` : ''}
                        </div>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-3 mb-4">
                        <div class="mb-3">
                            <label class="text-xs font-medium text-gray-700 mb-1 block">Search Contests</label>
                            <div class="flex gap-2">
                                <input
                                    id="search-input"
                                    type="text"
                                    value="${state.filters.searchQuery || ''}"
                                    onkeypress="if(event.key==='Enter') applySearch()"
                                    placeholder="Search by contest title or creator name..."
                                    class="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none"
                                />
                                <button
                                    onclick="applySearch()"
                                    class="px-4 py-2 bg-mauve-500 text-white rounded-lg text-sm font-semibold hover:bg-mauve-600 transition"
                                >
                                    Search
                                </button>
                            </div>
                        </div>
                        <div class="flex gap-3 flex-wrap">
                        <div class="flex-1 min-w-[200px]">
                            <label class="text-xs font-medium text-gray-700 mb-1 block">Sort By</label>
                            <select onchange="setSortBy(this.value)" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none">
                                <option value="withFolders" ${state.filters.sortBy === 'withFolders' ? 'selected' : ''}>With Folders</option>
                                <option value="newest" ${state.filters.sortBy === 'newest' || state.filters.sortBy === 'dateDesc' ? 'selected' : ''}>Newest First</option>
                                <option value="oldest" ${state.filters.sortBy === 'oldest' || state.filters.sortBy === 'dateAsc' ? 'selected' : ''}>Oldest First</option>
                                <option value="titleAsc" ${state.filters.sortBy === 'titleAsc' ? 'selected' : ''}>A-Z</option>
                                <option value="titleDesc" ${state.filters.sortBy === 'titleDesc' ? 'selected' : ''}>Z-A</option>
                                <option value="mostVoted" ${state.filters.sortBy === 'mostVoted' || state.filters.sortBy === 'votersDesc' ? 'selected' : ''}>Most Voters</option>
                                <option value="leastVoted" ${state.filters.sortBy === 'leastVoted' || state.filters.sortBy === 'votersAsc' ? 'selected' : ''}>Fewest Voters</option>
                                <option value="imagesDesc" ${state.filters.sortBy === 'imagesDesc' ? 'selected' : ''}>Most Images</option>
                                <option value="imagesAsc" ${state.filters.sortBy === 'imagesAsc' ? 'selected' : ''}>Fewest Images</option>
                            </select>
                        </div>
                        <div class="flex-1 min-w-[200px]">
                            <label class="text-xs font-medium text-gray-700 mb-1 block">Filter by Creator</label>
                            <select onchange="setFilterCreator(this.value)" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none">
                                <option value="all" ${state.filters.createdBy === null ? 'selected' : ''}>All Creators</option>
                                ${uniqueCreators.map(creator => `
                                    <option value="${creator.id}" ${state.filters.createdBy === creator.id ? 'selected' : ''}>${creator.name}</option>
                                `).join('')}
                            </select>
                        </div>
                        ${state.filters.createdBy || state.filters.sortBy !== 'withFolders' || state.filters.searchQuery ? `
                            <div class="flex items-end">
                                <button onclick="clearAllFilters()" class="bg-red-500 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-600 transition text-sm">
                                    Clear All Filters
                                </button>
                            </div>
                        ` : ''}
                        </div>
                    </div>

                    ${state.filters.createdBy || state.filters.searchQuery ? `
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 flex gap-2 items-center flex-wrap">
                            <span class="text-sm font-medium text-blue-800">Active Filters:</span>
                            ${state.filters.createdBy ? `
                                <span class="bg-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs font-semibold flex items-center gap-1">
                                    Creator: ${uniqueCreators.find(c => c.id === state.filters.createdBy)?.name || 'Unknown'}
                                    <button onclick="setFilterCreator('all')" class="hover:text-blue-900">‚úï</button>
                                </span>
                            ` : ''}
                            ${state.filters.searchQuery ? `
                                <span class="bg-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs font-semibold flex items-center gap-1">
                                    Search: "${state.filters.searchQuery}"
                                    <button onclick="setSearchQuery('')" class="hover:text-blue-900">‚úï</button>
                                </span>
                            ` : ''}
                        </div>
                    ` : ''}

                    ${(() => {
                        // Combine filtered contests, mergers, and extracts into a unified list
                        const allItems = [
                            ...filteredMergers.map(m => ({ ...m, itemType: 'merger' })),
                            ...filteredExtracts.map(e => ({ ...e, itemType: 'extract' })),
                            ...filteredContests.map(c => ({ ...c, itemType: 'contest' }))
                        ];

                        // Apply sorting based on selected sort option
                        allItems.sort((a, b) => {
                            // Get voter counts (handle both single voterCount and min/max ranges)
                            const getVoterCount = (item) => {
                                if (item.voterCountMax !== undefined) return item.voterCountMax;
                                if (item.voterCount !== undefined) return item.voterCount;
                                return 0;
                            };
                            const voterCountA = getVoterCount(a);
                            const voterCountB = getVoterCount(b);

                            // Get image/item counts
                            const getItemCount = (item) => {
                                if (item.images) return item.images.length;
                                if (item.imageIds) return item.imageIds.length;
                                return 0;
                            };
                            const itemCountA = getItemCount(a);
                            const itemCountB = getItemCount(b);

                            // Get titles/names for sorting
                            const titleA = (a.title || a.name || '').toLowerCase();
                            const titleB = (b.title || b.name || '').toLowerCase();

                            switch (state.filters.sortBy) {
                                case 'newest':
                                case 'dateDesc':
                                case 'withFolders':
                                    return (b.createdAt || 0) - (a.createdAt || 0);
                                case 'oldest':
                                case 'dateAsc':
                                    return (a.createdAt || 0) - (b.createdAt || 0);
                                case 'titleAsc':
                                    return titleA.localeCompare(titleB);
                                case 'titleDesc':
                                    return titleB.localeCompare(titleA);
                                case 'mostVoted':
                                case 'votersDesc':
                                    return voterCountB - voterCountA;
                                case 'leastVoted':
                                case 'votersAsc':
                                    return voterCountA - voterCountB;
                                case 'imagesDesc':
                                    return itemCountB - itemCountA;
                                case 'imagesAsc':
                                    return itemCountA - itemCountB;
                                default:
                                    return (b.createdAt || 0) - (a.createdAt || 0);
                            }
                        });

                        // Check if we should show folders (only when sort is withFolders and no filters)
                        const showFolders = state.filters.sortBy === 'withFolders' && !state.filters.createdBy && !state.filters.searchQuery;

                        if (showFolders && state.groups.length > 0) {
                            // Get items that are in folders
                            const itemsInFolders = new Set();
                            state.groups.forEach(group => {
                                (group.items || []).forEach(item => {
                                    itemsInFolders.add(`${item.item_type}:${item.item_id}`);
                                });
                            });

                            // Get ungrouped items
                            const ungroupedItems = allItems.filter(item =>
                                !itemsInFolders.has(`${item.itemType}:${item.id}`)
                            );

                            // Pinned folder ID - always first, always expanded, red gradient
                            const PINNED_FOLDER_ID = 'd88c5bcc-8b54-44ab-bca9-ed186124bcd2';

                            // Sort folders: pinned first, then others
                            const sortedGroups = [...state.groups].sort((a, b) => {
                                if (a.id === PINNED_FOLDER_ID) return -1;
                                if (b.id === PINNED_FOLDER_ID) return 1;
                                return 0;
                            });

                            // Get unfoldered items position from app settings (default to bottom if not set)
                            const unfolderedPosition = state.appSettings.unfoldered_items_position !== undefined
                                ? parseInt(state.appSettings.unfoldered_items_position)
                                : sortedGroups.length;

                            // Helper function to render a folder
                            const renderFolder = (group) => {
                                const isPinned = group.id === PINNED_FOLDER_ID;
                                const isExpanded = isPinned || state.expandedFolderIds.includes(group.id);
                                // Get actual items for this folder
                                const folderItems = (group.items || []).map(item => {
                                    if (item.item_type === 'contest') {
                                        const contest = state.contests.find(c => c.id === item.item_id);
                                        return contest ? { ...contest, itemType: 'contest' } : null;
                                    } else if (item.item_type === 'merger') {
                                        const merger = state.mergers.find(m => m.id === item.item_id);
                                        return merger ? { ...merger, itemType: 'merger' } : null;
                                    } else if (item.item_type === 'extract') {
                                        const extract = state.extracts.find(e => e.id === item.item_id);
                                        return extract ? { ...extract, itemType: 'extract' } : null;
                                    }
                                    return null;
                                }).filter(Boolean);

                                const headerGradient = isPinned
                                    ? 'bg-gradient-to-r from-red-400 to-red-600 hover:from-red-500 hover:to-red-700'
                                    : 'bg-gradient-to-r from-mauve-400 to-mauve-600 hover:from-mauve-500 hover:to-mauve-700';
                                const contentGradient = isPinned
                                    ? 'bg-gradient-to-b from-red-50 to-red-100'
                                    : 'bg-gradient-to-b from-pink-50 to-pink-100';

                                return `
                                    <div class="bg-white rounded-xl shadow-lg overflow-hidden mb-4 fade-in">
                                        <div class="${headerGradient} p-4 cursor-pointer transition" onclick="toggleFolderExpanded('${group.id}')">
                                            <div class="flex items-center gap-3 text-white">
                                                <svg class="w-5 h-5 transition-transform ${isExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                </svg>
                                                ${isPinned ? `
                                                    <span class="text-2xl">üìå</span>
                                                ` : `
                                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
                                                    </svg>
                                                `}
                                                <div class="flex-1">
                                                    <h3 class="text-lg font-bold">${group.name}</h3>
                                                    ${isPinned ? `<p class="text-xs opacity-90 mt-0.5">Trending Must-Votes üî•</p>` : ''}
                                                </div>
                                                <span class="text-sm opacity-90">${folderItems.length} items</span>
                                            </div>
                                        </div>
                                        ${isExpanded ? `
                                            <div class="p-4 ${contentGradient}">
                                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                                    ${folderItems.map(item => {
                                                        if (item.itemType === 'merger') {
                                                            return renderMergerCard(item);
                                                        } else if (item.itemType === 'extract') {
                                                            return renderExtractCard(item);
                                                        } else {
                                                            return renderContestCard(item);
                                                        }
                                                    }).join('')}
                                                </div>
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            };

                            // Helper function to render unfoldered items
                            const renderUnfolderedItems = () => {
                                if (ungroupedItems.length === 0) return '';
                                return `
                                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 mb-4">
                                        ${ungroupedItems.map(item => {
                                            if (item.itemType === 'merger') {
                                                return renderMergerCard(item);
                                            } else if (item.itemType === 'extract') {
                                                return renderExtractCard(item);
                                            } else {
                                                return renderContestCard(item);
                                            }
                                        }).join('')}
                                    </div>
                                `;
                            };

                            // Build the output with unfoldered items at the correct position
                            return `
                                ${(() => {
                                    let output = '';
                                    sortedGroups.forEach((group, index) => {
                                        // Insert unfoldered items before this folder if needed
                                        if (index === unfolderedPosition) {
                                            output += renderUnfolderedItems();
                                        }
                                        output += renderFolder(group);
                                    });
                                    // Insert unfoldered items at the end if position >= folder count
                                    if (unfolderedPosition >= sortedGroups.length) {
                                        output += renderUnfolderedItems();
                                    }
                                    return output;
                                })()}
                            `;
                        } else {
                            // Show flat list when not using default sort or when no folders exist
                            return `
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                    ${allItems.map(item => {
                                        if (item.itemType === 'merger') {
                                            return renderMergerCard(item);
                                        } else if (item.itemType === 'extract') {
                                            return renderExtractCard(item);
                                        } else {
                                            return renderContestCard(item);
                                        }
                                    }).join('')}
                                </div>
                            `;
                        }
                    })()}
                </div>
            `;
        }

        function renderContestInfoModal() {
            if (!state.contestInfoModal) return '';

            const { item, itemType, voters } = state.contestInfoModal;
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === item.createdBy;
            const canManageSettings = isAdmin || isCreator;

            // Format date
            const createdDate = formatDate(item.createdAt);

            // Get voter count display
            let voterCountDisplay;
            if (itemType === 'merger') {
                voterCountDisplay = item.voterCountMin && item.voterCountMax
                    ? `${item.voterCountMin}-${item.voterCountMax}üë•`
                    : '0üë•';
            } else {
                voterCountDisplay = `${item.voterCount || 0}üë•`;
            }

            // Get merged contests info (for mergers)
            let mergedContestsHTML = '';
            if (itemType === 'merger' && item.contestIds && item.contestIds.length > 0) {
                const mergedContests = state.contests.filter(c => item.contestIds.includes(c.id));
                mergedContestsHTML = `
                    <details class="mt-2">
                        <summary class="cursor-pointer font-semibold text-gray-700 hover:text-mauve-600 transition">
                            Merged Contests (${mergedContests.length})
                        </summary>
                        <ul class="mt-2 ml-4 space-y-1">
                            ${mergedContests.map(c => `
                                <li class="text-sm text-gray-600">‚Ä¢ ${c.title}</li>
                            `).join('')}
                        </ul>
                    </details>
                `;
            }

            // Get source info (for extracts)
            let sourceHTML = '';
            if (itemType === 'extract' && item.sourceType && item.sourceId) {
                const sourceItem = item.sourceType === 'contest'
                    ? state.contests.find(c => c.id === item.sourceId)
                    : state.mergers.find(m => m.id === item.sourceId);
                if (sourceItem) {
                    const sourceName = sourceItem.title || sourceItem.name;
                    sourceHTML = `
                        <div class="mt-2">
                            <span class="font-semibold text-gray-700">Source:</span>
                            <span class="text-sm text-gray-600">${sourceName}</span>
                        </div>
                    `;
                }
            }

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeContestInfoModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200 flex-shrink-0">
                            <div class="flex items-start justify-between gap-4">
                                <h2 class="text-2xl font-bold text-gray-800 flex-1">${item.title || item.name}</h2>
                                <button onclick="closeContestInfoModal()" class="p-2 hover:bg-gray-100 rounded-lg transition flex-shrink-0">
                                    <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Scrollable Content -->
                        <div class="flex-1 overflow-y-auto p-6">
                            <!-- Main Info Section -->
                            <div class="mb-6">
                                <div class="flex items-center gap-3 mb-3">
                                    <img src="${item.creatorAvatar}" alt="${item.creatorName}" class="w-12 h-12 rounded-full cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="viewUserProfile('${item.createdBy}')" />
                                    <div>
                                        <div class="font-semibold text-gray-800 cursor-pointer hover:text-mauve-600 transition" onclick="viewUserProfile('${item.createdBy}')">${item.creatorName}</div>
                                        <div class="text-sm text-gray-500">${createdDate || 'Date unknown'}</div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-3 text-sm">
                                    <div>
                                        <span class="font-semibold text-gray-700">Images:</span>
                                        <span class="text-gray-600">${item.images?.length || 0}üñºÔ∏è</span>
                                    </div>
                                    <div>
                                        <span class="font-semibold text-gray-700">Voters:</span>
                                        <span class="text-gray-600">${voterCountDisplay}</span>
                                    </div>
                                </div>
                                ${mergedContestsHTML}
                                ${sourceHTML}
                            </div>

                            <!-- Actions Section (visible to all) -->
                            <div class="mb-6 p-4 bg-gray-50 rounded-lg">
                                <h3 class="font-semibold text-gray-800 mb-3">Actions</h3>
                                <button
                                    onclick="shareContestFromModal()"
                                    class="w-full px-4 py-2 bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg font-semibold hover:from-purple-600 hover:to-purple-700 transition shadow-md flex items-center justify-center gap-2"
                                >
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/>
                                    </svg>
                                    Share
                                </button>
                            </div>

                            <!-- Admin/Creator Settings Section -->
                            ${canManageSettings ? `
                                <div class="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                                    <h3 class="font-semibold text-gray-800 mb-3">Settings (Creator/Admin Only)</h3>
                                    <div class="space-y-3">
                                        <!-- Lock Toggle -->
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-2">
                                                <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                                                </svg>
                                                <span class="font-medium text-gray-700">Lock Contest</span>
                                            </div>
                                            <button
                                                onclick="toggleContestLock('${item.id}'); closeContestInfoModal();"
                                                class="px-3 py-1 rounded-lg font-semibold transition text-sm ${item.isLocked ? 'bg-black text-white hover:bg-gray-900' : 'bg-green-500 text-white hover:bg-green-600'}"
                                            >
                                                ${item.isLocked ? 'üîí Locked' : 'üîì Unlocked'}
                                            </button>
                                        </div>
                                        <!-- Results Visibility Toggle -->
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-2">
                                                <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                                                </svg>
                                                <span class="font-medium text-gray-700">Results Visibility</span>
                                            </div>
                                            <button
                                                onclick="toggleResultsPublic('${item.id}'); closeContestInfoModal();"
                                                class="px-3 py-1 rounded-lg font-semibold transition text-sm ${item.resultsPublic !== false ? 'bg-green-500 text-white hover:bg-green-600' : 'bg-black text-white hover:bg-gray-900'}"
                                            >
                                                ${item.resultsPublic !== false ? 'üëÅÔ∏è Public' : 'üîí Private'}
                                            </button>
                                        </div>
                                        <!-- Delete Button -->
                                        <button
                                            onclick="deleteContest('${item.id}'); closeContestInfoModal();"
                                            class="w-full px-4 py-2 bg-red-500 text-white rounded-lg font-semibold hover:bg-red-600 transition text-sm"
                                        >
                                            üóëÔ∏è Delete ${itemType === 'contest' ? 'Contest' : itemType === 'merger' ? 'Merger' : 'Extract'}
                                        </button>
                                    </div>
                                </div>
                            ` : ''}

                            <!-- Voters Section -->
                            <div class="p-4 bg-blue-50 rounded-lg">
                                <h3 class="font-semibold text-gray-800 mb-3">Voters (${voters.length})</h3>
                                ${voters.length > 0 ? `
                                    <div class="space-y-2 max-h-64 overflow-y-auto">
                                        ${voters.map(voter => `
                                            <div class="flex items-center gap-3 p-2 hover:bg-blue-100 rounded-lg transition cursor-pointer" onclick="viewUserProfile('${voter.id}')">
                                                <img src="${voter.avatar}" alt="${voter.username}" class="w-8 h-8 rounded-full" />
                                                <span class="text-sm font-medium text-gray-700">${voter.username}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : `
                                    <p class="text-sm text-gray-600 text-center py-4">No votes yet</p>
                                `}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderUserProfileModal() {
            if (!state.showUserProfileModal) return '';

            const userId = state.viewingUserId;
            if (!userId) {
                return '';
            }

            // Find user info from allUsers or from contest data
            let userInfo = state.allUsers.find(u => u.id === userId);

            // If not in allUsers, try to find from contest votes
            if (!userInfo) {
                // Look through all contests to find this user's votes
                for (const contest of state.contests) {
                    const votes = contest.votes || [];
                    const vote = votes.find(v => v.userId === userId);
                    if (vote) {
                        userInfo = { id: userId, username: vote.username, avatar: vote.avatar };
                        break;
                    }
                }
            }

            if (!userInfo) {
                return `
                    <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeUserProfileModal()">
                        <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 modal-content flex flex-col" onclick="event.stopPropagation()">
                            <div class="text-center">
                                <p class="text-xl font-bold text-gray-800 mb-4">User Not Found</p>
                                <p class="text-gray-600 mb-6">The requested user profile could not be loaded.</p>
                                <button onclick="closeUserProfileModal()" class="bg-mauve-500 text-white px-6 py-2 rounded-lg hover:bg-mauve-600 transition">
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Find items created by this user
            const createdContests = state.contests.filter(c => c.createdBy === userId);
            const createdMergers = state.mergers.filter(m => m.createdBy === userId);
            const createdExtracts = state.extracts.filter(e => e.createdBy === userId);

            // Find items voted on by this user (using fetched vote data)
            const userVotedContestIds = state.userProfileVotedContests || [];

            // Get contests this user has voted on (INCLUDING ones they created)
            const votedContests = state.contests.filter(contest =>
                userVotedContestIds.includes(contest.id)
            );

            // Get mergers where user voted on source contests (INCLUDING ones they created)
            const votedMergers = state.mergers.filter(merger => {
                const sourceContestIds = merger.contestIds || [];
                return sourceContestIds.some(contestId => userVotedContestIds.includes(contestId));
            });

            // Get extracts where user voted on source (INCLUDING ones they created)
            const votedExtracts = state.extracts.filter(extract => {
                if (extract.sourceType === 'contest') {
                    return userVotedContestIds.includes(extract.sourceContestId);
                } else if (extract.sourceType === 'merger') {
                    const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (!merger) return false;
                    const sourceContestIds = merger.contestIds || [];
                    return sourceContestIds.some(contestId => userVotedContestIds.includes(contestId));
                }
                return false;
            });

            const allCreatedItems = [
                ...createdContests.map(c => ({ ...c, itemType: 'contest' })),
                ...createdMergers.map(m => ({ ...m, itemType: 'merger' })),
                ...createdExtracts.map(e => ({ ...e, itemType: 'extract' }))
            ];

            const allVotedItems = [
                ...votedContests.map(c => ({ ...c, itemType: 'contest' })),
                ...votedMergers.map(m => ({ ...m, itemType: 'merger' })),
                ...votedExtracts.map(e => ({ ...e, itemType: 'extract' }))
            ];

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isBanned = state.bannedUsers.includes(userId);
            const isCurrentUser = state.user && state.user.id === userId;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeUserProfileModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden modal-content flex flex-col" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200 flex-shrink-0">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-2xl font-bold text-gray-800">User Profile</h3>
                                <button onclick="closeUserProfileModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="flex items-center gap-4">
                                <img src="${userInfo.avatar}" alt="${userInfo.username}" class="w-20 h-20 rounded-full" />
                                <div class="flex-1">
                                    <h2 class="text-2xl font-bold text-gray-800">${userInfo.username}</h2>
                                    <p class="text-gray-600">${isCurrentUser ? '(You)' : ''} ${isBanned ? 'üö´ BANNED' : ''}</p>
                                    <p class="text-sm text-gray-500 mt-1">
                                        Created ${allCreatedItems.length} ${allCreatedItems.length === 1 ? 'item' : 'items'} ‚Ä¢
                                        Voted in ${allVotedItems.length} ${allVotedItems.length === 1 ? 'item' : 'items'}
                                    </p>
                                </div>
                            </div>
                        </div>

                        <!-- Scrollable content -->
                        <div class="flex-1 overflow-y-auto p-6">
                            <!-- Created Items Section -->
                            ${allCreatedItems.length > 0 ? `
                                <div class="mb-6">
                                    <h3 class="text-lg font-bold text-gray-800 mb-3">Contests Created (${allCreatedItems.length})</h3>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                        ${allCreatedItems.map(item => {
                                            const title = item.title || item.name;
                                            return `
                                                <div class="text-sm text-gray-700 hover:text-mauve-600 transition p-2 hover:bg-gray-50 rounded">
                                                    ‚Ä¢ ${title}
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                            ` : ''}

                            <!-- Voting History Section -->
                            <div class="mb-4">
                                <h3 class="text-lg font-bold text-gray-800 mb-3">Contests Voted On (${allVotedItems.length})</h3>
                            </div>

                            ${allVotedItems.length === 0 ? `
                                <div class="bg-gray-50 rounded-lg p-8 text-center">
                                    <p class="text-gray-500">No voting history yet</p>
                                </div>
                            ` : `
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                    ${allVotedItems.map(item => {
                                        const title = item.title || item.name;
                                        return `
                                            <div class="text-sm text-gray-700 hover:text-mauve-600 transition p-2 hover:bg-gray-50 rounded">
                                                ‚Ä¢ ${title}
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            `}
                        </div>

                        <!-- Footer with ban button -->
                        ${isAdmin && !isCurrentUser && !isBanned ? `
                            <div class="p-4 border-t border-gray-200 flex-shrink-0">
                                <button onclick="confirmBanUser('${userId}', '${userInfo.username}')" class="w-full bg-red-500 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-600 transition">
                                    üö´ Ban User
                                </button>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function renderContestCard(contest) {
                        try {
                                const hasVoted = state.userVotedContests[contest.id];
                                // Display voter range (min-max) or single value if they're equal
                                const voterDisplay = contest.voterCountMin !== undefined && contest.voterCountMax !== undefined
                                    ? (contest.voterCountMin === contest.voterCountMax
                                        ? `${contest.voterCountMax}üë•`
                                        : `${contest.voterCountMin}-${contest.voterCountMax}üë•`)
                                    : '0üë•';
                            const canDelete = canDeleteContest(contest);
                            const isBanned = state.bannedUsers.includes(state.user.id);
                            const createdDate = formatDate(contest.createdAt);

                            return `
                                <div class="bg-white rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative">
                                    ${contest.isLocked ? `
                                        <div class="absolute top-3 right-3 bg-black text-white p-1.5 rounded-full shadow-lg" title="Contest is locked">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                                            </svg>
                                        </div>
                                    ` : ''}
                                    <div class="flex items-start gap-2 mb-2">
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${contest.createdBy}');" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h3 class="text-base font-bold text-gray-800 truncate">${contest.title}</h3>
                                            </div>
                                            <div class="text-xs text-gray-500 flex items-center gap-2 flex-wrap">
                                                <span class="truncate">by <span class="cursor-pointer hover:text-mauve-600 transition" onclick="event.stopPropagation(); viewUserProfile('${contest.createdBy}');">${contest.creatorName}</span></span>
                                                <span class="ml-auto whitespace-nowrap">${voterDisplay} ${contest.images.length}üñºÔ∏è</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="flex gap-2">
                                        ${contest.isLocked ? `
                                            <button
                                                onclick='viewLockedResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : (hasVoted || contest.createdBy === state.user.id) && (contest.voterCountMax > 0) ? `
                                            ${contest.createdBy === state.user.id && !hasVoted ? `
                                                <button
                                                    onclick='startVoting(${safeStringify(contest)})'
                                                    class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                                                >
                                                    Start Voting
                                                </button>
                                            ` : ''}
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : isBanned ? `
                                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                                üö´ Account restricted
                                            </div>
                                        ` : `
                                            <button
                                                onclick='startVoting(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                                            >
                                                Start Voting
                                            </button>
                                        `}
                                        <button
                                            onclick='showContestInfoModal(${safeStringify(contest)}, "contest")'
                                            class="bg-gradient-to-r from-blue-300 to-blue-500 text-white px-3 py-2 rounded-lg font-semibold hover:from-blue-400 hover:to-blue-600 transition shadow-md text-sm flex items-center gap-1"
                                            title="Contest Info"
                                        >
                                            ‚ÑπÔ∏è
                                        </button>
                                    </div>
                                </div>
                            `;
                            } catch (error) {
                                console.error('Error rendering contest:', contest?.id, error);
                                return ''; // Skip this contest and continue
                            }
        }

        function renderMergerCard(merger) {
            // Get contest details for the merged contests
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
            const totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);
            const voterRange = merger.voterCountMin && merger.voterCountMax
                ? `${merger.voterCountMin}-${merger.voterCountMax}üë•`
                : '0üë•';

            // Check if user has voted in all, some, or no merged contests
            const votedContests = mergedContests.filter(c => state.userVotedContests[c.id]);
            const hasVotedAll = votedContests.length === mergedContests.length && mergedContests.length > 0;
            const hasVotedSome = votedContests.length > 0 && votedContests.length < mergedContests.length;
            const hasVotedNone = votedContests.length === 0;

            const isBanned = state.bannedUsers.includes(state.user.id);

            return `
                <div class="bg-blue-50 border-2 border-blue-300 rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative">
                    <div class="flex items-start gap-2 mb-2">
                        <img src="${merger.creatorAvatar}" alt="${merger.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-blue-400 transition" onclick="event.stopPropagation(); viewUserProfile('${merger.createdBy}');" />
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h3 class="text-base font-bold text-blue-900 truncate">${merger.name}</h3>
                            </div>
                            <div class="text-xs text-blue-700 flex items-center gap-2 flex-wrap">
                                <span class="truncate">by <span class="cursor-pointer hover:text-blue-900 transition" onclick="event.stopPropagation(); viewUserProfile('${merger.createdBy}');">${merger.creatorName}</span></span>
                                <span class="ml-auto whitespace-nowrap">${voterRange} ${totalImages}üñºÔ∏è</span>
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-2">
                        ${isBanned ? `
                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                üö´ Account restricted
                            </div>
                        ` : hasVotedAll ? `
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedNone ? `
                            <button
                                onclick='startMergerVoting("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                            >
                                Start Voting
                            </button>
                        ` : `
                            <button
                                onclick='showMergerVoteModal("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                            >
                                Complete Voting
                            </button>
                        `}
                        <button
                            onclick='showContestInfoModal(${safeStringify(merger)}, "merger")'
                            class="bg-gradient-to-r from-blue-300 to-blue-500 text-white px-3 py-2 rounded-lg font-semibold hover:from-blue-400 hover:to-blue-600 transition shadow-md text-sm flex items-center gap-1"
                            title="Merger Info"
                        >
                            ‚ÑπÔ∏è
                        </button>
                    </div>
                </div>
            `;
        }

        function renderExtractCard(extract) {
            // Get source reference
            let sourceRef = 'Unknown';
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                sourceRef = sourceContest ? sourceContest.title : 'Unknown Contest';
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                sourceRef = sourceMerger ? sourceMerger.name : 'Unknown Merger';
            } else if (extract.sourceType === 'extract') {
                const sourceExtract = state.extracts.find(e => e.id === extract.sourceContestId);
                sourceRef = sourceExtract ? sourceExtract.name : 'Unknown Extract';
            }

            const imageCount = extract.imageIds.length;
            const isBanned = state.bannedUsers.includes(state.user.id);
            const createdDate = formatDate(extract.createdAt);

            return `
                <div class="bg-yellow-50 border-2 border-yellow-400 rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative">
                    <div class="absolute top-2 left-2 bg-yellow-500 text-white px-2 py-0.5 rounded text-xs font-bold">EXTRACT</div>
                    <div class="flex items-start gap-2 mb-2 mt-6">
                        <img src="${extract.creatorAvatar}" alt="${extract.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-yellow-400 transition" onclick="event.stopPropagation(); viewUserProfile('${extract.createdBy}');" />
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h3 class="text-base font-bold text-yellow-900 truncate">${extract.name}</h3>
                            </div>
                            <div class="text-xs text-yellow-700 flex items-center gap-2 flex-wrap">
                                <span class="truncate">by <span class="cursor-pointer hover:text-yellow-900 transition" onclick="event.stopPropagation(); viewUserProfile('${extract.createdBy}');">${extract.creatorName}</span></span>
                                <span class="ml-auto whitespace-nowrap">${imageCount}üñºÔ∏è</span>
                            </div>
                            <div class="text-xs text-yellow-600 mt-1">
                                From: ${sourceRef}
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-2">
                        ${isBanned ? `
                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                üö´ Account restricted
                            </div>
                        ` : `
                            <button
                                onclick='startExtractVoting("${extract.id}")'
                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                            >
                                Start Voting
                            </button>
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        `}
                        <button
                            onclick='showContestInfoModal(${safeStringify(extract)}, "extract")'
                            class="bg-gradient-to-r from-blue-400 to-blue-600 text-white px-3 py-2 rounded-lg font-semibold hover:from-blue-500 hover:to-blue-700 transition shadow-md text-sm flex items-center gap-1"
                            title="Extract Info"
                        >
                            ‚ÑπÔ∏è
                        </button>
                    </div>
                </div>
            `;
        }

        function renderCreateContest() {
            return `
                <div class="max-w-5xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="flex justify-between items-center mb-4">
                            <div>
                                <h2 class="text-2xl font-bold text-gray-800">${state.newContest.title}</h2>
                            </div>
                            <button onclick="cancelCreateContest()" class="text-gray-600 hover:text-gray-800 flex items-center gap-1 text-sm">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                                Cancel
                            </button>
                        </div>

                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                            <h3 class="font-bold text-blue-900 mb-2 flex items-center gap-2 text-sm">
                                <span class="text-xl">üì∏</span>
                                How to Add Images
                            </h3>
                            <p class="text-xs text-blue-800 mb-1">
                                üíª <strong>Desktop:</strong> Click image ‚Üí Right-click ‚Üí Copy image link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üì± <strong>Mobile:</strong> Open image ‚Üí Share ‚Üí Copy link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üìÅ <strong>Or:</strong> Click "Upload Image Files" or drag & drop files (max 10MB each, multiple files supported)
                            </p>
                            <p class="text-xs text-green-800 font-semibold">
                                ‚ö° Uploaded files are automatically compressed to 500 KB max to optimize loading speed
                            </p>
                        </div>

                        <div class="bg-yellow-50 border border-yellow-300 rounded-lg p-3 mb-4">
                            <p class="text-xs text-yellow-800">
                                ‚ö†Ô∏è <strong>Warning:</strong> Discord image URLs expire after 24 hours. Use permanent image hosting (Imgur, etc.) or upload files directly.
                            </p>
                        </div>

                        <div class="mb-4">
                            <input type="url" id="contestUrlInput" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg text-sm mb-2" placeholder="Paste Discord image URL or any image URL...">
                            <div class="flex gap-2 mb-2">
                                <button onclick="clearUrlInput()" class="flex-1 bg-gray-500 text-white py-2 rounded-lg font-semibold hover:bg-gray-600 transition text-sm">
                                    Clear Text Field
                                </button>
                                <button onclick="addImageFromUrl('contestUrlInput')" class="flex-1 bg-gradient-to-r from-pink-500 to-rose-600 text-white py-2 rounded-lg font-semibold hover:from-pink-600 hover:to-rose-700 transition text-sm">
                                    Add URL
                                </button>
                            </div>
                            <div class="flex items-center gap-2 mb-3">
                                <span class="text-sm text-gray-600 font-medium">or</span>
                                <input type="file" id="contestFileInput" accept="image/jpeg,image/png,image/gif,image/webp" multiple class="hidden" onchange="handleFileSelect(this)">
                                <button onclick="document.getElementById('contestFileInput').click()" class="flex-1 bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-indigo-700 transition text-sm flex items-center justify-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                    </svg>
                                    Upload Image Files
                                </button>
                            </div>
                            <div
                                id="dropZone"
                                class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center bg-gray-50 hover:border-blue-400 hover:bg-blue-50 transition cursor-pointer"
                                ondragover="handleDragOver(event)"
                                ondragleave="handleDragLeave(event)"
                                ondrop="handleDrop(event)"
                                onclick="document.getElementById('contestFileInput').click()"
                            >
                                <svg class="w-12 h-12 mx-auto mb-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <p class="text-sm text-gray-600 font-medium mb-1">Drag & drop images here</p>
                                <p class="text-xs text-gray-500">or click to browse files</p>
                            </div>
                        </div>

                        <div class="flex items-center justify-between mb-3 p-3 bg-gray-50 rounded-lg">
                            <div class="text-sm font-semibold text-gray-800">
                                ${state.newContest.images.length} / 50 images added
                            </div>
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="checkbox" ${state.newContest.labelsEnabled ? 'checked' : ''} onchange="toggleImageLabels()" class="w-4 h-4 text-mauve-500 rounded focus:ring-mauve-400">
                                <span class="text-sm font-medium text-gray-700">Enable Image Labels</span>
                            </label>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 min-h-[100px]">
                            ${state.newContest.images.length === 0 ? `
                                <div class="col-span-full text-center text-gray-400 py-8 text-sm italic">
                                    No images added yet
                                </div>
                            ` : state.newContest.images.map((img, index) => `
                                <div class="relative group">
                                    <img src="${img.url}" class="w-full h-48 object-contain rounded-lg bg-gray-100" />
                                    <button onclick="removeContestImage(${index})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition shadow-lg">
                                        √ó
                                    </button>
                                    ${img.compressedSize ? `
                                        <div class="text-xs text-center text-gray-600 mt-1 font-medium">
                                            ${formatFileSize(img.compressedSize)}
                                        </div>
                                    ` : ''}
                                    ${state.newContest.labelsEnabled ? `
                                        <input
                                            type="text"
                                            value="${img.label || ''}"
                                            onchange="updateImageLabel(${index}, this.value)"
                                            maxlength="30"
                                            placeholder="Label (optional)"
                                            class="w-full mt-2 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:border-pink-500"
                                        />
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>

                        <button 
                            onclick="finishCreateContest()" 
                            ${state.newContest.images.length === 0 ? 'disabled' : ''}
                            class="w-full bg-gradient-to-r from-green-500 to-green-700 text-white py-3 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                        >
                            Create Contest (${state.newContest.images.length} images)
                        </button>
                    </div>
                </div>
            `;
        }

        function renderVoting() {
            const currentImage = state.shuffledImages[state.currentImageIndex];
            const currentVote = state.votes[currentImage.id];
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);

            // Determine voting context (contest or merger)
            const isMergerVoting = state.currentMergerId && !state.currentContest;
            const votingTitle = isMergerVoting
                ? (state.mergers.find(m => m.id === state.currentMergerId)?.name || 'Merger Voting')
                : (state.currentContest?.title || 'Voting');
            const labelsEnabled = state.currentContest?.labelsEnabled || false;

            // Adaptive progress bar logic - ensure EXACTLY segmentCount dashes
            const imageCount = state.shuffledImages.length;
            const segmentCount = Math.min(imageCount, 20);
            const imagesPerSegment = Math.ceil(imageCount / segmentCount);

            return `
                <div class="max-w-4xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <div class="bg-gray-200 h-3 flex gap-1 p-1">
                            ${Array.from({ length: segmentCount }, (_, segmentIdx) => {
                                const startIdx = segmentIdx * imagesPerSegment;
                                const endIdx = Math.min(startIdx + imagesPerSegment, imageCount);

                                // Skip segments that would start beyond our image count
                                if (startIdx >= imageCount) return '';

                                const segmentImages = state.shuffledImages.slice(startIdx, endIdx);

                                const votedCount = segmentImages.filter(img => state.votes[img.id]).length;
                                const totalCount = segmentImages.length;
                                const hasCurrentImage = state.currentImageIndex >= startIdx && state.currentImageIndex < endIdx;

                                // Determine color based on priority
                                let bgColor;
                                if (hasCurrentImage) {
                                    bgColor = 'bg-mauve-400';
                                } else if (votedCount === totalCount) {
                                    bgColor = 'bg-green-500';
                                } else if (votedCount > 0) {
                                    bgColor = 'bg-yellow-500';
                                } else {
                                    bgColor = 'bg-gray-300';
                                }

                                const imageRange = startIdx + 1 === endIdx ? `Image ${startIdx + 1}` : `Images ${startIdx + 1}-${endIdx}`;
                                const tooltip = `${imageRange} (${votedCount}/${totalCount} voted)`;

                                return `
                                    <div
                                        onclick="jumpToImage(${startIdx})"
                                        class="progress-segment flex-1 ${bgColor}"
                                        title="${tooltip}"
                                    ></div>
                                `;
                            }).join('')}
                        </div>

                        <div class="p-3">
                            <div class="flex justify-between items-center mb-3 gap-2">
                                <h2 class="text-lg font-bold text-gray-800">${votingTitle}</h2>
                                <span class="text-gray-600 font-medium text-sm">${state.currentImageIndex + 1}/${state.shuffledImages.length}</span>
                            </div>

                            <div class="relative mb-3 bg-gray-100 overflow-hidden flex items-center justify-center" style="height: 55vh;">
                                ${labelsEnabled && currentImage.label ? `
                                    <div class="absolute top-0 left-0 right-0 bg-white px-4 py-2 text-center border-b border-gray-200 z-10">
                                        <span class="text-sm font-semibold text-gray-800">${currentImage.label}</span>
                                    </div>
                                ` : ''}
                                <img
                                    src="${currentImage.url}"
                                    alt="Image ${state.currentImageIndex + 1}"
                                    class="max-h-full max-w-full object-contain"
                                    style="max-height: 100%; max-width: 100%;"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                                ${currentVote ? `
                                    <div class="absolute top-2 right-2 bg-white rounded-full px-3 py-1 shadow-lg flex items-center gap-1 text-sm">
                                        <svg class="w-4 h-4 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                                        </svg>
                                        <span class="font-semibold">Voted: ${currentVote}</span>
                                    </div>
                                ` : ''}
                            </div>

                            <div class="flex justify-center gap-2 mb-3">
                                ${[1, 2, 3, 4, 5].map(score => `
                                    <button 
                                        data-score="${score}"
                                        onclick="handleVote(${score})" 
                                        ${state.isAnimating ? 'disabled' : ''}
                                        class="w-12 h-12 sm:w-14 sm:h-14 rounded-full font-bold text-white text-base shadow-lg hover:scale-110 transition-transform relative ${currentVote === score ? 'ring-4 ring-offset-2' : ''} ${state.isAnimating ? 'opacity-70 cursor-not-allowed' : ''}"
                                        style="background-color: ${getScoreColor(score)}; transform: ${currentVote === score ? 'scale(1.15)' : 'scale(1)'}; ring-color: ${getScoreColor(score)};"
                                    >
                                        ${score}
                                        ${currentVote === score && state.showTickAnimation ? `
                                            <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-green-600 rounded-full p-1 tick-animation" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                            </svg>
                                        ` : currentVote === score ? `
                                            <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-green-600 rounded-full p-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                            </svg>
                                        ` : ''}
                                    </button>
                                `).join('')}
                            </div>

                            <div class="flex justify-between items-center gap-2">
                                <button 
                                    onclick="navigateImage('prev')" 
                                    ${state.currentImageIndex === 0 ? 'disabled' : ''}
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                                >
                                    ‚Üê Prev
                                </button>

                                ${allVoted ? `
                                    <button onclick="submitVotes()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition flex items-center gap-1 shadow-lg text-sm">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        Submit
                                    </button>
                                ` : '<div></div>'}

                                <button 
                                    onclick="navigateImage('next')" 
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition text-sm"
                                >
                                    Next ‚Üí
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderResults() {
            // Check privacy settings
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === state.currentContest.createdBy;
            const isPrivate = state.currentContest.resultsPublic === false;
            const canViewPrivateResults = isAdmin || isCreator;

            // Block unauthorized users from viewing private results
            if (isPrivate && !canViewPrivateResults) {
                return `
                    <div class="max-w-7xl mx-auto px-3 py-4">
                        <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                            <div class="text-center mb-4">
                                <div class="flex items-center justify-center gap-2 mb-2">
                                    <span class="text-4xl">üéÜ</span>
                                    <h2 class="text-2xl font-bold text-gray-800">Final Ranking</h2>
                                </div>
                            </div>

                            <div class="mt-3 flex flex-col items-center justify-center gap-2 mb-4">
                                <!-- Disabled tabs -->
                                <div class="flex items-center justify-center gap-3 opacity-50">
                                    <button class="px-3 py-1 rounded-lg bg-gray-200 cursor-not-allowed" disabled>
                                        Total
                                    </button>
                                    <button class="px-3 py-1 rounded-lg bg-gray-200 cursor-not-allowed" disabled>
                                        By User
                                    </button>
                                    <button class="px-3 py-1 rounded-lg bg-gray-200 cursor-not-allowed" disabled>
                                        Average
                                    </button>
                                </div>
                            </div>

                            <!-- Privacy message -->
                            <div class="text-center py-16">
                                <div class="text-8xl mb-6">üîí</div>
                                <h3 class="text-2xl font-bold text-gray-800 mb-3">Results are Private</h3>
                                <p class="text-gray-600 max-w-md mx-auto">
                                    Only the contest creator can view results. Contact the creator if you believe you should have access.
                                </p>
                            </div>
                        </div>
                    </div>
                `;
            }

            let displayResults, grouped, sortedKeys, voterStats;

            // === BY VOTER VIEW ===
            // Shows statistics for each voter, including their average score across all images
            if (state.resultsView === 'byVoter') {
                voterStats = generateVoterStats();
            }
            // === USER VOTES VIEW ===
            // Shows images grouped by a selected user's vote scores
            else if (state.resultsView === 'userVotes') {
                const selectedUserId = state.selectedVoterUserId || state.user?.id;

                // Find all votes by the selected user from the loaded results (including blocked ones)
                const userVotesMap = {};
                const blockedVotesSet = new Set();
                state.results.forEach(imageResult => {
                    const userVote = imageResult.breakdown.find(v => v.userId === selectedUserId);
                    if (userVote) {
                        userVotesMap[imageResult.id] = userVote.score;
                        if (userVote.isBlocked) {
                            blockedVotesSet.add(imageResult.id);
                        }
                    }
                });

                const hasVotes = Object.keys(userVotesMap).length > 0;

                // Map the selected user's votes onto the images
                displayResults = state.results.map(img => ({
                    ...img,
                    averageScore: userVotesMap[img.id] || 0,
                    userVoteScore: userVotesMap[img.id],
                    isBlocked: blockedVotesSet.has(img.id)
                })).filter(img => img.userVoteScore); // Only show images the user voted on

                grouped = groupMyVotesByScore(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => parseInt(b) - parseInt(a));
            }
            // === AVERAGE VIEW ===
            // Shows images grouped by average score ranges (e.g., 4.5-5.0, 4.0-4.49, etc.)
            else {
                displayResults = state.results;
                grouped = groupByScoreRange(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => {
                    const aMin = grouped[a].min;
                    const bMin = grouped[b].min;
                    return bMin - aMin;
                });
            }
            
            const baseSize = 150;
            const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
            const baseFontSize = 12;
            const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="text-center mb-4">
                            <div class="flex items-center justify-center gap-2 mb-2">
                                <span class="text-4xl">üéÜ</span>
                                <h2 class="text-2xl font-bold text-gray-800">Final Ranking</h2>
                            </div>
                            <p class="text-gray-600 text-sm mb-1">${
                                state.resultsView === 'byVoter' ? 'Average scores per voter' :
                                state.resultsView === 'userVotes' ? 'Individual user votes' :
                                'Total votes from all participants'
                            }</p>
                            <p class="text-xs text-gray-500">Click on any image to see the vote breakdown</p>

                            ${(() => {
                                if (isPrivate) {
                                    const message = isCreator
                                        ? "These results are private. Only you can view them."
                                        : "These results are private. Only you and the creator can view them.";
                                    return `
                                        <div class="mt-3 mb-2 max-w-2xl mx-auto">
                                            <div class="bg-yellow-50 border border-yellow-400 text-yellow-800 px-4 py-3 rounded-lg text-sm flex items-start gap-2">
                                                <span class="text-lg flex-shrink-0">‚ö†Ô∏è</span>
                                                <p class="flex-1">${message}</p>
                                            </div>
                                        </div>
                                    `;
                                }
                                return '';
                            })()}

                            <div class="mt-3 flex flex-col items-center justify-center gap-2">
                                <!-- First row: View tabs -->
                                <div class="flex items-center justify-center gap-3">
                                    <button
                                        onclick="setResultsView('average')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'average' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        Total
                                    </button>
                                    <button
                                        onclick="setResultsView('userVotes')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'userVotes' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        By User
                                    </button>
                                    <button
                                        onclick="setResultsView('byVoter')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'byVoter' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        Average
                                    </button>
                                </div>
                                <!-- Second row: Action buttons (only show if user has voted and contest is not locked) -->
                                ${state.userVotedContests[state.currentContest.id] && !state.currentContest.isLocked ? `
                                    <div class="flex items-center justify-center gap-3">
                                        ${(() => {
                                            const revotingEnabled = state.appSettings.revoting_enabled !== false;
                                            if (!revotingEnabled) {
                                                return `
                                                    <button
                                                        onclick="showRevotingDisabledModal()"
                                                        class="px-3 py-1 rounded-lg bg-gray-400 text-gray-200 opacity-50 cursor-not-allowed transition text-sm"
                                                        title="Revoting is temporarily disabled"
                                                    >
                                                        üîÑ Revote
                                                    </button>
                                                `;
                                            }
                                            return `
                                                <button
                                                    onclick="startRevote()"
                                                    class="px-3 py-1 rounded-lg bg-purple-500 text-white hover:bg-purple-600 transition text-sm"
                                                    title="Re-vote from scratch"
                                                >
                                                    üîÑ Revote
                                                </button>
                                            `;
                                        })()}
                                    </div>
                                ` : ''}
                            </div>
                                <!-- User selector dropdown for User Votes view -->
                                ${state.resultsView === 'userVotes' && state.contestVoters.length > 0 ? `
                                    <div class="flex justify-center items-center gap-2">
                                        <label class="text-xs font-medium text-gray-700">Select User:</label>
                                        <select
                                            onchange="setResultsView('userVotes', this.value)"
                                            class="px-2 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                        >
                                            ${state.contestVoters.map(voter => {
                                                const isSelected = (state.selectedVoterUserId || state.user?.id) === voter.userId;
                                                const isCurrent = voter.userId === state.user?.id;
                                                return `
                                                    <option value="${voter.userId}" ${isSelected ? 'selected' : ''}>
                                                        ${voter.username}${isCurrent ? ' (You)' : ''}
                                                    </option>
                                                `;
                                            }).join('')}
                                        </select>
                                    </div>
                                ` : ''}
                            </div>

                        ${state.resultsView !== 'byVoter' ? `
                            <div class="mb-4 max-w-md mx-auto">
                                <div class="flex items-center gap-2">
                                    <label class="text-xs font-medium text-gray-700 whitespace-nowrap">Image Scale:</label>
                                    <button
                                        onclick="adjustScale(-1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Decrease scale"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        id="scaleSlider"
                                        min="40"
                                        max="200"
                                        value="${state.imageScale}"
                                        oninput="updateScale(this.value)"
                                        class="flex-1 h-2 bg-gray-200 rounded-lg cursor-pointer"
                                    />
                                    <button
                                        onclick="adjustScale(1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Increase scale"
                                    >+</button>
                                    <span class="text-xs font-medium text-gray-700 w-10">${state.imageScale}%</span>
                                </div>
                            </div>
                        ` : ''}

                        ${state.resultsView === 'byVoter' ? `
                            ${voterStats && voterStats.length > 0 ? `
                                <div class="mb-4 flex justify-center">
                                    <div class="flex items-center gap-2">
                                        <label class="text-xs font-medium text-gray-700">Sort by:</label>
                                        <select
                                            onchange="setVoterSortBy(this.value)"
                                            class="px-3 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                        >
                                            <option value="scoreDesc" ${state.voterSortBy === 'scoreDesc' ? 'selected' : ''}>Score: High to Low</option>
                                            <option value="scoreAsc" ${state.voterSortBy === 'scoreAsc' ? 'selected' : ''}>Score: Low to High</option>
                                            <option value="nameAsc" ${state.voterSortBy === 'nameAsc' ? 'selected' : ''}>Name: A-Z</option>
                                            <option value="nameDesc" ${state.voterSortBy === 'nameDesc' ? 'selected' : ''}>Name: Z-A</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-2">
                                    ${(() => {
                                        // Calculate contest average from all non-blocked votes
                                        let totalVotes = 0;
                                        let totalScore = 0;
                                        state.results.forEach(img => {
                                            img.breakdown.forEach(vote => {
                                                if (!vote.isBlocked) {
                                                    totalVotes++;
                                                    totalScore += vote.score;
                                                }
                                            });
                                        });
                                        const contestAverage = totalVotes > 0 ? (totalScore / totalVotes).toFixed(2) : 0;

                                        return `
                                            <div class="bg-gradient-to-br from-yellow-50 to-yellow-100 rounded-lg shadow-md p-3 flex flex-col items-center border-2 border-yellow-500">
                                                <div class="text-2xl mb-2">üèÜ</div>
                                                <div class="text-xs font-semibold text-gray-800 text-center mb-1">
                                                    Contest Average
                                                </div>
                                                <div class="text-xl font-bold text-white score-text">
                                                    ${contestAverage}
                                                </div>
                                                <div class="text-xs text-gray-500">
                                                    ${totalVotes} vote${totalVotes !== 1 ? 's' : ''}
                                                </div>
                                            </div>
                                        `;
                                    })()}
                                    ${voterStats.map(voter => `
                                        <div class="bg-white rounded-lg shadow-md p-3 flex flex-col items-center hover:shadow-lg transition-shadow cursor-pointer border-2 ${voter.isCurrentUser ? 'border-mauve-400' : 'border-transparent'}">
                                            <img src="${voter.avatar}" alt="${voter.username}" class="w-12 h-12 rounded-full mb-2" />
                                            <div class="text-xs font-semibold text-gray-800 truncate w-full text-center mb-1" title="${voter.username}">
                                                ${voter.username}
                                            </div>
                                            <div class="text-xl font-bold text-white score-text">
                                                ${voter.averageScore}
                                            </div>
                                            <div class="text-xs text-gray-500">
                                                ${voter.totalImages} vote${voter.totalImages !== 1 ? 's' : ''}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">üë•</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Voters Yet</h3>
                                    <p class="text-gray-600">No voting data available for this contest.</p>
                                </div>
                            `}
                        ` : state.resultsView === 'userVotes' && (!displayResults || displayResults.length === 0) ? `
                            <div class="text-center py-12">
                                <div class="text-6xl mb-4">üì≠</div>
                                <h3 class="text-xl font-bold text-gray-800 mb-2">No Votes Yet</h3>
                                <p class="text-gray-600">This user hasn't voted on this contest yet.</p>
                            </div>
                        ` : sortedKeys.map(key => {
                            const group = grouped[key];

                            if (state.resultsView === 'userVotes') {
                                const score = group.score;
                                const colorStyle = getScoreColor(score);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg inline-block" style="color: white; background-color: ${colorStyle};">
                                            Score ${score}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdown(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    ${item.isBlocked ? `
                                                        <div class="absolute inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-10">
                                                            <span class="text-4xl">üö´</span>
                                                        </div>
                                                    ` : ''}
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover ${item.isBlocked ? 'opacity-60' : ''}"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            } else {
                                const colorStyle = getCategoryColor(group.min, group.isMissing);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg ${colorStyle.color} ${colorStyle.bg} w-full block">
                                            ${getCategoryLabel(group.min, group.max, group.isMissing)}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdown(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                    <div class="absolute bottom-0 left-0 right-0 text-white text-center py-1 font-bold score-text" style="font-size: ${fontSize}px;">
                                                        ${item.averageScore}
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>
                    ${state.showBreakdownModal ? renderBreakdownModal() : ''}
                </div>
            `;
        }

        function renderBreakdownModal() {
            const item = state.results.find(r => r.id === state.showBreakdownModal);
            if (!item) return '';

            const votesByScore = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            item.breakdown.forEach(vote => {
                votesByScore[vote.score].push(vote);
            });

            Object.keys(votesByScore).forEach(score => {
                votesByScore[score].sort((a, b) => a.username.localeCompare(b.username));
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[85vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Vote Breakdown</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="overflow-y-auto flex-1 p-4">

                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 400px;">
                                <img
                                    src="${item.url}"
                                    alt="Image"
                                    class="max-w-full max-h-[400px] object-contain"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                            </div>

                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-gray-800">${item.averageScore}</div>
                                    <div class="text-xs text-gray-600">Average Score</div>
                                    <div class="text-xs text-gray-500 mt-1">${item.totalVotes} total votes</div>
                                </div>
                            </div>

                            <div class="space-y-3">
                                ${[5, 4, 3, 2, 1].map(score => `
                                    <div>
                                        <h4 class="text-sm font-bold mb-2 px-3 py-1 rounded-lg inline-block" style="color: ${getScoreColor(score)}; background-color: ${getScoreColor(score)}20;">
                                            Score ${score} (${votesByScore[score].length} ${votesByScore[score].length === 1 ? 'vote' : 'votes'})
                                        </h4>
                                        ${votesByScore[score].length > 0 ? `
                                            <div class="grid grid-cols-1 gap-2 mt-2">
                                                ${votesByScore[score].map(vote => {
                                                    const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                                                    return `
                                                    <div class="flex items-center gap-2 p-2 rounded-lg ${
                                                        vote.isBanned ? 'bg-red-100 opacity-60' :
                                                        vote.isBlocked ? 'bg-gray-300' :
                                                        vote.isCurrentUser ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'
                                                    }">
                                                        <img src="${vote.avatar}" alt="${vote.username}" class="w-8 h-8 rounded-full flex-shrink-0 ${vote.isBanned ? 'opacity-50' : ''} cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');" />
                                                        <span class="text-sm flex-1 truncate cursor-pointer ${
                                                            vote.isBanned ? 'line-through text-red-600' :
                                                            vote.isBlocked ? 'line-through text-gray-700' :
                                                            'text-gray-700 hover:text-mauve-600'
                                                        }" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');">
                                                            ${vote.username}${vote.isCurrentUser ? ' (You)' : ''}${vote.isBanned ? ' (BANNED)' : ''}
                                                        </span>
                                                        ${isAdmin ? `
                                                            <button
                                                                onclick="adminEditVote('${vote.userId}', ${item.id}, ${score})"
                                                                class="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-xs"
                                                                title="Edit vote"
                                                            >
                                                                ‚úèÔ∏è
                                                            </button>
                                                            <button
                                                                onclick="adminToggleBlockVote('${vote.userId}', ${item.id}, ${vote.isBlocked || false})"
                                                                class="px-2 py-1 ${vote.isBlocked ? 'bg-green-500 hover:bg-green-600' : 'bg-red-500 hover:bg-red-600'} text-white rounded text-xs"
                                                                title="${vote.isBlocked ? 'Unblock vote' : 'Block vote'}"
                                                            >
                                                                ${vote.isBlocked ? '‚úì' : 'üö´'}
                                                            </button>
                                                        ` : ''}
                                                    </div>
                                                `}).join('')}
                                            </div>
                                        ` : `
                                            <div class="text-gray-400 italic text-sm mt-2 ml-3">No votes</div>
                                        `}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAdminDashboard() {
            if (!state.showAdminDashboard) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get banned users info
            const bannedUsersInfo = state.bannedUsers.map(userId => {
                // Try to find user info from contests
                const contest = state.contests.find(c => c.createdBy === userId);
                if (contest) {
                    return {
                        id: userId,
                        username: contest.creatorName,
                        avatar: contest.creatorAvatar
                    };
                }
                // Fallback
                return {
                    id: userId,
                    username: 'User' + userId.substring(0, 4),
                    avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${userId}`
                };
            });

            // Calculate admin statistics
            const totalContests = state.contests.length;
            const totalVotes = state.adminStats.totalVotes;
            const totalUniqueVoters = state.adminStats.totalUniqueVoters;
            const totalBannedUsers = state.bannedUsers.length;
            const totalImages = state.contests.reduce((sum, contest) => sum + (contest.images?.length || 0), 0);

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-50 p-4" onclick="event.target === this && closeAdminDashboard()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-3xl w-full max-h-[90vh] overflow-y-auto modal-content" onclick="event.stopPropagation()">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-2xl font-bold text-gray-800">Admin Dashboard</h3>
                                <button onclick="closeAdminDashboard()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>

                            <div class="space-y-4">
                                <div class="bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg p-4 border border-purple-200">
                                    <h4 class="font-bold text-gray-800 mb-3">Statistics</h4>
                                    <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-purple-600">${totalContests}</div>
                                            <div class="text-xs text-gray-600">Total Contests</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-blue-600">${totalVotes}</div>
                                            <div class="text-xs text-gray-600">Total Votes</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-green-600">${totalUniqueVoters}</div>
                                            <div class="text-xs text-gray-600">Unique Voters</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-orange-600">${totalImages}</div>
                                            <div class="text-xs text-gray-600">Total Images</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-red-600">${totalBannedUsers}</div>
                                            <div class="text-xs text-gray-600">Banned Users</div>
                                        </div>
                                    </div>
                                </div>

                                <div class="bg-blue-50 rounded-lg p-4 border border-blue-200">
                                    <h4 class="font-bold text-blue-800 mb-3">üë• All Users</h4>
                                    ${state.allUsers.length > 0 ? `
                                        <div class="space-y-2 max-h-96 overflow-y-auto">
                                            ${[...state.allUsers].sort((a, b) => a.username.localeCompare(b.username)).map(user => {
                                                const isBanned = state.bannedUsers.includes(user.id);
                                                return `
                                                    <div class="flex items-center justify-between p-3 bg-white rounded-lg ${isBanned ? 'opacity-50' : ''}">
                                                        <div class="flex items-center gap-3">
                                                            <img src="${user.avatar}" alt="${user.username}" class="w-10 h-10 rounded-full" />
                                                            <div>
                                                                <div class="font-semibold text-gray-800">${user.username}</div>
                                                                <div class="text-xs text-gray-500">${user.id}</div>
                                                                ${isBanned ? '<span class="text-xs text-red-600 font-semibold">BANNED</span>' : ''}
                                                            </div>
                                                        </div>
                                                        ${isBanned ? `
                                                            <button onclick="unbanUser('${user.id}')" class="bg-green-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-green-600 transition text-sm">
                                                                Unban
                                                            </button>
                                                        ` : `
                                                            <button onclick="confirmBanUser('${user.id}')" class="bg-red-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-red-600 transition text-sm">
                                                                Ban
                                                            </button>
                                                        `}
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : '<p class="text-sm text-gray-500 italic">No users have logged in yet</p>'}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAppSettingsModal() {
            if (!state.showAppSettingsModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get current settings values (default to true if not set)
            const contestCreationEnabled = state.appSettings.contest_creation_enabled !== false;
            const revotingEnabled = state.appSettings.revoting_enabled !== false;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeAppSettings()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full modal-content" onclick="event.stopPropagation()">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h3 class="text-2xl font-bold text-gray-800">App Settings</h3>
                                <button onclick="closeAppSettings()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>

                            <div class="space-y-6">
                                <!-- Contest Creation Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Contest Creation</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Allow users to create new contests
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${contestCreationEnabled ? 'active' : ''}"
                                        onclick="toggleAppSetting('contest_creation_enabled')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <!-- Revoting Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Revoting</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Allow users to change their votes after submission
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${revotingEnabled ? 'active' : ''}"
                                        onclick="toggleAppSetting('revoting_enabled')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <p class="text-sm text-blue-800">
                                        üí° <strong>Note:</strong> These settings affect all users globally. Disabled features will show informative messages to users.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderManageFoldersModal() {
            if (!state.showManageFoldersModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get all items that are already in folders
            const itemsInFolders = new Set();
            state.groups.forEach(group => {
                (group.items || []).forEach(item => {
                    itemsInFolders.add(`${item.item_type}:${item.item_id}`);
                });
            });

            // Calculate ungrouped items count
            const allItems = [...state.contests.map(c => ({ itemType: 'contest', id: c.id })),
                            ...state.mergers.map(m => ({ itemType: 'merger', id: m.id })),
                            ...state.extracts.map(e => ({ itemType: 'extract', id: e.id }))];
            const ungroupedItemsCount = allItems.filter(item =>
                !itemsInFolders.has(`${item.itemType}:${item.id}`)
            ).length;

            // Get unfoldered items position from app settings (default to bottom if not set)
            const unfolderedPosition = state.appSettings.unfoldered_items_position !== undefined
                ? parseInt(state.appSettings.unfoldered_items_position)
                : state.groups.length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeManageFoldersModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden modal-content flex flex-col" onclick="event.stopPropagation()">
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex justify-between items-center">
                                <h3 class="text-2xl font-bold text-gray-800">üìÅ Manage Folders</h3>
                                <button onclick="closeManageFoldersModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="p-6 overflow-y-auto flex-1">
                            <div class="mb-6">
                                <button onclick="showCreateFolderModal()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg">
                                    + Create New Folder
                                </button>
                            </div>

                            ${state.groups.length === 0 && ungroupedItemsCount === 0 ? `
                                <div class="text-center py-8 text-gray-500">
                                    <p class="text-lg mb-2">No folders yet</p>
                                    <p class="text-sm">Create a folder to organize your contests, mergers, and extracts</p>
                                </div>
                            ` : `
                                <div class="space-y-4" id="folders-list">
                                    ${(() => {
                                        // Build the sorted list with unfoldered items meta-item
                                        const items = [];
                                        state.groups.forEach((group, index) => {
                                            items.push({ type: 'folder', data: group, originalIndex: index });
                                        });
                                        // Insert unfoldered items meta-item at the specified position
                                        items.splice(unfolderedPosition, 0, { type: 'unfoldered', data: null });

                                        return items.map((item, index) => {
                                            if (item.type === 'unfoldered') {
                                                return `
                                                    <div class="border border-gray-300 rounded-lg overflow-hidden bg-gradient-to-r from-gray-100 to-gray-200" data-unfoldered="true">
                                                        <div class="bg-gray-100 p-4 flex items-center gap-3">
                                                            <div class="cursor-move text-gray-400 hover:text-gray-600">
                                                                ‚ãÆ‚ãÆ
                                                            </div>
                                                            <div class="flex-1">
                                                                <h4 class="font-semibold text-gray-700 flex items-center gap-2">
                                                                    <span>üìã</span>
                                                                    <span>Unfoldered Items</span>
                                                                </h4>
                                                                <p class="text-sm text-gray-600">${ungroupedItemsCount} items (not draggable within)</p>
                                                            </div>
                                                            <span class="text-xs text-gray-500 italic">Special Section</span>
                                                        </div>
                                                    </div>
                                                `;
                                            } else {
                                                const group = item.data;
                                                const isExpanded = state.expandedFolderIds.includes(group.id);
                                                return `
                                                    <div class="border border-gray-300 rounded-lg overflow-hidden" data-folder-id="${group.id}">
                                                        <div class="bg-gray-50 p-4 flex items-center gap-3">
                                                            <div class="cursor-move text-gray-400 hover:text-gray-600">
                                                                ‚ãÆ‚ãÆ
                                                            </div>
                                                            <button onclick="event.stopPropagation(); toggleFolderExpanded('${group.id}')" class="text-gray-600 hover:text-gray-800 transition">
                                                                <svg class="w-5 h-5 transition-transform ${isExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                                </svg>
                                                            </button>
                                                            <div class="flex-1">
                                                                <h4 class="font-semibold text-gray-800">${group.name}</h4>
                                                                <p class="text-sm text-gray-600">${(group.items || []).length} items</p>
                                                            </div>
                                                            <button onclick="addItemToFolder('${group.id}')" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 text-sm">
                                                                + Add Item
                                                            </button>
                                                            <button onclick="deleteFolder('${group.id}')" class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600 text-sm">
                                                                Delete
                                                            </button>
                                                        </div>
                                                        ${isExpanded && (group.items || []).length > 0 ? `
                                                            <div class="p-4 bg-white space-y-2" id="folder-items-${group.id}" data-folder-id="${group.id}">
                                                                ${(group.items || []).map(item => {
                                                                    // Find the actual item
                                                                    let itemData = null;
                                                                    let itemTitle = 'Unknown';
                                                                    if (item.item_type === 'contest') {
                                                                        itemData = state.contests.find(c => c.id === item.item_id);
                                                                        itemTitle = itemData?.title || 'Unknown Contest';
                                                                    } else if (item.item_type === 'merger') {
                                                                        itemData = state.mergers.find(m => m.id === item.item_id);
                                                                        itemTitle = itemData?.name || 'Unknown Merger';
                                                                    } else if (item.item_type === 'extract') {
                                                                        itemData = state.extracts.find(e => e.id === item.item_id);
                                                                        itemTitle = itemData?.name || 'Unknown Extract';
                                                                    }

                                                                    return `
                                                                        <div class="flex items-center gap-3 p-2 bg-gray-50 rounded">
                                                                            <div class="cursor-move text-gray-400 hover:text-gray-600 text-xs">
                                                                                ‚ãÆ‚ãÆ
                                                                            </div>
                                                                            <div class="flex-1">
                                                                                <span class="text-sm font-medium text-gray-800">${itemTitle}</span>
                                                                                <span class="text-xs text-gray-500 ml-2">[${item.item_type.toUpperCase()}]</span>
                                                                            </div>
                                                                            <button onclick="removeItemFromFolder('${group.id}', '${item.item_id}', '${item.item_type}')" class="text-red-500 hover:text-red-700 text-sm">
                                                                                Remove
                                                                            </button>
                                                                        </div>
                                                                    `;
                                                                }).join('')}
                                                            </div>
                                                        ` : ''}
                                                    </div>
                                                `;
                                            }
                                        }).join('');
                                    })()}
                                </div>
                            `}

                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-6">
                                <p class="text-sm text-blue-800">
                                    üí° <strong>Note:</strong> Folders organize your contests, mergers, and extracts on the home page.
                                    Drag the "Unfoldered Items" section to position it above or below specific folders.
                                    Click the arrow to expand/collapse folders and see their items.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderMergedResults() {
            if (!state.mergedResults) {
                return '<div class="text-center p-8">No merged results available</div>';
            }

            const { contestIds, contestTitles, images } = state.mergedResults;

            // Create results structure similar to single contest
            const mergedResultsData = images.map(img => ({
                id: img.id,
                url: img.url,
                contestId: img.contestId,
                averageScore: parseFloat(img.averageScore),
                totalVotes: img.totalVotes,
                breakdown: img.voteBreakdown || []
            }));

            let displayResults, grouped, sortedKeys, voterStats;

            // === BY VOTER VIEW ===
            if (state.resultsView === 'byVoter') {
                // Generate voter stats from breakdown data
                const voterMap = {};
                mergedResultsData.forEach(imageResult => {
                    (imageResult.breakdown || []).forEach(vote => {
                        if (!vote.isBlocked) {
                            if (!voterMap[vote.userId]) {
                                voterMap[vote.userId] = {
                                    userId: vote.userId,
                                    username: vote.username,
                                    avatar: vote.avatar,
                                    totalScore: 0,
                                    totalImages: 0,
                                    isCurrentUser: vote.userId === state.user?.id
                                };
                            }
                            voterMap[vote.userId].totalScore += vote.score;
                            voterMap[vote.userId].totalImages++;
                        }
                    });
                });

                voterStats = Object.values(voterMap).map(voter => ({
                    ...voter,
                    averageScore: (voter.totalScore / voter.totalImages).toFixed(2)
                }));

                // Sort based on voterSortBy state
                voterStats.sort((a, b) => {
                    switch (state.voterSortBy) {
                        case 'scoreAsc':
                            return parseFloat(a.averageScore) - parseFloat(b.averageScore);
                        case 'nameAsc':
                            return a.username.toLowerCase().localeCompare(b.username.toLowerCase());
                        case 'nameDesc':
                            return b.username.toLowerCase().localeCompare(a.username.toLowerCase());
                        case 'scoreDesc':
                        default:
                            return parseFloat(b.averageScore) - parseFloat(a.averageScore);
                    }
                });
            }
            // === USER VOTES VIEW ===
            else if (state.resultsView === 'userVotes') {
                const selectedUserId = state.selectedVoterUserId || state.user?.id;

                const userVotesMap = {};
                mergedResultsData.forEach(imageResult => {
                    const userVote = (imageResult.breakdown || []).find(v => v.userId === selectedUserId && !v.isBlocked);
                    if (userVote) {
                        userVotesMap[imageResult.id] = userVote.score;
                    }
                });

                displayResults = mergedResultsData.map(img => ({
                    ...img,
                    averageScore: userVotesMap[img.id] || 0,
                    userVoteScore: userVotesMap[img.id]
                })).filter(img => img.userVoteScore);

                grouped = groupMyVotesByScore(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => parseInt(b) - parseInt(a));
            }
            // === AVERAGE VIEW ===
            else {
                displayResults = mergedResultsData;
                grouped = groupByScoreRange(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => {
                    const aMin = grouped[a].min;
                    const bMin = grouped[b].min;
                    return bMin - aMin;
                });
            }

            // Get all voters for dropdown
            const voterSet = new Set();
            mergedResultsData.forEach(img => {
                (img.breakdown || []).forEach(vote => {
                    if (!vote.isBlocked) {
                        voterSet.add(JSON.stringify({ userId: vote.userId, username: vote.username, avatar: vote.avatar }));
                    }
                });
            });
            const mergedVoters = Array.from(voterSet)
                .map(v => JSON.parse(v))
                .sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));

            const baseSize = 150;
            const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
            const baseFontSize = 12;
            const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

            // Build title
            const titleText = contestIds.length <= 3
                ? contestIds.map(id => contestTitles[id]).join(', ')
                : `${contestIds.length} contests`;

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="text-center mb-4">
                            <div class="flex items-center justify-center gap-2 mb-2">
                                <span class="text-4xl">üîÄ</span>
                                <h2 class="text-2xl font-bold text-gray-800">Merged Results</h2>
                            </div>
                            <div class="mb-1">
                                <button
                                    onclick="toggleMergedContestsDropdown()"
                                    class="text-gray-600 text-sm hover:bg-gray-100 px-3 py-1 rounded-lg border border-gray-300 transition-colors inline-flex items-center gap-1"
                                >
                                    ${contestIds.length} contest${contestIds.length !== 1 ? 's' : ''}
                                    <span class="text-xs">${state.showMergedContestsDropdown ? '‚ñ≤' : '‚ñº'}</span>
                                </button>
                                ${state.showMergedContestsDropdown ? `
                                    <div class="mt-2 bg-gray-50 border border-gray-300 rounded-lg px-4 py-2 text-left max-w-md mx-auto">
                                        ${contestIds.map(id => `
                                            <div class="text-sm text-gray-700 py-1">
                                                ‚Ä¢ ${contestTitles[id]}
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                            <p class="text-xs text-gray-500">Click on any image to see the vote breakdown</p>

                            <div class="mt-3 flex flex-col items-center justify-center gap-2">
                                <!-- First row: View tabs -->
                                <div class="flex items-center justify-center gap-3">
                                    <button
                                        onclick="setResultsView('average')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'average' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        Total
                                    </button>
                                    <button
                                        onclick="setResultsView('userVotes')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'userVotes' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        By User
                                    </button>
                                    <button
                                        onclick="setResultsView('byVoter')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'byVoter' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        Average
                                    </button>
                                </div>
                                <!-- Revote button row -->
                                <div class="flex items-center justify-center gap-3">
                                    <button
                                        onclick="revoteMerge()"
                                        class="px-3 py-1 rounded-lg bg-purple-500 text-white hover:bg-purple-600 transition text-sm"
                                        title="Re-vote on all merged contests"
                                    >
                                        üîÑ Revote
                                    </button>
                                </div>
                                <!-- User selector dropdown for User Votes view -->
                                ${state.resultsView === 'userVotes' && mergedVoters.length > 0 ? `
                                    <div class="flex items-center gap-2">
                                        <label class="text-xs font-medium text-gray-700">Select User:</label>
                                        <select
                                            onchange="setResultsView('userVotes', this.value)"
                                            class="px-2 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                        >
                                            ${mergedVoters.map(voter => {
                                                const isSelected = (state.selectedVoterUserId || state.user?.id) === voter.userId;
                                                const isCurrent = voter.userId === state.user?.id;
                                                return `
                                                    <option value="${voter.userId}" ${isSelected ? 'selected' : ''}>
                                                        ${voter.username}${isCurrent ? ' (You)' : ''}
                                                    </option>
                                                `;
                                            }).join('')}
                                        </select>
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        ${state.resultsView !== 'byVoter' ? `
                            <div class="mb-4 max-w-md mx-auto">
                                <div class="flex items-center gap-2">
                                    <label class="text-xs font-medium text-gray-700 whitespace-nowrap">Image Scale:</label>
                                    <button
                                        onclick="adjustScale(-1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Decrease scale"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        id="scaleSlider"
                                        min="40"
                                        max="200"
                                        value="${state.imageScale}"
                                        oninput="updateScale(this.value)"
                                        class="flex-1 h-2 bg-gray-200 rounded-lg cursor-pointer"
                                    />
                                    <button
                                        onclick="adjustScale(1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Increase scale"
                                    >+</button>
                                    <span class="text-xs font-medium text-gray-700 w-10">${state.imageScale}%</span>
                                </div>
                            </div>
                        ` : ''}

                        ${state.resultsView === 'byVoter' ? `
                            ${voterStats && voterStats.length > 0 ? `
                                <div class="mb-4 flex justify-center">
                                    <div class="flex items-center gap-2">
                                        <label class="text-xs font-medium text-gray-700">Sort by:</label>
                                        <select
                                            onchange="setVoterSortBy(this.value)"
                                            class="px-3 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                        >
                                            <option value="scoreDesc" ${state.voterSortBy === 'scoreDesc' ? 'selected' : ''}>Score: High to Low</option>
                                            <option value="scoreAsc" ${state.voterSortBy === 'scoreAsc' ? 'selected' : ''}>Score: Low to High</option>
                                            <option value="nameAsc" ${state.voterSortBy === 'nameAsc' ? 'selected' : ''}>Name: A-Z</option>
                                            <option value="nameDesc" ${state.voterSortBy === 'nameDesc' ? 'selected' : ''}>Name: Z-A</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-2">
                                    ${(() => {
                                        let totalVotes = 0;
                                        let totalScore = 0;
                                        mergedResultsData.forEach(img => {
                                            (img.breakdown || []).forEach(vote => {
                                                if (!vote.isBlocked) {
                                                    totalVotes++;
                                                    totalScore += vote.score;
                                                }
                                            });
                                        });
                                        const contestAverage = totalVotes > 0 ? (totalScore / totalVotes).toFixed(2) : 0;

                                        return `
                                            <div class="bg-gradient-to-br from-yellow-50 to-yellow-100 rounded-lg shadow-md p-3 flex flex-col items-center border-2 border-yellow-500">
                                                <div class="text-2xl mb-2">üèÜ</div>
                                                <div class="text-xs font-semibold text-gray-800 text-center mb-1">
                                                    Contest Average
                                                </div>
                                                <div class="text-xl font-bold text-white score-text">
                                                    ${contestAverage}
                                                </div>
                                                <div class="text-xs text-gray-500">
                                                    ${totalVotes} vote${totalVotes !== 1 ? 's' : ''}
                                                </div>
                                            </div>
                                        `;
                                    })()}
                                    ${voterStats.map(voter => `
                                        <div class="bg-white rounded-lg shadow-md p-3 flex flex-col items-center hover:shadow-lg transition-shadow cursor-pointer border-2 ${voter.isCurrentUser ? 'border-mauve-400' : 'border-transparent'}">
                                            <img src="${voter.avatar}" alt="${voter.username}" class="w-12 h-12 rounded-full mb-2" />
                                            <div class="text-xs font-semibold text-gray-800 truncate w-full text-center mb-1" title="${voter.username}">
                                                ${voter.username}
                                            </div>
                                            <div class="text-xl font-bold text-white score-text">
                                                ${voter.averageScore}
                                            </div>
                                            <div class="text-xs text-gray-500">
                                                ${voter.totalImages} vote${voter.totalImages !== 1 ? 's' : ''}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">üë•</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Voters Yet</h3>
                                    <p class="text-gray-600">No voting data available for merged contests.</p>
                                </div>
                            `}
                        ` : state.resultsView === 'userVotes' && (!displayResults || displayResults.length === 0) ? `
                            <div class="text-center py-12">
                                <div class="text-6xl mb-4">üì≠</div>
                                <h3 class="text-xl font-bold text-gray-800 mb-2">No Votes Yet</h3>
                                <p class="text-gray-600">This user hasn't voted on any images in these contests.</p>
                            </div>
                        ` : sortedKeys.map(key => {
                            const group = grouped[key];

                            if (state.resultsView === 'userVotes') {
                                const score = group.score;
                                const colorStyle = getScoreColor(score);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg inline-block" style="color: white; background-color: ${colorStyle};">
                                            Score ${score}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdownMerged(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            } else {
                                const colorStyle = getCategoryColor(group.min, group.isMissing);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg ${colorStyle.color} ${colorStyle.bg} w-full block">
                                            ${getCategoryLabel(group.min, group.max, group.isMissing)}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdownMerged(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                    <div class="absolute bottom-0 left-0 right-0 text-white text-center py-1 font-bold score-text" style="font-size: ${fontSize}px;">
                                                        ${item.averageScore}
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>

                    ${state.showBreakdownModal ? renderBreakdownModalMerged() : ''}
                </div>
            `;
        }

        function render() {
            const app = document.getElementById('app');
            
            if (!state.isLoggedIn) {
                app.innerHTML = renderHeader() + renderLoginScreen() + renderModal() + renderCompressionModal() + renderUploadProgressModal() + renderToast() + renderLoadingOverlay();
                return;
            }

            let content = '';
            switch(state.view) {
                case 'home':
                    content = renderHome();
                    break;
                case 'createContest':
                    content = renderCreateContest();
                    break;
                case 'vote':
                    content = renderVoting();
                    break;
                case 'results':
                    content = renderResults();
                    break;
                case 'mergedResults':
                    content = renderMergedResults();
                    break;
                default:
                    content = renderHome();
            }

            app.innerHTML = renderHeader() + content + renderModal() + renderContestInfoModal() + renderCreateMergerModal() + renderCreateExtractModal() + renderUserProfileModal() + renderCompressionModal() + renderUploadProgressModal() + (state.showAdminDashboard ? renderAdminDashboard() : '') + (state.showAppSettingsModal ? renderAppSettingsModal() : '') + (state.showManageFoldersModal ? renderManageFoldersModal() : '') + renderToast() + renderLoadingOverlay();
        }

        window.login = login;
        window.logout = logout;
        window.startCreateContest = startCreateContest;
        window.showContestCreationDisabledModal = showContestCreationDisabledModal;
        window.showRevotingDisabledModal = showRevotingDisabledModal;
        window.showContestInfoModal = showContestInfoModal;
        window.closeContestInfoModal = closeContestInfoModal;
        window.shareContestFromModal = shareContestFromModal;
        window.handleContestTitle = handleContestTitle;
        window.confirmCreateWithDuplicateTitle = confirmCreateWithDuplicateTitle;
        window.cancelCreateContest = cancelCreateContest;
        window.confirmCancelCreate = confirmCancelCreate;
        window.addImageFromUrl = addImageFromUrl;
        window.clearUrlInput = clearUrlInput;
        window.handleFileSelect = handleFileSelect;
        window.handleDragOver = handleDragOver;
        window.handleDragLeave = handleDragLeave;
        window.handleDrop = handleDrop;
        window.removeContestImage = removeContestImage;
        window.confirmRemoveImage = confirmRemoveImage;
        window.finishCreateContest = finishCreateContest;
        window.confirmFinishCreateContest = confirmFinishCreateContest;
        window.startVoting = startVoting;
        window.viewResults = viewResults;
        window.viewLockedResults = viewLockedResults;
        window.startRevote = startRevote;
        window.confirmRevote = confirmRevote;
        window.toggleUserDropdown = toggleUserDropdown;
        window.shareContest = shareContest;
        window.shareMerge = shareMerge;
        window.showBreakdownMerged = showBreakdownMerged;
        window.toggleContestLock = toggleContestLock;
        window.toggleResultsPublic = toggleResultsPublic;
        window.handleVote = handleVote;
        window.navigateImage = navigateImage;
        window.jumpToImage = jumpToImage;
        window.cancelVoting = cancelVoting;
        window.submitVotes = submitVotes;
        window.showBreakdown = showBreakdown;
        window.closeBreakdown = closeBreakdown;
        window.backToHome = backToHome;
        window.confirmBackToHome = confirmBackToHome;
        window.closeModal = closeModal;
        window.closeUploadProgress = closeUploadProgress;
        window.retryUpload = retryUpload;
        window.cancelAllUploads = cancelAllUploads;
        window.closeCompressionModal = closeCompressionModal;
        window.compressMoreImage = compressMoreImage;
        window.cancelCompressionImage = cancelCompressionImage;
        window.addOversizedImageAnyway = addOversizedImageAnyway;
        window.updateScale = updateScale;
        window.adjustScale = adjustScale;
        window.confirmSubmitVotes = confirmSubmitVotes;
        window.confirmCancelVoting = confirmCancelVoting;
        window.toggleVoteView = toggleVoteView;
        window.deleteContest = deleteContest;
        window.handleDeleteContestConfirmation = handleDeleteContestConfirmation;
        window.confirmDeleteContest = confirmDeleteContest;
        window.setSortBy = setSortBy;
        window.setFilterCreator = setFilterCreator;
        window.setSearchQuery = setSearchQuery;
        window.applySearch = applySearch;
        window.clearAllFilters = clearAllFilters;
        window.toggleImageLabels = toggleImageLabels;
        window.updateImageLabel = updateImageLabel;
        window.showAdminDashboard = showAdminDashboard;
        window.closeAdminDashboard = closeAdminDashboard;
        window.showAppSettings = showAppSettings;
        window.closeAppSettings = closeAppSettings;
        window.toggleAppSetting = toggleAppSetting;
        window.confirmBanUser = confirmBanUser;
        window.handleBanUserReason = handleBanUserReason;
        window.executeBanUser = executeBanUser;
        window.unbanUser = unbanUser;
        window.adminEditVote = adminEditVote;
        window.confirmEditVote = confirmEditVote;
        window.adminToggleBlockVote = adminToggleBlockVote;
        window.executeToggleBlockVote = executeToggleBlockVote;
        window.confirmAddDuplicateImage = confirmAddDuplicateImage;
        window.setResultsView = setResultsView;
        window.setVoterSortBy = setVoterSortBy;
        window.toggleMergedContestsDropdown = toggleMergedContestsDropdown;
        window.openCreateMergerModal = openCreateMergerModal;
        window.closeCreateMergerModal = closeCreateMergerModal;
        window.toggleContestForMerger = toggleContestForMerger;
        window.setMergerName = setMergerName;
        window.updateMergerNameOnBlur = updateMergerNameOnBlur;
        window.saveMerger = saveMerger;
        window.deleteMerger = deleteMerger;
        window.viewMergerResults = viewMergerResults;
        window.startMergerVoting = startMergerVoting;
        window.showMergerVoteModal = showMergerVoteModal;
        window.shareMerger = shareMerger;
        window.revoteMerge = revoteMerge;
        window.openCreateExtractModal = openCreateExtractModal;
        window.closeCreateExtractModal = closeCreateExtractModal;
        window.deleteExtract = deleteExtract;
        window.startExtractVoting = startExtractVoting;
        window.viewExtractResults = viewExtractResults;
        window.selectExtractSource = selectExtractSource;
        window.toggleExtractImage = toggleExtractImage;
        window.setExtractName = setExtractName;
        window.updateExtractNameOnBlur = updateExtractNameOnBlur;
        window.saveExtract = saveExtract;
        window.openManageFoldersModal = openManageFoldersModal;
        window.closeManageFoldersModal = closeManageFoldersModal;
        window.showCreateFolderModal = showCreateFolderModal;
        window.cancelCreateFolder = cancelCreateFolder;
        window.confirmCreateFolder = confirmCreateFolder;
        window.createFolder = createFolder;
        window.deleteFolder = deleteFolder;
        window.confirmDeleteFolder = confirmDeleteFolder;
        window.executeDeleteFolder = executeDeleteFolder;
        window.addItemToFolder = addItemToFolder;
        window.selectFolderItem = selectFolderItem;
        window.toggleFolderItemSelection = toggleFolderItemSelection;
        window.confirmAddMultipleItemsToFolder = confirmAddMultipleItemsToFolder;
        window.removeItemFromFolder = removeItemFromFolder;
        window.toggleFolderExpanded = toggleFolderExpanded;
        window.viewUserProfile = viewUserProfile;
        window.closeUserProfileModal = closeUserProfileModal;
        window.confirmDeleteMerger = confirmDeleteMerger;
        window.executeDeleteMerger = executeDeleteMerger;
        window.confirmDeleteExtract = confirmDeleteExtract;
        window.executeDeleteExtract = executeDeleteExtract;

        // Initialize app
        // Check for existing session on load
        (async function init() {
            const storedUser = localStorage.getItem('peony_user');
            if (storedUser) {
                try {
                    const user = JSON.parse(storedUser);

                    // Check if token is expired
                    if (user.expiresAt && Date.now() < user.expiresAt) {
                        // Check if user is banned and get ban reason
                        const banCheckResponse = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${user.id}&select=is_banned,ban_reason`, {
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Cache-Control': 'no-cache'
                            }
                        });

                        const userData = await banCheckResponse.json();

                        // If user is banned, log them out with reason
                        if (userData && userData.length > 0 && userData[0].is_banned === true) {
                            const banReason = userData[0].ban_reason || 'No reason provided';
                            localStorage.removeItem('peony_user');
                            showAlert(`Your account has been banned from Peony.\n\nReason: ${banReason}`, 'üö´');
                        } else {
                            // User not banned, proceed with login
                            state.isLoggedIn = true;
                            // AFTER: ensure user exists, then continue
                            state.user = { 
                                id: user.id, 
                                username: user.username, 
                                avatar: user.avatar 
                            };

                            // Ensure the row exists in public.users, then continue
                            ensureLocalUser(state.user)
                                .then(async () => {
                                    // proceed normally once the user row is present (or insertion attempted)
                                    await loadContests();

                                    render();
                                })
                                .catch(async (err) => {
                                    // should not happen because ensureLocalUser swallows errors, but safe fallback
                                    console.error('ensureLocalUser unexpected error:', err);
                                    await loadContests();
                                    render();
                                });
                        }
                    } else {
                        // Token expired, clear it
                        localStorage.removeItem('peony_user');
                    }
                } catch (e) {
                    console.error('Error loading user session:', e);
                    localStorage.removeItem('peony_user');
                }
            }

            await Promise.all([
                loadContests(),
                loadMergers(),
                loadExtracts(),
                ensurePinnedFolder().then(() => loadGroups()),
                loadAppSettings()
            ]);
            if (state.user) {
                await loadUserVotes();
            }

            // Parse URL search parameter
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('search');
            if (searchQuery) {
                state.filters.searchQuery = searchQuery;
            }

            render();

            // Setup hash change listener for browser back/forward
            window.addEventListener('hashchange', handleHashChange);

            // Check for shared contest link on initial load
            if (window.location.hash && state.isLoggedIn) {
                handleHashChange();
            }
        })();
        }); // End DOMContentLoaded event listener
    </script>
</body>
</html>
