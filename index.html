<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <!-- PWA Configuration -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Peony">

    <!-- Favicon for browsers -->
    <link rel="icon" type="image/x-icon" href="favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">

    <!-- Apple Touch Icon for iOS home screen -->
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">

    <!-- Android Chrome Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="favicon/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="favicon/android-chrome-512x512.png">
    <!-- PWA Manifest -->
    <link rel="manifest" href="favicon/site.webmanifest">

    <!-- Canonical URL for GitHub Pages PWA -->
    <link rel="canonical" href="https://bicipikay.github.io/peony/">

    <!-- Theme color for mobile browsers -->
    <meta name="theme-color" content="#C77BA6">

    <title>Peony</title>

    <!-- Supabase JS Client for Realtime -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- SortableJS for drag-and-drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: ['class', '.dark-theme'],
            theme: {
                extend: {
                    colors: {
                        'mauve': {
                            300: '#D88FB8',
                            400: '#C77BA6',
                            500: '#B76E9E',
                            600: '#A86590',
                            700: '#995C82'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lilita+One&display=swap');
        
        @keyframes tickAppear {
            0% { transform: scale(0) rotate(-45deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(0deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        .tick-animation {
            animation: tickAppear 0.6s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal-overlay {
            animation: modalFadeIn 0.2s ease-out;
            background: rgba(0, 0, 0, 0.7);
        }
        @keyframes modalSlideIn {
            from { transform: scale(0.9) translateY(-20px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }
        .modal-content {
            animation: modalSlideIn 0.3s ease-out;
        }
        body {
            background: linear-gradient(to bottom,
                rgba(250, 232, 255, 0.3),
                rgba(220, 252, 231, 0.3)
            );
            min-height: 100vh;
        }
        body.modal-open {
            overflow: hidden;
        }
        .rotate-90 { transform: rotate(90deg); }
        .collapse-arrow { transition: transform 0.2s ease; display: inline-block; }
        .image-loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        @keyframes toastSlideIn {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes toastFadeOut {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-20px); opacity: 0; }
        }
        .toast-notification {
            animation: toastSlideIn 0.3s ease-out;
        }
        .toast-notification.fade-out {
            animation: toastFadeOut 0.3s ease-out;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        input[type="range"]::-webkit-slider-track {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, rgb(180, 90, 145) 0%, rgb(34, 197, 94) 100%);
            border: 2px solid rgba(0, 0, 0, 0.25);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        input[type="range"]::-moz-range-track {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, rgb(180, 90, 145) 0%, rgb(34, 197, 94) 100%);
            border: 2px solid rgba(0, 0, 0, 0.25);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: #ec4899;
            border: 3px solid #f472b6;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: #ec4899;
            border: 3px solid #f472b6;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        .upload-area {
            border: 3px dashed #C77BA6;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            border-color: #B76E9E;
            background: rgba(199, 123, 166, 0.05);
        }
        .upload-area.dragover {
            border-color: #22C55E;
            background: rgba(34, 197, 94, 0.1);
            transform: scale(1.02);
        }
        .score-text {
            font-family: 'Lilita One', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), -1px -1px 2px rgba(0,0,0,0.8), 1px -1px 2px rgba(0,0,0,0.8), -1px 1px 2px rgba(0,0,0,0.8);
        }
        .progress-segment {
            height: 8px;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .progress-segment:hover {
            transform: scaleY(1.3);
        }
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background-color: #ccc;
            border-radius: 30px;
            cursor: pointer;
            transition: background-color 0.3s;
            display: inline-block;
        }
        .toggle-switch.active {
            background-color: #C77BA6;
        }
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(30px);
        }
        .voting-image {
            max-height: 50vh;
        }
        @media (min-width: 640px) {
            .voting-image {
                max-height: min(40vh, 500px);
            }
        }
        /* PWA safe area support for iOS and Android fullscreen mode */
        .safe-header {
            padding-top: env(safe-area-inset-top);
        }
        /* Realtime toast notifications - slide in from right */
        @keyframes slideInRight {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background-color: #ccc;
            border-radius: 26px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .toggle-switch.active {
            background-color: #4CAF50;
        }
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        /* Range Slider Track Styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #d1d5db;
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #C77BA6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #C77BA6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-track {
            height: 6px;
            background: #d1d5db;
            border-radius: 3px;
        }
        body.dark-theme input[type="range"] {
            background: #4a4a5a;
        }
        body.dark-theme input[type="range"]::-webkit-slider-thumb {
            background: #D88FB8;
            border-color: #2a2a3a;
        }
        body.dark-theme input[type="range"]::-moz-range-thumb {
            background: #D88FB8;
            border-color: #2a2a3a;
        }
        body.dark-theme input[type="range"]::-moz-range-track {
            background: #4a4a5a;
        }

        /* Dark Theme Styles */
        body.dark-theme {
            background: linear-gradient(to bottom,
                rgba(60, 55, 65, 0.95),
                rgba(55, 65, 60, 0.95)
            );
            color: #e0e0e0;
        }

        body.dark-theme .bg-white:not(.rounded-full) {
            background-color: #1e1e2e !important;
        }

        /* Keep voting mode switch circle white */
        body.dark-theme .bg-white.rounded-full {
            background-color: white !important;
        }

        /* Loading spinner should be transparent, not white */
        body.dark-theme .animate-spin.rounded-full {
            background-color: transparent !important;
        }

        body.dark-theme .bg-blue-50 {
            background-color: #1a2540 !important;
        }

        /* Extract cards - blueish tint */
        body.dark-theme .bg-yellow-50:not(button):not(.hover\:bg-yellow-100) {
            background-color: #2a3550 !important;
        }

        /* Image container backgrounds blend with dark theme */
        body.dark-theme .bg-gray-100 {
            background-color: #2a2a3a !important;
        }

        /* Don't change text color for most text elements */
        body.dark-theme .text-gray-800,
        body.dark-theme .text-gray-600 {
            color: #e0e0e0 !important;
        }

        body.dark-theme .text-gray-700 {
            color: #e0e0e0 !important;
        }

        body.dark-theme .text-gray-500 {
            color: #b0b0b0 !important;
        }

        /* Keep text dark on gray backgrounds for readability - but not when dark:bg is applied */
        body.dark-theme .bg-gray-50:not(.dark\:bg-gray-800) .text-gray-800,
        body.dark-theme .bg-gray-50:not(.dark\:bg-gray-800) .text-gray-700,
        body.dark-theme .bg-gray-50:not(.dark\:bg-gray-800) .text-gray-600 {
            color: #374151 !important;
        }
        body.dark-theme .bg-gray-50.dark\:bg-gray-800 .text-gray-800,
        body.dark-theme .bg-gray-50.dark\:bg-gray-800 .text-gray-700,
        body.dark-theme .bg-gray-50.dark\:bg-gray-800 .text-gray-600 {
            color: #e0e0e0 !important;
        }

        /* Keep text dark on buttons and controls with bg-gray-200 */
        body.dark-theme button.bg-gray-200.text-gray-700,
        body.dark-theme .bg-gray-200 .text-gray-700 {
            color: #374151 !important;
        }

        body.dark-theme .text-blue-900,
        body.dark-theme .text-blue-700 {
            color: #a0c4ff !important;
        }

        body.dark-theme .text-yellow-900,
        body.dark-theme .text-yellow-700 {
            color: #ffd68a !important;
        }

        body.dark-theme .border-gray-200,
        body.dark-theme .border-gray-300 {
            border-color: #3a3a4a !important;
        }

        body.dark-theme .border-yellow-400 {
            border-color: #6a5a2a !important;
        }

        /* Merger cards - more blueish border */
        body.dark-theme .border-blue-300 {
            border-color: #4a5a7a !important;
        }

        body.dark-theme .shadow-lg,
        body.dark-theme .shadow-xl {
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5) !important;
        }

        body.dark-theme .hover\:bg-gray-100:hover {
            background-color: #2a2a3a !important;
        }

        body.dark-theme input[type="text"],
        body.dark-theme input[type="number"],
        body.dark-theme input[type="date"],
        body.dark-theme textarea,
        body.dark-theme select {
            background-color: #2a2a3a !important;
            color: #e0e0e0 !important;
            border-color: #3a3a4a !important;
        }

        body.dark-theme input::placeholder,
        body.dark-theme textarea::placeholder {
            color: #888 !important;
        }

        body.dark-theme .modal-overlay {
            background: rgba(0, 0, 0, 0.85) !important;
        }

        body.dark-theme .image-loading {
            background: linear-gradient(90deg, #2a2a3a 25%, #3a3a4a 50%, #2a2a3a 75%);
        }

        /* Keep navigation buttons (bg-gray-200) visible in dark theme */
        body.dark-theme button.bg-gray-200,
        body.dark-theme button.bg-gray-300 {
            background-color: #d0d0d0 !important;
        }

        /* Keep theme switch background gray in dark mode */
        body.dark-theme .bg-gray-300.rounded-full {
            background-color: #6b7280 !important; /* Proper gray that contrasts with white circle */
        }

        body.dark-theme button.hover\:bg-gray-300:hover {
            background-color: #e0e0e0 !important;
        }

        /* Progress bar container should be dark */
        body.dark-theme .bg-gray-200.h-3 {
            background-color: #1a1a1a !important;
        }

        /* Keep text on navigation buttons dark for visibility */
        body.dark-theme .bg-gray-200.text-gray-700 {
            color: #374151 !important;
        }

        /* Keep voting mode switch circle white */
        body.dark-theme .toggle-slider {
            background-color: white !important;
        }

        /* Use gray gradient for card action buttons */
        body.dark-theme .bg-gradient-to-r.from-blue-500.to-blue-600,
        body.dark-theme .bg-gradient-to-r.from-blue-400.to-blue-600 {
            background: linear-gradient(to right, #4a5568, #2d3748) !important;
        }

        /* Adapt "Show more" button sections to dark theme */
        body.dark-theme button.bg-yellow-50,
        body.dark-theme .bg-yellow-50.hover\:bg-yellow-100 {
            background-color: #3a3520 !important;
        }

        body.dark-theme button.bg-red-50,
        body.dark-theme .bg-red-50.hover\:bg-red-100 {
            background-color: #3a2020 !important;
        }

        body.dark-theme button.bg-green-50,
        body.dark-theme .bg-green-50.hover\:bg-green-100 {
            background-color: #203a20 !important;
        }

        /* Dark mode modal: lighten text for readability on dark backgrounds */
        body.dark-theme .modal-content .text-gray-800 {
            color: #f3f4f6 !important;
        }
        body.dark-theme .modal-content .text-gray-700 {
            color: #e5e7eb !important;
        }
        body.dark-theme .modal-content .text-gray-600 {
            color: #d1d5db !important;
        }
        body.dark-theme .modal-content .text-gray-500 {
            color: #9ca3af !important;
        }
        body.dark-theme .modal-content .text-blue-800 {
            color: #93c5fd !important;
        }
        /* Dark mode modal: darken section backgrounds */
        body.dark-theme .modal-content .bg-gray-50 {
            background-color: #2a2a3a !important;
        }
        body.dark-theme .modal-content .bg-gray-100 {
            background-color: #252535 !important;
        }
        body.dark-theme .modal-content .bg-blue-50 {
            background-color: #1e2a3a !important;
        }

        /* Override Tailwind dark: variants to only respond to app theme toggle, not OS preference */
        /* Force dark blue text in light mode (consistent across mobile and PC) */
        body:not(.dark-theme) .bg-blue-50 .text-blue-800 {
            color: #1e40af !important; /* blue-800 - matches PC behavior */
        }

        /* Make tip message text readable in dark theme (multi-mode voting) */
        body.dark-theme .bg-blue-50 .text-blue-800 {
            color: #bfdbfe !important; /* blue-200 */
        }

        /* Make voter stats usernames more readable in dark theme (but exclude modal content) */
        body.dark-theme div.text-xs.font-semibold.text-gray-800:not(.modal-content *) {
            color: #e0e0e0 !important;
        }

        /* Darken Contest Average card background for better text contrast */
        body.dark-theme .bg-gradient-to-br.from-yellow-50.to-yellow-100 {
            background: linear-gradient(to bottom right, #4a4020, #5a5030) !important;
        }

        /* Make vote count text more readable on dark Contest Average card */
        body.dark-theme .bg-gradient-to-br.from-yellow-50.to-yellow-100 .text-gray-500 {
            color: #b0b0b0 !important;
        }

        body.dark-theme .text-yellow-600:not(.modal-content *),
        body.dark-theme .text-red-600:not(.modal-content *),
        body.dark-theme .text-green-600:not(.modal-content *) {
            color: #d0d0d0 !important;
        }

        body.dark-theme .hover\:text-yellow-700:hover,
        body.dark-theme .hover\:text-red-700:hover,
        body.dark-theme .hover\:text-green-700:hover {
            color: #e0e0e0 !important;
        }

        body.dark-theme .hover\:bg-yellow-100:hover:not(.modal-content *) {
            background-color: #4a4530 !important;
        }

        body.dark-theme .hover\:bg-red-100:hover:not(.modal-content *) {
            background-color: #4a3030 !important;
        }

        body.dark-theme .hover\:bg-green-100:hover:not(.modal-content *) {
            background-color: #304a30 !important;
        }

        body.dark-theme .hover\:bg-blue-200:hover:not(.modal-content *) {
            background-color: #304050 !important;
        }

        body.dark-theme .hover\:bg-purple-200:hover:not(.modal-content *) {
            background-color: #403050 !important;
        }

        body.dark-theme .hover\:bg-yellow-200:hover:not(.modal-content *) {
            background-color: #4a4530 !important;
        }

        /* No default white backgrounds for images or avatars in dark theme */
        /* Specific elements that need white backgrounds are handled by individual rules below */

        /* Keep tabs text black on results page */
        body.dark-theme button[onclick*="setResultsView"] {
            color: #000 !important;
        }

        /* Statistics label and numbers should keep their default colors in dark theme */
        /* Removed forced dark colors to allow proper visibility */

        /* Keep info buttons gray instead of blue */
        body.dark-theme button[onclick*="showContestInfoModal"].bg-blue-500,
        body.dark-theme button[onclick*="showContestInfoModal"].hover\:bg-blue-600 {
            background: linear-gradient(to right, #4a5568, #2d3748) !important;
        }

        /* Activity list text should keep default colors for readability */
        /* Removed forced dark text colors on light backgrounds */

        /* Polish folder header colors for dark theme */
        body.dark-theme .bg-gradient-to-r.from-yellow-400.to-yellow-500 {
            background: linear-gradient(to right, #b8860b, #daa520) !important;
        }

        /* Polish "Complete Voting" section header */
        body.dark-theme .bg-gradient-to-r.from-yellow-300.to-yellow-400 {
            background: linear-gradient(to right, #b8860b, #daa520) !important;
        }

        /* Polish top bar gradient */
        body.dark-theme .bg-gradient-to-r.from-mauve-400.to-purple-500,
        body.dark-theme .bg-gradient-to-r.from-mauve-500.to-purple-600 {
            background: linear-gradient(to right, #6b5b95, #8b7bb8) !important;
        }

        /* Fix Statistics section background for dark theme */
        body.dark-theme .bg-gradient-to-r.from-purple-50.to-pink-50 {
            background: linear-gradient(to right, #2a2040, #402030) !important;
        }

        body.dark-theme .border-purple-200 {
            border-color: #5a4a6a !important;
        }

        /* Keep unvoted score indicator circles white in dark theme */
        body.dark-theme .score-indicator-unvoted {
            background-color: white !important;
            color: #9ca3af !important;
        }

        /* Fix Create modal button gradients for dark theme */
        body.dark-theme .bg-gradient-to-r.from-green-50.to-green-100 {
            background: linear-gradient(to right, #1a3a1a, #2a4a2a) !important;
        }

        body.dark-theme .bg-gradient-to-r.from-amber-50.to-amber-100 {
            background: linear-gradient(to right, #3a3010, #4a4020) !important;
        }

        body.dark-theme .bg-gradient-to-r.from-blue-50.to-blue-100 {
            background: linear-gradient(to right, #1a2a3a, #2a3a4a) !important;
        }

        body.dark-theme .bg-gradient-to-r.from-yellow-50.to-yellow-100 {
            background: linear-gradient(to right, #3a3520, #4a4530) !important;
        }

        /* Fix hover state light backgrounds in dark theme */
        body.dark-theme .hover\:bg-yellow-50:hover {
            background-color: #3a3520 !important;
        }

        body.dark-theme .hover\:bg-blue-50:hover {
            background-color: #1a2a3a !important;
        }

        /* Dark mode: results tab labels (Image Scale, Sort, Filter, etc.) */
        body.dark-theme .text-gray-700.whitespace-nowrap,
        body.dark-theme label.text-gray-700 {
            color: #d0d0d0 !important;
        }

        /* Dark mode: Count tab Show buttons when unselected - need dark text on light bg */
        body.dark-theme .bg-gray-200:not(:hover) {
            color: #1f2937 !important;
        }

        /* Dark mode: Comparing table percentage badges - darker bg for contrast */
        body.dark-theme td span[style*="background: #bbf7d0"],
        body.dark-theme td span[style*="background: #fef08a"],
        body.dark-theme td span[style*="background: #bfdbfe"],
        body.dark-theme td span[style*="background: #fed7aa"],
        body.dark-theme td span[style*="background: #fecaca"] {
            color: #1f2937 !important;
        }

        /* Dark mode: Comparison detail category headers and subcategory bars - keep text dark for readability */
        body.dark-theme .comparison-cat-header {
            color: #1a1a1a !important;
        }

        /* Dark mode: comparison table percentage badges - always dark text */
        body.dark-theme .comparison-pct-badge {
            color: #1f2937 !important;
        }

        /* Dark mode: comparison table Contest Average row */
        body.dark-theme tr.bg-yellow-50 {
            background-color: #3a3520 !important;
        }
        body.dark-theme tr.bg-yellow-50 .text-yellow-800 {
            color: #fcd34d !important;
        }

        /* Dark mode: multi mode voting view header labels */
        body.dark-theme .dark\:text-gray-300 {
            color: #d1d5db !important;
        }
        body.dark-theme .dark\:text-gray-400 {
            color: #9ca3af !important;
        }
        body.dark-theme .dark\:text-gray-100 {
            color: #f3f4f6 !important;
        }
        body.dark-theme .dark\:bg-gray-800 {
            background-color: #1f2937 !important;
        }
        body.dark-theme .dark\:bg-gray-900 {
            background-color: #111827 !important;
        }
        body.dark-theme .dark\:bg-gray-700 {
            background-color: #374151 !important;
        }
        body.dark-theme .dark\:border-gray-700 {
            border-color: #374151 !important;
        }
        body.dark-theme .dark\:border-gray-600 {
            border-color: #4b5563 !important;
        }
        body.dark-theme .dark\:hover\:bg-gray-600:hover {
            background-color: #4b5563 !important;
        }
        body.dark-theme .dark\:text-blue-200 {
            color: #bfdbfe !important;
        }

        /* Dark mode: user filter dropdown */
        body.dark-theme .image-filter-dropdown,
        body.dark-theme .user-filter-dropdown {
            background-color: #1e1e2e !important;
            border-color: #3a3a4a !important;
        }
        body.dark-theme .image-filter-dropdown .sticky,
        body.dark-theme .user-filter-dropdown .sticky {
            background-color: #1e1e2e !important;
            border-color: #3a3a4a !important;
        }
        body.dark-theme .image-filter-dropdown label:hover,
        body.dark-theme .user-filter-dropdown label:hover {
            background-color: #2a2a3a !important;
        }

        /* Dark mode: colored backgrounds for activity log and divisive categories */
        body.dark-theme .bg-green-100 {
            background-color: #1a3a1a !important;
        }
        body.dark-theme .bg-blue-100 {
            background-color: #1a2a3a !important;
        }
        body.dark-theme .bg-yellow-100 {
            background-color: #3a3520 !important;
        }
        body.dark-theme .bg-purple-100 {
            background-color: #2a1a3a !important;
        }
        body.dark-theme .bg-red-100 {
            background-color: #3a1a1a !important;
        }
        body.dark-theme .bg-orange-100 {
            background-color: #3a2a1a !important;
        }
        body.dark-theme .bg-lime-100 {
            background-color: #2a3a1a !important;
        }
        body.dark-theme .bg-cyan-100 {
            background-color: #1a2a3a !important;
        }
        body.dark-theme .bg-emerald-100 {
            background-color: #1a3a2a !important;
        }
        body.dark-theme .bg-red-200 {
            background-color: #4a1a1a !important;
        }
        body.dark-theme .bg-green-200 {
            background-color: #1a4a1a !important;
        }
        body.dark-theme .bg-yellow-200 {
            background-color: #4a4020 !important;
        }
        body.dark-theme .bg-purple-200 {
            background-color: #3a1a3a !important;
        }

        /* Dark mode: colored text in divisive categories and badges */
        body.dark-theme .text-red-900 {
            color: #fca5a5 !important;
        }
        body.dark-theme .text-red-800 {
            color: #fca5a5 !important;
        }
        body.dark-theme .text-orange-800 {
            color: #fdba74 !important;
        }
        body.dark-theme .text-yellow-800 {
            color: #fde047 !important;
        }
        body.dark-theme .text-lime-800 {
            color: #bef264 !important;
        }
        body.dark-theme .text-lime-700 {
            color: #d9f99d !important;
        }
        body.dark-theme .text-cyan-700 {
            color: #67e8f9 !important;
        }
        body.dark-theme .text-purple-800 {
            color: #d8b4fe !important;
        }
        body.dark-theme .text-green-800 {
            color: #86efac !important;
        }
        body.dark-theme .text-emerald-800 {
            color: #6ee7b7 !important;
        }
        body.dark-theme .text-green-700 {
            color: #86efac !important;
        }
        body.dark-theme .text-red-700 {
            color: #fca5a5 !important;
        }
        body.dark-theme .text-red-600 {
            color: #fca5a5 !important;
        }

        /* Dark theme for merged results contest list */
        body.dark-theme .contest-list-dropdown {
            background-color: #2a2a3a !important;
            border-color: #4a4a5a !important;
        }

        body.dark-theme .contest-list-item {
            color: #e5e7eb !important;
        }

        /* Dark theme for modal content text */
        body.dark-theme .modal-content .text-gray-700:not(.bg-gray-300 *):not(.line-through) {
            color: #d1d5db !important;
        }

        body.dark-theme .modal-content .text-gray-600 {
            color: #d1d5db !important;
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="app"></div>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            // Emergency error handler to catch JavaScript errors
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e);
            const app = document.getElementById('app');
            if (app && !app.innerHTML) {
                app.innerHTML = `
                    <div style="padding: 2rem; font-family: sans-serif; max-width: 800px; margin: 0 auto;">
                        <h1 style="color: #ef4444; margin-bottom: 1rem;">‚ö†Ô∏è Error Loading App</h1>
                        <div style="background: #fee; border: 1px solid #fcc; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <p><strong>Error:</strong> ${e.message || 'Unknown error'}</p>
                            <p><strong>File:</strong> ${e.filename || 'Unknown'}</p>
                            <p><strong>Line:</strong> ${e.lineno || 'Unknown'}:${e.colno || 'Unknown'}</p>
                        </div>
                        <p style="margin-bottom: 0.5rem;"><strong>What to do:</strong></p>
                        <ol style="line-height: 1.6;">
                            <li>Open browser console (F12) for detailed error information</li>
                            <li>Check for JavaScript syntax errors in index.html</li>
                            <li>Verify Supabase is loading correctly</li>
                            <li>Clear browser cache and reload the page</li>
                        </ol>
                    </div>
                `;
            }
        });

        // Supabase Configuration
        const SUPABASE_URL = 'https://tbduuuzwbiidjgztupfp.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRiZHV1dXp3YmlpZGpnenR1cGZwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0NTI3NjcsImV4cCI6MjA4MDAyODc2N30.lMDbB1I7vNoMFCncGw7_i9hUtWp-mO9rsmFLgd3GMMQ';

        // Discord OAuth Configuration
        const DISCORD_CLIENT_ID = '1442282566810861568';  // Replace with your actual Discord Client ID
        const DISCORD_REDIRECT_URI = 'https://bicipikay.github.io/peony/auth/callback';  // Replace with YOUR actual GitHub Pages URL + /auth/callback

        // Admin Discord ID - Replace with your actual Discord user ID after first login
        const ADMIN_DISCORD_ID = '719271552247529571';

        // Initialize Supabase client (only if not already initialized to prevent duplicate declaration errors)
        if (typeof window.supabaseClient === 'undefined') {
            window.supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }
        const supabase = window.supabaseClient;

        let state = {
            isLoggedIn: false,
            user: null,
            view: 'home',
            contests: [],
            currentContest: null,
            currentImageIndex: 0,
            votes: {},
            userVotedContests: {},
            hasSubmitted: false,
            showBreakdownModal: null,
            showTickAnimation: false,
            isAnimating: false,
            modal: null,
            modalProcessing: false,
            imageScale: 100,
            results: null,
            scaleUpdateTimeout: null,
            extractScaleUpdateTimeout: null,
            multiVotingScaleUpdateTimeout: null,
            newContest: { title: '', images: [] },
            showMyVotes: false,  // Deprecated, use resultsView
            resultsView: 'average',  // 'average', 'divisive', 'count', 'userVotes', or 'byVoter'
            voterSortBy: 'scoreDesc',  // 'scoreDesc', 'scoreAsc', 'nameAsc', 'nameDesc' for byVoter view
            selectedVoterUserId: null,  // For user votes dropdown (null = current user)
            contestVoters: [],  // List of all users who voted in current contest(s)
            countSelectedScores: [],  // Array of selected scores for count view (e.g., [1, 5])
            shuffledImages: [],
            nextContestId: 1,
            bannedUsers: [], // Array of user IDs who are banned from app
            allUsers: [], // Track all users who have logged in
            uploadProgress: null, // Upload progress tracking: { files: [{name, status, error, progress}], completed: false }
            showUserList: false, // Show user list modal (admin only)
            showAdminDashboard: false, // Show admin dashboard modal
            showAppSettingsModal: false, // Show app settings modal (admin only)
            showActivityLogsModal: false, // Show activity logs modal (admin only)
            activityLogs: [], // Recent vote submission activity
            activityLogsLoading: false, // Loading state for activity logs modal
            activityDateStart: null, // Start date for activity logs (null = default to 7 days ago)
            activityDateEnd: null, // End date for activity logs (null = default to today)
            activityFilterUser: null, // Filter activity by specific user ID (null = all users)
            activityFilterContest: null, // Filter activity by specific contest ID (null = all contests)
            activityFilterAction: null, // Filter activity by action type (null = all actions)
            adminStats: { totalVotes: 0, totalUniqueVoters: 0 }, // Admin dashboard statistics
            adminDashboardLoading: false, // Loading state for admin dashboard modal
            showFilters: false, // Toggle for search/sort/filter section
            filters: {
                createdBy: null,           // Username or null
                sortBy: 'newest',          // 'newest', 'oldest', 'mostVoted', 'leastVoted', etc.
                searchQuery: ''            // Search term for contest titles
            },
            mergedResults: null, // Results from merged contests
            mergers: [], // Array of merger objects from database
            extracts: [], // Array of extract objects from database
            groups: [], // Array of group objects from database
            showCreateMergerModal: false, // Show create merger modal
            showCreateExtractModal: false, // Show create extract modal
            showManageFoldersModal: false, // Show manage folders modal
            newMergerName: '', // Name for new merger being created
            newExtractName: '', // Name for new extract being created
            extractSourceType: null, // 'contest' or 'merger'
            extractSourceId: null, // ID of source contest/merger
            isInitializing: false, // Flag to prevent rendering during initialization
            extractSelectedImages: [], // Array of image IDs selected for extract
            selectedFolderId: null, // Currently selected folder for viewing
            expandedFolderIds: [], // Array of folder IDs that are expanded
            appSettings: {}, // Global app settings (contest creation enabled, revoting enabled)
            view: 'home',
            viewingUserId: null, // User ID being viewed in profile
            showUserProfileModal: false, // Show user profile modal
            toast: null, // Toast notification { message, icon }
            isLoading: false,
            loadingMessage: '',
            showUserDropdown: false,  // User menu dropdown state
            showMergedContestsDropdown: false,  // Merged contests dropdown state
            currentMergerId: null,  // ID of current merger being voted on
            mergerContestIds: [],  // Array of contest IDs in current merger voting session
            selectedFolderItems: [],  // Array of indices for multi-select in Add Item modal
            votingMode: 'multi',  // 'single' or 'multi' - voting view mode (default: multi)
            selectedScore: null,  // Currently selected score in multi-mode voting (1-5 or null)
            multiVotingImageScale: 100,  // Image scale for multi-mode voting (20-200%)
            multiModeFilter: [],  // Filter for multi-mode voting: array of scores (1-5) or 'non-voted'
            multiModeSort: 'default',  // Sort for multi-mode voting: 'default', 'highest', 'lowest'
            showUnifiedCreateModal: false,  // Show unified creation modal
            extractImageScale: 100,  // Image scale for extract image selection pages (100-400%)
            pinnedItems: [],  // Array of pinned items from database
            isPinnedSectionExpanded: false,  // Whether pinned section is expanded (default: folded)
            isCompleteVotingExpanded: false,  // Whether Complete Voting section is expanded (default: folded, show 1 item)
            showPinIcons: false,  // Whether to show pin icons (admin only, default: false)
            isAllContestsSectionExpanded: true,  // Whether All Contests section is expanded (default: expanded)
            lastClickedImageId: null,  // Last clicked image ID in multi-mode voting
            isLoadingMultiModeImages: false,  // Whether images are loading in multi mode
            isTransitioningVotingMode: false,  // Whether voting mode is transitioning (brief modal)
            multiModeLoadedImages: 0,  // Number of images loaded in multi mode
            multiModeTotalImages: 0,  // Total images to load in multi mode
            showLogoutConfirmModal: false,  // Show logout confirmation modal
            darkTheme: false,  // Dark theme enabled
            themeToggling: false,  // Prevent theme toggle spam
            pendingRoute: null,  // Store route to redirect after login (e.g., '#contest=uuid')
            // Results tab enhancements
            collapsedSections: {},  // { sectionKey: true } for collapsed sections (persists across tab switches)
            userFilterSelectedUsers: null,  // null = all users selected, Set of userIds when filtered
            userFilterDropdownOpen: false,  // Whether user filter dropdown is open
            countMode: 'images',  // 'images' or 'users' for Count tab toggle
            comparisonView: null,  // null, 'table', or 'detail' for By User comparison
            comparisonDetailUserId: null,  // User whose detail comparison is being viewed
            comparisonDetailView: 'match',  // 'match' or 'relative' toggle in comparison detail
            comparisonDetailCollapsed: {},  // Collapsed state for comparison detail categories
            comparisonTableView: 'match',  // 'match' or 'relative' for comparison table columns
            comparisonAvgView: 'match',  // 'match' or 'relative' for contest average comparison
            imageFilterSelectedImages: null,  // null = all, Set of imageIds when filtered
            imageFilterDropdownOpen: false,  // Whether image filter dropdown is open
            comparisonTableSortKeys: [],  // Array of {key, direction} for multi-sort
            averageTabCompareAll: false,  // Whether "Compare with all" mode is active on Average tab
            averageTabCompareUserId: null,  // User selected for contest average comparison in Average tab
            userAutosavedVotes: {},  // Autosaved votes keyed by context: { 'contest_UUID': {imageId: score}, 'merger_UUID': {...} }
            autosaveContext: { type: null, id: null },  // Current voting context for auto-save ('contest' or 'merger')
            isAutoSaving: false,  // Whether auto-save is in progress
            lastAutoSaveTime: null,  // Timestamp of last successful auto-save
            pendingDraftContext: null,  // Pending draft context for resume/discard confirmation modals
            isAutosaveDraftExpanded: false  // Whether "Continue Drafts" section is expanded (default: folded)
        };

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function formatVoterCount(voterCount, voterCountMin, voterCountMax) {
            if (voterCountMin !== undefined && voterCountMax !== undefined && voterCountMin !== voterCountMax) {
                return `${voterCountMin}-${voterCountMax}`;
            }
            return voterCount;
        }

        function setLoading(message) {
            state.isLoading = true;
            state.loadingMessage = message;
            render();
        }

        function clearLoading() {
            state.isLoading = false;
            state.loadingMessage = '';
            render();
        }

        // ==================== HELPER FUNCTIONS ====================

        // Generic Supabase fetch with cache-busting headers
        async function fetchFromSupabase(endpoint, options = {}) {
            const defaultHeaders = {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                'Pragma': 'no-cache',
                'Expires': '0'
            };

            return fetch(`${SUPABASE_URL}${endpoint}`, {
                ...options,
                headers: { ...defaultHeaders, ...options.headers }
            });
        }

        // Format date as "day month year" (e.g., "30 Nov 2025")
        function formatDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
        }

        // Safely stringify JSON for HTML attributes
        function safeStringify(obj) {
            return JSON.stringify(obj).replace(/'/g, "&apos;");
        }

        // ==================== TOAST NOTIFICATIONS ====================

        /**
         * Show toast notification (lightweight, non-disruptive)
         * Used for user actions (ban/unban, vote submission, etc.)
         * @param {string} message - Message to display
         * @param {string} type - 'info', 'success', 'error', or 'warning'
         * @param {number} duration - Display duration in ms (default 3000)
         */
        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            const bgColors = {
                info: 'bg-blue-500',
                success: 'bg-green-500',
                error: 'bg-red-500',
                warning: 'bg-yellow-500'
            };

            toast.className = `fixed top-20 right-4 z-50 px-4 py-3 rounded-lg shadow-lg text-white text-sm font-medium transition-all transform translate-x-0 ${bgColors[type] || 'bg-gray-700'}`;
            toast.textContent = message;
            toast.style.animation = 'slideInRight 0.3s ease-out';

            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // ==================== END TOAST NOTIFICATIONS ====================

        function getScoreColor(score) {
            const colors = {
                1: 'rgb(220, 38, 38)',
                2: 'rgb(249, 115, 22)',
                3: 'rgb(234, 179, 8)',
                4: 'rgb(132, 204, 22)',
                5: 'rgb(34, 197, 94)'
            };
            return colors[score] || 'rgb(156, 163, 175)';
        }

        function getCategoryLabel(min, max, isMissing) {
            if (isMissing) return 'Votes Missing';
            if (min === 4.5) return '4.5 - 5.0';
            return `${min.toFixed(1)} - ${max.toFixed(2)}`;
        }

        function getCategoryColor(min, isMissing) {
            // Special styling for missing votes - black text on dark gray background
            if (isMissing) return { color: 'text-black', bg: 'bg-gray-400', textColor: 'rgb(0, 0, 0)', bgColor: 'rgb(156, 163, 175)' };

            // Strong blue (4.5-5.0) - highest scores
            if (min >= 4.5) return { color: 'text-blue-900', bg: 'bg-blue-100', textColor: 'rgb(30, 58, 138)', bgColor: 'rgb(219, 234, 254)' };
            // Saturated cyan (4.0-4.49) - very good scores
            if (min >= 4.0) return { color: 'text-cyan-700', bg: 'bg-cyan-100', textColor: 'rgb(14, 116, 144)', bgColor: 'rgb(207, 250, 254)' };
            // Bright green (3.5-3.99) - good scores
            if (min >= 3.5) return { color: 'text-green-700', bg: 'bg-green-100', textColor: 'rgb(21, 128, 61)', bgColor: 'rgb(220, 252, 231)' };
            // Lime-green (3.0-3.49) - above average, MUST be green
            if (min >= 3.0) return { color: 'text-lime-700', bg: 'bg-lime-100', textColor: 'rgb(77, 124, 15)', bgColor: 'rgb(236, 252, 203)' };
            // Pale yellow (2.5-2.99) - average
            if (min >= 2.5) return { color: 'text-yellow-800', bg: 'bg-yellow-100', textColor: 'rgb(113, 63, 18)', bgColor: 'rgb(253, 224, 71)' };
            // Pale orange (2.0-2.49) - below average
            if (min >= 2.0) return { color: 'text-orange-800', bg: 'bg-orange-100', textColor: 'rgb(154, 52, 18)', bgColor: 'rgb(253, 186, 116)' };
            // Pale red (1.5-1.99) - low scores
            if (min >= 1.5) return { color: 'text-red-800', bg: 'bg-red-100', textColor: 'rgb(153, 27, 27)', bgColor: 'rgb(252, 165, 165)' };
            // Pale purple (1.0-1.49) - lowest scores
            if (min >= 1.0) return { color: 'text-purple-800', bg: 'bg-purple-200', textColor: 'rgb(107, 33, 168)', bgColor: 'rgb(216, 180, 254)' };
            // Fallback for any edge cases
            return { color: 'text-gray-600', bg: 'bg-gray-50', textColor: 'rgb(75, 85, 99)', bgColor: 'rgb(249, 250, 251)' };
        }


        async function loadResults() {
            setLoading('Loading results...');
            try {
                console.log('üîç DEBUG: Loading results for contest:', state.currentContest.id);
                console.log('üîç DEBUG: Current user:', state.user);

                let allVotes = [];
                const isExtract = state.currentContest.isExtract === true;

                if (isExtract) {
                    // For extracts, query votes from source contest(s) with pagination
                    const extractImageIds = state.currentContest.extractImageIds || [];

                    if (state.currentContest.extractSourceType === 'contest') {
                        // Query votes from source contest with pagination, filtering by extract image IDs
                        const contestId = state.currentContest.extractSourceContestId;
                        const votes = await fetchAllVotesPaginated(
                            `contest_id=eq.${contestId}`,
                            '*,voter:users!votes_user_id_fkey(username,avatar,is_banned)'
                        );
                        allVotes = Array.isArray(votes) ? votes.filter(v => extractImageIds.includes(v.image_id)) : [];
                    } else if (state.currentContest.extractSourceType === 'merger') {
                        // Query votes from all merged contests with pagination, filtering by extract image IDs
                        const mergerId = state.currentContest.extractSourceMergerId;
                        const merger = state.mergers.find(m => m.id === mergerId);
                        if (merger && merger.contestIds) {
                            const votesPromises = merger.contestIds.map(contestId =>
                                fetchAllVotesPaginated(
                                    `contest_id=eq.${contestId}`,
                                    '*,voter:users!votes_user_id_fkey(username,avatar,is_banned)'
                                )
                            );
                            const votesArrays = await Promise.all(votesPromises);
                            const combinedVotes = votesArrays.flat();
                            allVotes = combinedVotes.filter(v => extractImageIds.includes(v.image_id));
                        }
                    }
                } else {
                    // Regular contest - query votes with pagination
                    allVotes = await fetchAllVotesPaginated(
                        `contest_id=eq.${state.currentContest.id}`,
                        '*,voter:users!votes_user_id_fkey(username,avatar,is_banned)'
                    );
                }

                console.log('üîç DEBUG: Fetched votes:', allVotes);

                // Check if votes response is valid
                if (!Array.isArray(allVotes)) {
                    console.error('Invalid votes response:', allVotes);
                    showAlert('Error loading votes: ' + (allVotes.message || 'Invalid response'), '‚ùå');
                    return;
                }

                console.log('üîç DEBUG: Number of votes:', allVotes.length);

                // Warn if we hit the vote limit
                if (allVotes.length === 2000) {
                    console.warn('‚ö†Ô∏è Hit vote limit of 2000 - may be missing votes');
                }

                // Build list of unique voters for dropdown (exclude banned users)
                const votersMap = new Map();
                allVotes.forEach(vote => {
                    const voterIsBanned = vote.voter?.is_banned || false;
                    if (!votersMap.has(vote.user_id) && !voterIsBanned) {
                        votersMap.set(vote.user_id, {
                            userId: vote.user_id,
                            username: vote.voter.username,
                            avatar: vote.voter.avatar
                        });
                    }
                });
                state.contestVoters = Array.from(votersMap.values()).sort((a, b) =>
                    a.username.localeCompare(b.username)
                );

                const imageScores = {};
                allVotes.forEach(vote => {
                    console.log('üîç DEBUG: Processing vote:', vote);
                    if (!imageScores[vote.image_id]) {
                        imageScores[vote.image_id] = {
                            scores: [],
                            breakdown: []
                        };
                    }

                    const isBlocked = vote.is_blocked || false;
                    const voterIsBanned = vote.voter?.is_banned || false;

                    // Only include non-blocked AND non-banned votes in score calculations
                    if (!isBlocked && !voterIsBanned) {
                        imageScores[vote.image_id].scores.push(vote.score);
                    }

                    // Include ALL votes in breakdown (blocked, banned, and non-blocked)
                    imageScores[vote.image_id].breakdown.push({
                        userId: vote.user_id,
                        username: vote.voter.username,
                        avatar: vote.voter.avatar,
                        score: vote.score,
                        isCurrentUser: vote.user_id === state.user?.id,
                        isBlocked: isBlocked,
                        isBanned: voterIsBanned
                    });
                });

                console.log('üîç DEBUG: Image scores:', imageScores);
                console.log('üîç DEBUG: Contest images:', state.currentContest.images);

                // Map images with their scores
                state.results = state.currentContest.images.map(img => {
                    const scores = imageScores[img.id]?.scores || [];
                    const sum = scores.reduce((acc, s) => acc + s, 0);
                    const average = scores.length > 0 ? parseFloat((sum / scores.length).toFixed(2)) : 0;

                    console.log(`üîç DEBUG: Image ${img.id} - scores:`, scores, 'average:', average);

                    return {
                        ...img,
                        averageScore: average,
                        totalVotes: scores.length,
                        breakdown: imageScores[img.id]?.breakdown || []
                    };
                }).sort(compareWithTieBreaking);

                console.log('üîç DEBUG: Final results:', state.results);
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        async function loadMergedResults(contestIds) {
            setLoading('Loading merged results...');
            try {
                // Fetch contests with their images
                const contestsResponse = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=in.(${contestIds.join(',')})&select=*,images(*)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const contests = await contestsResponse.json();

                // Fetch ALL votes for these contests using pagination
                const allVotes = await fetchAllVotesPaginated(`contest_id=in.(${contestIds.join(',')})`, '*,voter:users!votes_user_id_fkey(username,avatar,is_banned)');

                // Build image scores from votes
                const imageScores = {};
                allVotes.forEach(vote => {
                    if (!imageScores[vote.image_id]) {
                        imageScores[vote.image_id] = {
                            scores: [],
                            breakdown: [],
                            userVotes: new Map() // Track votes by (userId, contestId) to prevent duplicates within same contest
                        };
                    }

                    const isBlocked = vote.is_blocked || false;
                    const voterIsBanned = vote.voter?.is_banned || false;
                    const userId = vote.user_id;
                    const contestId = vote.contest_id;

                    // Create unique key combining userId and contestId
                    // This allows same user to vote on same image in different contests
                    const voteKey = `${userId}_${contestId}`;

                    // Check if we already have a vote from this user for this image in this contest
                    if (imageScores[vote.image_id].userVotes.has(voteKey)) {
                        // Skip true duplicate vote (same user, same image, same contest)
                        return;
                    }

                    // Mark this user as having voted in this contest
                    imageScores[vote.image_id].userVotes.set(voteKey, true);

                    // Only include non-blocked AND non-banned votes in score calculations
                    if (!isBlocked && !voterIsBanned) {
                        imageScores[vote.image_id].scores.push(vote.score);
                    }

                    // Include ALL votes in breakdown (now deduplicated)
                    imageScores[vote.image_id].breakdown.push({
                        userId: userId,
                        username: vote.voter.username,
                        avatar: vote.voter.avatar,
                        score: vote.score,
                        isCurrentUser: userId === state.user?.id,
                        isBlocked: isBlocked,
                        isBanned: voterIsBanned
                    });
                });

                // Collect all images from all contests
                const allImages = [];
                const contestTitles = {};

                contests.forEach(contest => {
                    contestTitles[contest.id] = contest.title;
                    contest.images.forEach(img => {
                        const scores = imageScores[img.id]?.scores || [];
                        const sum = scores.reduce((acc, s) => acc + s, 0);
                        const average = scores.length > 0 ? parseFloat((sum / scores.length).toFixed(2)) : 0;

                        allImages.push({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            contestId: contest.id,
                            contestTitle: contest.title,
                            averageScore: average,
                            totalVotes: scores.length,
                            voteBreakdown: imageScores[img.id]?.breakdown || []
                        });
                    });
                });

                // Set merged results
                state.mergedResults = {
                    contestIds: contestIds,
                    contestTitles: contestTitles,
                    images: allImages.sort(compareWithTieBreaking)
                };

                // Build contestVoters from merged breakdown data for comparison features
                const mergedVoterMap = new Map();
                allImages.forEach(img => {
                    (img.voteBreakdown || []).forEach(vote => {
                        if (!vote.isBlocked && !vote.isBanned && !mergedVoterMap.has(vote.userId)) {
                            mergedVoterMap.set(vote.userId, {
                                userId: vote.userId,
                                username: vote.username,
                                avatar: vote.avatar
                            });
                        }
                    });
                });
                state.contestVoters = Array.from(mergedVoterMap.values()).sort((a, b) =>
                    a.username.toLowerCase().localeCompare(b.username.toLowerCase())
                );

            } catch (error) {
                console.error('Error loading merged results:', error);
                showAlert('Error loading merged results: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        // Temporary stub for merge functionality - returns empty results
        // TODO: Implement proper async merge functionality with database queries
        // Tie-breaking logic: when scores are equal, count 5s, 4s, 3s, 2s, 1s
        function compareWithTieBreaking(a, b) {
            // First, compare by average score
            const scoreDiff = b.averageScore - a.averageScore;
            if (Math.abs(scoreDiff) > 0.001) return scoreDiff; // Not a tie

            // Tie detected - count votes by score level
            const getVoteCounts = (item) => {
                const counts = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
                if (item.breakdown && Array.isArray(item.breakdown)) {
                    item.breakdown.forEach(vote => {
                        if (!vote.isBlocked && counts[vote.score] !== undefined) {
                            counts[vote.score]++;
                        }
                    });
                }
                return counts;
            };

            const countsA = getVoteCounts(a);
            const countsB = getVoteCounts(b);

            // Compare 5s, then 4s, then 3s, etc.
            for (let score = 5; score >= 1; score--) {
                if (countsB[score] !== countsA[score]) {
                    return countsB[score] - countsA[score];
                }
            }

            // If still equal, use total vote count
            const totalA = a.breakdown?.filter(v => !v.isBlocked).length || 0;
            const totalB = b.breakdown?.filter(v => !v.isBlocked).length || 0;
            if (totalB !== totalA) return totalB - totalA;

            // If still equal, maintain original order
            return 0;
        }

        function groupByScoreRange(results) {
            const ranges = [
                { min: 4.5, max: 5.0 },
                { min: 4.0, max: 4.49 },
                { min: 3.5, max: 3.99 },
                { min: 3.0, max: 3.49 },
                { min: 2.5, max: 2.99 },
                { min: 2.0, max: 2.49 },
                { min: 1.5, max: 1.99 },
                { min: 1.0, max: 1.49 }
            ];

            const grouped = {};

            // Check for images with missing votes (averageScore === 0 or null)
            const missingVotes = results.filter(r => !r.averageScore || r.averageScore === 0);
            if (missingVotes.length > 0) {
                grouped['missing'] = {
                    items: missingVotes,
                    min: 0,
                    max: 0,
                    isMissing: true
                };
            }

            // Group images by score ranges (only those with actual votes)
            ranges.forEach(range => {
                const key = `${range.min}-${range.max}`;
                const items = results.filter(r => r.averageScore > 0 && r.averageScore >= range.min && r.averageScore <= range.max);
                if (items.length > 0) {
                    grouped[key] = {
                        items: items.sort(compareWithTieBreaking),
                        min: range.min,
                        max: range.max
                    };
                }
            });

            return grouped;
        }

        function groupMyVotesByScore(results) {
            const grouped = {};

            [5, 4, 3, 2, 1].forEach(score => {
                const items = results.filter(r => r.averageScore === score);
                if (items.length > 0) {
                    grouped[score] = {
                        items: items,
                        score: score
                    };
                }
            });

            return grouped;
        }

        /**
         * Generate voter statistics from loaded results
         * Calculates each voter's average score across all images they voted on
         * Uses only data from state.results (already loaded from database)
         *
         * @returns {Array} Array of voter objects with calculated averages, sorted by average score (highest first)
         */
        function generateVoterStats() {
            if (!state.results) return [];

            // Accumulator for voter data
            // Structure: { userId: { votes: [], totalScore: 0, totalImages: 0, username, avatar, etc. } }
            const voterVotes = {};

            // Collect votes from all images in loaded results
            state.results.forEach(imageResult => {
                if (!imageResult.breakdown) return;

                imageResult.breakdown.forEach(vote => {
                    // Skip blocked and banned votes
                    if (vote.isBlocked || vote.isBanned) return;

                    if (!voterVotes[vote.userId]) {
                        voterVotes[vote.userId] = {
                            userId: vote.userId,
                            username: vote.username,
                            avatar: vote.avatar,
                            isCurrentUser: vote.isCurrentUser || false,
                            votes: [],
                            totalScore: 0,
                            totalImages: 0
                        };
                    }

                    voterVotes[vote.userId].votes.push(vote.score);
                    voterVotes[vote.userId].totalScore += vote.score;
                    voterVotes[vote.userId].totalImages++;
                });
            });

            // Calculate averages and sort based on state.voterSortBy
            const voters = Object.values(voterVotes)
                .map(voter => ({
                    ...voter,
                    averageScore: voter.totalImages > 0
                        ? parseFloat((voter.totalScore / voter.totalImages).toFixed(2))
                        : 0
                }));

            // Apply sorting based on state.voterSortBy
            switch (state.voterSortBy) {
                case 'scoreAsc':
                    return voters.sort((a, b) => a.averageScore - b.averageScore);
                case 'nameAsc':
                    return voters.sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
                case 'nameDesc':
                    return voters.sort((a, b) => b.username.toLowerCase().localeCompare(a.username.toLowerCase()));
                case 'scoreDesc':
                default:
                    return voters.sort((a, b) => b.averageScore - a.averageScore);
            }
        }

        function showModal(config) {
            if (state.modalProcessing) return;
            state.modal = config;
            document.body.classList.add('modal-open');
            render();
        }

        function closeModal() {
            if (state.modalProcessing) return;
            state.modal = null;
            state.modalProcessing = false;
            document.body.classList.remove('modal-open');
            render();
        }

        function showAlert(message, icon = 'üö®') {
            showModal({
                type: 'alert',
                icon,
                message,
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showContestCreationDisabledModal() {
            showModal({
                type: 'alert',
                icon: 'üîí',
                message: 'Contest creation is temporarily disabled. Contact admin for more information.',
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showRevotingDisabledModal() {
            showModal({
                type: 'alert',
                icon: 'üîí',
                message: 'Revoting is temporarily disabled. Contact admin for more information.',
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showConfirm(message, onConfirmName, icon = 'üö®') {
            showModal({
                type: 'confirm',
                icon,
                message,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Confirm', action: onConfirmName, primary: true }
                ]
            });
        }

        function showToast(message, icon = '‚úÖ') {
            state.toast = { message, icon };
            render();

            // Auto-dismiss after 5 seconds for better visibility
            setTimeout(() => {
                const toastEl = document.querySelector('.toast-notification');
                if (toastEl) {
                    toastEl.classList.add('fade-out');
                }
                setTimeout(() => {
                    state.toast = null;
                    render();
                }, 300);
            }, 5000);
        }

        function showInputModal(title, placeholder, onConfirmAction, allowEmpty = false) {
            showModal({
                type: 'input',
                icon: '‚úèÔ∏è',
                title,
                placeholder,
                allowEmpty,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Continue', action: onConfirmAction, primary: true }
                ]
            });
        }

        // Helper function to recalculate voter count ranges for an item (contest, merger, or extract)
        async function recalculateVoterCounts(itemType, itemId, imageIds, sourceContestIds) {
            try {
                // Fetch all votes for the specified images
                const votesResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/votes?contest_id=in.(${sourceContestIds.join(',')})&image_id=in.(${imageIds.join(',')})&is_blocked=eq.false&select=user_id,image_id`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                if (!votesResponse.ok) {
                    console.error('Failed to fetch votes for voter count calculation');
                    return;
                }

                const votes = await votesResponse.json();

                // Group votes by user
                const votesByUser = {};
                votes.forEach(vote => {
                    if (!votesByUser[vote.user_id]) {
                        votesByUser[vote.user_id] = new Set();
                    }
                    votesByUser[vote.user_id].add(vote.image_id);
                });

                // Count how many images each user has voted on
                const voterCounts = Object.keys(votesByUser).map(userId => {
                    const userVotedImages = votesByUser[userId];
                    // Count only images in the specified imageIds array
                    const votedInSet = imageIds.filter(imgId => userVotedImages.has(imgId)).length;
                    return votedInSet === imageIds.length ? userId : null;
                }).filter(userId => userId !== null);

                // Voter count calculation complete (no longer storing in database)
            } catch (error) {
                console.error(`Error recalculating voter counts for ${itemType} ${itemId}:`, error);
            }
        }

        async function confirmSubmitVotes() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            render(); // Close modal immediately before async work

            setLoading('Submitting votes...');

            // Timeout fallback: force clear loading and show error if submission takes >10 seconds
            const timeoutId = setTimeout(() => {
                if (state.isLoading) {
                    clearLoading();
                    showAlert('Vote submission timed out. Please try again.', '‚ùå');
                    state.modalProcessing = false;
                    render();
                }
            }, 10000);

            // Check if we're in merger voting mode
            const isMergerVoting = state.currentMergerId && state.mergerContestIds.length > 0;

            const votesToSubmit = [];
            state.shuffledImages.forEach(img => {
                if (state.votes[img.id]) {
                    // Find which contest this image belongs to
                    let contestId;
                    if (isMergerVoting) {
                        // In merger mode, find the original contest for each image
                        const contest = state.contests.find(c =>
                            state.mergerContestIds.includes(c.id) &&
                            c.images.some(i => i.id === img.id)
                        );
                        contestId = contest ? contest.id : state.mergerContestIds[0];
                    } else if (state.currentContest.isExtract) {
                        // For extract voting, find the source contest for each image
                        if (state.currentContest.extractSourceType === 'contest') {
                            contestId = state.currentContest.extractSourceContestId;
                        } else if (state.currentContest.extractSourceType === 'merger') {
                            // For merger-based extracts, find which contest the image belongs to
                            const merger = state.mergers.find(m => m.id === state.currentContest.extractSourceMergerId);
                            if (merger) {
                                const contest = state.contests.find(c =>
                                    merger.contestIds.includes(c.id) &&
                                    c.images.some(i => i.id === img.id)
                                );
                                contestId = contest ? contest.id : merger.contestIds[0];
                            }
                        }
                    } else {
                        contestId = state.currentContest.id;
                    }

                    votesToSubmit.push({
                        user_id: state.user.id,
                        image_id: img.id,
                        contest_id: contestId,
                        score: state.votes[img.id]
                    });
                }
            });

            try {
                // Group votes by contest for checking existing votes
                const votesByContest = {};
                votesToSubmit.forEach(vote => {
                    if (!votesByContest[vote.contest_id]) {
                        votesByContest[vote.contest_id] = [];
                    }
                    votesByContest[vote.contest_id].push(vote);
                });

                // Process votes for each contest
                for (const contestId of Object.keys(votesByContest)) {
                    const contestVotes = votesByContest[contestId];

                    // Check if votes already exist for this user and contest
                    const existingVotesResponse = await fetch(
                        `${SUPABASE_URL}/rest/v1/votes?user_id=eq.${state.user.id}&contest_id=eq.${contestId}&select=*`,
                        {
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Cache-Control': 'no-cache'
                            }
                        }
                    );

                    if (!existingVotesResponse.ok) {
                        throw new Error('Failed to check existing votes');
                    }

                    const existingVotes = await existingVotesResponse.json();

                    // Separate votes into updates and inserts
                    const votesToUpdate = [];
                    const votesToInsert = [];

                    contestVotes.forEach(vote => {
                        const existingVote = existingVotes.find(ev => ev.image_id === vote.image_id);
                        if (existingVote) {
                            votesToUpdate.push(vote);
                        } else {
                            votesToInsert.push(vote);
                        }
                    });

                    // Update existing votes
                    if (votesToUpdate.length > 0) {
                        const updatePromises = votesToUpdate.map(async (vote) => {
                            const response = await fetch(
                                `${SUPABASE_URL}/rest/v1/votes?user_id=eq.${vote.user_id}&contest_id=eq.${vote.contest_id}&image_id=eq.${vote.image_id}`,
                                {
                                    method: 'PATCH',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'apikey': SUPABASE_ANON_KEY,
                                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                        'Prefer': 'return=minimal',
                                        'Cache-Control': 'no-cache'
                                    },
                                    body: JSON.stringify({ score: vote.score })
                                }
                            );

                            if (!response.ok) {
                                throw new Error(`Failed to update vote for image ${vote.image_id}`);
                            }
                        });

                        await Promise.all(updatePromises);
                    }

                    // Insert new votes
                    if (votesToInsert.length > 0) {
                        const response = await fetch(`${SUPABASE_URL}/rest/v1/votes`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Prefer': 'return=minimal',
                                'Cache-Control': 'no-cache'
                            },
                            body: JSON.stringify(votesToInsert)
                        });

                        if (!response.ok) {
                            throw new Error('Failed to insert new votes');
                        }
                    }
                }

                // Reload user votes to reflect new submissions
                await loadUserVotes();
                await loadAllUserAutosaves();
                state.hasSubmitted = true;

                // Delete autosaves for this context now that votes are submitted
                clearTimeout(autoSaveTimer);
                if (state.autosaveContext.type && state.autosaveContext.id) {
                    await deleteAutosaves(state.autosaveContext.type, state.autosaveContext.id);
                    state.autosaveContext = { type: null, id: null };
                }

                // Update voter counts BEFORE loading results to ensure fresh data
                // Check if we're voting on an extract (only if not in merger mode)
                const isExtractVoting = !isMergerVoting && state.currentContest && state.currentContest.isExtract === true;

                if (isExtractVoting) {
                    // Extract voting - update both extract and source voter counts
                    const extractId = state.currentContest.id;
                    const extract = state.extracts.find(e => e.id === extractId);

                    if (extract) {
                        // Get source contest IDs
                        let sourceContestIds = [];
                        if (extract.sourceType === 'contest') {
                            sourceContestIds = [extract.sourceContestId];
                        } else if (extract.sourceType === 'merger') {
                            const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                            if (merger) {
                                sourceContestIds = merger.contestIds;
                            }
                        }

                        // Update extract voter counts based on its specific images
                        await recalculateVoterCounts('extract', extractId, extract.imageIds, sourceContestIds);

                        // Update source contest/merger voter counts based on ALL their images
                        if (extract.sourceType === 'contest') {
                            const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                            if (sourceContest) {
                                const allImageIds = sourceContest.images.map(img => img.id);
                                await recalculateVoterCounts('contest', extract.sourceContestId, allImageIds, [extract.sourceContestId]);
                            }
                        } else if (extract.sourceType === 'merger') {
                            const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                            if (merger) {
                                const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                                const allImageIds = mergedContests.flatMap(c => c.images.map(img => img.id));
                                await recalculateVoterCounts('merger', extract.sourceMergerId, allImageIds, merger.contestIds);
                            }
                        }

                        // Reload extracts to get updated voter counts
                        await loadExtracts();
                    }
                } else if (isMergerVoting) {
                    // Merger voting - update merger and source contest voter counts
                    const merger = state.mergers.find(m => m.id === state.currentMergerId);
                    if (merger) {
                        const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                        const allImageIds = mergedContests.flatMap(c => c.images.map(img => img.id));

                        // Update merger voter counts
                        await recalculateVoterCounts('merger', state.currentMergerId, allImageIds, merger.contestIds);

                        // Update each source contest
                        for (const contestId of merger.contestIds) {
                            const contest = state.contests.find(c => c.id === contestId);
                            if (contest) {
                                const contestImageIds = contest.images.map(img => img.id);
                                await recalculateVoterCounts('contest', contestId, contestImageIds, [contestId]);
                            }
                        }

                        // Reload mergers to get updated voter counts
                        await loadMergers();
                    }
                } else {
                    // Regular contest voting - update contest voter counts
                    const contest = state.contests.find(c => c.id === state.currentContest.id);
                    if (contest) {
                        const contestImageIds = contest.images.map(img => img.id);
                        await recalculateVoterCounts('contest', state.currentContest.id, contestImageIds, [state.currentContest.id]);
                    }
                }

                // Navigate to appropriate results view
                if (isMergerVoting) {
                    // Load merged results and display
                    const merger = state.mergers.find(m => m.id === state.currentMergerId);
                    if (merger) {
                        await loadMergedResults(merger.contestIds);
                        state.view = 'mergedResults';
                        state.resultsView = 'average';
                        state.showMyVotes = false;

                        // Update URL hash
                        window.location.hash = `merger=${state.currentMergerId}`;
                    } else {
                        // Merger not found - reload mergers and show menu
                        await loadMergers();
                        state.view = 'menu';
                        showToast('Merger results loaded successfully', 'success');
                    }
                } else {
                    // Refresh contest list to update voter counts FIRST
                    await loadContests();

                    // Switch to single contest results view
                    // If this was partial voting, load results for the original full contest
                    if (state.currentContest.isPartialVoting && state.currentContest.originalContestId) {
                        const originalContest = state.contests.find(c => c.id === state.currentContest.originalContestId);
                        if (originalContest) {
                            state.currentContest = originalContest;
                        }
                    }

                    // Load results BEFORE changing view (to match merger flow that works)
                    await loadResults();
                    state.view = 'results';

                    // Update URL hash
                    window.location.hash = `contest=${state.currentContest.id}`;
                }

                // Refresh contest list one more time if it was merger voting
                if (isMergerVoting) {
                    await loadContests();
                }

                // Clear processing state and clear loading before final render
                state.modalProcessing = false;
                clearTimeout(timeoutId);
                clearLoading();

                // Final render to show results view
                render();
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);

                // Ensure loading is cleared and modal processing is reset
                clearTimeout(timeoutId);
                clearLoading();
                state.modalProcessing = false;

                // Show error to user
                showAlert('Failed to submit votes: ' + error.message, '‚ùå');
                render();
            }
        }

        function confirmCancelVoting() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            // Cancel pending auto-save timer but keep autosaves in DB for later resume
            clearTimeout(autoSaveTimer);
            state.autosaveContext = { type: null, id: null };
            state.view = 'home';
            state.currentContest = null;
            state.modalProcessing = false;
            render();
        }

        function canDeleteContest(contest) {
            if (!state.user) return false;

            // Check if user is contest creator
            if (contest.createdBy === state.user.id) return true;

            // Admin check
            return state.user.id === ADMIN_DISCORD_ID;
        }

        function deleteContest(contestId) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) return;

            // Store contest info for validation
            state.contestToDelete = contest;

            showInputModal(
                `Type "${contest.title}" to confirm deletion`,
                'Enter contest title exactly...',
                'handleDeleteContestConfirmation',
                false
            );
        }

        function handleDeleteContestConfirmation() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const enteredTitle = input ? input.value.trim() : '';

            if (!state.contestToDelete) {
                showAlert('Contest information not found.', '‚ùå');
                return;
            }

            if (enteredTitle !== state.contestToDelete.title) {
                showAlert('Title does not match. Deletion cancelled.', '‚ùå');
                return;
            }

            // Title matches, proceed with deletion
            confirmDeleteContest(state.contestToDelete.id);
        }

        async function confirmDeleteContest(contestId) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            setLoading('Deleting contest...');

            try {
                // First, fetch contest images to clean up storage
                const contest = state.contests.find(c => c.id === contestId);
                if (contest && contest.images) {
                    const filesToDelete = [];

                    for (const image of contest.images) {
                        // Only delete images that were uploaded to storage (not external URLs)
                        if (image.isFileUpload && image.url) {
                            // Extract file path from Supabase storage URL
                            // URL format: https://{project}.supabase.co/storage/v1/object/public/contest-images/{fileName}
                            const urlParts = image.url.split('/contest-images/');
                            if (urlParts.length === 2) {
                                filesToDelete.push(urlParts[1]);
                            }
                        }
                    }

                    // Delete files from storage if there are any
                    if (filesToDelete.length > 0) {
                        console.log('Deleting files from storage:', filesToDelete);
                        const { data, error } = await supabase.storage
                            .from('contest-images')
                            .remove(filesToDelete);

                        if (error) {
                            console.warn('Storage cleanup error:', error);
                            // Don't fail the entire deletion if storage cleanup fails
                        } else {
                            console.log('Successfully deleted files from storage:', data);
                        }
                    }
                }

                // Now delete the contest from database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete contest');
                }

                await loadContests();
                delete state.userVotedContests[contestId];
                state.modalProcessing = false;
                showAlert('Contest deleted successfully!', '‚úÖ');
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Failed to delete contest: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            } finally {
                clearLoading();
            }
        }

        function startCreateContest() {
            showInputModal('Contest Title', 'Enter contest title...', 'handleContestTitle', false);
        }

        function handleContestTitle() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const title = input ? input.value.trim() : '';

            if (!title || title.length === 0) {
                showAlert('Contest title cannot be empty.', '‚ùå');
                return;
            }
            if (title.length > 50) {
                showAlert('Contest title is too long (max 50 characters).', '‚ùå');
                return;
            }

            // Check for duplicate title - BLOCK creation entirely
            const existingContest = state.contests.find(c => c.title.toLowerCase() === title.toLowerCase());
            if (existingContest) {
                showAlert('A contest with this title already exists. Please choose a different title.', '‚ùå');
                return;
            }

            state.modalProcessing = true;
            state.newContest.title = title;
            state.newContest.images = [];
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.view = 'createContest';
            state.modalProcessing = false;
            render();
        }

        function confirmCreateWithDuplicateTitle() {
            state.modalProcessing = true;
            const title = state.tempContestTitle;
            state.tempContestTitle = null;
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.newContest.title = title;
            state.newContest.images = [];
            state.view = 'createContest';
            state.modalProcessing = false;
            render();
        }

        function cancelCreateContest() {
            showConfirm(
                'Your progress will be lost if you proceed. Are you sure?',
                'confirmCancelCreate',
                'üö®'
            );
        }

        function confirmCancelCreate() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URLs to free memory
            state.newContest.images.forEach(img => {
                if (img.isLocalFile && img.url.startsWith('blob:')) {
                    URL.revokeObjectURL(img.url);
                }
            });

            state.view = 'home';
            state.newContest = { title: '', images: [] };
            state.modalProcessing = false;
            render();
        }

        function openEditContestModal(contestId) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) {
                showToast('Contest not found', 'error');
                return;
            }

            // Set up editing mode
            state.editingContestId = contestId;
            state.newContest.title = contest.title;
            state.newContest.images = [...contest.images.map(img => ({...img, isExisting: true}))]; // Copy existing images and mark them
            state.view = 'createContest'; // Reuse the create contest view
            render();
        }

        function cancelEditContest() {
            showConfirm(
                'Your changes will be lost if you proceed. Are you sure?',
                'confirmCancelEdit',
                'üö®'
            );
        }

        function confirmCancelEdit() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URLs for newly added images
            state.newContest.images.forEach(img => {
                if (!img.isExisting && img.isLocalFile && img.url.startsWith('blob:')) {
                    URL.revokeObjectURL(img.url);
                }
            });

            state.view = 'home';
            state.newContest = { title: '', images: [] };
            state.editingContestId = null;
            state.modalProcessing = false;
            render();
        }

        async function addImageFromUrl(urlInputId) {
            const input = document.getElementById(urlInputId);
            let url = input.value.trim();

            if (!url) {
                showAlert('Please enter an image URL!', '‚ùå');
                return;
            }

            // Convert Discord CDN URLs to media.discordapp.net for compatibility
            url = url.replace(/cdn\.discordapp\.com/g, 'media.discordapp.net');
            url = url.replace(/images-ext-\d+\.discordapp\.net/g, 'media.discordapp.net');

            // Check for duplicate URL
            const isDuplicate = state.newContest.images.some(img => img.url === url);

            if (isDuplicate) {
                console.log('‚ö†Ô∏è Duplicate image URL detected:', url);
                state.tempDuplicateUrl = url;
                state.tempDuplicateUrlInputId = urlInputId;
                showConfirm(
                    '‚ö†Ô∏è This image URL already exists in the contest. Do you want to add it anyway?',
                    'confirmAddDuplicateImage',
                    '‚ö†Ô∏è'
                );
                return;
            }

            try {
                const img = await loadImageFromUrl(url);
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random(),
                    url,
                    author: null,
                    isFileUpload: false,
                    label: `${imageCount}`
                });
                input.value = '';
                showToast('Image added successfully!', '‚úÖ');
                render();
            } catch (error) {
                showAlert(`Failed to load image: ${error.message}`, '‚ùå');
            }
        }

        async function confirmAddDuplicateImage() {
            const url = state.tempDuplicateUrl;
            const urlInputId = state.tempDuplicateUrlInputId;

            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            if (!url) {
                state.modalProcessing = false;
                return;
            }

            console.log('‚úÖ User confirmed adding duplicate URL:', url);

            try {
                const img = await loadImageFromUrl(url);
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random(),
                    url,
                    author: null,
                    isFileUpload: false,
                    label: `${imageCount}`
                });

                const input = document.getElementById(urlInputId);
                if (input) {
                    input.value = '';
                }

                showToast('Duplicate image added!', '‚úÖ');
            } catch (error) {
                showAlert(`Failed to load image: ${error.message}`, '‚ùå');
            }

            state.tempDuplicateUrl = null;
            state.tempDuplicateUrlInputId = null;
            state.modalProcessing = false;
            render();
        }

        function clearUrlInput() {
            const input = document.getElementById('contestUrlInput');
            if (input) {
                input.value = '';
            }
        }

        // Format file size in human-readable format
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }


        async function handleFileSelect(fileInput) {
            const files = Array.from(fileInput.files);
            if (files.length === 0) return;

            const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            const maxSizeBytes = 1000 * 1024; // 1MB = 1000KB

            // Validate file types
            const invalidTypeFiles = files.filter(file => !validTypes.includes(file.type));
            if (invalidTypeFiles.length > 0) {
                showAlert(`${invalidTypeFiles.length} file(s) are not valid image types (JPG, PNG, GIF, or WebP)`, '‚ùå');
                fileInput.value = '';
                return;
            }

            // Check for files that exceed 1MB
            const oversizedFiles = files.filter(file => file.size > maxSizeBytes);
            if (oversizedFiles.length > 0) {
                const fileDetails = oversizedFiles.map(file =>
                    `${file.name} (${formatFileSize(file.size)})`
                ).join(', ');
                showAlert(`Image(s) too large: ${fileDetails}. Maximum size is 1MB.`, '‚ùå');
                fileInput.value = '';
                return;
            }

            fileInput.value = '';

            // Add images directly to contest
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const imageCount = state.newContest.images.length + 1;
                const previewUrl = URL.createObjectURL(file);

                const newImage = {
                    id: Date.now() + Math.random() + i,
                    url: previewUrl,
                    localFile: file,
                    isLocalFile: true,
                    author: null,
                    isFileUpload: true,
                    label: `${imageCount}`,
                    fileSize: file.size
                };

                state.newContest.images.push(newImage);
            }

            render();
            showToast(`${files.length} image${files.length > 1 ? 's' : ''} added to contest!`, '‚úÖ');
        }

        async function uploadImageFile(file, progressCallback) {
            // Always use .jpg extension for uploaded images
            const fileExt = 'jpg';

            // Generate unique filename
            const fileName = `contest-${Date.now()}-${Math.random().toString(36).substring(2, 9)}.${fileExt}`;

            // Simulate progress updates (Supabase doesn't provide native progress)
            let progressInterval;
            if (progressCallback) {
                let simulatedProgress = 10;
                progressInterval = setInterval(() => {
                    if (simulatedProgress < 90) {
                        simulatedProgress += 10;
                        progressCallback(simulatedProgress);
                    }
                }, 200);
            }

            try {
                // Upload to Supabase Storage
                const { data, error } = await supabase.storage
                    .from('contest-images')
                    .upload(fileName, file, {
                        cacheControl: '3600',
                        upsert: false
                    });

                if (progressInterval) clearInterval(progressInterval);

                if (error) {
                    console.error('Supabase storage error:', error);
                    throw new Error(error.message || 'Failed to upload image to storage');
                }

                if (progressCallback) progressCallback(95);

                // Get public URL
                const { data: urlData } = supabase.storage
                    .from('contest-images')
                    .getPublicUrl(fileName);

                if (!urlData || !urlData.publicUrl) {
                    throw new Error('Failed to get public URL for uploaded image');
                }

                if (progressCallback) progressCallback(100);

                return urlData.publicUrl;
            } catch (error) {
                if (progressInterval) clearInterval(progressInterval);
                console.error('Upload error:', error);
                throw error;
            }
        }

        async function uploadImageFileWithRetry(file, fileIndex, maxRetries = 3) {
            const updateProgress = (progress) => {
                if (state.uploadProgress && state.uploadProgress.files[fileIndex]) {
                    state.uploadProgress.files[fileIndex].progress = progress;
                    render();
                }
            };

            let lastError;
            const retryCount = state.uploadProgress?.files[fileIndex]?.retryCount || 0;

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    // Exponential backoff: wait before retry (0ms, 1s, 2s, 4s)
                    if (attempt > 0) {
                        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 4000);
                        console.log(`Retrying upload for ${file.name} after ${delay}ms (attempt ${attempt + 1}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        updateProgress(5);
                    }

                    const imageUrl = await uploadImageFile(file, updateProgress);
                    return imageUrl;
                } catch (error) {
                    lastError = error;
                    console.error(`Upload attempt ${attempt + 1} failed for ${file.name}:`, error);

                    // Don't retry on certain errors
                    const errorMsg = error.message || String(error);
                    if (errorMsg.includes('413') || errorMsg.includes('Payload Too Large') ||
                        errorMsg.includes('401') || errorMsg.includes('403')) {
                        throw error; // Don't retry auth or size errors
                    }

                    // Continue to next retry if available
                    if (attempt < maxRetries - 1) {
                        updateProgress(0);
                    }
                }
            }

            // All retries failed
            throw lastError || new Error('Upload failed after multiple attempts');
        }

        // Upload progress modal helper functions
        function closeUploadProgress() {
            // Add successfully uploaded images to the contest
            const successfulUploads = state.uploadProgress.files.filter(f => f.status === 'success' && f.imageUrl);
            successfulUploads.forEach((file, index) => {
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random() + index,
                    url: file.imageUrl,
                    author: null,
                    isFileUpload: true,
                    label: `${imageCount}`
                });
            });

            state.uploadProgress = null;
            render();

            if (successfulUploads.length > 0) {
                showToast(`${successfulUploads.length} image${successfulUploads.length > 1 ? 's' : ''} added to contest!`, '‚úÖ');
            }
        }

        async function retryUpload(fileIndex) {
            const fileData = state.uploadProgress.files[fileIndex];
            if (!fileData || !fileData.originalFile) return;

            // Reset file status
            fileData.status = 'pending';
            fileData.progress = 0;
            fileData.error = null;
            fileData.retryCount = (fileData.retryCount || 0) + 1;
            render();

            try {
                // Use original file
                fileData.file = fileData.originalFile;

                // Upload the file
                fileData.status = 'uploading';
                fileData.progress = 15;
                render();

                const imageUrl = await uploadImageFileWithRetry(fileData.file, fileIndex);
                fileData.status = 'success';
                fileData.imageUrl = imageUrl;
                fileData.progress = 100;
            } catch (error) {
                fileData.status = 'failed';
                fileData.error = getFriendlyErrorMessage(error);
            }

            render();
        }

        function cancelAllUploads() {
            // Mark all pending/uploading files as cancelled
            state.uploadProgress.files.forEach(file => {
                if (file.status === 'pending' || file.status === 'uploading') {
                    file.status = 'failed';
                    file.error = 'Cancelled by user';
                }
            });
            render();
        }

        function getFriendlyErrorMessage(error) {
            const errorMsg = error.message || String(error);

            if (errorMsg.includes('Failed to fetch') || errorMsg.includes('ERR_HTTP2_PROTOCOL_ERROR')) {
                return 'Network error - please check your connection and try again';
            } else if (errorMsg.includes('timeout') || errorMsg.includes('timed out')) {
                return 'Upload timed out - file may be too large or connection too slow';
            } else if (errorMsg.includes('413') || errorMsg.includes('Payload Too Large')) {
                return 'File is too large for upload';
            } else if (errorMsg.includes('401') || errorMsg.includes('403')) {
                return 'Authentication error - please try logging in again';
            } else if (errorMsg.includes('storage')) {
                return 'Storage error: ' + errorMsg;
            }

            return errorMsg;
        }


        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.add('border-blue-500', 'bg-blue-100');
                dropZone.classList.remove('border-gray-300', 'bg-gray-50');
            }
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-100');
                dropZone.classList.add('border-gray-300', 'bg-gray-50');
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();

            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-100');
                dropZone.classList.add('border-gray-300', 'bg-gray-50');
            }

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                // Create a mock file input object to reuse handleFileSelect logic
                const mockInput = {
                    files: files,
                    value: ''
                };
                handleFileSelect(mockInput);
            }
        }

        function removeContestImage(index) {
            showConfirm(
                'Delete this image from the contest?',
                `confirmRemoveImage_${index}`,
                'üö®'
            );
        }

        function confirmRemoveImage(index) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URL if it's a local file
            const img = state.newContest.images[index];
            if (img && img.isLocalFile && img.url.startsWith('blob:')) {
                URL.revokeObjectURL(img.url);
            }

            state.newContest.images.splice(index, 1);
            state.modalProcessing = false;
            render();

            // Show success message
            showAlert('Image successfully removed!', '‚úÖ');
        }
        function toggleUserDropdown() {
            state.showUserDropdown = !state.showUserDropdown;
            render();
        }

        async function toggleDarkTheme() {
            // Prevent spam clicking
            if (state.themeToggling) return;

            state.themeToggling = true;
            setLoading('Switching theme...');

            // Small delay to show loading modal and smooth transition
            await new Promise(resolve => setTimeout(resolve, 300));

            state.darkTheme = !state.darkTheme;

            // Apply dark theme class to body
            if (state.darkTheme) {
                document.body.classList.add('dark-theme');
            } else {
                document.body.classList.remove('dark-theme');
            }

            // Save to database
            if (state.user && state.user.id) {
                try {
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${state.user.id}`, {
                        method: 'PATCH',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Content-Type': 'application/json',
                            'Prefer': 'return=minimal'
                        },
                        body: JSON.stringify({
                            dark_theme: state.darkTheme
                        })
                    });

                    if (!response.ok) {
                        console.error('Failed to save dark theme preference');
                    }
                } catch (error) {
                    console.error('Error saving dark theme preference:', error);
                }
            }

            clearLoading();
            state.themeToggling = false;
            render();
        }

        function toggleMergedContestsDropdown() {
            state.showMergedContestsDropdown = !state.showMergedContestsDropdown;
            render();
        }

        async function shareContest(contestId) {
            try {
                const shareUrl = `${window.location.origin}${window.location.pathname}#contest=${contestId}`;

                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                showToast('üîó Contest link copied!', 'success');
            } catch (error) {
                console.error('Failed to copy link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        // Helper function to fetch all votes with pagination (works around 2000 row DB limit)
        async function fetchAllVotesPaginated(filterQuery, selectFields) {
            let allVotes = [];
            let offset = 0;
            const limit = 2000; // Database row limit per query
            let hasMore = true;

            while (hasMore) {
                const url = `${SUPABASE_URL}/rest/v1/votes?${filterQuery}&order=id.asc&limit=${limit}&offset=${offset}&select=${selectFields}`;
                const response = await fetch(url, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch votes: ${response.statusText}`);
                }

                const batch = await response.json();
                if (!Array.isArray(batch)) {
                    break;
                }

                allVotes = allVotes.concat(batch);

                // If we got fewer than limit rows, we've reached the end
                if (batch.length < limit) {
                    hasMore = false;
                } else {
                    offset += limit;
                }
            }

            return allVotes;
        }

        async function showContestInfoModal(item, itemType) {
            setLoading('Loading information...');
            try {
                // Fetch voters for this contest/merger/extract
                let voters = [];
                let votesData = [];

                if (itemType === 'merger') {
                    // For mergers, we need to get all voters and calculate how many contests they voted on
                    const contestIds = item.contestIds || [];
                    if (contestIds.length === 0) {
                        voters = [];
                    } else {
                        // Get all votes from merged contests with pagination
                        votesData = await fetchAllVotesPaginated(
                            `contest_id=in.(${contestIds.join(',')})`,
                            'user_id,contest_id,users!inner(id,username,avatar,is_banned)'
                        );
                    }
                } else if (itemType === 'extract') {
                    // For extracts, query votes from source contest(s)
                    let sourceContestIds = [];
                    if (item.sourceType === 'contest') {
                        sourceContestIds = [item.sourceContestId];
                    } else if (item.sourceType === 'merger') {
                        const merger = state.mergers.find(m => m.id === item.sourceMergerId);
                        if (merger) {
                            sourceContestIds = merger.contestIds;
                        }
                    }

                    if (sourceContestIds.length === 0) {
                        voters = [];
                    } else {
                        votesData = await fetchAllVotesPaginated(
                            `contest_id=in.(${sourceContestIds.join(',')})`,
                            'user_id,users!inner(id,username,avatar,is_banned)'
                        );
                    }
                } else {
                    // For regular contests, query using the contest_id with pagination
                    const contestId = item.id;
                    votesData = await fetchAllVotesPaginated(
                        `contest_id=eq.${contestId}`,
                        'user_id,users!inner(id,username,avatar,is_banned)'
                    );
                }

                // Deduplicate voters and sort by username (exclude banned users)
                if (votesData && votesData.length > 0) {
                    if (Array.isArray(votesData)) {
                        if (itemType === 'merger') {
                            // For mergers, calculate how many contests each user voted on
                            const voterContestsMap = new Map();
                            votesData.forEach(vote => {
                                if (vote.users && !vote.users.is_banned) {
                                    if (!voterContestsMap.has(vote.user_id)) {
                                        voterContestsMap.set(vote.user_id, {
                                            user: vote.users,
                                            contestIds: new Set()
                                        });
                                    }
                                    voterContestsMap.get(vote.user_id).contestIds.add(vote.contest_id);
                                }
                            });
                            voters = Array.from(voterContestsMap.entries()).map(([userId, data]) => ({
                                ...data.user,
                                completedContests: data.contestIds.size,
                                totalContests: item.contestIds.length
                            })).sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
                        } else {
                            // For contests and extracts, calculate image completion per voter
                            // First, need to fetch full vote data with image_id
                            let fullVotesData = [];
                            if (itemType === 'extract') {
                                // For extracts, get source contests
                                let sourceContestIds = [];
                                if (item.sourceType === 'contest') {
                                    sourceContestIds = [item.sourceContestId];
                                } else if (item.sourceType === 'merger') {
                                    const merger = state.mergers.find(m => m.id === item.sourceMergerId);
                                    if (merger) {
                                        sourceContestIds = merger.contestIds;
                                    }
                                }
                                if (sourceContestIds.length > 0) {
                                    fullVotesData = await fetchAllVotesPaginated(
                                        `contest_id=in.(${sourceContestIds.join(',')})`,
                                        'user_id,image_id,users!inner(id,username,avatar,is_banned)'
                                    );
                                }
                            } else {
                                // For contests
                                const contestId = item.id;
                                fullVotesData = await fetchAllVotesPaginated(
                                    `contest_id=eq.${contestId}`,
                                    'user_id,image_id,users!inner(id,username,avatar,is_banned)'
                                );
                            }

                            // Calculate how many images each user has voted on
                            const voterImagesMap = new Map();
                            const relevantImageIds = itemType === 'extract'
                                ? (item.imageIds || [])
                                : item.images.map(img => img.id);

                            fullVotesData.forEach(vote => {
                                if (vote.users && !vote.users.is_banned && relevantImageIds.includes(vote.image_id)) {
                                    if (!voterImagesMap.has(vote.user_id)) {
                                        voterImagesMap.set(vote.user_id, {
                                            user: vote.users,
                                            imageIds: new Set()
                                        });
                                    }
                                    voterImagesMap.get(vote.user_id).imageIds.add(vote.image_id);
                                }
                            });

                            voters = Array.from(voterImagesMap.entries()).map(([userId, data]) => ({
                                ...data.user,
                                completedImages: data.imageIds.size,
                                totalImages: relevantImageIds.length
                            })).sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
                        }
                    }
                }

                // Set state for modal
                state.contestInfoModal = {
                    item,
                    itemType,
                    voters
                };

                clearLoading();
                render();
            } catch (error) {
                console.error('Error loading contest info:', error);
                clearLoading();
                showAlert('Failed to load contest info: ' + error.message, '‚ùå');
            }
        }

        function closeContestInfoModal() {
            state.contestInfoModal = null;
            render();
        }

        async function shareContestFromModal() {
            if (!state.contestInfoModal) return;

            const { item, itemType } = state.contestInfoModal;
            let shareUrl;

            if (itemType === 'merger') {
                shareUrl = `${window.location.origin}${window.location.pathname}#merger=${item.id}`;
            } else if (itemType === 'extract') {
                shareUrl = `${window.location.origin}${window.location.pathname}#extract=${item.id}`;
            } else {
                shareUrl = `${window.location.origin}${window.location.pathname}#contest=${item.id}`;
            }

            try {
                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                const itemTypeName = itemType === 'merger' ? 'Merger' : itemType === 'extract' ? 'Extract' : 'Contest';
                showToast(`üîó ${itemTypeName} link copied!`, 'success');
            } catch (error) {
                console.error('Failed to copy link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        function showBreakdownMerged(imageId) {
            state.showBreakdownModal = imageId;
            render();
        }

        function renderBreakdownModalMerged() {
            if (!state.mergedResults || !state.mergedResults.images) return '';

            const item = state.mergedResults.images.find(img => img.id === state.showBreakdownModal);
            if (!item) return '';

            const userFilterIds = getFilteredUserIds();
            const isFiltered = isUserFilterActive();

            const votesByScore = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            (item.voteBreakdown || []).forEach(vote => {
                if ((userFilterIds === null || userFilterIds.has(vote.userId)) && votesByScore[vote.score]) {
                    votesByScore[vote.score].push(vote);
                }
            });

            Object.keys(votesByScore).forEach(score => {
                votesByScore[score].sort((a, b) => a.username.localeCompare(b.username));
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[85vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Vote Breakdown${isFiltered ? ' <span class="text-mauve-500 text-base" title="Filtered by user selection">*</span>' : ''}</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="overflow-y-auto flex-1 p-4">

                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 400px;">
                                <img
                                    src="${item.url}"
                                    alt="Image"
                                    class="max-w-full max-h-[400px] object-contain"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                            </div>

                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-gray-400">${item.averageScore}</div>
                                    <div class="text-xs text-gray-400">Average Score</div>
                                    <div class="text-xs text-gray-500 mt-1">${item.totalVotes} total votes</div>
                                </div>
                            </div>

                            <div class="space-y-3">
                                ${[5, 4, 3, 2, 1].map(score => {
                                    const votes = votesByScore[score] || [];
                                    return `
                                    <div>
                                        <h4 class="text-sm font-bold mb-2 px-3 py-1 rounded-lg inline-block" style="color: ${getScoreColor(score)}; background-color: ${getScoreColor(score)}20;">
                                            Score ${score} (${votes.length} ${votes.length === 1 ? 'vote' : 'votes'})
                                        </h4>
                                        ${votes.length > 0 ? `
                                            <div class="grid grid-cols-1 gap-2 mt-2">
                                                ${votes.map(vote => `
                                                    <div class="flex items-center gap-2 p-2 rounded-lg ${
                                                        vote.isBlocked ? 'bg-gray-300' :
                                                        vote.isCurrentUser ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'
                                                    }">
                                                        <img src="${vote.avatar}" alt="${vote.username}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');" />
                                                        <span class="text-sm flex-1 truncate cursor-pointer ${
                                                            vote.isBlocked ? 'line-through text-gray-700' : 'text-gray-700 hover:text-mauve-600'
                                                        }" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');">
                                                            ${vote.username}${vote.isCurrentUser ? ' (You)' : ''}
                                                        </span>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        ` : `
                                            <div class="text-gray-400 italic text-sm mt-2 ml-3">No votes</div>
                                        `}
                                    </div>
                                `}).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        async function shareMerge() {
            if (state.selectedContestsForMerge.length < 2) {
                showAlert('Please select at least 2 contests to merge', '‚ùå');
                return;
            }

            try {
                // Convert contest IDs to contest numbers for shorter URLs
                const contestNumbers = state.selectedContestsForMerge.map(id => {
                    const contest = state.contests.find(c => c.id === id);
                    return contest ? contest.contestNumber : null;
                }).filter(n => n !== null);

                const shareUrl = `${window.location.origin}${window.location.pathname}#merge=${contestNumbers.join(',')}`;

                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                showToast('üîó Merge link copied!', 'success');
            } catch (error) {
                console.error('Failed to copy merge link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        async function loadSharedContest(contestId) {
            try {
                console.log('Loading shared contest:', contestId);

                // Fetch contest from database with aggressive cache-busting
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}&select=*,images(*),creator:users!contests_created_by_fkey(username,avatar)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const contests = await response.json();

                if (!contests || contests.length === 0) {
                    showAlert('Contest not found. It may have been deleted.', '‚ùå');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                const contestData = contests[0];
                const contest = {
                    id: contestData.id,
                    title: contestData.title,
                    isLocked: contestData.is_locked,
                    resultsPublic: contestData.results_public,
                    createdBy: contestData.created_by,
                    creatorName: contestData.creator.username,
                    creatorAvatar: contestData.creator.avatar,
                    createdAt: contestData.created_at,
                    images: contestData.images
                        .sort((a, b) => a.image_order - b.image_order)
                        .map(img => ({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            isFileUpload: img.is_file_upload
                        }))
                };

                // Check if user is banned
                if (state.bannedUsers.includes(state.user?.id)) {
                    showAlert('Your account has been restricted. You cannot access this contest.', 'üö´');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Add contest to state if not already present (for Complete Voting modal to work)
                const existingContest = state.contests.find(c => c.id === contest.id);
                if (!existingContest) {
                    state.contests.push(contest);
                }

                // Check voting status
                const userVotes = state.userVotedContests[contest.id] || {};
                const votedImageCount = Object.keys(userVotes).length;
                const totalImageCount = contest.images.length;
                const hasVotedAll = votedImageCount === totalImageCount && totalImageCount > 0;
                const hasVotedSome = votedImageCount > 0 && votedImageCount < totalImageCount;

                // Clear the hash to avoid issues on reload
                window.location.hash = '';

                if (contest.isLocked || hasVotedAll) {
                    // Show results
                    await viewResults(contest);
                } else if (hasVotedSome) {
                    // Show Complete Voting modal
                    showContestVoteModal(contest.id);
                } else {
                    // Start voting
                    startVoting(contest);
                }
            } catch (error) {
                console.error('Error loading shared contest:', error);
                showAlert('Failed to load contest: ' + error.message, '‚ùå');
                window.location.hash = '';
                state.view = 'home';
                render();
            }
        }


        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove '#'

            console.log('üîó [NAVIGATION] Hash changed:', hash);

            // Don't handle hash changes if we're currently in voting mode
            // (this prevents interrupting the voting flow during "Complete Voting")
            if (state.view === 'vote') {
                console.log('üîó [NAVIGATION] Skipping hash change handling - currently voting');
                return;
            }

            // Parse hash parameters
            const params = new URLSearchParams(hash);
            const contestId = params.get('contest');
            const mergerId = params.get('merger');
            const extractId = params.get('extract');

            // If user is not logged in but trying to access a shared link, store it and show login
            if ((contestId || mergerId || extractId) && !state.isLoggedIn) {
                console.log('üîó [NAVIGATION] Shared link detected but user not logged in, storing route');
                state.pendingRoute = hash;
                localStorage.setItem('peony_pending_route', hash);
                render(); // This will show the login screen with the pending route
                return;
            }

            // Check for contest share: #contest={uuid}
            if (contestId && state.isLoggedIn) {
                // Prevent infinite loop: don't reload if already viewing this contest's results
                if (state.view === 'results' && state.currentContest && state.currentContest.id === contestId) {
                    console.log('üîó [NAVIGATION] Already viewing results for this contest, skipping reload');
                    return;
                }
                console.log('üîó [NAVIGATION] Detected contest share link');
                loadSharedContest(contestId);
            }
            // Check for merger share: #merger={uuid}
            else if (mergerId && state.isLoggedIn) {
                console.log('üîó [NAVIGATION] Detected merger share link');
                loadSharedMerger(mergerId);
            }
            // Check for extract share: #extract={uuid}
            else if (extractId && state.isLoggedIn) {
                console.log('üîó [NAVIGATION] Detected extract share link');
                loadSharedExtract(extractId);
            }
        }

        async function loadSharedMerger(mergerId) {
            try {
                console.log('Loading shared merger:', mergerId);

                // Check if user is banned first
                if (state.bannedUsers.includes(state.user?.id)) {
                    showAlert('Your account has been restricted. You cannot access this merger.', 'üö´');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Reload data to get latest state
                await loadContests();
                await loadMergers();
                await loadExtracts();
                await loadVoterCounts();

                // Find the merger in state
                const merger = state.mergers.find(m => m.id === mergerId);

                if (!merger) {
                    showAlert('Merger not found. It may have been deleted.', '‚ùå');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Get all contests in the merger
                const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                const isCreator = state.user && state.user.id === merger.createdBy;

                // Check if user has voted on all contests
                const unlockedContests = mergedContests.filter(c => !c.isLocked);
                const votedContests = unlockedContests.filter(c => state.userVotedContests[c.id]);
                const hasVotedAll = votedContests.length === unlockedContests.length && unlockedContests.length > 0;
                const hasVotedSome = votedContests.length > 0 && votedContests.length < unlockedContests.length;
                const hasVotedNone = votedContests.length === 0;

                // Clear the hash to avoid issues on reload
                window.location.hash = '';

                // Route user based on their voting status
                if (merger.isLocked || hasVotedAll || isAdmin || isCreator) {
                    // Merger is locked, user has voted on all contests, or is admin/creator -> show results
                    await viewMergerResults(mergerId);
                } else if (hasVotedSome) {
                    // User has voted on some contests -> show "Complete Voting" modal
                    showMergerVoteModal(mergerId);
                } else {
                    // User hasn't voted on any -> start merger voting
                    startMergerVoting(mergerId, false);
                }
            } catch (error) {
                console.error('Error loading shared merger:', error);
                showAlert('Failed to load merger: ' + error.message, '‚ùå');
                window.location.hash = '';
                state.view = 'home';
                render();
            }
        }

        async function loadSharedExtract(extractId) {
            try {
                console.log('Loading shared extract:', extractId);

                // Check if user is banned first
                if (state.bannedUsers.includes(state.user?.id)) {
                    showAlert('Your account has been restricted. You cannot access this extract.', 'üö´');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Reload data to get latest state
                await loadContests();
                await loadMergers();
                await loadExtracts();
                await loadVoterCounts();

                // Find the extract in state
                const extract = state.extracts.find(e => e.id === extractId);

                if (!extract) {
                    showAlert('Extract not found. It may have been deleted.', '‚ùå');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Check if user has voted on the source
                let hasVotedOnSource = false;

                if (extract.sourceType === 'contest') {
                    // For contest source, check if user has voted on the contest
                    hasVotedOnSource = !!state.userVotedContests[extract.sourceContestId];
                } else if (extract.sourceType === 'merger') {
                    // For merger source, check if user has voted on all contests in the merger
                    const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (sourceMerger) {
                        const mergedContests = state.contests.filter(c => sourceMerger.contestIds.includes(c.id));
                        const votedContests = mergedContests.filter(c => state.userVotedContests[c.id]);
                        hasVotedOnSource = votedContests.length === mergedContests.length && mergedContests.length > 0;
                    }
                }

                // Clear the hash to avoid issues on reload
                window.location.hash = '';

                // Route user based on their voting status
                const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                const isCreator = state.user && state.user.id === extract.createdBy;

                if (extract.isLocked || hasVotedOnSource || isAdmin || isCreator) {
                    // Extract is locked, user has voted on source, or is admin/creator -> show extract results
                    await viewExtractResults(extractId);
                } else {
                    // User hasn't voted on source -> show redirect modal
                    showExtractVotingRedirectModal(extractId);
                }
            } catch (error) {
                console.error('Error loading shared extract:', error);
                showAlert('Failed to load extract: ' + error.message, '‚ùå');
                window.location.hash = '';
                state.view = 'home';
                render();
            }
        }

        function finishCreateContest() {
            const isEditMode = !!state.editingContestId;
            const newImages = isEditMode ? state.newContest.images.filter(img => !img.isExisting) : state.newContest.images;

            if (!isEditMode && state.newContest.images.length === 0) {
                showAlert('Add at least one image!', '‚ùå');
                return;
            }

            if (isEditMode && newImages.length === 0) {
                showAlert('Add at least one new image!', '‚ùå');
                return;
            }

            // Check for duplicate title (only in create mode)
            if (!isEditMode) {
                const duplicateTitle = state.contests.some(c =>
                    c.title.toLowerCase().trim() === state.newContest.title.toLowerCase().trim()
                );

                if (duplicateTitle) {
                    showAlert('A contest with this title already exists. Please choose a different title.', '‚ùå');
                    return;
                }
            }

            // Show confirmation popup
            const message = isEditMode
                ? `Add ${newImages.length} new image(s) to contest "${state.newContest.title}"?`
                : `Create contest "${state.newContest.title}" with ${state.newContest.images.length} images?`;

            showConfirm(
                message,
                'confirmFinishCreateContest',
                'üö®'
            );
        }

        async function confirmFinishCreateContest() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const isEditMode = !!state.editingContestId;
            const imagesToProcess = isEditMode
                ? state.newContest.images.filter(img => !img.isExisting)
                : state.newContest.images;
            const uploadedUrls = [];
            const localFilesToUpload = imagesToProcess.filter(img => img.isLocalFile);

            try {
                // Step 1: Upload all local files first
                if (localFilesToUpload.length > 0) {
                    setLoading(`Uploading images (0/${localFilesToUpload.length})...`);

                    for (let i = 0; i < localFilesToUpload.length; i++) {
                        const img = localFilesToUpload[i];
                        setLoading(`Uploading images (${i + 1}/${localFilesToUpload.length})...`);

                        // Upload to storage
                        const uploadedUrl = await uploadImageFile(img.localFile);
                        uploadedUrls.push(uploadedUrl);

                        // Update the image URL in state
                        img.url = uploadedUrl;
                        img.isLocalFile = false;
                        delete img.localFile;
                    }
                }

                let contestId;

                if (isEditMode) {
                    // Step 2a: Use existing contest ID
                    contestId = state.editingContestId;
                    setLoading('Adding images to contest...');

                    // Get the current max image_order for this contest
                    const existingImagesCount = state.newContest.images.filter(img => img.isExisting).length;

                    // Insert only new images
                    const imagesToInsert = imagesToProcess.map((img, i) => ({
                        contest_id: contestId,
                        url: img.url,
                        is_file_upload: img.isFileUpload,
                        author: img.author,
                        image_order: existingImagesCount + i
                    }));

                    const imagesResponse = await fetch(`${SUPABASE_URL}/rest/v1/images`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Prefer': 'return=minimal',
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify(imagesToInsert)
                    });

                    if (!imagesResponse.ok) {
                        const errorData = await imagesResponse.json();
                        console.error('Image insertion failed:', errorData);
                        throw new Error(errorData.message || 'Failed to add images');
                    }
                } else {
                    // Step 2b: Insert contest - database auto-generates UUID
                    setLoading('Creating contest...');
                    const contestResponse = await fetch(`${SUPABASE_URL}/rest/v1/contests`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Prefer': 'return=representation',
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify({
                            title: state.newContest.title,
                            created_by: state.user.id
                        })
                    });

                    if (!contestResponse.ok) {
                        const errorData = await contestResponse.json();
                        console.error('Contest creation failed:', errorData);
                        throw new Error(errorData.message || 'Failed to create contest');
                    }

                    const createdContests = await contestResponse.json();
                    contestId = createdContests[0].id;

                    // Step 3: Insert images
                    const imagesToInsert = state.newContest.images.map((img, i) => ({
                        contest_id: contestId,
                        url: img.url,
                        is_file_upload: img.isFileUpload,
                        author: img.author,
                        image_order: i
                    }));

                    const imagesResponse = await fetch(`${SUPABASE_URL}/rest/v1/images`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Prefer': 'return=minimal',
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify(imagesToInsert)
                    });

                    if (!imagesResponse.ok) {
                        const errorData = await imagesResponse.json();
                        console.error('Image insertion failed:', errorData);
                        throw new Error(errorData.message || 'Failed to add images');
                    }
                }

                // Revoke all Object URLs after successful creation/editing
                state.newContest.images.forEach(img => {
                    if (img.url.startsWith('blob:')) {
                        URL.revokeObjectURL(img.url);
                    }
                });

                state.newContest = { title: '', images: [] };
                state.editingContestId = null;
                await loadContests();
                state.view = 'home';
                state.modalProcessing = false;

                // Show success message
                const successMessage = isEditMode
                    ? `Images added successfully! ${imagesToProcess.length} new image(s) added to contest.`
                    : 'Contest created successfully!';
                showAlert(successMessage, '‚ú®');

            } catch (error) {
                console.error('Full contest creation/edit error:', error);

                // Clean up uploaded files if contest creation/edit failed
                if (uploadedUrls.length > 0) {
                    console.log('Cleaning up uploaded files due to error...');
                    for (const url of uploadedUrls) {
                        try {
                            const fileName = url.split('/').pop();
                            await supabase.storage
                                .from('contest-images')
                                .remove([fileName]);
                        } catch (cleanupError) {
                            console.error('Failed to cleanup file:', cleanupError);
                        }
                    }
                }

                state.modalProcessing = false;
                const errorMessage = isEditMode
                    ? 'Failed to add images: ' + error.message
                    : 'Failed to create contest: ' + error.message;
                showAlert(errorMessage, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        async function loadImageFromUrl(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                let timedOut = false;

                // Network timeout with specific message
                const timeoutId = setTimeout(() => {
                    timedOut = true;
                    reject(new Error('‚è±Ô∏è Network timeout: Image took too long to load. Possible causes: slow connection, large file size, or server issues. Try a different image or check your internet connection.'));
                }, 10000);

                img.onload = () => {
                    if (!timedOut) {
                        clearTimeout(timeoutId);
                        resolve(img);
                    }
                };

                img.onerror = () => {
                    if (timedOut) return; // Already handled by timeout
                    clearTimeout(timeoutId);

                    // Provide specific error details
                    let errorMsg = '‚ùå Failed to load image.\n\n';

                    // Check URL validity
                    try {
                        new URL(url);
                    } catch {
                        reject(new Error(errorMsg + 'üîó Invalid URL format. Please enter a valid image URL.'));
                        return;
                    }

                    // Check file extension
                    const extension = url.split('?')[0].split('.').pop().toLowerCase();
                    const validExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'];

                    // Provide likely causes based on URL analysis
                    if (url.includes('discord')) {
                        errorMsg += 'üí¨ Discord CDN issue: The link may be expired, deleted, or have restricted access. Try re-uploading the image to Discord and getting a fresh link.';
                    } else if (url.startsWith('http://')) {
                        errorMsg += 'üîí CORS/Security issue: HTTP URLs often have cross-origin restrictions. Try using an HTTPS URL instead, or upload the image to a public image host.';
                    } else if (!validExtensions.includes(extension)) {
                        errorMsg += 'üìÅ Unsupported format: The URL doesn\'t end with a recognized image extension (.jpg, .png, .gif, .webp). Make sure you\'re linking directly to an image file.';
                    } else if (url.includes('imgur') && !url.includes('i.imgur')) {
                        errorMsg += 'üñºÔ∏è Imgur link issue: Use direct image links (i.imgur.com) instead of gallery links. Right-click the image and select "Copy image address".';
                    } else {
                        errorMsg += 'üåê Possible causes:\n‚Ä¢ CORS restrictions from the image host\n‚Ä¢ Broken or expired link\n‚Ä¢ Image was deleted or moved\n‚Ä¢ Server is down or blocking requests\n‚Ä¢ Private/restricted access image\n\nTry uploading to a public image host like Imgur or Discord.';
                    }

                    reject(new Error(errorMsg));
                };

                img.src = url;
            });
        }

        function login() {
            const authUrl = `https://discord.com/oauth2/authorize?client_id=${DISCORD_CLIENT_ID}&redirect_uri=${encodeURIComponent(DISCORD_REDIRECT_URI)}&response_type=token&scope=identify`;
            window.location.href = authUrl;
        }

        function showLogoutConfirmation() {
            state.showLogoutConfirmModal = true;
            render();
        }

        function cancelLogout() {
            state.showLogoutConfirmModal = false;
            render();
        }

        function confirmLogout() {
            localStorage.removeItem('peony_user');
            state.isLoggedIn = false;
            state.user = null;
            state.view = 'home';
            state.showLogoutConfirmModal = false;
            render();
        }

        function logout() {
            showLogoutConfirmation();
        }

        async function loadVoterCounts() {
            // Only show loading modal if not in initialization phase
            if (!state.isInitializing) {
                setLoading('Loading voter counts...');
            }
            try {
                // Fetch all votes using pagination to avoid row limit
                const votes = await fetchAllVotesPaginated('', 'contest_id,user_id');

                if (Array.isArray(votes)) {
                    // Calculate voter counts for each contest
                    const contestVoterCounts = new Map();
                    votes.forEach(vote => {
                        if (!contestVoterCounts.has(vote.contest_id)) {
                            contestVoterCounts.set(vote.contest_id, new Set());
                        }
                        contestVoterCounts.get(vote.contest_id).add(vote.user_id);
                    });

                    // Update contest voter counts
                    state.contests.forEach(contest => {
                        const voters = contestVoterCounts.get(contest.id);
                        contest.voterCount = voters ? voters.size : 0;
                    });

                    // Update merger voter counts (count unique voters across all merged contests)
                    state.mergers.forEach(merger => {
                        const allVoters = new Set();
                        merger.contestIds.forEach(contestId => {
                            const voters = contestVoterCounts.get(contestId);
                            if (voters) {
                                voters.forEach(voterId => allVoters.add(voterId));
                            }
                        });
                        merger.voterCount = allVoters.size;
                    });

                    // Update extract voter counts (count unique voters from source)
                    state.extracts.forEach(extract => {
                        const allVoters = new Set();
                        if (extract.sourceType === 'contest') {
                            const voters = contestVoterCounts.get(extract.sourceContestId);
                            if (voters) {
                                voters.forEach(voterId => allVoters.add(voterId));
                            }
                        } else if (extract.sourceType === 'merger') {
                            const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                            if (merger) {
                                merger.contestIds.forEach(contestId => {
                                    const voters = contestVoterCounts.get(contestId);
                                    if (voters) {
                                        voters.forEach(voterId => allVoters.add(voterId));
                                    }
                                });
                            }
                        }
                        extract.voterCount = allVoters.size;
                    });
                }
            } catch (error) {
                console.error('Error loading voter counts:', error);
                // Don't throw - just log the error and continue with 0 voter counts
            } finally {
                // Only clear loading if not in initialization phase
                if (!state.isInitializing) {
                    clearLoading();
                }
            }
        }

        async function loadContests() {
            setLoading('Loading contests...');
            try {
                const response = await fetchFromSupabase('/rest/v1/contests?select=*,images(*),creator:users!contests_created_by_fkey(username,avatar)&order=created_at.desc');

                const contests = await response.json();

                // Check if contests response is valid
                if (!Array.isArray(contests)) {
                    console.error('Invalid contests response:', contests);
                    throw new Error(contests.message || 'Failed to load contests');
                }

                // Map contests with their voter counts from database fields
                state.contests = contests.map(contest => ({
                    id: contest.id,
                    contestNumber: contest.contest_number,
                    title: contest.title,
                    isLocked: contest.is_locked,
                    resultsPublic: contest.results_public,
                    createdBy: contest.created_by,
                    creatorName: contest.creator.username,
                    creatorAvatar: contest.creator.avatar,
                    createdAt: contest.created_at,
                    voterCount: 0, // Will be updated after fetching voter counts
                    images: contest.images
                        .sort((a, b) => a.image_order - b.image_order)
                        .map(img => ({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            isFileUpload: img.is_file_upload
                        }))
                }));

                // Load voter counts after loading contests (unless in initialization phase)
                if (!state.isInitializing) {
                    await loadVoterCounts();
                    render();
                }
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            } finally {
                // Only clear loading if not in initialization phase
                if (!state.isInitializing) {
                    clearLoading();
                }
            }
        }

        async function loadMergers() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?select=*,creator:users!mergers_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const mergers = await response.json();
                if (Array.isArray(mergers)) {
                    state.mergers = mergers.map(m => ({
                        id: m.id,
                        name: m.name,
                        createdBy: m.created_by,
                        creatorName: m.creator.username,
                        creatorAvatar: m.creator.avatar,
                        createdAt: m.created_at,
                        contestIds: m.contest_ids,
                        isLocked: m.is_locked || false,
                        resultsPublic: m.results_public !== false,
                        voterCount: 0, // Will be updated by loadVoterCounts
                        type: 'merger'
                    }));
                }
            } catch (error) {
                console.error('Error loading mergers:', error);
            }
        }

        async function loadExtracts() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?select=*,creator:users!extracts_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const extracts = await response.json();
                if (Array.isArray(extracts)) {
                    state.extracts = extracts.map(e => ({
                        id: e.id,
                        name: e.name,
                        createdBy: e.created_by,
                        creatorName: e.creator.username,
                        creatorAvatar: e.creator.avatar,
                        createdAt: e.created_at,
                        sourceContestId: e.source_type === 'contest' ? e.source_contest_id : (e.source_type === 'extract' ? e.source_contract_id : null),
                        sourceMergerId: e.source_type === 'merger' ? e.source_contest_id : null,
                        sourceType: e.source_type,
                        imageIds: e.image_ids,
                        isLocked: e.is_locked || false,
                        resultsPublic: e.results_public !== false,
                        voterCount: 0, // Will be updated by loadVoterCounts
                        type: 'extract'
                    }));
                }
            } catch (error) {
                console.error('Error loading extracts:', error);
            }
        }

        async function loadPinnedItems() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/pinned_items?select=*&order=pinned_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const pinnedItems = await response.json();
                if (Array.isArray(pinnedItems)) {
                    state.pinnedItems = pinnedItems;
                }
            } catch (error) {
                console.error('Error loading pinned items:', error);
            }
        }

        async function pinItem(itemType, itemId) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showToast('Only admins can pin items', 'error');
                return;
            }

            // Check if item is already pinned
            const alreadyPinned = state.pinnedItems.some(
                item => item.item_type === itemType && item.item_id === itemId
            );

            if (alreadyPinned) {
                showToast('Item is already pinned', 'info');
                return;
            }

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/pinned_items`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=minimal'
                    },
                    body: JSON.stringify({
                        item_type: itemType,
                        item_id: itemId,
                        pinned_by: state.user.id
                    })
                });

                if (response.ok) {
                    showToast('Item pinned successfully', 'success');
                    await loadPinnedItems();
                    render();
                } else {
                    const error = await response.text();
                    console.error('Failed to pin item:', error);
                    showToast('Failed to pin item', 'error');
                }
            } catch (error) {
                console.error('Error pinning item:', error);
                showToast('Error pinning item', 'error');
            }
        }

        async function unpinItem(itemType, itemId) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showToast('Only admins can unpin items', 'error');
                return;
            }

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/pinned_items?item_type=eq.${itemType}&item_id=eq.${itemId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (response.ok) {
                    showToast('Item unpinned successfully', 'success');
                    await loadPinnedItems();
                    render();
                } else {
                    showToast('Failed to unpin item', 'error');
                }
            } catch (error) {
                console.error('Error unpinning item:', error);
                showToast('Error unpinning item', 'error');
            }
        }

        function togglePin(event, itemType, itemId, isPinned) {
            event.stopPropagation();
            if (isPinned) {
                unpinItem(itemType, itemId);
            } else {
                pinItem(itemType, itemId);
            }
        }

        async function loadAppSettings() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const settings = await response.json();
                if (Array.isArray(settings)) {
                    settings.forEach(s => {
                        state.appSettings[s.setting_name] = s.value;
                    });
                }
            } catch (error) {
                console.error('Error loading app settings:', error);
            }
        }

        async function loadUserVotes() {
            if (!state.user) return;

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${state.user.id}&select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const votes = await response.json();

                state.userVotedContests = {};
                votes.forEach(vote => {
                    if (!state.userVotedContests[vote.contest_id]) {
                        state.userVotedContests[vote.contest_id] = {};
                    }
                    state.userVotedContests[vote.contest_id][vote.image_id] = vote.score;
                });
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            }
        }

        // ‚îÄ‚îÄ‚îÄ AUTO-SAVE DRAFT VOTING SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        let autoSaveTimer = null;  // Debounce timer handle for auto-save

        // Load all autosaved votes for the current user (called on home screen load)
        async function loadAllUserAutosaves() {
            if (!state.user) return;
            try {
                const response = await fetch(
                    `${SUPABASE_URL}/rest/v1/autosave_votes?user_id=eq.${state.user.id}&select=*`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );
                if (!response.ok) throw new Error('Failed to load autosaves');
                const autosaves = await response.json();
                state.userAutosavedVotes = {};
                autosaves.forEach(save => {
                    if (save.score >= 1 && save.score <= 5) {
                        const key = `${save.voting_context_type}_${save.voting_context_id}`;
                        if (!state.userAutosavedVotes[key]) state.userAutosavedVotes[key] = {};
                        state.userAutosavedVotes[key][save.image_id] = save.score;
                    }
                });
            } catch (error) {
                console.error('Failed to load autosaves from DB, trying localStorage:', error);
                // localStorage fallback is loaded lazily per-context when needed
            }
        }

        // Delete autosaves for a specific voting context (called after submit or revote)
        async function deleteAutosaves(contextType, contextId) {
            if (!state.user || !contextType || !contextId) return;
            // Clear from in-memory state immediately
            const key = `${contextType}_${contextId}`;
            delete state.userAutosavedVotes[key];
            // Clear localStorage backup
            try {
                localStorage.removeItem(`autosave_${state.user.id}_${contextType}_${contextId}`);
            } catch (e) { /* ignore */ }
            // Delete from database (fire and forget ‚Äì don't block UI)
            try {
                await fetch(
                    `${SUPABASE_URL}/rest/v1/autosave_votes?user_id=eq.${state.user.id}&voting_context_type=eq.${contextType}&voting_context_id=eq.${contextId}`,
                    {
                        method: 'DELETE',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    }
                );
            } catch (error) {
                console.error('Failed to delete autosaves from DB:', error);
            }
        }

        // Debounced trigger ‚Äì call after each vote action (2-second delay)
        function debouncedAutoSave() {
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(performAutoSave, 3000);
        }

        // Perform the actual auto-save to DB + localStorage
        async function performAutoSave() {
            if (!state.user) return;
            const contextType = state.autosaveContext.type;
            const contextId   = state.autosaveContext.id;
            if (!contextType || !contextId) return;

            // Build list of votes to save
            const votesToSave = [];
            const isMergerVoting = contextType === 'merger';

            state.shuffledImages.forEach(img => {
                if (!state.votes[img.id]) return;
                let contestId;
                if (isMergerVoting) {
                    const owningContest = state.contests.find(c =>
                        state.mergerContestIds.includes(c.id) &&
                        c.images.some(i => i.id === img.id)
                    );
                    contestId = owningContest ? owningContest.id : (state.mergerContestIds[0] || contextId);
                } else {
                    contestId = state.currentContest ? state.currentContest.id : contextId;
                }
                if (contestId) {
                    votesToSave.push({
                        user_id: state.user.id,
                        image_id: img.id,
                        contest_id: contestId,
                        score: state.votes[img.id],
                        voting_context_type: contextType,
                        voting_context_id: contextId
                    });
                }
            });

            if (votesToSave.length === 0) return;

            // Persist to localStorage as backup
            const lsKey = `autosave_${state.user.id}_${contextType}_${contextId}`;
            try {
                const lsData = {};
                votesToSave.forEach(v => { lsData[v.image_id] = v.score; });
                localStorage.setItem(lsKey, JSON.stringify(lsData));
            } catch (e) { console.error('localStorage save failed:', e); }

            // Upsert to database
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/autosave_votes`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'resolution=merge-duplicates'
                    },
                    body: JSON.stringify(votesToSave)
                });
                if (response.ok) {
                    // Update in-memory state
                    const key = `${contextType}_${contextId}`;
                    if (!state.userAutosavedVotes[key]) state.userAutosavedVotes[key] = {};
                    votesToSave.forEach(v => { state.userAutosavedVotes[key][v.image_id] = v.score; });
                    state.lastAutoSaveTime = new Date();
                    showAutoSaveToast();
                }
            } catch (error) {
                console.error('Auto-save DB write failed (localStorage backup preserved):', error);
            }
        }

        // Brief non-intrusive "Auto-saved ‚úì" toast at bottom-center
        function showAutoSaveToast() {
            const existing = document.getElementById('autosave-toast');
            if (existing) { existing.remove(); }
            const toast = document.createElement('div');
            toast.id = 'autosave-toast';
            toast.style.cssText = [
                'position:fixed',
                'bottom:24px',
                'left:50%',
                'transform:translateX(-50%)',
                'background:#22c55e',
                'color:#fff',
                'padding:5px 14px',
                'border-radius:999px',
                'font-size:13px',
                'font-weight:600',
                'z-index:9999',
                'opacity:0',
                'transition:opacity 200ms ease',
                'pointer-events:none',
                'white-space:nowrap'
            ].join(';');
            toast.textContent = 'Auto-saved \u2713';
            document.body.appendChild(toast);
            requestAnimationFrame(() => {
                toast.style.opacity = '1';
                setTimeout(() => {
                    toast.style.opacity = '0';
                    setTimeout(() => { if (toast.parentNode) toast.remove(); }, 200);
                }, 1800);
            });
        }

        // Show "Continue Draft" modal for a contest or merger
        function continueVotingDraft(itemId, itemType) {
            const key = `${itemType}_${itemId}`;
            const autosaves = state.userAutosavedVotes[key] || {};
            const autosaveCount = Object.keys(autosaves).length;

            let item, totalImages, itemName;
            if (itemType === 'contest') {
                item = state.contests.find(c => c.id === itemId);
                totalImages = item ? item.images.length : 0;
                itemName = item ? item.title : 'Unknown';
            } else if (itemType === 'merger') {
                item = state.mergers.find(m => m.id === itemId);
                const mergedContests = item ? state.contests.filter(c => item.contestIds.includes(c.id)) : [];
                totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);
                itemName = item ? item.name : 'Unknown';
            }
            if (!item) return;

            state.pendingDraftContext = { itemId, itemType, item };

            state.modal = {
                icon: '\uD83D\uDCBE',
                message: `You have ${autosaveCount} out of ${totalImages} votes auto-saved for "${itemName}".\n\nThese votes have not been submitted yet.`,
                buttons: [
                    { text: 'Discard Draft', action: 'confirmDiscardDraft', primary: false, color: 'red-outline' },
                    { text: 'Resume Drafting', action: 'confirmResumeDraft', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        // Resume a draft: start voting with autosaved votes pre-populated
        async function confirmResumeDraft() {
            if (!state.pendingDraftContext) return;
            const { itemId, itemType, item } = state.pendingDraftContext;
            state.pendingDraftContext = null;
            state.modal = null;
            document.body.classList.remove('modal-open');

            if (itemType === 'contest') {
                startVoting(item, true);  // true = load autosaves
            } else if (itemType === 'merger') {
                await startMergerVoting(itemId, false, true);  // false = don't revote all, true = load autosaves
            }
        }

        // Ask for confirmation before discarding a draft
        function confirmDiscardDraft() {
            if (!state.pendingDraftContext) return;
            const { itemId, itemType } = state.pendingDraftContext;
            const key = `${itemType}_${itemId}`;
            const autosaveCount = Object.keys(state.userAutosavedVotes[key] || {}).length;

            state.modal = {
                icon: '\u26A0\uFE0F',
                message: `Are you sure? This will delete ${autosaveCount} auto-saved vote${autosaveCount !== 1 ? 's' : ''}.`,
                buttons: [
                    { text: 'Cancel', action: 'cancelDiscardDraft', primary: false },
                    { text: 'Delete Draft', action: 'executeDiscardDraft', primary: true, color: 'red' }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        // Go back to the resume modal from the discard confirmation (or just close if triggered from voting page)
        function cancelDiscardDraft() {
            if (!state.pendingDraftContext || state.pendingDraftContext.fromVoting) {
                state.pendingDraftContext = null;
                closeModal();
                return;
            }
            const { itemId, itemType } = state.pendingDraftContext;
            // Re-show the resume modal (home screen flow only)
            continueVotingDraft(itemId, itemType);
        }

        // Actually delete the draft and return to home
        async function executeDiscardDraft() {
            if (!state.pendingDraftContext) { closeModal(); return; }
            const { itemId, itemType } = state.pendingDraftContext;
            state.pendingDraftContext = null;
            state.modal = null;
            document.body.classList.remove('modal-open');
            await deleteAutosaves(itemType, itemId);
            render();
            showToast('Draft discarded successfully.', 'üóëÔ∏è');
        }

        // Manual "Save now" button ‚Äî flushes the debounce and saves immediately
        async function manualSaveVotes() {
            clearTimeout(autoSaveTimer);
            await performAutoSave();
            const ctxKey = state.autosaveContext.type && state.autosaveContext.id
                ? `${state.autosaveContext.type}_${state.autosaveContext.id}` : null;
            const savedCount = ctxKey ? Object.keys(state.userAutosavedVotes[ctxKey] || {}).length : 0;
            const total = state.shuffledImages.length;
            showAlert(
                `${savedCount} of ${total} vote${savedCount !== 1 ? 's' : ''} saved as a draft.\n\nYou can safely close this tab and pick up where you left off from the "Continue Draft" button on the home screen.`,
                '‚úÖ'
            );
        }

        // "Discard draft" while actively voting ‚Äî confirms, then clears both autosaves and current votes
        function discardCurrentDraftFromVoting() {
            if (!state.autosaveContext.type || !state.autosaveContext.id) return;
            const { type, id } = state.autosaveContext;
            const ctxKey = `${type}_${id}`;
            const autosaveCount = Object.keys(state.userAutosavedVotes[ctxKey] || {}).length;
            const inProgressCount = Object.keys(state.votes).length;
            const totalCount = Math.max(autosaveCount, inProgressCount);

            let item;
            if (type === 'contest') item = state.currentContest;
            else if (type === 'merger') item = state.mergers.find(m => m.id === id);
            if (!item) return;

            state.pendingDraftContext = { itemId: id, itemType: type, item, fromVoting: true };
            state.modal = {
                icon: '\uD83D\uDDD1\uFE0F',
                message: `Discard your draft? This will clear ${totalCount} in-progress vote${totalCount !== 1 ? 's' : ''} and start fresh.\n\nThis cannot be undone.`,
                buttons: [
                    { text: 'Keep Draft', action: 'cancelDiscardDraft', primary: false },
                    { text: 'Discard & Start Fresh', action: 'executeDiscardDraftFromVoting', primary: true, color: 'red' }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        // Actually discard and reset current votes, staying in voting view
        async function executeDiscardDraftFromVoting() {
            if (!state.pendingDraftContext) { closeModal(); return; }
            const { itemId, itemType } = state.pendingDraftContext;
            state.pendingDraftContext = null;
            state.modal = null;
            document.body.classList.remove('modal-open');
            clearTimeout(autoSaveTimer);
            await deleteAutosaves(itemType, itemId);
            state.votes = {};
            state.currentImageIndex = 0;
            showToast('Draft discarded. Starting fresh!', 'üóëÔ∏è');
            render();
        }

        // Render the autosave status bar shown above the voting section
        function renderAutosaveStatusBar() {
            if (!state.autosaveContext.type || !state.autosaveContext.id) return '';
            const ctxKey = `${state.autosaveContext.type}_${state.autosaveContext.id}`;
            const savedCount = Object.keys(state.userAutosavedVotes[ctxKey] || {}).length;
            const totalCount = state.shuffledImages.length;
            const hasAnySaved = savedCount > 0;

            let statusText;
            if (state.isAutoSaving) {
                statusText = 'üíæ Saving‚Ä¶';
            } else if (hasAnySaved) {
                statusText = `üíæ ${savedCount} of ${totalCount} vote${savedCount !== 1 ? 's' : ''} auto-saved`;
            } else {
                statusText = 'üíæ Votes will be auto-saved after each vote';
            }

            return `
                <div class="bg-amber-50 border border-amber-200 dark:bg-amber-900/20 dark:border-amber-700 rounded-lg px-3 py-2 mb-3">
                    <div class="flex items-center gap-2">
                        <p class="text-xs text-amber-800 dark:text-amber-300 flex-1 min-w-0">${statusText}</p>
                        <button
                            onclick="manualSaveVotes()"
                            class="flex items-center gap-1 px-2.5 py-1 rounded-lg text-xs font-semibold bg-green-100 dark:bg-green-900/40 text-green-700 dark:text-green-300 hover:bg-green-200 dark:hover:bg-green-900/70 border border-green-300 dark:border-green-700 transition flex-shrink-0"
                            title="Save all current votes as a draft right now"
                        >
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"/>
                            </svg>
                            Save now
                        </button>
                        <button
                            onclick="discardCurrentDraftFromVoting()"
                            class="flex items-center gap-1 px-2.5 py-1 rounded-lg text-xs font-semibold bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/40 border border-red-300 dark:border-red-700 transition flex-shrink-0"
                            title="Discard saved draft and start fresh"
                        >
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                            </svg>
                            Discard draft
                        </button>
                    </div>
                </div>
            `;
        }

        // Toggle "Continue Draft" section expansion
        function toggleAutosaveDraftSection() {
            state.isAutosaveDraftExpanded = !state.isAutosaveDraftExpanded;
            render();
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        async function loadActivityLogs() {
            try {
                state.activityLogsLoading = true;
                render(); // Show loading state

                // Use state dates or default to last 7 days
                const now = new Date();
                let weekStart, weekEnd;

                if (state.activityDateStart || state.activityDateEnd) {
                    // Use provided dates, or compute defaults
                    if (state.activityDateStart) {
                        weekStart = new Date(state.activityDateStart);
                        weekStart.setHours(0, 0, 0, 0); // Start of day
                    } else {
                        // If no start date, default to 7 days before end date
                        weekStart = state.activityDateEnd ? new Date(state.activityDateEnd) : new Date(now);
                        weekStart.setDate(weekStart.getDate() - 7);
                        weekStart.setHours(0, 0, 0, 0);
                    }

                    if (state.activityDateEnd) {
                        weekEnd = new Date(state.activityDateEnd);
                        weekEnd.setHours(23, 59, 59, 999); // End of day
                    } else {
                        // If no end date, default to today
                        weekEnd = new Date(now);
                        weekEnd.setHours(23, 59, 59, 999);
                    }
                } else {
                    // Both dates are null, use default last 7 days
                    weekStart = new Date(now);
                    weekStart.setDate(now.getDate() - 7);
                    weekStart.setHours(0, 0, 0, 0);
                    weekEnd = new Date(now);
                    weekEnd.setHours(23, 59, 59, 999);
                }

                const weekStartISO = weekStart.toISOString();
                const weekEndISO = weekEnd.toISOString();
                console.log('Recent Activity - Week Start:', weekStartISO, '| Week End:', weekEndISO);

                // Query votes from the date range with pagination (2000 row limit per query)
                let votes = [];
                let offset = 0;
                const limit = 2000;
                while (true) {
                    const votesResponse = await fetch(
                        `${SUPABASE_URL}/rest/v1/votes?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=${limit}&offset=${offset}&select=user_id,contest_id,created_at,voter:users!votes_user_id_fkey(username,avatar)&order=created_at.desc`,
                        {
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Cache-Control': 'no-cache'
                            }
                        }
                    );

                    if (!votesResponse.ok) {
                        console.error('Votes fetch failed:', votesResponse.status, votesResponse.statusText);
                        throw new Error('Failed to fetch vote activity logs');
                    }

                    const batch = await votesResponse.json();
                    votes.push(...batch);

                    // If we got less than the limit, we've fetched all data
                    if (batch.length < limit) break;

                    offset += limit;
                }

                // Query contest creations from the date range
                const contestsResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/contests?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=2000&select=id,title,created_at,created_by,creator:users!contests_created_by_fkey(username,avatar)&order=created_at.desc`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                // Query merger creations from the date range
                const mergersResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/mergers?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=2000&select=id,name,created_at,created_by,creator:users!mergers_created_by_fkey(username,avatar)&order=created_at.desc`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                // Query extract creations from the date range
                const extractsResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/extracts?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=2000&select=id,name,created_at,created_by,creator:users!extracts_created_by_fkey(username,avatar)&order=created_at.desc`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                // Query user signups from the date range
                const usersResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/users?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=2000&select=id,username,avatar,created_at&order=created_at.desc`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                const contests = contestsResponse.ok ? await contestsResponse.json() : [];
                const mergers = mergersResponse.ok ? await mergersResponse.json() : [];
                const extracts = extractsResponse.ok ? await extractsResponse.json() : [];
                const users = usersResponse.ok ? await usersResponse.json() : [];

                console.log('Recent Activity Data:', {
                    votes: votes.length,
                    contests: contests.length,
                    mergers: mergers.length,
                    extracts: extracts.length,
                    users: users.length,
                    voteSample: votes[0],
                    contestSample: contests[0],
                    userSample: users[0]
                });

                // Group votes by user-contest combination and check if voting is complete
                const activityMap = new Map();
                const votesByUserContest = new Map(); // Group all votes by user-contest

                // Group all votes by user-contest combination
                votes.forEach(vote => {
                    const key = `${vote.user_id}-${vote.contest_id}`;
                    if (!votesByUserContest.has(key)) {
                        votesByUserContest.set(key, []);
                    }
                    votesByUserContest.get(key).push(vote);
                });

                // Analyze each user-contest combination to determine voting portions
                votesByUserContest.forEach((userVotes, key) => {
                    // Sort votes by timestamp
                    userVotes.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

                    // Get contest info
                    const contest = state.contests.find(c => c.id === userVotes[0].contest_id);
                    const totalImages = contest?.images?.length || 0;

                    // Group votes into portions based on time gaps (> 1 hour = new portion)
                    const portions = [];
                    let currentPortion = [userVotes[0]];

                    for (let i = 1; i < userVotes.length; i++) {
                        const prevTime = new Date(userVotes[i - 1].created_at);
                        const currTime = new Date(userVotes[i].created_at);
                        const timeDiff = (currTime - prevTime) / (1000 * 60 * 60); // hours

                        if (timeDiff > 1) {
                            // New portion - significant time gap
                            portions.push(currentPortion);
                            currentPortion = [userVotes[i]];
                        } else {
                            currentPortion.push(userVotes[i]);
                        }
                    }
                    portions.push(currentPortion); // Add last portion

                    // For each portion, create an activity entry
                    // First portion is always "voted on", subsequent portions are "completed voting on"
                    portions.forEach((portion, portionIndex) => {
                        const isFirstPortion = portionIndex === 0;
                        const latestVoteInPortion = portion[portion.length - 1];
                        const activityKey = `vote-${key}-${portionIndex}`;

                        activityMap.set(activityKey, {
                            type: isFirstPortion ? 'vote' : 'vote_completed',
                            userId: latestVoteInPortion.user_id,
                            username: latestVoteInPortion.voter?.username || 'Unknown User',
                            avatar: latestVoteInPortion.voter?.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${latestVoteInPortion.user_id}`,
                            contestId: latestVoteInPortion.contest_id,
                            contestTitle: contest?.title || 'Unknown Contest',
                            timestamp: latestVoteInPortion.created_at,
                            voteCount: userVotes.length,
                            totalImages: totalImages
                        });
                    });
                });

                // Add contest creations
                contests.forEach(contest => {
                    activityMap.set(`contest-${contest.id}`, {
                        type: 'contest',
                        userId: contest.created_by,
                        username: contest.creator?.username || 'Unknown User',
                        avatar: contest.creator?.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${contest.created_by}`,
                        itemId: contest.id,
                        itemName: contest.title,
                        timestamp: contest.created_at
                    });
                });

                // Add merger creations
                mergers.forEach(merger => {
                    activityMap.set(`merger-${merger.id}`, {
                        type: 'merger',
                        userId: merger.created_by,
                        username: merger.creator?.username || 'Unknown User',
                        avatar: merger.creator?.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${merger.created_by}`,
                        itemId: merger.id,
                        itemName: merger.name,
                        timestamp: merger.created_at
                    });
                });

                // Add extract creations
                extracts.forEach(extract => {
                    activityMap.set(`extract-${extract.id}`, {
                        type: 'extract',
                        userId: extract.created_by,
                        username: extract.creator?.username || 'Unknown User',
                        avatar: extract.creator?.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${extract.created_by}`,
                        itemId: extract.id,
                        itemName: extract.name,
                        timestamp: extract.created_at
                    });
                });

                // Add user signups
                users.forEach(user => {
                    activityMap.set(`user-${user.id}`, {
                        type: 'signup',
                        userId: user.id,
                        username: user.username || 'Unknown User',
                        avatar: user.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${user.id}`,
                        timestamp: user.created_at
                    });
                });

                // Convert to array and sort by timestamp (most recent first)
                state.activityLogs = Array.from(activityMap.values()).sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                console.log('Recent Activity - Final count:', state.activityLogs.length, 'activities');
                if (state.activityLogs.length > 0) {
                    console.log('Sample activities:', state.activityLogs.slice(0, 3));
                }

                state.activityLogsLoading = false;
                render();
            } catch (error) {
                console.error('Error loading activity logs:', error);
                state.activityLogsLoading = false;
                showToast('Failed to load activity logs', 'error');
                render();
            }
        }

        function showActivityLogs() {
            state.showActivityLogsModal = true;
            loadActivityLogs();
        }

        function closeActivityLogs() {
            state.showActivityLogsModal = false;
            render();
        }

        function setActivityStartDate(value) {
            state.activityDateStart = value;
            loadActivityLogs();
        }

        function setActivityEndDate(value) {
            state.activityDateEnd = value;
            loadActivityLogs();
        }

        function setActivityFilterUser(userId) {
            state.activityFilterUser = userId || null;
            render();
        }

        function setActivityFilterContest(contestId) {
            state.activityFilterContest = contestId || null;
            render();
        }

        function setActivityFilterAction(actionType) {
            state.activityFilterAction = actionType || null;
            render();
        }

        // --- ADD: ensureLocalUser (insert this near other helper functions) ---
        function ensureLocalUser(user) {
            // returns a Promise that resolves when the user exists (or after insertion)
            console.log('üë§ Ensuring user exists in database:', user.id, user.username);
            return fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${user.id}`, {
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'Cache-Control': 'no-cache'
                }
            })
            .then(r => r.json())
            .then(rows => {
                if (rows.length === 0) {
                    console.log('üë§ User not found in database, creating new user');
                    // create the user row in public.users
                    return fetch(`${SUPABASE_URL}/rest/v1/users`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify({
                            id: user.id,
                            username: user.username,
                            avatar: user.avatar
                        })
                    }).then(resp => {
                        // If the insert fails, still let caller continue but log error
                        if (!resp.ok) {
                            return resp.text().then(t => {
                                console.error('‚ùå Failed to insert local user:', t);
                                console.error('‚ùå Response status:', resp.status);
                                console.error('‚ùå User data:', { id: user.id, username: user.username, avatar: user.avatar });
                                // swallow error to avoid locking login flow; caller can handle later
                                return;
                            });
                        } else {
                            console.log('‚úÖ User successfully created in database');
                        }
                    });
                } else {
                    console.log('‚úÖ User already exists in database');
                }
                // user already exists: resolve immediately
                return;
            })
            .catch(err => {
                console.error('‚ùå ensureLocalUser error:', err);
                // resolve anyway so login flow continues; caller may show an error later
                return;
            });
        }
        // --- END ADD ---

        // Helper function to load images with proper tracking
        function loadImagesWithTracking(images) {
            return new Promise((resolve) => {
                const MAX_TIMEOUT = 10000; // 10 seconds max timeout
                let loadedCount = 0;
                let hasCompleted = false;

                // Timeout fallback
                const timeoutId = setTimeout(() => {
                    if (!hasCompleted) {
                        hasCompleted = true;
                        state.isLoadingMultiModeImages = false;
                        render();
                        resolve();
                    }
                }, MAX_TIMEOUT);

                // If no images, resolve immediately
                if (!images || images.length === 0) {
                    clearTimeout(timeoutId);
                    state.isLoadingMultiModeImages = false;
                    render();
                    resolve();
                    return;
                }

                // Create image load promises
                const imagePromises = images.map((img, index) => {
                    return new Promise((resolveImg) => {
                        const imageObj = new Image();

                        const onLoadOrError = () => {
                            if (!hasCompleted) {
                                loadedCount++;
                                state.multiModeLoadedImages = loadedCount;
                                render();
                                resolveImg();
                            }
                        };

                        imageObj.onload = onLoadOrError;
                        imageObj.onerror = onLoadOrError; // Count errors as loaded to prevent hanging
                        imageObj.src = img.url;
                    });
                });

                // Wait for all images to load
                Promise.all(imagePromises).then(() => {
                    if (!hasCompleted) {
                        hasCompleted = true;
                        clearTimeout(timeoutId);
                        state.isLoadingMultiModeImages = false;
                        render();
                        resolve();
                    }
                });
            });
        }

        function startVoting(contest, loadAutosaves = false) {
            state.currentContest = contest;
            state.shuffledImages = shuffleArray(contest.images);
            state.votes = {};
            state.currentImageIndex = 0;
            state.hasSubmitted = false;
            state.results = null;
            state.view = 'vote';

            // Set auto-save context (only for regular contests, not extracts)
            if (!contest.isExtract) {
                state.autosaveContext = { type: 'contest', id: contest.id };
                // Pre-populate votes from autosaves when resuming a draft
                if (loadAutosaves) {
                    const autosaveKey = `contest_${contest.id}`;
                    const autosaves = state.userAutosavedVotes[autosaveKey] || {};
                    Object.entries(autosaves).forEach(([imgId, score]) => {
                        state.votes[parseInt(imgId)] = score;
                    });
                }
            } else {
                state.autosaveContext = { type: null, id: null };
            }

            // Load voting mode preference from localStorage, default to 'multi'
            const savedVotingMode = localStorage.getItem('peony_voting_mode');
            state.votingMode = savedVotingMode || 'multi';

            // Clear merger context (we're voting on a single contest)
            state.currentMergerId = null;
            state.mergerContestIds = [];

            // Update URL hash for shareable link
            window.location.hash = `contest=${contest.id}`;

            // Show loading modal if starting in multi mode
            if (state.votingMode === 'multi') {
                state.isLoadingMultiModeImages = true;
                state.multiModeLoadedImages = 0;
                state.multiModeTotalImages = state.shuffledImages.length;
                render();

                // Load images with tracking, hide modal when done or after 10s timeout
                loadImagesWithTracking(state.shuffledImages);
            } else {
                // Show brief transition modal for single mode
                state.isTransitioningVotingMode = true;
                render();
                setTimeout(() => {
                    state.isTransitioningVotingMode = false;
                    render();
                }, 400);
            }
        }

        async function viewResults(contest) {
            // Skip database check for extracts
            const isExtract = contest.isExtract === true;

            if (!isExtract) {
                // Check if contest still exists in the database
                try {
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contest.id}&select=*`, {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    });

                    const contests = await response.json();

                    // If contest doesn't exist (deleted), refresh the page
                    if (!contests || contests.length === 0) {
                        console.log('Contest no longer exists, refreshing...');
                        showAlert('Contest was deleted. Refreshing...', 'üîÑ');
                        setTimeout(() => location.reload(), 1500);
                        return;
                    }

                    // Check if results are public
                    const contestData = contests[0];
                    const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                    const isCreator = state.user && state.user.id === contestData.created_by;
                    const resultsPublic = contestData.results_public !== false;
                    const hasVoted = !!state.userVotedContests[contest.id];

                    // For hidden results, allow viewing with restrictions if user has voted
                    if (!resultsPublic && !isAdmin && !isCreator && !hasVoted) {
                        showAlert('Results are private. Only voters, the creator, or admin can view them.', 'üîí');
                        return;
                    }
                } catch (error) {
                    console.error('Error checking contest existence:', error);
                    showAlert('Error loading results: ' + error.message, '‚ùå');
                    return;
                }
            }

            state.currentContest = contest;
            const userVotes = state.userVotedContests[contest.id] || {};
            state.votes = userVotes;
            await loadResults();
            state.showMyVotes = false;

            // For hidden results, default to userVotes tab (showing own votes only)
            const isPrivate = contest.resultsPublic === false;
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === contest.createdBy;
            if (isPrivate && !isAdmin && !isCreator) {
                state.resultsView = 'userVotes';
                state.selectedVoterUserId = state.user.id;
            } else {
                state.resultsView = 'average'; // Default to average for public results
            }

            state.view = 'results';

            // Update URL hash for shareable link (only for real contests, not extracts)
            if (!isExtract) {
                window.location.hash = `contest=${contest.id}`;
            }

            render();
        }

        async function viewLockedResults(contest) {
            // Check if results are public
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === contest.createdBy;
            const resultsPublic = contest.resultsPublic !== false;

            if (!resultsPublic && !isAdmin && !isCreator) {
                showAlert('Results are private. Only the creator or admin can view them.', 'üîí');
                return;
            }

            state.currentContest = contest;
            state.votes = {};
            await loadResults();
            state.showMyVotes = false;
            state.view = 'results';
            render();
        }

        // Admin bypass functions - allow viewing results without voting requirement
        async function adminViewResults(contestOrId) {
            setLoading('Loading results...');
            try {
                // Handle both contest object and contest ID
                let contest;
                if (typeof contestOrId === 'string') {
                    // It's an ID, look up the contest
                    contest = state.contests.find(c => c.id === contestOrId);
                    if (!contest) {
                        throw new Error('Contest not found');
                    }
                } else {
                    // It's already a contest object
                    contest = contestOrId;
                }

                state.currentContest = contest;
                state.votes = {};
                await loadResults();
                state.showMyVotes = false;
                state.view = 'results';
                window.location.hash = `contest=${contest.id}`;
                clearLoading();
                render();
            } catch (error) {
                console.error('Error loading results:', error);
                clearLoading();
                showAlert('Error loading results: ' + error.message, '‚ùå');
            }
        }

        async function adminViewMergerResults(mergerId) {
            setLoading('Loading merger results...');
            try {
                const merger = state.mergers.find(m => m.id === mergerId);
                if (!merger) {
                    showAlert('Merger not found', '‚ùå');
                    clearLoading();
                    return;
                }

                state.currentMergerId = mergerId;
                state.mergerContestIds = merger.contestIds;
                state.votes = {};
                await loadMergedResults(mergerId);
                state.view = 'mergedResults';
                window.location.hash = `merger=${mergerId}`;
                clearLoading();
                render();
            } catch (error) {
                console.error('Error loading merger results:', error);
                clearLoading();
                showAlert('Error loading merger results: ' + error.message, '‚ùå');
            }
        }

        async function adminViewExtractResults(extractId) {
            setLoading('Loading extract results...');
            try {
                const extract = state.extracts.find(e => e.id === extractId);
                if (!extract) {
                    showAlert('Extract not found', '‚ùå');
                    clearLoading();
                    return;
                }

                // Navigate to the extract's results view
                await viewExtractResults(extractId);
                clearLoading();
            } catch (error) {
                console.error('Error loading extract results:', error);
                clearLoading();
                showAlert('Error loading extract results: ' + error.message, '‚ùå');
            }
        }

        function startRevoteFromHome(contest) {
            // Set the current contest first
            state.currentContest = contest;
            // Then call the standard revote flow
            startRevote();
        }

        function startRevote() {
            // Show confirmation modal with options to start fresh or preload existing votes
            state.modal = {
                type: 'confirm',
                icon: 'üîÑ',
                message: 'How would you like to revote?',
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Start Fresh', action: 'confirmRevote', primary: true },
                    { text: 'Preload Previous Votes', action: 'confirmRevoteWithPrefill', primary: false, color: 'blue' }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function confirmRevote() {
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Clear any pending auto-save and delete existing autosaves (starting fresh)
            clearTimeout(autoSaveTimer);
            if (state.currentContest && !state.currentContest.isExtract) {
                deleteAutosaves('contest', state.currentContest.id);
            }

            // Reset voting state with clean slate
            state.votes = {};
            state.hasSubmitted = false;
            state.shuffledImages = shuffleArray(state.currentContest.images);
            state.currentImageIndex = 0;
            state.view = 'vote';

            // Set fresh autosave context
            if (state.currentContest && !state.currentContest.isExtract) {
                state.autosaveContext = { type: 'contest', id: state.currentContest.id };
            }

            render();
        }

        async function confirmRevoteWithPrefill() {
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Clear any pending auto-save and delete existing autosaves (starting fresh revote)
            clearTimeout(autoSaveTimer);
            if (state.currentContest && !state.currentContest.isExtract) {
                await deleteAutosaves('contest', state.currentContest.id);
            }

            setLoading('Loading your previous votes...');

            try {
                // Fetch user's previous votes for this contest
                const userVotes = await fetchAllVotesPaginated(
                    `contest_id=eq.${state.currentContest.id}&user_id=eq.${state.user.id}`,
                    'image_id,score'
                );

                // Prefill votes from previous submission
                state.votes = {};
                userVotes.forEach(vote => {
                    state.votes[vote.image_id] = vote.score;
                });

                // Set up voting state
                state.hasSubmitted = false;
                state.shuffledImages = shuffleArray(state.currentContest.images);
                state.currentImageIndex = 0;
                state.view = 'vote';

                // Set autosave context for fresh revote session
                if (state.currentContest && !state.currentContest.isExtract) {
                    state.autosaveContext = { type: 'contest', id: state.currentContest.id };
                }

                clearLoading();
                render();

                // Show toast to confirm prefill
                showToast('Previous votes loaded!', 'success');
            } catch (error) {
                console.error('Error loading previous votes:', error);
                clearLoading();
                showAlert('Failed to load previous votes. Starting fresh instead.', '‚ùå');

                // Fall back to fresh start
                confirmRevote();
            }
        }

        function startRevoteFromHomeMerger(merger) {
            // Set the current merger first
            state.currentMergerId = merger.id;
            state.currentMerger = merger;
            // Then call the standard revote flow
            startRevoteMerger();
        }

        function startRevoteMerger() {
            // Show confirmation modal with options to start fresh or preload existing votes
            state.modal = {
                type: 'confirm',
                icon: 'üîÑ',
                message: 'How would you like to revote?',
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Start Fresh', action: 'confirmRevoteMerger', primary: true },
                    { text: 'Preload Previous Votes', action: 'confirmRevoteMergerWithPrefill', primary: false, color: 'blue' }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        async function confirmRevoteMerger() {
            const mergerId = state.currentMergerId;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Clear any pending auto-save and delete existing autosaves (starting fresh)
            clearTimeout(autoSaveTimer);
            if (mergerId) await deleteAutosaves('merger', mergerId);

            // Start merger voting with fresh slate (revoteAll = true)
            await startMergerVoting(mergerId, true);
        }

        async function confirmRevoteMergerWithPrefill() {
            const mergerId = state.currentMergerId;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Clear any pending auto-save and delete existing autosaves (starting fresh revote)
            clearTimeout(autoSaveTimer);
            if (mergerId) await deleteAutosaves('merger', mergerId);

            setLoading('Loading your previous votes...');

            try {
                const merger = state.mergers.find(m => m.id === state.currentMergerId);
                if (!merger) {
                    throw new Error('Merger not found');
                }

                // Get all contests in the merger
                const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                const unlockedContests = mergedContests.filter(c => !c.isLocked);

                if (unlockedContests.length === 0) {
                    throw new Error('All contests in this merger are locked');
                }

                // Fetch user's previous votes for all contests in the merger
                const allUserVotes = [];
                for (const contest of unlockedContests) {
                    const contestVotes = await fetchAllVotesPaginated(
                        `contest_id=eq.${contest.id}&user_id=eq.${state.user.id}`,
                        'image_id,score'
                    );
                    allUserVotes.push(...contestVotes);
                }

                // Prefill votes from previous submissions
                state.votes = {};
                allUserVotes.forEach(vote => {
                    state.votes[vote.image_id] = vote.score;
                });

                // Collect all images from unlocked contests
                const allImages = unlockedContests.flatMap(c => c.images);
                state.mergerContestIds = unlockedContests.map(c => c.id);

                // Set up voting state
                state.hasSubmitted = false;
                state.shuffledImages = shuffleArray(allImages);
                state.currentImageIndex = 0;
                state.view = 'vote';

                // Load voting mode preference from localStorage, default to 'multi'
                const savedVotingMode = localStorage.getItem('peony_voting_mode');
                state.votingMode = savedVotingMode || 'multi';

                // Set currentContest to null to indicate merger voting mode
                state.currentContest = null;

                // Set autosave context for this revote session
                state.autosaveContext = { type: 'merger', id: state.currentMergerId };

                // Update URL hash for shareable link
                window.location.hash = `merger=${state.currentMergerId}`;

                // Show loading modal if starting in multi mode
                if (state.votingMode === 'multi') {
                    state.isLoadingMultiModeImages = true;
                }

                clearLoading();
                render();

                // Show toast to confirm prefill
                showToast('Previous votes loaded!', 'success');
            } catch (error) {
                console.error('Error loading previous votes:', error);
                clearLoading();
                showAlert('Failed to load previous votes. Starting fresh instead.', '‚ùå');

                // Fall back to fresh start
                await startMergerVoting(state.currentMergerId, true);
            }
        }

        async function toggleContestLock(itemId) {
            // Find item across all types
            let item = state.contests.find(c => c.id === itemId);
            let itemType = 'contest';
            let tableName = 'contests';

            if (!item) {
                item = state.mergers.find(m => m.id === itemId);
                itemType = 'merger';
                tableName = 'mergers';
            }
            if (!item) {
                item = state.extracts.find(e => e.id === itemId);
                itemType = 'extract';
                tableName = 'extracts';
            }
            if (!item) return;

            // Only the creator or admin can lock/unlock
            if (item.createdBy !== state.user.id && state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Only the creator or admin can lock/unlock this item.', 'üîí');
                return;
            }

            const newLockStatus = !item.isLocked;

            try {
                // Update database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/${tableName}?id=eq.${itemId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_locked: newLockStatus
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Lock status update failed:', errorData);
                    throw new Error(errorData.message || 'Failed to update lock status');
                }

                // Update local state only if database update succeeded
                item.isLocked = newLockStatus;
                const itemLabel = itemType.charAt(0).toUpperCase() + itemType.slice(1);
                showAlert(item.isLocked ? `üîí ${itemLabel} locked - Users cannot vote` : `üîì ${itemLabel} unlocked - Users can now vote`, item.isLocked ? 'üö®' : '‚úÖ');
                render();
            } catch (error) {
                console.error('Full lock toggle error:', error);
                showAlert('Failed to update lock status: ' + error.message, '‚ùå');
            }
        }

        async function toggleResultsPublic(itemId) {
            try {
                // Find item across all types
                let item = state.contests.find(c => c.id === itemId);
                let tableName = 'contests';

                if (!item) {
                    item = state.mergers.find(m => m.id === itemId);
                    tableName = 'mergers';
                }
                if (!item) {
                    item = state.extracts.find(e => e.id === itemId);
                    tableName = 'extracts';
                }

                if (!item) {
                    throw new Error('Item not found');
                }

                // Check if user is creator or admin
                const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                const isCreator = state.user && state.user.id === item.createdBy;

                if (!isAdmin && !isCreator) {
                    showAlert('Only the creator or admin can toggle results visibility', '‚ùå');
                    return;
                }

                const newPublicStatus = !item.resultsPublic;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/${tableName}?id=eq.${itemId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        results_public: newPublicStatus
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Results public update failed:', errorData);
                    throw new Error(errorData.message || 'Failed to update results visibility');
                }

                // Update local state only if database update succeeded
                item.resultsPublic = newPublicStatus;
                showAlert(item.resultsPublic ? 'üëÅÔ∏è Results public - Everyone can view' : 'üîí Results hidden - Only you can view', item.resultsPublic ? 'üëÅÔ∏è' : 'üîí');
                render();
            } catch (error) {
                console.error('Results public toggle error:', error);
                showAlert('Failed to update results visibility: ' + error.message, '‚ùå');
            }
        }

        // ==================== MERGER SYSTEM FUNCTIONS ====================

        function openCreateMergerModal() {
            state.showCreateMergerModal = true;
            state.selectedContestsForMerge = [];
            state.newMergerName = '';
            document.body.classList.add('modal-open');
            render();
        }

        function closeCreateMergerModal() {
            state.showCreateMergerModal = false;
            state.selectedContestsForMerge = [];
            state.newMergerName = '';
            document.body.classList.remove('modal-open');
            render();
        }

        function openUnifiedCreateModal() {
            state.showUnifiedCreateModal = true;
            document.body.classList.add('modal-open');
            render();
        }

        function closeUnifiedCreateModal() {
            state.showUnifiedCreateModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        function toggleContestForMerger(contestId) {
            if (!state.selectedContestsForMerge) {
                state.selectedContestsForMerge = [];
            }

            const index = state.selectedContestsForMerge.indexOf(contestId);
            if (index > -1) {
                state.selectedContestsForMerge.splice(index, 1);
            } else {
                state.selectedContestsForMerge.push(contestId);
            }

            // Preserve scroll position
            const modalContent = document.querySelector('.modal-content .overflow-y-auto');
            const scrollTop = modalContent ? modalContent.scrollTop : 0;

            render();

            // Restore scroll position after render
            setTimeout(() => {
                const newModalContent = document.querySelector('.modal-content .overflow-y-auto');
                if (newModalContent && scrollTop > 0) {
                    newModalContent.scrollTop = scrollTop;
                }
            }, 0);
        }

        function setMergerName(name) {
            state.newMergerName = name;
            // Don't render to avoid input blur - button state will be updated on blur
        }

        function updateMergerNameOnBlur() {
            const input = document.getElementById('merger-name-input');
            if (input) {
                state.newMergerName = input.value;
                render();
            }
        }

        async function saveMerger() {
            if (state.selectedContestsForMerge.length < 2) {
                showToast('Please select at least 2 contests', 'error');
                return;
            }

            if (!state.newMergerName || state.newMergerName.trim() === '') {
                showToast('Please enter a name for the merger', 'error');
                return;
            }

            setLoading('Creating merger...');

            try {
                // Save to mergers table
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify({
                        name: state.newMergerName.trim(),
                        created_by: state.user.id,
                        contest_ids: state.selectedContestsForMerge
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Merger creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create merger');
                }

                // Reload mergers
                await loadMergers();

                showToast('Merger created successfully!', 'success');
                closeCreateMergerModal();
            } catch (error) {
                console.error('Error creating merger:', error);
                showToast('Failed to create merger: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        function openEditMergerModal(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Store the merger being edited
            state.editingMergerId = mergerId;
            state.editMergerSelectedContests = [...merger.contestIds]; // Copy current contest IDs
            state.showEditMergerModal = true;
            document.body.classList.add('modal-open');
            render();
        }

        function closeEditMergerModal() {
            state.showEditMergerModal = false;
            state.editingMergerId = null;
            state.editMergerSelectedContests = [];
            document.body.classList.remove('modal-open');
            render();
        }

        function toggleContestForEditMerger(contestId) {
            if (!state.editMergerSelectedContests) {
                state.editMergerSelectedContests = [];
            }

            const index = state.editMergerSelectedContests.indexOf(contestId);
            if (index > -1) {
                // Remove contest
                state.editMergerSelectedContests.splice(index, 1);
            } else {
                // Add contest
                state.editMergerSelectedContests.push(contestId);
            }

            // Preserve scroll position
            const modalContent = document.querySelector('.modal-content .overflow-y-auto');
            const scrollTop = modalContent ? modalContent.scrollTop : 0;

            render();

            // Restore scroll position after render
            setTimeout(() => {
                const newModalContent = document.querySelector('.modal-content .overflow-y-auto');
                if (newModalContent && scrollTop > 0) {
                    newModalContent.scrollTop = scrollTop;
                }
            }, 0);
        }

        async function saveEditedMerger() {
            const mergerId = state.editingMergerId;
            const merger = state.mergers.find(m => m.id === mergerId);

            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            if (state.editMergerSelectedContests.length < 2) {
                showAlert('Please select at least 2 contests', '‚ùå');
                return;
            }

            try {
                setLoading('Saving merger...');

                // Validate that contest_ids is an array
                if (!Array.isArray(state.editMergerSelectedContests)) {
                    throw new Error('Invalid contest selection');
                }

                // Verify user is logged in
                if (!state.user || !state.user.id) {
                    throw new Error('You must be logged in to update mergers');
                }

                // Verify user owns this merger
                if (merger.createdBy !== state.user.id) {
                    throw new Error('You can only update mergers you created');
                }

                console.log('üîÑ Updating merger:', {
                    mergerId,
                    userId: state.user.id,
                    currentContestIds: merger.contestIds,
                    newContestIds: state.editMergerSelectedContests
                });

                // Update merger in database with user context
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?id=eq.${mergerId}&created_by=eq.${state.user.id}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation',
                        'Cache-Control': 'no-cache',
                        'X-Client-Info': JSON.stringify({ user_id: state.user.id })
                    },
                    body: JSON.stringify({
                        contest_ids: state.editMergerSelectedContests
                    })
                });

                console.log('üì° Response status:', response.status, response.statusText);

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('‚ùå Merger update failed:', {
                        status: response.status,
                        error: errorData,
                        mergerId,
                        userId: state.user.id
                    });

                    // Provide specific error messages
                    if (response.status === 403) {
                        throw new Error('Permission denied: RLS policy may be blocking this update. Check that you own this merger.');
                    } else if (response.status === 404) {
                        throw new Error('Merger not found or you do not have permission to update it.');
                    }

                    throw new Error(errorData.message || errorData.hint || `Failed to update merger (${response.status})`);
                }

                // Verify the update by checking the response
                const updatedData = await response.json();
                console.log('‚úÖ Merger updated successfully:', updatedData);

                if (Array.isArray(updatedData) && updatedData.length === 0) {
                    console.warn('‚ö†Ô∏è No rows updated - possible causes:');
                    console.warn('  1. Merger does not exist');
                    console.warn('  2. RLS policy is blocking the update');
                    console.warn('  3. User does not own this merger');
                    console.warn('  Current user ID:', state.user.id);
                    console.warn('  Merger created_by:', merger.createdBy);
                    throw new Error('Update failed: No rows were updated. You may not have permission to edit this merger.');
                }

                // Reload mergers to get updated data
                await loadMergers();

                // If currently viewing this merger's results, reload them
                if (state.view === 'mergedResults' && state.currentMergerId === mergerId) {
                    const updatedMerger = state.mergers.find(m => m.id === mergerId);
                    if (updatedMerger) {
                        await loadMergedResults(updatedMerger.contestIds);
                    }
                }

                closeEditMergerModal();
                showToast('Merger updated successfully', 'success');
            } catch (error) {
                console.error('Error updating merger:', error);
                showToast('Failed to update merger: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        function deleteMerger(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) return;

            // Store merger info for validation
            state.mergerToDelete = merger;

            showInputModal(
                `Type "${merger.name}" to confirm deletion`,
                'Enter merger name exactly...',
                'handleDeleteMergerConfirmation',
                false
            );
        }

        function handleDeleteMergerConfirmation() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const enteredName = input ? input.value.trim() : '';

            if (!state.mergerToDelete) {
                showAlert('Merger information not found.', '‚ùå');
                return;
            }

            if (enteredName !== state.mergerToDelete.name) {
                showAlert('Name does not match. Deletion cancelled.', '‚ùå');
                return;
            }

            // Name matches, proceed with deletion
            confirmDeleteMerger(state.mergerToDelete.id);
        }

        async function confirmDeleteMerger(mergerId) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            setLoading('Deleting merger...');

            try {
                // Delete only the merger record, leave contests intact
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?id=eq.${mergerId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete merger');
                }

                await loadMergers();
                state.modalProcessing = false;
                showAlert('Merger deleted successfully!', '‚úÖ');
            } catch (error) {
                console.error('Error deleting merger:', error);
                showAlert('Failed to delete merger: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            } finally {
                clearLoading();
            }
        }

        async function viewMergerResults(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Check permissions (admin/creator can view)
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === merger.createdBy;

            // Check if all source contests have public results
            if (!isAdmin && !isCreator) {
                const hasPrivateContest = mergedContests.some(c => c.resultsPublic === false && c.createdBy !== state.user.id);
                if (hasPrivateContest) {
                    showAlert('Some contests in this merger have private results. Only the creator or admin can view them.', 'üîí');
                    return;
                }
            }

            // Store current merger for revote functionality
            state.currentMergerId = mergerId;

            // Load merged results and display
            await loadMergedResults(merger.contestIds);
            state.view = 'mergedResults';
            state.resultsView = 'average';
            state.showMyVotes = false;
            render();
        }

        async function startMergerVoting(mergerId, revoteAll = false, loadAutosaves = false) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            if (merger.isLocked) {
                showToast('This merger is locked', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Filter out locked contests (unless revoting all)
            const unlockedContests = mergedContests.filter(c => !c.isLocked);

            if (unlockedContests.length === 0) {
                showToast('All contests in this merger are locked', 'error');
                return;
            }

            // Determine which images to vote on based on user's vote status
            let allImages = [];

            if (revoteAll) {
                // Revote all images in all unlocked contests
                allImages = unlockedContests.flatMap(c => c.images);
                state.mergerContestIds = unlockedContests.map(c => c.id);
            } else {
                // Collect only unvoted images from each contest
                const contestsWithMissingVotes = [];

                unlockedContests.forEach(c => {
                    const userVotes = state.userVotedContests[c.id] || {};
                    const votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
                    const unvotedImages = c.images.filter(img => !votedImageIds.includes(img.id));

                    if (unvotedImages.length > 0) {
                        allImages.push(...unvotedImages);
                        contestsWithMissingVotes.push(c.id);
                    }
                });

                state.mergerContestIds = contestsWithMissingVotes;

                // If no missing votes, include all images (fallback)
                if (allImages.length === 0) {
                    allImages = unlockedContests.flatMap(c => c.images);
                    state.mergerContestIds = unlockedContests.map(c => c.id);
                }
            }

            if (allImages.length === 0) {
                showToast('No images available to vote on', 'error');
                return;
            }

            // Store merger context
            state.currentMergerId = mergerId;
            // mergerContestIds is already set in the if/else block above

            // Shuffle all images together
            state.shuffledImages = shuffleArray(allImages);
            state.votes = {};
            state.currentImageIndex = 0;
            state.hasSubmitted = false;
            state.results = null;
            state.view = 'vote';

            // Set auto-save context for merger voting
            state.autosaveContext = { type: 'merger', id: mergerId };

            // Pre-populate votes from autosaves when resuming a draft
            if (loadAutosaves) {
                const autosaveKey = `merger_${mergerId}`;
                const autosaves = state.userAutosavedVotes[autosaveKey] || {};
                Object.entries(autosaves).forEach(([imgId, score]) => {
                    state.votes[parseInt(imgId)] = score;
                });
            }

            // Load voting mode preference from localStorage, default to 'multi'
            const savedVotingMode = localStorage.getItem('peony_voting_mode');
            state.votingMode = savedVotingMode || 'multi';

            // Set currentContest to null to indicate merger voting mode
            state.currentContest = null;

            // Update URL hash for shareable link
            window.location.hash = `merger=${mergerId}`;

            // Show loading modal if starting in multi mode
            if (state.votingMode === 'multi') {
                state.isLoadingMultiModeImages = true;
                state.multiModeLoadedImages = 0;
                state.multiModeTotalImages = state.shuffledImages.length;
                render();

                // Load images with tracking, hide modal when done or after 10s timeout
                loadImagesWithTracking(state.shuffledImages);
            } else {
                render();
            }
        }

        function revoteMerge() {
            if (!state.currentMergerId) {
                showToast('No merger context found', 'error');
                return;
            }

            // Restart merger voting with revote all flag
            startMergerVoting(state.currentMergerId, true);
        }

        function showMergerVoteModal(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            if (merger.isLocked) {
                showToast('This merger is locked', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Find which contests user hasn't voted in (excluding locked ones)
            const unlockedContests = mergedContests.filter(c => !c.isLocked);

            // Check for contests with incomplete voting
            const contestsWithStatus = unlockedContests.map(c => {
                const userVotes = state.userVotedContests[c.id] || {};
                const votedImageCount = Object.keys(userVotes).length;
                const totalImageCount = c.images.length;
                const hasVotedAll = votedImageCount === totalImageCount && totalImageCount > 0;
                const hasVotedSome = votedImageCount > 0 && votedImageCount < totalImageCount;
                const missingVotes = totalImageCount - votedImageCount;

                return {
                    contest: c,
                    hasVotedAll,
                    hasVotedSome,
                    hasVotedNone: votedImageCount === 0,
                    votedImageCount,
                    totalImageCount,
                    missingVotes
                };
            });

            const fullyVoted = contestsWithStatus.filter(cs => cs.hasVotedAll);
            const partiallyVoted = contestsWithStatus.filter(cs => cs.hasVotedSome);
            const unvoted = contestsWithStatus.filter(cs => cs.hasVotedNone);

            // Build detailed message
            let messageLines = [];
            messageLines.push(`You've fully voted in ${fullyVoted.length} out of ${unlockedContests.length} unlocked contests.`);

            if (partiallyVoted.length > 0) {
                messageLines.push(`\nContests with incomplete voting (${partiallyVoted.length}):`);
                partiallyVoted.forEach(cs => {
                    messageLines.push(`‚Ä¢ ${cs.contest.title}: ${cs.missingVotes} new image(s) added`);
                });
            }

            if (unvoted.length > 0) {
                messageLines.push(`\nUnvoted contests (${unvoted.length}):`);
                unvoted.forEach(cs => {
                    messageLines.push(`‚Ä¢ ${cs.contest.title}`);
                });
            }

            messageLines.push('\nWhat would you like to do?');
            const message = messageLines.join('\n');

            // Store the mergerId for the action functions
            state.pendingMergerId = mergerId;

            state.modal = {
                icon: 'üîÑ',
                title: 'Complete Voting - ' + merger.name,
                message: message,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Vote Missing Only', action: 'confirmVoteMissingOnly', primary: true },
                    { text: 'Revote All', action: 'confirmRevoteAll', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function confirmVoteMissingOnly() {
            const mergerId = state.pendingMergerId;
            state.modal = null;
            state.pendingMergerId = null;
            document.body.classList.remove('modal-open');
            startMergerVoting(mergerId, false);
        }

        function confirmRevoteAll() {
            const mergerId = state.pendingMergerId;
            state.modal = null;
            state.pendingMergerId = null;
            document.body.classList.remove('modal-open');
            // Clear any pending auto-save and delete existing autosaves (starting fresh)
            clearTimeout(autoSaveTimer);
            if (mergerId) deleteAutosaves('merger', mergerId);
            startMergerVoting(mergerId, true);
        }

        async function shareMerger(mergerId) {
            try {
                const shareUrl = `${window.location.origin}${window.location.pathname}#merger=${mergerId}`;

                if (navigator.share) {
                    await navigator.share({
                        title: 'Peony - Merger',
                        text: 'Check out this merged contest!',
                        url: shareUrl
                    });
                    showToast('Share successful!', 'success');
                } else {
                    await navigator.clipboard.writeText(shareUrl);
                    showToast('Link copied to clipboard!', 'success');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Share error:', error);
                    showToast('Failed to share', 'error');
                }
            }
        }

        // Contest "Complete Voting" modal (similar to merger)
        function showContestVoteModal(contestId) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) {
                showToast('Contest not found', 'error');
                return;
            }

            if (contest.isLocked) {
                showToast('This contest is locked', 'error');
                return;
            }

            // Get user's voted images for this contest
            const userVotes = state.userVotedContests[contest.id] || {};
            const votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
            const unvotedImages = contest.images.filter(img => !votedImageIds.includes(img.id));

            // Show modal with options
            const message = `You've voted on ${votedImageIds.length} out of ${contest.images.length} images.\n\nUnvoted images: ${unvotedImages.length}\n\nWhat would you like to do?`;

            // Store the contestId for the action functions
            state.pendingContestId = contestId;

            state.modal = {
                icon: 'üîÑ',
                title: 'Complete Voting - ' + contest.title,
                message: message,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Vote Missing Only', action: 'confirmContestVoteMissingOnly', primary: true },
                    { text: 'Revote All', action: 'confirmContestRevoteAll', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function confirmContestVoteMissingOnly() {
            const contestId = state.pendingContestId;
            state.modal = null;
            state.pendingContestId = null;
            document.body.classList.remove('modal-open');
            startContestVoting(contestId, false);
        }

        function confirmContestRevoteAll() {
            const contestId = state.pendingContestId;
            state.modal = null;
            state.pendingContestId = null;
            document.body.classList.remove('modal-open');
            startContestVoting(contestId, true);
        }

        function startContestVoting(contestId, revoteAll = false) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) {
                showToast('Contest not found', 'error');
                return;
            }

            if (contest.isLocked) {
                showToast('This contest is locked', 'error');
                return;
            }

            // If revoteAll is false, only include unvoted images
            let imagesToVote;
            if (revoteAll) {
                imagesToVote = contest.images;
            } else {
                const userVotes = state.userVotedContests[contest.id] || {};
                const votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
                imagesToVote = contest.images.filter(img => !votedImageIds.includes(img.id));
            }

            if (imagesToVote.length === 0) {
                showToast('No images to vote on', 'info');
                return;
            }

            // Create a temporary contest object with only the images to vote on
            // But keep reference to original contest for results display
            const votingContest = {
                ...contest,
                images: imagesToVote,
                isPartialVoting: !revoteAll,
                originalContestId: contest.id
            };

            startVoting(votingContest);
        }

        // Extract voting redirect modal
        function showExtractVotingRedirectModal(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Determine the source
            let sourceName = '';
            let sourceType = '';
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                sourceName = sourceContest ? sourceContest.title : 'Unknown Contest';
                sourceType = 'contest';
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                sourceName = sourceMerger ? sourceMerger.name : 'Unknown Merger';
                sourceType = 'merger';
            }

            const message = `In order to be able to see this extract's results, you will be prompted to vote in the original ${sourceType}: ${sourceName}`;

            // Store the extractId for the action function
            state.pendingExtractId = extractId;

            state.modal = {
                icon: 'üìã',
                title: 'Vote on Extract',
                message: message,
                buttons: [
                    { text: 'OK', action: 'redirectToExtractSource', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function redirectToExtractSource() {
            const extractId = state.pendingExtractId;
            const extract = state.extracts.find(e => e.id === extractId);

            state.modal = null;
            state.pendingExtractId = null;
            document.body.classList.remove('modal-open');

            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Redirect to source contest or merger voting
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                if (sourceContest) {
                    // Check if user has partially voted
                    const userVotes = state.userVotedContests[sourceContest.id] || {};
                    const votedImageCount = Object.keys(userVotes).length;
                    const hasVotedSome = votedImageCount > 0 && votedImageCount < sourceContest.images.length;

                    // Start voting on the contest
                    startVoting(sourceContest);
                }
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (sourceMerger) {
                    // Check if user has partially voted on the merger
                    const mergedContests = state.contests.filter(c => sourceMerger.contestIds.includes(c.id));
                    const votedContests = mergedContests.filter(c => state.userVotedContests[c.id]);
                    const hasVotedSome = votedContests.length > 0 && votedContests.length < mergedContests.length;

                    if (hasVotedSome) {
                        // Show merger "Complete Voting" modal
                        showMergerVoteModal(sourceMerger.id);
                    } else {
                        // Start voting on the merger
                        startMergerVoting(sourceMerger.id, false);
                    }
                }
            }
        }

        // ==================== END MERGER SYSTEM FUNCTIONS ====================

        // ==================== EXTRACT SYSTEM FUNCTIONS ====================

        function openCreateExtractModal() {
            state.view = 'createExtract';
            state.extractSourceType = null;
            state.extractSourceId = null;
            state.extractSelectedImages = [];
            state.newExtractName = '';
            state.extractContestFilter = 'all'; // For filtering merger contests
            state.extractImageScale = 100;
            render();
        }

        function closeCreateExtractModal() {
            state.view = 'home';
            state.extractSourceType = null;
            state.extractSourceId = null;
            state.extractSelectedImages = [];
            state.newExtractName = '';
            state.extractContestFilter = 'all';
            render();
        }

        function selectExtractSource(sourceType, sourceId) {
            state.extractSourceType = sourceType;
            state.extractSourceId = sourceId;
            state.extractSelectedImages = [];
            state.extractContestFilter = 'all';
            render();
        }

        function setExtractContestFilter(contestId) {
            state.extractContestFilter = contestId;
            render();
        }

        function toggleExtractImage(imageId) {
            if (!state.extractSelectedImages) {
                state.extractSelectedImages = [];
            }

            const index = state.extractSelectedImages.indexOf(imageId);
            if (index > -1) {
                state.extractSelectedImages.splice(index, 1);
            } else {
                state.extractSelectedImages.push(imageId);
            }

            // Update the count display and button state without full re-render to prevent blink
            const countDisplay = document.querySelector('[data-extract-count]');
            if (countDisplay) {
                let sourceName = '';
                if (state.extractSourceType === 'contest') {
                    sourceName = state.contests.find(c => c.id === state.extractSourceId)?.title;
                } else if (state.extractSourceType === 'merger') {
                    sourceName = state.mergers.find(m => m.id === state.extractSourceId)?.name;
                }
                countDisplay.textContent = `From: ${sourceName} (${state.extractSelectedImages.length} selected)`;
            }

            // Update save button state
            const saveButton = document.querySelector('[data-extract-save]');
            if (saveButton) {
                const canSave = state.extractSelectedImages.length > 0 && state.newExtractName;
                saveButton.disabled = !canSave;
                if (canSave) {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700';
                } else {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-300 text-gray-500 cursor-not-allowed';
                }
            }

            // Update the specific checkbox visual
            const imageElement = event?.target?.closest('[data-image-id]');
            if (imageElement) {
                const isSelected = state.extractSelectedImages.includes(imageId);
                const borderDiv = imageElement.querySelector('.relative.cursor-pointer');
                const checkboxDiv = imageElement.querySelector('.absolute.top-2');

                if (borderDiv) {
                    if (isSelected) {
                        borderDiv.className = 'relative cursor-pointer rounded-lg overflow-hidden border-4 border-blue-500 bg-blue-50';
                    } else {
                        borderDiv.className = 'relative cursor-pointer rounded-lg overflow-hidden border-4 border-transparent hover:border-blue-300';
                    }
                }

                if (checkboxDiv) {
                    if (isSelected) {
                        checkboxDiv.innerHTML = `
                            <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                            </svg>
                        `;
                        checkboxDiv.className = 'absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 border-blue-500';
                    } else {
                        checkboxDiv.innerHTML = '<div class="w-4 h-4 border-2 border-gray-400 rounded"></div>';
                        checkboxDiv.className = 'absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 border-gray-300';
                    }
                }
            }
        }

        function setExtractName(name) {
            state.newExtractName = name;
            // Update button state without full render
            updateExtractSaveButtonState();
        }

        function updateExtractImageScale(value) {
            clearTimeout(state.extractScaleUpdateTimeout);
            state.extractScaleUpdateTimeout = setTimeout(() => {
                state.extractImageScale = parseInt(value);
                render();
            }, 200);
        }

        function adjustExtractImageScale(delta) {
            const newScale = Math.max(20, Math.min(250, state.extractImageScale + delta));
            state.extractImageScale = newScale;
            render();
        }

        function updateExtractNameOnBlur() {
            const input = document.getElementById('extract-name-input');
            if (input) {
                state.newExtractName = input.value;
                // Update save button state without full re-render to preserve selection visual state
                updateExtractSaveButtonState();
            }
        }

        function updateExtractSaveButtonState() {
            // Update save button state without full re-render
            const saveButton = document.querySelector('[data-extract-save]');
            if (saveButton) {
                const canSave = state.extractSelectedImages.length > 0 && state.newExtractName && state.newExtractName.trim() !== '';
                saveButton.disabled = !canSave;
                if (canSave) {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700';
                } else {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-300 text-gray-500 cursor-not-allowed';
                }
            }
        }

        async function saveExtract() {
            if (!state.extractSelectedImages || state.extractSelectedImages.length === 0) {
                showToast('Please select at least one image', 'error');
                return;
            }

            if (!state.newExtractName || state.newExtractName.trim() === '') {
                showToast('Please enter a name for the extract', 'error');
                return;
            }

            setLoading('Creating extract...');

            try {
                // Ensure image IDs are integers (convert from any type)
                const imageIds = state.extractSelectedImages.map(id => parseInt(id));

                setLoading('Creating extract...');

                // Get source contest ID
                let sourceContestId = null;
                if (state.extractSourceType === 'contest') {
                    let contest = state.contests.find(c => c.id === state.extractSourceId);
                    if (!contest) {
                        const sourceIdAsNumber = parseInt(state.extractSourceId);
                        if (!isNaN(sourceIdAsNumber)) {
                            contest = state.contests.find(c => c.contestNumber === sourceIdAsNumber);
                        }
                    }
                    if (contest) {
                        sourceContestId = contest.id;
                    }
                } else if (state.extractSourceType === 'merger') {
                    const merger = state.mergers.find(m => m.id === state.extractSourceId);
                    if (merger) {
                        sourceContestId = merger.contestIds;
                    }
                }

                // Image IDs are integers in the database
                const extractData = {
                    name: state.newExtractName.trim(),
                    created_by: state.user.id,
                    source_type: state.extractSourceType,
                    image_ids: imageIds
                };

                // Set source_contest_id based on source type
                // For contests and mergers, store their IDs in source_contest_id
                // The column name says "contest" but it's used for all based on source_type
                if (state.extractSourceType === 'contest') {
                    if (sourceContestId) {
                        extractData.source_contest_id = sourceContestId;
                    } else {
                        throw new Error('Contest not found');
                    }
                } else if (state.extractSourceType === 'merger') {
                    // For mergers, store the merger's id in source_contest_id
                    const merger = state.mergers.find(m => m.id === state.extractSourceId);
                    if (merger) {
                        extractData.source_contest_id = merger.id;
                    } else {
                        throw new Error('Merger not found');
                    }
                } else {
                    throw new Error('Invalid extract source type. Must be contest or merger.');
                }

                // Save to extracts table
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify(extractData)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create extract');
                }

                // Reload extracts
                await loadExtracts();

                showToast('Extract created successfully!', 'success');
                closeCreateExtractModal();
            } catch (error) {
                console.error('Error creating extract:', error);
                showToast('Failed to create extract: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        function confirmDeleteExtract(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) return;

            // Store extract info for validation
            state.extractToDelete = extract;

            showInputModal(
                `Type "${extract.name}" to confirm deletion`,
                'Enter extract name exactly...',
                'handleDeleteExtractConfirmation',
                false
            );
        }

        function handleDeleteExtractConfirmation() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const enteredName = input ? input.value.trim() : '';

            if (!state.extractToDelete) {
                showAlert('Extract information not found.', '‚ùå');
                return;
            }

            if (enteredName !== state.extractToDelete.name) {
                showAlert('Name does not match. Deletion cancelled.', '‚ùå');
                return;
            }

            // Name matches, proceed with deletion
            executeDeleteExtract(state.extractToDelete.id);
        }

        async function executeDeleteExtract(extractId) {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            state.extractToDelete = null;

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?id=eq.${extractId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract deletion failed:', errorData);
                    throw new Error(errorData.message || 'Failed to delete extract');
                }

                // Reload extracts
                await loadExtracts();

                showToast('Extract deleted successfully', 'success');
            } catch (error) {
                console.error('Error deleting extract:', error);
                showToast('Failed to delete extract: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                render();
            }
        }

        // Legacy function name for backwards compatibility
        async function deleteExtract(extractId) {
            confirmDeleteExtract(extractId);
        }

        function openEditExtractModal(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Store the extract being edited
            state.editingExtractId = extractId;
            state.editExtractSelectedImages = [...extract.imageIds]; // Copy current image IDs
            state.view = 'editExtract';
            state.extractImageScale = 100;
            render();
        }

        function closeEditExtractModal() {
            state.view = 'home';
            state.editingExtractId = null;
            state.editExtractSelectedImages = [];
            render();
        }

        function toggleEditExtractImage(imageId) {
            if (!state.editExtractSelectedImages) {
                state.editExtractSelectedImages = [];
            }

            const index = state.editExtractSelectedImages.indexOf(imageId);
            if (index > -1) {
                // Remove image
                state.editExtractSelectedImages.splice(index, 1);
            } else {
                // Add image
                state.editExtractSelectedImages.push(imageId);
            }

            // Preserve scroll position of the modal
            const modalContent = document.querySelector('.fixed.inset-0.modal-overlay[style*="z-index: 60"], .fixed.inset-0.modal-overlay.z-\\[60\\]');
            let scrollContainer = null;
            let scrollTop = 0;

            if (modalContent) {
                scrollContainer = modalContent.querySelector('.overflow-y-auto');
                if (scrollContainer) {
                    scrollTop = scrollContainer.scrollTop;
                }
            }

            render();

            // Restore scroll position after render
            requestAnimationFrame(() => {
                const newModalContent = document.querySelector('.fixed.inset-0.modal-overlay[style*="z-index: 60"], .fixed.inset-0.modal-overlay.z-\\[60\\]');
                if (newModalContent) {
                    const newScrollContainer = newModalContent.querySelector('.overflow-y-auto');
                    if (newScrollContainer && scrollTop > 0) {
                        newScrollContainer.scrollTop = scrollTop;
                    }
                }
            });
        }

        async function saveEditedExtract() {
            const extractId = state.editingExtractId;
            const extract = state.extracts.find(e => e.id === extractId);

            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            if (state.editExtractSelectedImages.length === 0) {
                showAlert('Please select at least one image', '‚ùå');
                return;
            }

            try {
                setLoading('Saving extract...');

                // Update extract in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?id=eq.${extractId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        image_ids: state.editExtractSelectedImages
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract update failed:', errorData);
                    throw new Error(errorData.message || 'Failed to update extract');
                }

                // Reload extracts to get updated data
                await loadExtracts();

                closeEditExtractModal();
                showToast('Extract updated successfully', 'success');
            } catch (error) {
                console.error('Error updating extract:', error);
                showToast('Failed to update extract: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        async function startExtractVoting(extractId, revoteAll = true) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            if (extract.isLocked) {
                showToast('This extract is locked', 'error');
                return;
            }

            // Get source contest to find the images
            let sourceContest = null;
            let sourceImages = [];

            if (extract.sourceType === 'contest') {
                sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                if (sourceContest) {
                    sourceImages = sourceContest.images;
                }
            } else if (extract.sourceType === 'merger') {
                // For mergers, we need to get all images from all merged contests
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceImages = mergedContests.flatMap(c => c.images);
                    // Create a pseudo source contest for ID purposes
                    sourceContest = {
                        id: merger.contestIds[0], // Use first contest ID for vote storage
                        title: extract.name,
                        createdBy: extract.createdBy,
                        creatorName: extract.creatorName,
                        creatorAvatar: extract.creatorAvatar
                    };
                }
            } else if (extract.sourceType === 'extract') {
                // Get images from source extract
                const sourceExtract = state.extracts.find(e => e.id === extract.sourceContestId);
                if (sourceExtract && sourceExtract.sourceType === 'contest') {
                    const originalContest = state.contests.find(c => c.id === sourceExtract.sourceContestId);
                    if (originalContest) {
                        sourceImages = originalContest.images;
                        sourceContest = originalContest;
                    }
                }
            }

            if (!sourceContest || sourceImages.length === 0) {
                showToast('Source not found', 'error');
                return;
            }

            // Filter images to only those in the extract
            const extractImages = sourceImages.filter(img => extract.imageIds.includes(img.id));

            // If revoteAll is false, filter to only unvoted images
            let imagesToVote = extractImages;
            if (!revoteAll) {
                // Get user's voted images from source contest(s)
                let votedImageIds = [];
                if (extract.sourceType === 'contest' && extract.sourceContestId) {
                    const userVotes = state.userVotedContests[extract.sourceContestId] || {};
                    votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
                } else if (extract.sourceType === 'merger' && extract.sourceMergerId) {
                    const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (merger) {
                        let allVotedImageIds = [];
                        merger.contestIds.forEach(contestId => {
                            const userVotes = state.userVotedContests[contestId] || {};
                            allVotedImageIds.push(...Object.keys(userVotes).map(id => parseInt(id)));
                        });
                        votedImageIds = allVotedImageIds;
                    }
                }
                imagesToVote = extractImages.filter(img => !votedImageIds.includes(img.id));
            }

            if (imagesToVote.length === 0) {
                showToast('No images to vote on', 'info');
                return;
            }

            // Create a temporary contest object for voting
            const extractContest = {
                id: extractId,
                title: extract.name,
                images: imagesToVote,
                createdBy: extract.createdBy,
                creatorName: extract.creatorName,
                creatorAvatar: extract.creatorAvatar,
                isExtract: true,
                extractSourceType: extract.sourceType,
                extractSourceContestId: extract.sourceContestId,
                extractSourceMergerId: extract.sourceMergerId,
                extractImageIds: extract.imageIds,
                isPartialVoting: !revoteAll,
                originalContestId: extractId
            };

            startVoting(extractContest);
        }

        async function viewExtractResults(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Check if user can view results (admin, creator, or source has public results)
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === extract.createdBy;

            if (!isAdmin && !isCreator) {
                // Check source contest/merger results_public
                if (extract.sourceType === 'contest') {
                    const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                    if (sourceContest && sourceContest.resultsPublic === false && sourceContest.createdBy !== state.user.id) {
                        showAlert('The source contest has private results. Only the creator or admin can view them.', 'üîí');
                        return;
                    }
                } else if (extract.sourceType === 'merger') {
                    const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (merger) {
                        const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                        const hasPrivateContest = mergedContests.some(c => c.resultsPublic === false && c.createdBy !== state.user.id);
                        if (hasPrivateContest) {
                            showAlert('Some contests in the source merger have private results. Only the creator or admin can view them.', 'üîí');
                            return;
                        }
                    }
                }
            }

            // Get source contest or merger
            let sourceImages = [];
            let resultsPublic = true; // Default to public
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                if (sourceContest) {
                    sourceImages = sourceContest.images;
                    resultsPublic = sourceContest.resultsPublic !== false;
                }
            } else if (extract.sourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceImages = mergedContests.flatMap(c => c.images);
                    // If any merged contest has private results, the extract is also private
                    resultsPublic = !mergedContests.some(c => c.resultsPublic === false);
                }
            }

            if (sourceImages.length === 0) {
                showToast('Source not found', 'error');
                return;
            }

            // Filter images to only those in the extract
            const extractImages = sourceImages.filter(img => extract.imageIds.includes(img.id));

            // Create a temporary contest object for results with extract information
            const extractContest = {
                id: extractId,
                title: extract.name,
                images: extractImages,
                createdBy: extract.createdBy,
                creatorName: extract.creatorName,
                creatorAvatar: extract.creatorAvatar,
                resultsPublic: resultsPublic,
                isExtract: true,
                extractSourceType: extract.sourceType,
                extractSourceContestId: extract.sourceContestId,
                extractSourceMergerId: extract.sourceMergerId,
                extractImageIds: extract.imageIds
            };

            viewResults(extractContest);
        }

        // ==================== END EXTRACT SYSTEM FUNCTIONS ====================

        function handleVote(score) {
            if (state.isAnimating) return;

            state.isAnimating = true;
            const currentImage = state.shuffledImages[state.currentImageIndex];
            state.votes[currentImage.id] = score;
            state.lastClickedImageId = currentImage.id;
            state.showTickAnimation = true;

            debouncedAutoSave();

            render();

            setTimeout(() => {
                state.showTickAnimation = false;
                state.isAnimating = false;
                if (state.currentImageIndex < state.shuffledImages.length - 1) {
                    state.currentImageIndex++;
                }
                render();
            }, 500);
        }

        function navigateImage(direction) {
            if (direction === 'next') {
                if (state.currentImageIndex < state.shuffledImages.length - 1) {
                    state.currentImageIndex++;
                }
            } else if (direction === 'prev' && state.currentImageIndex > 0) {
                state.currentImageIndex--;
            }
            render();
        }

        function jumpToImage(index) {
            if (state.isAnimating) return;
            state.currentImageIndex = index;
            render();
        }

        function toggleScoreSelection(score) {
            // Toggle score selection: if already selected, unselect it
            if (state.selectedScore === score) {
                state.selectedScore = null;
            } else {
                state.selectedScore = score;
            }
            render();
        }

        function voteImageMulti(imageId) {
            // If no score is selected, do nothing
            if (state.selectedScore === null) {
                return;
            }

            // Track the last clicked image
            state.lastClickedImageId = imageId;

            // Assign the selected score to this image
            state.votes[imageId] = state.selectedScore;
            debouncedAutoSave();
            render();
        }

        function updateMultiVotingImageScale(value) {
            clearTimeout(state.multiVotingScaleUpdateTimeout);
            state.multiVotingScaleUpdateTimeout = setTimeout(() => {
                state.multiVotingImageScale = parseInt(value, 10);
                render();
            }, 200);
        }

        function adjustMultiVotingImageScale(delta) {
            const newScale = Math.max(20, Math.min(250, state.multiVotingImageScale + delta));
            state.multiVotingImageScale = newScale;
            render();
        }

        function setMultiModeFilter(filter) {
            // Toggle filter: if filter is in array, remove it; otherwise add it
            const index = state.multiModeFilter.indexOf(filter);
            if (index > -1) {
                state.multiModeFilter.splice(index, 1);
            } else {
                state.multiModeFilter.push(filter);
            }
            render();
        }

        function setMultiModeSort(sort) {
            state.multiModeSort = sort;
            render();
        }

        function cancelVoting() {
            showConfirm(
                'Your votes are being auto-saved ‚Äî you can resume from the "Continue Draft" button on the home screen. Exit voting now?',
                'confirmCancelVoting',
                'üíæ'
            );
        }

        function submitVotes() {
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);
            if (!allVoted) {
                showAlert('Please vote on all images before submitting!', '‚ùå');
                return;
            }
            showConfirm(
                'Confirm to submit your votes. After submission, you can revote completely. When revoting, you can choose to start fresh or preload your existing votes.',
                'confirmSubmitVotes',
                'üó≥Ô∏è'
            );
        }

        function showBreakdown(imageId) {
            state.showBreakdownModal = imageId;
            document.body.classList.add('modal-open');
            render();
        }

        function showVoterVotes(username) {
            // Set viewing specific user
            state.viewingSpecificUser = username;
            state.showMyVotes = false;
            state.showVoterBreakdown = false;

            // Filter mockResults to show only images with this user's votes
            // and update the results to show this user's score as the primary score
            state.results = state.results.map(img => {
                const vote = img.breakdown.find(v => v.username === username);
                if (vote) {
                    return {
                        ...img,
                        averageScore: vote.score,
                        userSpecificScore: vote.score
                    };
                }
                return null;
            }).filter(img => img !== null)
            .sort(compareWithTieBreaking);

            render();
        }

        function viewUserVotes(username) {
            // Alias for showVoterVotes for clarity
            showVoterVotes(username);
        }

        async function clearUserVotesView() {
            state.viewingSpecificUser = null;
            state.showVoterBreakdown = true;
            // Regenerate full results
            if (state.currentContest) {
                await loadResults();
            }
            render();
        }

        function closeBreakdown() {
            state.showBreakdownModal = null;
            document.body.classList.remove('modal-open');
            render();
        }

        // Admin vote editing
        async function adminEditVote(userId, imageId, currentScore) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Admin access required', 'üîí');
                return;
            }

            // Show modal with score buttons
            const voteData = state.results.find(r => r.id === imageId)?.breakdown.find(v => v.userId === userId);
            if (!voteData) return;

            showModal({
                type: 'custom',
                title: `Edit ${voteData.username}'s Vote`,
                icon: '‚úèÔ∏è',
                message: `Current score: ${currentScore}\nSelect new score:`,
                buttons: [1, 2, 3, 4, 5].map(score => ({
                    text: score.toString(),
                    primary: false,
                    action: `confirmEditVote_${userId}_${imageId}_${currentScore}_${score}`
                })).concat([{
                    text: 'Cancel',
                    primary: false,
                    action: 'closeModal'
                }])
            });
        }

        async function confirmEditVote(userId, imageId, oldScore, newScore) {
            try {
                // Close modal FIRST before setting modalProcessing
                state.modal = null;
                document.body.classList.remove('modal-open');
                render();

                state.modalProcessing = true;
                setLoading('Updating vote...');

                // Find the contest ID for this image
                // For extracts, need to find the actual source contest ID where the vote is stored
                let contestId = state.currentContest.id;
                if (state.currentContest.isExtract) {
                    // Find which source contest this image belongs to
                    const image = state.currentContest.images.find(img => img.id === imageId);
                    if (image && image.contestId) {
                        contestId = image.contestId;
                    } else if (state.currentContest.extractSourceType === 'contest') {
                        contestId = state.currentContest.extractSourceContestId;
                    }
                }

                // Update vote in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&image_id=eq.${imageId}&contest_id=eq.${contestId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({ score: parseInt(newScore) })
                });

                if (!response.ok) {
                    throw new Error('Failed to update vote');
                }

                showToast(`Vote updated from ${oldScore} to ${newScore}`, 'success');

                // Reload results to get fresh data
                await loadResults();
                clearLoading();

            } catch (error) {
                console.error('Error updating vote:', error);
                clearLoading();
                showAlert('Failed to update vote: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            }
        }

        // Admin vote blocking
        async function adminToggleBlockVote(userId, imageId, currentlyBlocked) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Admin access required', 'üîí');
                return;
            }

            const voteData = state.results.find(r => r.id === imageId)?.breakdown.find(v => v.userId === userId);
            if (!voteData) return;

            const action = currentlyBlocked ? 'unblock' : 'block';
            showConfirm(
                `Are you sure you want to ${action} ${voteData.username}'s vote?`,
                `executeToggleBlockVote_${userId}_${imageId}_${!currentlyBlocked}`,
                'üö´'
            );
        }

        async function executeToggleBlockVote(userId, imageId, shouldBlock) {
            try {
                // Close modal FIRST before setting modalProcessing
                state.modal = null;
                document.body.classList.remove('modal-open');
                render();

                state.modalProcessing = true;
                setLoading(shouldBlock ? 'Blocking vote...' : 'Unblocking vote...');

                // Find the contest ID for this image
                // For extracts, need to find the actual source contest ID where the vote is stored
                let contestId = state.currentContest.id;
                if (state.currentContest.isExtract) {
                    // Find which source contest this image belongs to
                    const image = state.currentContest.images.find(img => img.id === imageId);
                    if (image && image.contestId) {
                        contestId = image.contestId;
                    } else if (state.currentContest.extractSourceType === 'contest') {
                        contestId = state.currentContest.extractSourceContestId;
                    }
                }

                // Update vote in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&image_id=eq.${imageId}&contest_id=eq.${contestId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({ is_blocked: shouldBlock })
                });

                if (!response.ok) {
                    throw new Error('Failed to update vote block status');
                }

                showToast(`Vote ${shouldBlock ? 'blocked' : 'unblocked'}`, 'success');

                // Reload results to get fresh data with updated ban status
                await loadResults();

                // Re-render to refresh the breakdown modal
                render();

            } catch (error) {
                console.error('Error toggling vote block:', error);
                showAlert('Failed to toggle vote block: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
                state.modalProcessing = false;
            }
        }


        async function backToHome() {
            console.log('üè† [NAVIGATION] Returning to home from view:', state.view);

            // Check for both contest and merge voting in progress
            const isContestVoting = state.view === 'vote' && !state.hasSubmitted && state.currentContest && state.currentContest.images;
            const isMergeVoting = state.view === 'vote' && !state.hasSubmitted && state.currentMergerId && state.mergerContestIds && state.mergerContestIds.length > 0;

            if (isContestVoting || isMergeVoting) {
                showConfirm(
                    'Your votes are being auto-saved ‚Äî you can resume from the "Continue Draft" button on the home screen. Go back now?',
                    'confirmBackToHome',
                    'üíæ'
                );
                return;
            }

            // Refresh contest list (this now includes fresh voter counts)
            console.log('üîÑ [CLEANUP] Refreshing contest list');
            await loadContests();

            // Reset all contest-related state
            state.view = 'home';
            window.location.hash = ''; // Clear hash to avoid confusion on reload
            state.currentContest = null;
            state.showBreakdownModal = null;
            state.results = null;
            state.mergedResults = null;
            state.showMyVotes = false;
            state.resultsView = 'average';
            state.selectedVoterUserId = null;
            state.contestVoters = [];
            // Reset results tab enhancement state
            state.userFilterSelectedUsers = null;
            state.userFilterDropdownOpen = false;
            state.imageFilterSelectedImages = null;
            state.imageFilterDropdownOpen = false;
            state.countMode = 'images';
            state.comparisonView = null;
            state.comparisonDetailUserId = null;
            state.comparisonDetailCollapsed = {};
            state.comparisonTableView = 'match';
            state.comparisonAvgView = 'match';
            state.comparisonTableSortKeys = [];
            state.collapsedSections = {};

            // Clear URL hash
            window.location.hash = '';

            console.log('‚úÖ [NAVIGATION] Successfully returned to home');

            render();
        }

        function confirmBackToHome() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Reset all contest-related state with null checks
            state.view = 'home';
            state.currentContest = null;
            state.showBreakdownModal = null;
            state.results = null;
            state.showMyVotes = false;
            state.resultsView = 'average';
            state.selectedVoterUserId = null;
            state.contestVoters = [];
            // Reset results tab enhancement state
            state.userFilterSelectedUsers = null;
            state.userFilterDropdownOpen = false;
            state.imageFilterSelectedImages = null;
            state.imageFilterDropdownOpen = false;
            state.countMode = 'images';
            state.comparisonView = null;
            state.comparisonDetailUserId = null;
            state.comparisonDetailCollapsed = {};
            state.comparisonTableView = 'match';
            state.comparisonAvgView = 'match';
            state.comparisonTableSortKeys = [];
            state.collapsedSections = {};

            // Clear URL hash
            window.location.hash = '';

            state.modalProcessing = false;
            render();
        }

        function toggleVoteView() {
            state.showMyVotes = !state.showMyVotes;
            render();
        }

        function toggleVotingMode() {
            const newMode = state.votingMode === 'single' ? 'multi' : 'single';

            // Save voting mode preference to localStorage
            localStorage.setItem('peony_voting_mode', newMode);

            // Show loading modal when switching to multi mode
            if (newMode === 'multi') {
                state.isLoadingMultiModeImages = true;
                state.multiModeLoadedImages = 0;
                state.multiModeTotalImages = state.shuffledImages.length;
                state.votingMode = newMode;
                render();

                // Load images with tracking, hide modal when done or after 10s timeout
                loadImagesWithTracking(state.shuffledImages);
            } else {
                // Switching from multi to single mode - show brief transition modal
                state.isTransitioningVotingMode = true;
                render();

                setTimeout(() => {
                    state.votingMode = newMode;
                    state.selectedScore = null;

                    // If there was a last clicked image, navigate to it
                    if (state.lastClickedImageId) {
                        const imageIndex = state.shuffledImages.findIndex(img => img.id === state.lastClickedImageId);
                        if (imageIndex !== -1) {
                            state.currentImageIndex = imageIndex;
                        }
                    }

                    state.isTransitioningVotingMode = false;
                    render();
                }, 400);
            }
        }

        function toggleFilters() {
            state.showFilters = !state.showFilters;
            render();
        }

        function togglePinnedSection() {
            state.isPinnedSectionExpanded = !state.isPinnedSectionExpanded;
            render();
        }

        function toggleCompleteVotingSection() {
            state.isCompleteVotingExpanded = !state.isCompleteVotingExpanded;
            render();
        }

        function toggleAllContestsSection() {
            state.isAllContestsSectionExpanded = !state.isAllContestsSectionExpanded;
            render();
        }

        // Make toggle functions globally accessible
        window.togglePinnedSection = togglePinnedSection;
        window.toggleCompleteVotingSection = toggleCompleteVotingSection;
        window.toggleAllContestsSection = toggleAllContestsSection;

        function setResultsView(view, userId = null) {
            state.resultsView = view;
            state.showMyVotes = view === 'userVotes';  // Backwards compatibility

            // Reset comparison state when changing views
            state.comparisonView = null;
            state.comparisonDetailUserId = null;
            state.userFilterDropdownOpen = false;
            state.averageTabCompareAll = false;
            state.averageTabCompareUserId = null;

            // Auto-exit image filter editing mode when switching away from Total tab
            if (view !== 'total' && state.imageFilterDropdownOpen) {
                state.imageFilterDropdownOpen = false;
            }

            // Reset selected voter when changing views
            if (view !== 'userVotes') {
                state.selectedVoterUserId = null;
            } else if (userId !== null) {
                // If userId provided, select that user
                state.selectedVoterUserId = userId;
            }
            // Otherwise leave state.selectedVoterUserId as null to force user to select someone

            render();
        }

        function setVoterSortBy(sortBy) {
            state.voterSortBy = sortBy;
            render();
        }

        function toggleCountScore(score) {
            const index = state.countSelectedScores.indexOf(score);
            if (index > -1) {
                // Remove score if already selected
                state.countSelectedScores.splice(index, 1);
            } else {
                // Add score if not selected
                state.countSelectedScores.push(score);
            }
            render();
        }

        function generateCountData() {
            // Count how many times each image received the selected scores
            const countMap = {}; // { imageId: count }
            const imageFilterIds = getFilteredImageIds();

            state.results.filter(img => imageFilterIds === null || imageFilterIds.has(img.id)).forEach(imageResult => {
                let count = 0;
                (imageResult.breakdown || []).forEach(vote => {
                    // Only count non-blocked, non-banned votes
                    if (!vote.isBlocked && !vote.isBanned && state.countSelectedScores.includes(vote.score)) {
                        count++;
                    }
                });

                if (count > 0) {
                    countMap[imageResult.id] = count;
                }
            });

            // Group images by count
            const grouped = {}; // { count: [imageResults] }
            const imagesWithCounts = state.results
                .filter(img => countMap[img.id] > 0)
                .map(img => ({
                    ...img,
                    count: countMap[img.id]
                }));

            imagesWithCounts.forEach(img => {
                if (!grouped[img.count]) {
                    grouped[img.count] = [];
                }
                grouped[img.count].push(img);
            });

            // Sort images within each count group by average score (tie-breaker)
            Object.keys(grouped).forEach(count => {
                grouped[count].sort((a, b) => b.averageScore - a.averageScore);
            });

            // Get sorted counts (highest to lowest)
            const sortedCounts = Object.keys(grouped)
                .map(k => parseInt(k))
                .sort((a, b) => b - a);

            const maxCount = sortedCounts.length > 0 ? sortedCounts[0] : 0;

            return { grouped, sortedCounts, maxCount };
        }

        // ==================== COLLAPSIBLE SECTIONS ====================
        function toggleSection(sectionKey) {
            if (state.collapsedSections[sectionKey]) {
                delete state.collapsedSections[sectionKey];
            } else {
                state.collapsedSections[sectionKey] = true;
            }
            render();
        }

        function isSectionCollapsed(sectionKey) {
            return !!state.collapsedSections[sectionKey];
        }

        function renderCollapseArrow(sectionKey) {
            const collapsed = isSectionCollapsed(sectionKey);
            return `<svg class="inline-block cursor-pointer select-none transition-transform duration-200 ${collapsed ? '' : 'rotate-90'} w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" onclick="event.stopPropagation(); toggleSection('${sectionKey}')"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>`;
        }

        // ==================== USER FILTER ====================
        function getContestVotersList() {
            if (!state.results) return [];
            const voterMap = {};
            state.results.forEach(img => {
                if (!img.breakdown) return;
                img.breakdown.forEach(vote => {
                    if (!vote.isBlocked && !vote.isBanned && !voterMap[vote.userId]) {
                        voterMap[vote.userId] = { userId: vote.userId, username: vote.username, avatar: vote.avatar };
                    }
                });
            });
            return Object.values(voterMap).sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
        }

        function toggleUserFilterDropdown() {
            state.userFilterDropdownOpen = !state.userFilterDropdownOpen;
            if (state.userFilterDropdownOpen) state.imageFilterDropdownOpen = false;
            render();
        }

        function toggleUserFilterUser(userId) {
            const scrollY = window.scrollY;
            const dropdown = document.querySelector('.user-filter-dropdown');
            const dropdownScrollTop = dropdown ? dropdown.scrollTop : 0;
            const allVoters = getContestVotersList();
            if (state.userFilterSelectedUsers === null) {
                // Was "all selected" - now deselect this one
                state.userFilterSelectedUsers = new Set(allVoters.map(v => v.userId));
                state.userFilterSelectedUsers.delete(userId);
            } else {
                if (state.userFilterSelectedUsers.has(userId)) {
                    state.userFilterSelectedUsers.delete(userId);
                } else {
                    state.userFilterSelectedUsers.add(userId);
                }
                // Don't automatically reset to null - user may want explicit control
            }
            render();
            window.scrollTo(0, scrollY);
            const newDropdown = document.querySelector('.user-filter-dropdown');
            if (newDropdown) newDropdown.scrollTop = dropdownScrollTop;
        }

        function selectAllFilterUsers() {
            state.userFilterSelectedUsers = null;
            render();
        }

        function unselectAllFilterUsers() {
            state.userFilterSelectedUsers = new Set();
            render();
        }

        function isUserFilterActive() {
            return state.userFilterSelectedUsers !== null;
        }

        function getFilteredUserIds() {
            if (state.userFilterSelectedUsers === null) return null; // All users
            return state.userFilterSelectedUsers;
        }

        function getFilteredResults() {
            if (!state.results) return [];
            let results = state.results;

            // Apply image filter first
            const imageFilterIds = getFilteredImageIds();
            if (imageFilterIds !== null) {
                results = results.filter(img => imageFilterIds.has(img.id));
            }

            // Apply user filter
            const filterIds = getFilteredUserIds();
            if (filterIds === null) return results;

            return results.map(img => {
                const filteredBreakdown = (img.breakdown || []).filter(v => !v.isBlocked && !v.isBanned && filterIds.has(v.userId));
                const scores = filteredBreakdown.map(v => v.score);
                const avg = scores.length > 0 ? parseFloat((scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2)) : 0;
                return {
                    ...img,
                    averageScore: avg,
                    totalVotes: scores.length
                };
            });
        }

        function renderUserFilterDropdown(tabPrefix) {
            const allVoters = getContestVotersList();
            if (allVoters.length === 0) return '';
            const selectedCount = state.userFilterSelectedUsers === null ? allVoters.length : state.userFilterSelectedUsers.size;
            const totalCount = allVoters.length;
            const isActive = isUserFilterActive();

            return `
                <div class="relative inline-flex items-center gap-1">
                    <button onclick="toggleUserFilterDropdown()" class="flex items-center gap-1 px-2 py-1 rounded-lg border-2 ${isActive ? 'border-mauve-400 bg-mauve-50' : 'border-gray-300 bg-white'} text-xs font-medium hover:border-mauve-400 transition">
                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.25 2.25 0 11-4.5 0 2.25 2.25 0 014.5 0z"/></svg>
                        Users
                    </button>
                    ${isActive ? `<span class="text-xs font-medium text-mauve-600">${selectedCount}/${totalCount}</span>` : ''}
                    ${state.userFilterDropdownOpen ? `
                        <div class="absolute z-40 mt-1 top-full w-64 bg-white rounded-lg shadow-xl border border-gray-200 max-h-64 overflow-y-auto user-filter-dropdown" style="left: 0;">
                            <div class="sticky top-0 bg-white border-b border-gray-200 p-2 flex gap-2">
                                <button onclick="selectAllFilterUsers()" class="px-2 py-1 text-xs bg-green-100 text-green-700 rounded hover:bg-green-200 font-medium">Select All</button>
                                <button onclick="unselectAllFilterUsers()" class="px-2 py-1 text-xs bg-red-100 text-red-700 rounded hover:bg-red-200 font-medium">Unselect All</button>
                            </div>
                            <div class="p-1">
                                ${allVoters.map(voter => {
                                    const isChecked = state.userFilterSelectedUsers === null || state.userFilterSelectedUsers.has(voter.userId);
                                    return `
                                        <label class="flex items-center gap-2 px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer">
                                            <input type="checkbox" ${isChecked ? 'checked' : ''} onchange="toggleUserFilterUser('${voter.userId}')" class="rounded border-gray-300 text-mauve-400 focus:ring-mauve-400" />
                                            <img src="${voter.avatar}" class="w-5 h-5 rounded-full" />
                                            <span class="text-sm truncate">${voter.username}</span>
                                        </label>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // ==================== IMAGE FILTER ====================
        function toggleImageFilterDropdown() {
            state.imageFilterDropdownOpen = !state.imageFilterDropdownOpen;
            if (state.imageFilterDropdownOpen) {
                state.userFilterDropdownOpen = false;
                // Auto-switch to Total tab when entering editing mode
                if (state.resultsView !== 'total') {
                    state.resultsView = 'total';
                }
            }
            render();
        }

        function toggleImageFilterImage(imageId) {
            const allImages = state.results || [];
            if (state.imageFilterSelectedImages === null) {
                // Was "all visible" - now hide this one
                state.imageFilterSelectedImages = new Set(allImages.map(img => img.id));
                state.imageFilterSelectedImages.delete(imageId);
            } else {
                if (state.imageFilterSelectedImages.has(imageId)) {
                    state.imageFilterSelectedImages.delete(imageId);
                } else {
                    state.imageFilterSelectedImages.add(imageId);
                }
                // Don't automatically reset to null - user may want explicit control
            }
            render();
        }

        function selectAllFilterImages() {
            state.imageFilterSelectedImages = null;
            render();
        }

        function unselectAllFilterImages() {
            state.imageFilterSelectedImages = new Set();
            render();
        }

        function isImageFilterActive() {
            return state.imageFilterSelectedImages !== null;
        }

        function getFilteredImageIds() {
            if (state.imageFilterSelectedImages === null) return null;
            return state.imageFilterSelectedImages;
        }

        function renderImageFilterDropdown() {
            const allImages = state.results || [];
            if (allImages.length === 0) return '';

            // Hide image filter in comparison views
            if (state.comparisonView !== null) return '';

            const selectedCount = state.imageFilterSelectedImages === null ? allImages.length : state.imageFilterSelectedImages.size;
            const totalCount = allImages.length;
            const isActive = isImageFilterActive();

            return `
                <div class="relative inline-flex items-center gap-1">
                    <button onclick="toggleImageFilterDropdown()" class="flex items-center gap-1 px-2 py-1 rounded-lg border-2 ${state.imageFilterDropdownOpen ? 'border-mauve-400 bg-mauve-100 ring-2 ring-mauve-300' : isActive ? 'border-mauve-400 bg-mauve-50' : 'border-gray-300 bg-white'} text-xs font-medium hover:border-mauve-400 transition">
                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/></svg>
                        Images
                    </button>
                    ${isActive ? `<span class="text-xs font-medium text-mauve-600">${selectedCount}/${totalCount}</span>` : ''}
                    ${state.imageFilterDropdownOpen ? `
                        <button onclick="selectAllFilterImages()" class="px-1.5 py-0.5 text-xs bg-green-100 text-green-700 rounded hover:bg-green-200 font-medium">Show All</button>
                        <button onclick="unselectAllFilterImages()" class="px-1.5 py-0.5 text-xs bg-red-100 text-red-700 rounded hover:bg-red-200 font-medium">Hide All</button>
                    ` : ''}
                </div>
            `;
        }

        function isImageVisibleInFilter(imageId) {
            return state.imageFilterSelectedImages === null || state.imageFilterSelectedImages.has(imageId);
        }

        function renderGlobalFilters() {
            const userFilter = renderUserFilterDropdown(state.resultsView);
            const imageFilter = renderImageFilterDropdown();
            if (!userFilter && !imageFilter) return '';
            return `
                <div class="flex items-center justify-center gap-2 flex-wrap mb-2">
                    <span class="text-xs font-semibold text-gray-700">Filter:</span>
                    ${userFilter}
                    ${imageFilter}
                </div>
            `;
        }

        // ==================== DIVISIVE TAB HELPERS ====================
        function calculateSD(scores) {
            if (scores.length < 2) return 0;
            const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const squaredDiffs = scores.map(s => Math.pow(s - mean, 2));
            return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / scores.length);
        }

        function generateDivisiveData() {
            if (!state.results) return { categories: [], allImages: [] };

            const imageFilterIds = getFilteredImageIds();
            const userFilterIds = getFilteredUserIds();

            const allImages = state.results
                .filter(img => imageFilterIds === null || imageFilterIds.has(img.id))
                .filter(img => img.totalVotes >= 2)
                .map(img => {
                    let scores = (img.breakdown || []).filter(v => !v.isBlocked && !v.isBanned);
                    if (userFilterIds !== null) scores = scores.filter(v => userFilterIds.has(v.userId));
                    const scoreVals = scores.map(v => v.score);
                    const sd = calculateSD(scoreVals);
                    const avg = scoreVals.length > 0 ? parseFloat((scoreVals.reduce((a, b) => a + b, 0) / scoreVals.length).toFixed(2)) : 0;
                    return { ...img, sd: parseFloat(sd.toFixed(2)), averageScore: avg, totalVotes: scoreVals.length };
                })
                .filter(img => img.totalVotes >= 2);

            const sortFn = (a, b) => b.sd - a.sd || b.averageScore - a.averageScore;
            const cat7 = allImages.filter(i => i.sd >= 1.5).sort(sortFn);
            const cat6 = allImages.filter(i => i.sd >= 1.25 && i.sd < 1.5).sort(sortFn);
            const cat5 = allImages.filter(i => i.sd >= 1.0 && i.sd < 1.25).sort(sortFn);
            const cat4 = allImages.filter(i => i.sd >= 0.75 && i.sd < 1.0).sort(sortFn);
            const cat3 = allImages.filter(i => i.sd >= 0.50 && i.sd < 0.75).sort(sortFn);
            const cat2 = allImages.filter(i => i.sd >= 0.25 && i.sd < 0.50).sort(sortFn);
            const cat1 = allImages.filter(i => i.sd < 0.25).sort(sortFn);

            return {
                categories: [
                    { key: 'divisive_very_high', label: 'Extremely Divisive', sublabel: 'SD 1.50+', items: cat7, color: 'bg-red-200 text-red-900', borderColor: 'rgb(220, 38, 38)' },
                    { key: 'divisive_high', label: 'Highly Divisive', sublabel: 'SD 1.25‚Äì1.50', items: cat6, color: 'bg-red-100 text-red-800', borderColor: 'rgb(239, 68, 68)' },
                    { key: 'divisive_moderate', label: 'Divisive', sublabel: 'SD 1.00‚Äì1.25', items: cat5, color: 'bg-orange-100 text-orange-800', borderColor: 'rgb(249, 115, 22)' },
                    { key: 'divisive_mild', label: 'Moderately Split', sublabel: 'SD 0.75‚Äì1.00', items: cat4, color: 'bg-yellow-100 text-yellow-800', borderColor: 'rgb(234, 179, 8)' },
                    { key: 'divisive_slight', label: 'Slightly Split', sublabel: 'SD 0.50‚Äì0.75', items: cat3, color: 'bg-lime-100 text-lime-800', borderColor: 'rgb(132, 204, 22)' },
                    { key: 'divisive_low', label: 'Near Consensus', sublabel: 'SD 0.25‚Äì0.50', items: cat2, color: 'bg-green-100 text-green-800', borderColor: 'rgb(34, 197, 94)' },
                    { key: 'divisive_consensus', label: 'Strong Consensus', sublabel: 'SD 0.00‚Äì0.25', items: cat1, color: 'bg-emerald-100 text-emerald-800', borderColor: 'rgb(16, 185, 129)' }
                ],
                allImages
            };
        }


        // ==================== COUNT TAB USERS MODE ====================
        function setCountMode(mode) {
            state.countMode = mode;
            render();
        }

        function generateCountDataUsers() {
            if (!state.results || state.countSelectedScores.length === 0) return { grouped: {}, sortedCounts: [], maxCount: 0 };
            const userCounts = {};

            state.results.forEach(imageResult => {
                (imageResult.breakdown || []).forEach(vote => {
                    if (!vote.isBlocked && !vote.isBanned && state.countSelectedScores.includes(vote.score)) {
                        if (!userCounts[vote.userId]) {
                            userCounts[vote.userId] = { userId: vote.userId, username: vote.username, avatar: vote.avatar, count: 0 };
                        }
                        userCounts[vote.userId].count++;
                    }
                });
            });

            const users = Object.values(userCounts).filter(u => u.count > 0);
            const grouped = {};
            users.forEach(u => {
                if (!grouped[u.count]) grouped[u.count] = [];
                grouped[u.count].push(u);
            });
            Object.keys(grouped).forEach(count => {
                grouped[count].sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
            });

            const sortedCounts = Object.keys(grouped).map(k => parseInt(k)).sort((a, b) => b - a);
            const maxCount = sortedCounts.length > 0 ? sortedCounts[0] : 0;
            return { grouped, sortedCounts, maxCount };
        }

        function generateCountDataFiltered() {
            const filterIds = getFilteredUserIds();
            const imageFilterIds = getFilteredImageIds();
            const countMap = {};

            state.results.filter(img => imageFilterIds === null || imageFilterIds.has(img.id)).forEach(imageResult => {
                let count = 0;
                (imageResult.breakdown || []).forEach(vote => {
                    if (!vote.isBlocked && !vote.isBanned && state.countSelectedScores.includes(vote.score)) {
                        if (filterIds === null || filterIds.has(vote.userId)) {
                            count++;
                        }
                    }
                });
                if (count > 0) countMap[imageResult.id] = count;
            });

            const grouped = {};
            const imagesWithCounts = state.results
                .filter(img => countMap[img.id] > 0)
                .map(img => ({ ...img, count: countMap[img.id] }));

            imagesWithCounts.forEach(img => {
                if (!grouped[img.count]) grouped[img.count] = [];
                grouped[img.count].push(img);
            });

            Object.keys(grouped).forEach(count => {
                grouped[count].sort((a, b) => b.averageScore - a.averageScore);
            });

            const sortedCounts = Object.keys(grouped).map(k => parseInt(k)).sort((a, b) => b - a);
            const maxCount = sortedCounts.length > 0 ? sortedCounts[0] : 0;
            return { grouped, sortedCounts, maxCount };
        }

        // ==================== BY USER TAB: COMPARISON ====================
        function startComparison() {
            if (!state.selectedVoterUserId) {
                showAlert('Please select a user to compare', '‚ö†Ô∏è');
                return;
            }
            state.comparisonView = 'table';
            render();
        }

        function backFromComparison() {
            state.comparisonView = null;
            state.comparisonDetailUserId = null;
            render();
        }

        function showComparisonDetail(targetUserId) {
            state.comparisonDetailUserId = targetUserId;
            state.comparisonView = 'detail';
            state.comparisonDetailView = targetUserId === '__contest_average__' ? 'match' : 'match';
            state.comparisonDetailCollapsed = {};
            render();
        }

        function backFromComparisonDetail() {
            state.comparisonView = 'table';
            state.comparisonDetailUserId = null;
            render();
        }

        function setComparisonDetailView(view) {
            state.comparisonDetailView = view;
            render();
        }

        function setComparisonTableView(view) {
            state.comparisonTableView = view;
            render();
        }

        function setComparisonAvgView(view) {
            state.comparisonAvgView = view;
            render();
        }

        function toggleComparisonTableSort(key) {
            const existing = state.comparisonTableSortKeys.find(s => s.key === key);
            if (existing) {
                if (existing.direction === 'desc') {
                    state.comparisonTableSortKeys = [{ key, direction: 'asc' }];
                } else {
                    state.comparisonTableSortKeys = [];
                }
            } else {
                state.comparisonTableSortKeys = [{ key, direction: 'desc' }];
            }
            render();
        }

        function toggleComparisonDetailSection(key) {
            if (state.comparisonDetailCollapsed[key]) {
                delete state.comparisonDetailCollapsed[key];
            } else {
                state.comparisonDetailCollapsed[key] = true;
            }
            render();
        }

        function startAverageCompareAll() {
            state.averageTabCompareAll = true;
            state.averageTabCompareUserId = null;
            state.comparisonAvgView = 'match';
            state.comparisonDetailCollapsed = {};
            render();
        }

        function backFromAverageCompareAll() {
            state.averageTabCompareAll = false;
            state.averageTabCompareUserId = null;
            render();
        }

        function showAverageCompareUser(userId) {
            state.averageTabCompareUserId = userId;
            state.comparisonAvgView = 'match';
            state.comparisonDetailCollapsed = {};
            render();
        }

        function backFromAverageCompareUser() {
            state.averageTabCompareUserId = null;
            render();
        }

        function getComparisonDataSource() {
            // Use state.results for contests, or build from mergedResults for mergers
            if (state.results && state.results.length > 0) return state.results;
            if (state.mergedResults && state.mergedResults.images) {
                return state.mergedResults.images.map(img => ({
                    id: img.id,
                    url: img.url,
                    averageScore: parseFloat(img.averageScore),
                    totalVotes: img.totalVotes,
                    breakdown: img.voteBreakdown || []
                }));
            }
            return [];
        }

        function generateComparisonTable() {
            const dataSource = getComparisonDataSource();
            if (dataSource.length === 0 || !state.selectedVoterUserId) return [];

            const selectedUserId = state.selectedVoterUserId;
            // Build map of selected user's votes
            const selectedUserVotes = {};
            dataSource.forEach(img => {
                const vote = (img.breakdown || []).find(v => v.userId === selectedUserId && !v.isBlocked && !v.isBanned);
                if (vote) selectedUserVotes[img.id] = vote.score;
            });

            // Build map of all other voters
            const voterMap = {};
            dataSource.forEach(img => {
                (img.breakdown || []).forEach(vote => {
                    if (vote.userId === selectedUserId || vote.isBlocked || vote.isBanned) return;
                    if (!voterMap[vote.userId]) {
                        voterMap[vote.userId] = { userId: vote.userId, username: vote.username, avatar: vote.avatar, comparisons: [] };
                    }
                    if (selectedUserVotes[img.id] !== undefined) {
                        voterMap[vote.userId].comparisons.push({
                            imageId: img.id,
                            selectedScore: selectedUserVotes[img.id],
                            otherScore: vote.score
                        });
                    }
                });
            });

            return Object.values(voterMap).map(voter => {
                const total = voter.comparisons.length;
                if (total === 0) return null;
                // Match-based: Exact + Close(¬±1) + Wide(¬±2+) = 100%
                let exact = 0, close = 0, wide = 0;
                // Relative: Exact + Above(any positive) + Below(any negative) = 100%
                let aboveAll = 0, belowAll = 0;
                voter.comparisons.forEach(c => {
                    const diff = c.otherScore - c.selectedScore;
                    if (diff === 0) exact++;
                    else if (Math.abs(diff) === 1) close++;
                    else wide++;
                    if (diff > 0) aboveAll++;
                    if (diff < 0) belowAll++;
                });
                return {
                    ...voter,
                    total,
                    exactPct: ((exact / total) * 100).toFixed(0),
                    closePct: ((close / total) * 100).toFixed(0),
                    widePct: ((wide / total) * 100).toFixed(0),
                    abovePct: ((aboveAll / total) * 100).toFixed(0),
                    belowPct: ((belowAll / total) * 100).toFixed(0)
                };
            }).filter(Boolean).sort((a, b) => parseFloat(b.exactPct) - parseFloat(a.exactPct));
        }

        function generateContestAvgComparisonTable() {
            const dataSource = getComparisonDataSource();
            if (dataSource.length === 0) return [];
            // Build per-voter contest average comparison percentages
            const voterMap = {};
            dataSource.forEach(img => {
                if (!img.averageScore || img.averageScore === 0) return;
                (img.breakdown || []).forEach(vote => {
                    if (vote.isBlocked || vote.isBanned) return;
                    if (!voterMap[vote.userId]) {
                        voterMap[vote.userId] = { userId: vote.userId, username: vote.username, avatar: vote.avatar, comparisons: [] };
                    }
                    voterMap[vote.userId].comparisons.push({
                        userScore: vote.score,
                        avgScore: img.averageScore,
                        diff: vote.score - img.averageScore,
                        absDiff: Math.abs(vote.score - img.averageScore)
                    });
                });
            });
            return Object.values(voterMap).map(voter => {
                const total = voter.comparisons.length;
                if (total === 0) return null;
                let exact = 0, close = 0, wide = 0, above = 0, below = 0;
                voter.comparisons.forEach(c => {
                    if (c.absDiff <= 0.50) exact++;
                    else if (c.absDiff <= 1.00) close++;
                    else wide++;
                    if (c.diff > 0.50) above++;
                    if (c.diff < -0.50) below++;
                });
                return {
                    ...voter,
                    total,
                    exactPct: ((exact / total) * 100).toFixed(0),
                    closePct: ((close / total) * 100).toFixed(0),
                    widePct: ((wide / total) * 100).toFixed(0),
                    abovePct: ((above / total) * 100).toFixed(0),
                    belowPct: ((below / total) * 100).toFixed(0)
                };
            }).filter(Boolean).sort((a, b) => parseFloat(b.exactPct) - parseFloat(a.exactPct));
        }

        function generateContestAverageComparison(viewMode) {
            const dataSource = getComparisonDataSource();
            if (dataSource.length === 0 || !state.selectedVoterUserId) return [];
            const selectedUserId = state.selectedVoterUserId;
            viewMode = viewMode || 'match';

            // Build user votes map
            const userVotes = {};
            dataSource.forEach(img => {
                const vote = (img.breakdown || []).find(v => v.userId === selectedUserId && !v.isBlocked && !v.isBanned);
                if (vote) userVotes[img.id] = vote.score;
            });

            // Build comparisons with contest averages
            const comparisons = [];
            dataSource.forEach(img => {
                if (userVotes[img.id] === undefined || img.averageScore === 0) return;
                const diff = userVotes[img.id] - img.averageScore;
                comparisons.push({
                    imageId: img.id,
                    url: img.url,
                    userScore: userVotes[img.id],
                    avgScore: img.averageScore,
                    averageScore: img.averageScore,
                    diff: parseFloat(diff.toFixed(2)),
                    absDiff: parseFloat(Math.abs(diff).toFixed(2))
                });
            });

            // Build user-score-based subcategories
            function buildUserScoreSubs(items, keyPrefix) {
                const scoreMap = {};
                items.forEach(c => {
                    const s = c.userScore;
                    if (!scoreMap[s]) scoreMap[s] = [];
                    scoreMap[s].push(c);
                });
                return Object.keys(scoreMap).sort((a, b) => b - a).map(s => ({
                    key: `${keyPrefix}_s${s}`,
                    label: `Score ${s}`,
                    items: scoreMap[s]
                }));
            }

            if (viewMode === 'relative') {
                // Relative: Near Exact (¬±0.50), Above Average, Below Average
                const nearExact = comparisons.filter(c => c.absDiff <= 0.50);
                const above = comparisons.filter(c => c.diff > 0.50).sort((a, b) => b.diff - a.diff);
                const below = comparisons.filter(c => c.diff < -0.50).sort((a, b) => a.diff - b.diff);
                return [
                    { key: 'cmp_rel_near', label: 'Near Exact', range: '¬±0.50', color: '#86efac', darkColor: '#1a4a1a', items: nearExact, subcategories: buildUserScoreSubs(nearExact, 'cmp_rel_near') },
                    { key: 'cmp_rel_above', label: 'Above Average', range: 'Difference > +0.50', color: '#93c5fd', darkColor: '#1a3a5a', items: above, subcategories: buildUserScoreSubs(above, 'cmp_rel_above') },
                    { key: 'cmp_rel_below', label: 'Below Average', range: 'Difference < -0.50', color: '#fdba74', darkColor: '#4a3a1a', items: below, subcategories: buildUserScoreSubs(below, 'cmp_rel_below') }
                ];
            }

            // Match-based: Near Exact (¬±0.50), Close (¬±0.51-1.00), Wide Gap (1.01+)
            const nearExact = comparisons.filter(c => c.absDiff <= 0.50);
            const close = comparisons.filter(c => c.absDiff > 0.50 && c.absDiff <= 1.00);
            const wide = comparisons.filter(c => c.absDiff > 1.00);
            return [
                { key: 'cmp_near_exact', label: 'Near Exact', range: '¬±0.50', color: '#86efac', darkColor: '#1a4a1a', items: nearExact, subcategories: buildUserScoreSubs(nearExact, 'cmp_near_exact') },
                { key: 'cmp_close', label: 'Close', range: '¬±0.51‚Äì1.00', color: '#fcd34d', darkColor: '#4a4a1a', items: close, subcategories: buildUserScoreSubs(close, 'cmp_close') },
                { key: 'cmp_wide', label: 'Wide Gap', range: '¬±1.01+', color: '#fca5a5', darkColor: '#4a1a1a', items: wide, subcategories: buildUserScoreSubs(wide, 'cmp_wide') }
            ];
        }

        function generateUserVsUserComparison(targetUserId) {
            const dataSource = getComparisonDataSource();
            if (dataSource.length === 0 || !state.selectedVoterUserId) return { matchBased: [], relativeBased: [] };
            const selectedUserId = state.selectedVoterUserId;

            const selectedVotes = {};
            const targetVotes = {};
            dataSource.forEach(img => {
                const sv = (img.breakdown || []).find(v => v.userId === selectedUserId && !v.isBlocked && !v.isBanned);
                const tv = (img.breakdown || []).find(v => v.userId === targetUserId && !v.isBlocked && !v.isBanned);
                if (sv) selectedVotes[img.id] = sv.score;
                if (tv) targetVotes[img.id] = tv.score;
            });

            const comparisons = [];
            dataSource.forEach(img => {
                if (selectedVotes[img.id] !== undefined && targetVotes[img.id] !== undefined) {
                    const diff = targetVotes[img.id] - selectedVotes[img.id];
                    comparisons.push({
                        imageId: img.id, url: img.url,
                        selectedScore: selectedVotes[img.id],
                        targetScore: targetVotes[img.id],
                        averageScore: img.averageScore,
                        diff, absDiff: Math.abs(diff)
                    });
                }
            });

            // Build subcategories by score pairs
            function buildScorePairSubs(items, keyPrefix) {
                const pairMap = {};
                items.forEach(c => {
                    const pairKey = `${c.selectedScore} vs ${c.targetScore}`;
                    if (!pairMap[pairKey]) pairMap[pairKey] = { items: [], selected: c.selectedScore, target: c.targetScore };
                    pairMap[pairKey].items.push(c);
                });
                return Object.keys(pairMap).sort((a, b) => {
                    const pa = pairMap[a], pb = pairMap[b];
                    return pb.selected - pa.selected || pb.target - pa.target;
                }).map(pk => ({
                    key: `${keyPrefix}_${pk.replace(/ /g, '')}`,
                    label: pk,
                    items: pairMap[pk].items
                }));
            }

            // Match-based view
            const exactItems = comparisons.filter(c => c.diff === 0);
            const closeItems = comparisons.filter(c => c.absDiff === 1);
            const wideItems = comparisons.filter(c => c.absDiff >= 2);
            const matchBased = [
                { key: 'uvu_exact', label: 'Exact Match', color: '#86efac', darkColor: '#1a4a1a', items: exactItems, subcategories: buildScorePairSubs(exactItems, 'uvu_exact') },
                { key: 'uvu_close', label: 'Close Match (¬±1)', color: '#fcd34d', darkColor: '#4a4a1a', items: closeItems, subcategories: buildScorePairSubs(closeItems, 'uvu_close') },
                { key: 'uvu_wide', label: 'Wide Gap (¬±2+)', color: '#fca5a5', darkColor: '#4a1a1a', items: wideItems, subcategories: buildScorePairSubs(wideItems, 'uvu_wide') }
            ];

            // Relative view
            const exactRelItems = comparisons.filter(c => c.diff === 0);
            const aboveItems = comparisons.filter(c => c.diff > 0);
            const belowItems = comparisons.filter(c => c.diff < 0);
            const relativeBased = [
                { key: 'uvu_exact_r', label: 'Exact Match', color: '#86efac', darkColor: '#1a4a1a', items: exactRelItems, subcategories: buildScorePairSubs(exactRelItems, 'uvu_exact_r') },
                { key: 'uvu_above', label: 'Above Yours', color: '#93c5fd', darkColor: '#1a3a5a', items: aboveItems, subcategories: buildScorePairSubs(aboveItems, 'uvu_above') },
                { key: 'uvu_below', label: 'Below Yours', color: '#fdba74', darkColor: '#4a3a1a', items: belowItems, subcategories: buildScorePairSubs(belowItems, 'uvu_below') }
            ];

            return { matchBased, relativeBased };
        }

        function updateScale(value) {
            clearTimeout(state.scaleUpdateTimeout);
            state.scaleUpdateTimeout = setTimeout(() => {
                state.imageScale = parseInt(value);
                render();
            }, 200);
        }

        function adjustScale(delta) {
            const newScale = Math.max(20, Math.min(250, state.imageScale + delta));
            state.imageScale = newScale;
            render();
        }

        async function showAdminDashboard() {
            try {
                state.showAdminDashboard = true;
                state.adminDashboardLoading = true;
                render(); // Show loading state

                // Load all users from database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?select=*&order=username.asc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Failed to load users:', errorData);
                    throw new Error(errorData.message || 'Failed to load users');
                }

                const users = await response.json();
                console.log('üìä Loaded users from database:', users);

                // Update state with all users (including current user, banned users, etc.)
                state.allUsers = users.map(user => ({
                    id: user.id,
                    username: user.username,
                    avatar: user.avatar,
                    isBanned: user.is_banned || false
                }));

                console.log('üìä All users in state:', state.allUsers);

                // Fetch admin statistics from database with aggressive cache-busting
                const voterResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?select=user_id`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const votes = await voterResponse.json();

                // Check if votes response is valid
                if (!Array.isArray(votes)) {
                    console.error('Invalid votes response:', votes);
                    throw new Error(votes.message || 'Failed to load voter statistics');
                }

                // Count unique voters from users table
                const totalUniqueVoters = users.length;

                // Count total votes using COUNT(*)
                const votesCountResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'count=exact',
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                // Parse count from Content-Range header (e.g., "0-99/150" means 150 total)
                const contentRange = votesCountResponse.headers.get('Content-Range');
                const totalVotes = contentRange ? parseInt(contentRange.split('/')[1]) : 0;

                state.adminStats = { totalVotes, totalUniqueVoters };

                state.adminDashboardLoading = false;
                document.body.classList.add('modal-open');
                render();
            } catch (error) {
                console.error('Error loading admin dashboard:', error);
                state.adminDashboardLoading = false;
                state.showAdminDashboard = false;
                showAlert('Failed to load admin dashboard: ' + error.message, '‚ùå');
            }
        }

        function closeAdminDashboard() {
            state.showAdminDashboard = false;
            document.body.classList.remove('modal-open');
            render();
        }

        async function showAppSettings() {
            state.showAppSettingsModal = true;
            state.showUserDropdown = false;
            document.body.classList.add('modal-open');
            render();
        }

        function closeAppSettings() {
            state.showAppSettingsModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        async function toggleAppSetting(settingName) {
            try {
                // Get current value (default to true if not set)
                const currentValue = state.appSettings[settingName] !== false;
                const newValue = !currentValue;

                // Update in database
                // First, check if setting exists
                const checkResponse = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                const existingSettings = await checkResponse.json();

                if (existingSettings.length > 0) {
                    // Update existing setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update setting');
                    }
                } else {
                    // Insert new setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            setting_name: settingName,
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create setting');
                    }
                }

                // Update local state
                state.appSettings[settingName] = newValue;

                // Format setting name properly
                const formattedName = settingName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                showToast(
                    `‚úÖ ${formattedName} ${newValue ? 'enabled' : 'disabled'}`
                );
                render();
            } catch (error) {
                console.error('Error toggling app setting:', error);
                showToast('Failed to update setting: ' + error.message, 'error');
            }
        }

        async function updateAppSetting(settingName, newValue) {
            try {
                // Update in database
                // First, check if setting exists
                const checkResponse = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                const existingSettings = await checkResponse.json();

                if (existingSettings.length > 0) {
                    // Update existing setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update setting');
                    }
                } else {
                    // Insert new setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            setting_name: settingName,
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create setting');
                    }
                }

                // Update local state
                state.appSettings[settingName] = newValue;
            } catch (error) {
                console.error('Error updating app setting:', error);
                throw error;
            }
        }

        // ==================== FOLDER MANAGEMENT ====================

        function initializeFolderSortable() {
            const foldersList = document.getElementById('folders-list');
            if (!foldersList || typeof Sortable === 'undefined') return;

            // Initialize folder reordering
            new Sortable(foldersList, {
                animation: 150,
                handle: '.cursor-move',
                ghostClass: 'bg-blue-100',
                onEnd: async (evt) => {
                    // Skip if dropped at the same position
                    if (evt.oldIndex === evt.newIndex) {
                        return;
                    }

                    // Save scroll position before re-render
                    const modalContent = document.querySelector('.overflow-y-auto');
                    const scrollPos = modalContent ? modalContent.scrollTop : 0;

                    try {
                        // Get all children to determine what was moved
                        const children = Array.from(foldersList.children);
                        const movedElement = evt.item;
                        const isUnfolderedMoved = movedElement.hasAttribute('data-unfoldered');

                        // Get current unfoldered position
                        const currentUnfolderedPos = state.appSettings.unfoldered_items_position !== undefined
                            ? parseInt(state.appSettings.unfoldered_items_position)
                            : state.groups.length;

                        if (isUnfolderedMoved) {
                            // Unfoldered items meta-item was moved
                            // The new index IS the new position (since it's in the combined list)
                            const newUnfolderedPos = evt.newIndex;
                            await updateAppSetting('unfoldered_items_position', newUnfolderedPos);
                        } else {
                            // A folder was moved
                            // Need to adjust folder positions and possibly unfoldered position

                            // Count folders before and after unfoldered in the NEW layout
                            let newUnfolderedPos = currentUnfolderedPos;
                            const unfolderedElement = children.find(c => c.hasAttribute('data-unfoldered'));
                            if (unfolderedElement) {
                                newUnfolderedPos = Array.from(foldersList.children).indexOf(unfolderedElement);
                            }

                            // Build mapping of folder IDs to new positions (excluding unfoldered item)
                            const folderPositions = [];
                            children.forEach((child, visualIndex) => {
                                if (!child.hasAttribute('data-unfoldered')) {
                                    const folderId = child.getAttribute('data-folder-id');
                                    if (folderId) {
                                        // Calculate actual folder position (excluding unfoldered item)
                                        const actualPosition = visualIndex < newUnfolderedPos ? visualIndex : visualIndex - 1;
                                        folderPositions.push({ folderId, position: actualPosition });
                                    }
                                }
                            });

                            // Reorder state.groups to match new positions
                            const reorderedGroups = folderPositions
                                .sort((a, b) => a.position - b.position)
                                .map(fp => state.groups.find(g => g.id === fp.folderId))
                                .filter(Boolean);

                            state.groups = reorderedGroups;

                            // Save all folder positions
                            const updatePromises = state.groups.map((group, index) =>
                                saveFolderOrder(group.id, index)
                            );

                            await Promise.all(updatePromises);

                            // Update unfoldered position if it changed
                            if (newUnfolderedPos !== currentUnfolderedPos) {
                                await updateAppSetting('unfoldered_items_position', newUnfolderedPos);
                            }
                        }

                        // Only reload and re-render after successful save
                        render();

                        // Restore scroll position after render
                        setTimeout(() => {
                            const newModalContent = document.querySelector('.overflow-y-auto');
                            if (newModalContent) newModalContent.scrollTop = scrollPos;
                            initializeFolderSortable();
                        }, 100);
                    } catch (error) {
                        console.error('Failed to save folder order:', error);
                        showToast('Failed to save folder order', 'error');
                        // Reload to revert visual state
                        render();

                        // Restore scroll position after render
                        setTimeout(() => {
                            const newModalContent = document.querySelector('.overflow-y-auto');
                            if (newModalContent) newModalContent.scrollTop = scrollPos;
                            initializeFolderSortable();
                        }, 100);
                    }
                }
            });

            // Initialize item reordering within each folder
            state.groups.forEach(group => {
                const itemsList = document.getElementById(`folder-items-${group.id}`);
                if (itemsList) {
                    new Sortable(itemsList, {
                        animation: 150,
                        handle: '.cursor-move',
                        ghostClass: 'bg-blue-100',
                        onEnd: async (evt) => {
                            // Skip if dropped at the same position
                            if (evt.oldIndex === evt.newIndex) {
                                return;
                            }

                            // Save scroll position before re-render
                            const modalContent = document.querySelector('.overflow-y-auto');
                            const scrollPos = modalContent ? modalContent.scrollTop : 0;

                            try {
                                const folderId = itemsList.dataset.folderId;
                                const folder = state.groups.find(g => g.id === folderId);
                                if (!folder) return;

                                // Reorder the items array
                                const movedItem = folder.items.splice(evt.oldIndex, 1)[0];
                                folder.items.splice(evt.newIndex, 0, movedItem);

                                // Collect all update promises and execute in parallel
                                const updatePromises = folder.items.map((item, index) =>
                                    saveItemOrder(folderId, item.item_id, item.item_type, index)
                                );

                                // Wait for all saves to complete before proceeding
                                await Promise.all(updatePromises);

                                // Only reload and re-render after successful save
                                        render();

                                // Restore scroll position after render
                                setTimeout(() => {
                                    const newModalContent = document.querySelector('.overflow-y-auto');
                                    if (newModalContent) newModalContent.scrollTop = scrollPos;
                                    initializeFolderSortable();
                                }, 100);
                            } catch (error) {
                                console.error('Failed to save item order:', error);
                                showToast('Failed to save item order', 'error');
                                // Reload to revert visual state
                                        render();

                                // Restore scroll position after render
                                setTimeout(() => {
                                    const newModalContent = document.querySelector('.overflow-y-auto');
                                    if (newModalContent) newModalContent.scrollTop = scrollPos;
                                    initializeFolderSortable();
                                }, 100);
                            }
                        }
                    });
                }
            });
        }

        async function openManageFoldersModal() {
            state.showManageFoldersModal = true;
            state.showUserDropdown = false;
            document.body.classList.add('modal-open');
            render();
            // Initialize SortableJS after render
            setTimeout(initializeFolderSortable, 100);
        }

        function closeManageFoldersModal() {
            state.showManageFoldersModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        function showCreateFolderModal() {
            state.modal = {
                icon: 'üìÅ',
                title: 'Create New Folder',
                type: 'input',
                placeholder: 'Enter folder name...',
                inputValue: '',
                buttons: [
                    {
                        text: 'Cancel',
                        primary: false,
                        action: 'cancelCreateFolder'
                    },
                    {
                        text: 'Create',
                        primary: true,
                        action: 'confirmCreateFolder'
                    }
                ]
            };
            document.body.classList.add('modal-open');
            render();
            // Focus the input after render
            setTimeout(() => {
                const input = document.getElementById('modal-input');
                if (input) input.focus();
            }, 100);
        }

        function cancelCreateFolder() {
            state.modal = null;
            document.body.classList.remove('modal-open');
            render();
        }

        async function confirmCreateFolder() {
            const folderName = document.getElementById('modal-input')?.value;
            if (!folderName || !folderName.trim()) {
                showToast('‚ùå Please enter a folder name');
                return;
            }
            state.modal = null;
            document.body.classList.remove('modal-open');
            await createFolder(folderName.trim());
        }

        async function createFolder(folderName) {
            try {
                setLoading('Creating folder...');
                const maxOrder = state.groups.length > 0 ? Math.max(...state.groups.map(g => g.display_order || 0)) : 0;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        name: folderName,
                        display_order: maxOrder + 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to create folder');
                }

                    showToast('‚úÖ Folder created successfully');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error creating folder:', error);
                showToast('‚ùå Failed to create folder: ' + error.message);
                clearLoading();
            }
        }

        function confirmDeleteFolder(folderId) {
            state.folderToDelete = folderId;
            showConfirm(
                'Delete this folder? Items will not be deleted, only ungrouped.',
                'executeDeleteFolder',
                'üóëÔ∏è'
            );
        }

        async function executeDeleteFolder() {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const folderId = state.folderToDelete;
            state.folderToDelete = null;

            try {
                setLoading('Deleting folder...');

                // First delete all contest_groups entries for this folder
                await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${folderId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                // Then delete the group itself
                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?id=eq.${folderId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete folder');
                }

                    showToast('Folder deleted successfully', 'success');
            } catch (error) {
                console.error('Error deleting folder:', error);
                showToast('Failed to delete folder: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                clearLoading();
                render();
            }
        }

        // Legacy function name for backwards compatibility
        async function deleteFolder(folderId) {
            confirmDeleteFolder(folderId);
        }

        async function addItemToFolder(folderId) {
            // Get all available items
            const allItems = [
                ...state.contests.map(c => ({ id: c.id, type: 'contest', title: c.title })),
                ...state.mergers.map(m => ({ id: m.id, type: 'merger', title: m.name })),
                ...state.extracts.map(e => ({ id: e.id, type: 'extract', title: e.name }))
            ];

            // Filter out items already in this folder
            const folder = state.groups.find(g => g.id === folderId);
            const folderItemIds = folder?.items?.map(i => `${i.item_type}:${i.item_id}`) || [];
            const availableItems = allItems.filter(item => !folderItemIds.includes(`${item.type}:${item.id}`));

            if (availableItems.length === 0) {
                showToast('No items available to add', 'info');
                return;
            }

            // Store data in state for the modal
            state.folderItemsToAdd = availableItems;
            state.targetFolderId = folderId;
            state.selectedFolderItems = []; // Reset selections

            // Show custom selection modal
            state.modal = {
                type: 'selectItem',
                icon: 'üìÅ',
                title: 'Add Items to Folder',
                message: 'Select one or more items to add to this folder:',
                items: availableItems,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Add Selected Items', action: 'confirmAddMultipleItemsToFolder', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function toggleFolderItemSelection(itemIndex) {
            const index = state.selectedFolderItems.indexOf(itemIndex);
            if (index > -1) {
                state.selectedFolderItems.splice(index, 1);
            } else {
                state.selectedFolderItems.push(itemIndex);
            }

            // Update the visual state of checkboxes without full re-render
            const checkbox = document.querySelector(`[data-folder-item-index="${itemIndex}"]`);
            if (checkbox) {
                const isSelected = state.selectedFolderItems.includes(itemIndex);
                const checkboxIcon = checkbox.querySelector('.checkbox-icon');
                if (checkboxIcon) {
                    if (isSelected) {
                        checkboxIcon.innerHTML = `
                            <svg class="w-5 h-5 text-mauve-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                            </svg>
                        `;
                        checkbox.classList.add('border-mauve-400', 'bg-mauve-50');
                        checkbox.classList.remove('border-gray-200');
                    } else {
                        checkboxIcon.innerHTML = '<div class="w-4 h-4 border-2 border-gray-400 rounded"></div>';
                        checkbox.classList.remove('border-mauve-400', 'bg-mauve-50');
                        checkbox.classList.add('border-gray-200');
                    }
                }
            }

            // Update button state
            const addButton = document.querySelector('[data-add-items-button]');
            if (addButton) {
                if (state.selectedFolderItems.length > 0) {
                    addButton.disabled = false;
                    addButton.className = 'px-5 py-2 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700';
                    addButton.textContent = `Add Selected Items (${state.selectedFolderItems.length})`;
                } else {
                    addButton.disabled = true;
                    addButton.className = 'px-5 py-2 rounded-lg font-semibold transition text-sm bg-gray-300 text-gray-500 cursor-not-allowed';
                    addButton.textContent = 'Add Selected Items';
                }
            }
        }

        async function confirmAddMultipleItemsToFolder() {
            if (state.modalProcessing) return;
            if (state.selectedFolderItems.length === 0) {
                showToast('Please select at least one item', 'error');
                return;
            }

            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const folderId = state.targetFolderId;

            try {
                setLoading(`Adding ${state.selectedFolderItems.length} item(s) to folder...`);
                const folder = state.groups.find(g => g.id === folderId);
                const maxOrder = folder?.items?.length > 0 ? Math.max(...folder.items.map(i => i.display_order || 0)) : -1;

                // Prepare batch of items to insert
                const itemsToInsert = state.selectedFolderItems.map((itemIndex, idx) => {
                    const selectedItem = state.folderItemsToAdd[itemIndex];
                    return {
                        group_id: folderId,
                        item_id: selectedItem.id,
                        item_type: selectedItem.type,
                        display_order: maxOrder + idx + 1
                    };
                });

                // Batch insert all items
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify(itemsToInsert)
                });

                if (!response.ok) {
                    throw new Error('Failed to add items to folder');
                }

                    showToast(`Added ${state.selectedFolderItems.length} item(s) successfully`, 'success');
                state.selectedFolderItems = [];
                render();
                setTimeout(initializeFolderSortable, 100);
            } catch (error) {
                console.error('Error adding items to folder:', error);
                showToast('Failed to add items: ' + error.message, 'error');
                render();
            } finally {
                state.modalProcessing = false;
                clearLoading();
            }
        }

        async function selectFolderItem(itemIndex) {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const selectedItem = state.folderItemsToAdd[itemIndex];
            const folderId = state.targetFolderId;

            try {
                setLoading('Adding item to folder...');
                const folder = state.groups.find(g => g.id === folderId);
                const maxOrder = folder?.items?.length > 0 ? Math.max(...folder.items.map(i => i.display_order || 0)) : 0;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        group_id: folderId,
                        item_id: selectedItem.id,
                        item_type: selectedItem.type,
                        display_order: maxOrder + 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to add item to folder');
                }

                    showToast('Item added to folder successfully', 'success');
            } catch (error) {
                console.error('Error adding item to folder:', error);
                showToast('Failed to add item to folder: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                clearLoading();
                render();
            }
        }

        async function removeItemFromFolder(groupId, itemId, itemType) {
            try {
                setLoading('Removing item from folder...');

                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${groupId}&item_id=eq.${itemId}&item_type=eq.${itemType}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to remove item from folder');
                }

                    showToast('Item removed from folder', 'success');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error removing item from folder:', error);
                showToast('Failed to remove item: ' + error.message, 'error');
                clearLoading();
            }
        }

        async function saveFolderOrder(folderId, newOrder) {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?id=eq.${folderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                },
                body: JSON.stringify({
                    display_order: newOrder
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(`Failed to update folder order: ${error.message || response.statusText}`);
            }
        }

        async function saveItemOrder(groupId, itemId, itemType, newOrder) {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${groupId}&item_id=eq.${itemId}&item_type=eq.${itemType}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                },
                body: JSON.stringify({
                    display_order: newOrder
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(`Failed to update item order: ${error.message || response.statusText}`);
            }
        }

        function toggleFolderExpanded(folderId) {
            const index = state.expandedFolderIds.indexOf(folderId);
            if (index > -1) {
                state.expandedFolderIds.splice(index, 1);
            } else {
                state.expandedFolderIds.push(folderId);
            }
            render();
        }


        function viewAllByCreator(userId) {
            state.filters.createdBy = userId;
            state.view = 'home';
            render();
        }

        async function viewUserProfile(userId) {
            // Close other modals first to prevent stacking
            state.contestInfoModal = null;
            state.modal = null;

            state.viewingUserId = userId;
            state.showUserProfileModal = true;
            document.body.classList.add('modal-open');

            // Ensure allUsers is loaded
            if (!state.allUsers || state.allUsers.length === 0) {
                try {
                    const usersResponse = await fetch(`${SUPABASE_URL}/rest/v1/users?select=*`, {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    });

                    if (usersResponse.ok) {
                        const users = await usersResponse.json();
                        state.allUsers = users.map(user => ({
                            id: user.id,
                            username: user.username,
                            avatar: user.avatar,
                            isBanned: user.is_banned || false
                        }));
                    }
                } catch (error) {
                    console.error('Error loading users:', error);
                    state.allUsers = [];
                }
            }

            // Fetch user's voting history
            try {
                const votesResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&select=contest_id`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const userVotes = await votesResponse.json();

                // Store unique contest IDs this user has voted on
                state.userProfileVotedContests = [...new Set(userVotes.map(v => v.contest_id))];
                state.userProfileTotalVotes = userVotes.length;
            } catch (error) {
                console.error('Error loading user voting history:', error);
                state.userProfileVotedContests = [];
                state.userProfileTotalVotes = 0;
            }

            render();
        }

        function closeUserProfileModal() {
            state.showUserProfileModal = false;
            state.viewingUserId = null;
            state.userProfileVotedContests = [];
            document.body.classList.remove('modal-open');
            render();
        }

        async function banUser(userId, banReason) {
            try {
                // Update database with ban status and reason
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${userId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_banned: true,
                        ban_reason: banReason
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to ban user in database');
                }

                // Update local state
                if (!state.bannedUsers.includes(userId)) {
                    state.bannedUsers.push(userId);
                }

                // Update allUsers state
                const userIndex = state.allUsers.findIndex(u => u.id === userId);
                if (userIndex !== -1) {
                    state.allUsers[userIndex].isBanned = true;
                    state.allUsers[userIndex].banReason = banReason;
                }

                // Reload results to refresh vote data with updated ban status
                if (state.view === 'results' && state.currentContest) {
                    await loadResults();
                }

                showAlert('User has been banned.', '‚úÖ');
                render();
            } catch (error) {
                console.error('Error banning user:', error);
                showAlert('Failed to ban user: ' + error.message, '‚ùå');
            }
        }

        async function unbanUser(userId) {
            try {
                // Update database - clear ban status and reason
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${userId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_banned: false,
                        ban_reason: null
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to unban user in database');
                }

                // Update local state
                state.bannedUsers = state.bannedUsers.filter(id => id !== userId);

                // Update allUsers state
                const userIndex = state.allUsers.findIndex(u => u.id === userId);
                if (userIndex !== -1) {
                    state.allUsers[userIndex].isBanned = false;
                    state.allUsers[userIndex].banReason = null;
                }

                // Reload results to refresh vote data with updated ban status
                if (state.view === 'results' && state.currentContest) {
                    await loadResults();
                }

                showAlert('User has been unbanned. Their votes will now be included in results.', '‚úÖ');
                render();
            } catch (error) {
                console.error('Error unbanning user:', error);
                showAlert('Failed to unban user: ' + error.message, '‚ùå');
            }
        }

        function confirmBanUser(userId) {
            // Store userId for later use
            state.userToBan = userId;
            showInputModal(
                'Ban User - Enter Reason',
                'e.g., spam, inappropriate content, etc.',
                'handleBanUserReason',
                false
            );
        }

        function handleBanUserReason() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const banReason = input ? input.value.trim() : '';

            if (!banReason || banReason.length === 0) {
                showAlert('Ban reason cannot be empty.', '‚ùå');
                return;
            }
            if (banReason.length > 500) {
                showAlert('Ban reason is too long (max 500 characters).', '‚ùå');
                return;
            }

            // Proceed with ban
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            banUser(state.userToBan, banReason);
            state.userToBan = null;
            state.modalProcessing = false;
        }

        function executeBanUser(userId) {
            // This function is no longer used, but kept for backwards compatibility
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            banUser(userId, 'No reason provided');
            state.modalProcessing = false;
        }


        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (state.showBreakdownModal) {
                    closeBreakdown();
                } else if (state.modal) {
                    closeModal();
                }
            }
        });

        function renderToast() {
            if (!state.toast) return '';

            return `
                <div class="fixed top-4 left-1/2 transform -translate-x-1/2 z-[70] toast-notification">
                    <div class="bg-white rounded-lg shadow-2xl px-6 py-3 flex items-center gap-3 border-2 border-green-500">
                        <span class="text-2xl">${state.toast.icon}</span>
                        <span class="text-sm font-semibold text-gray-800">${state.toast.message}</span>
                    </div>
                </div>
            `;
        }

        function renderUnifiedCreateModal() {
            if (!state.showUnifiedCreateModal) return '';

            const isBanned = state.user && state.bannedUsers.includes(state.user.id);
            const contestCreationEnabled = state.appSettings.contest_creation_enabled !== false;
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const canCreate = !isBanned && (contestCreationEnabled || isAdmin);

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeUnifiedCreateModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full p-6 modal-content" onclick="event.stopPropagation()">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-2xl font-bold text-gray-800">Create New Item</h3>
                            <button onclick="closeUnifiedCreateModal()" class="text-gray-500 hover:text-gray-700">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                            </button>
                        </div>

                        <p class="text-sm text-gray-600 mb-6">Choose what type of item you'd like to create:</p>

                        ${canCreate ? `
                            <div class="space-y-3">
                                <!-- Contest Option -->
                                <button
                                    onclick="closeUnifiedCreateModal(); startCreateContest();"
                                    class="w-full text-left p-4 bg-gradient-to-r from-green-50 to-green-100 hover:from-green-100 hover:to-green-200 rounded-lg border-2 border-green-300 transition group"
                                >
                                    <div class="flex items-start gap-4">
                                        <div class="text-3xl">üèÜ</div>
                                        <div class="flex-1">
                                            <h4 class="text-lg font-bold text-gray-800 group-hover:text-green-700">Contest</h4>
                                            <p class="text-sm text-gray-600 mt-1">Create a new voting contest with images. Users can vote on each image with scores from 1-5.</p>
                                        </div>
                                        <svg class="w-6 h-6 text-green-600 flex-shrink-0 mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                        </svg>
                                    </div>
                                </button>

                                <!-- Merger Option -->
                                <button
                                    onclick="closeUnifiedCreateModal(); openCreateMergerModal();"
                                    class="w-full text-left p-4 bg-gradient-to-r from-blue-50 to-blue-100 hover:from-blue-100 hover:to-blue-200 rounded-lg border-2 border-blue-300 transition group"
                                >
                                    <div class="flex items-start gap-4">
                                        <div class="text-3xl">üîÄ</div>
                                        <div class="flex-1">
                                            <h4 class="text-lg font-bold text-gray-800 group-hover:text-blue-700">Merger</h4>
                                            <p class="text-sm text-gray-600 mt-1">Combine multiple existing contests into one merged voting session. View aggregated results across all selected contests.</p>
                                        </div>
                                        <svg class="w-6 h-6 text-blue-600 flex-shrink-0 mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                        </svg>
                                    </div>
                                </button>

                                <!-- Extract Option -->
                                <button
                                    onclick="closeUnifiedCreateModal(); openCreateExtractModal();"
                                    class="w-full text-left p-4 bg-gradient-to-r from-yellow-50 to-yellow-100 hover:from-yellow-100 hover:to-yellow-200 rounded-lg border-2 border-yellow-300 transition group"
                                >
                                    <div class="flex items-start gap-4">
                                        <div class="text-3xl">‚úÇÔ∏è</div>
                                        <div class="flex-1">
                                            <h4 class="text-lg font-bold text-gray-800 group-hover:text-yellow-700">Extract</h4>
                                            <p class="text-sm text-gray-600 mt-1">Create a subset by selecting specific images from an existing contest or merger. Perfect for narrowing down favourites.</p>
                                        </div>
                                        <svg class="w-6 h-6 text-yellow-600 flex-shrink-0 mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                        </svg>
                                    </div>
                                </button>
                            </div>
                        ` : `
                            <div class="text-center py-8">
                                <div class="text-6xl mb-4">üö´</div>
                                <h4 class="text-lg font-bold text-gray-800 mb-2">Creation Disabled</h4>
                                <p class="text-gray-600">Contest creation is currently disabled. Please contact an administrator.</p>
                            </div>
                        `}
                    </div>
                </div>
            `;
        }

        function renderModal() {
            if (!state.modal) return '';

            const isInput = state.modal.type === 'input';
            const isSelectItem = state.modal.type === 'selectItem';

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-${isSelectItem ? '2xl' : 'md'} w-full ${isSelectItem ? 'max-h-[80vh]' : ''} p-6 modal-content ${isSelectItem ? 'flex flex-col' : ''}" onclick="event.stopPropagation()">
                        <div class="text-center mb-2 ${isSelectItem ? 'flex-shrink-0' : ''}">
                            <div class="text-5xl mb-2">${state.modal.icon}</div>
                            ${isInput ? `
                                <h3 class="text-xl font-bold text-gray-800 mb-2">${state.modal.title}</h3>
                                <input id="modal-input" type="text" value="${state.modal.inputValue || ''}" class="modal-input w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-mauve-400 focus:outline-none" placeholder="${state.modal.placeholder}" />
                            ` : isSelectItem ? `
                                <h3 class="text-xl font-bold text-gray-800 mb-2">${state.modal.title}</h3>
                                <p class="text-sm text-gray-600 mb-2">${state.modal.message}</p>
                            ` : `
                                <p class="text-base font-bold text-gray-800 whitespace-pre-line">${state.modal.message}</p>
                            `}
                        </div>
                        ${isSelectItem ? `
                            <div class="flex-1 overflow-y-auto mb-4">
                                <div class="space-y-2">
                                    ${state.modal.items.map((item, idx) => {
                                        const typeColor = item.type === 'contest' ? 'mauve' : item.type === 'merger' ? 'blue' : 'yellow';
                                        const isSelected = state.selectedFolderItems.includes(idx);
                                        return `
                                            <div data-folder-item-index="${idx}" class="border-2 ${isSelected ? 'border-mauve-400 bg-mauve-50' : 'border-gray-200'} rounded-lg p-3 cursor-pointer hover:border-${typeColor}-400 hover:bg-${typeColor}-50 transition"
                                                 onclick="toggleFolderItemSelection(${idx})">
                                                <div class="flex items-center gap-3">
                                                    <div class="checkbox-icon flex-shrink-0 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-md border-2 ${isSelected ? 'border-mauve-500' : 'border-gray-300'}">
                                                        ${isSelected ? `
                                                            <svg class="w-5 h-5 text-mauve-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                            </svg>
                                                        ` : `
                                                            <div class="w-4 h-4 border-2 border-gray-400 rounded"></div>
                                                        `}
                                                    </div>
                                                    <div class="flex-1">
                                                        <div class="font-semibold text-gray-800">${item.title}</div>
                                                        <div class="text-xs text-gray-500 uppercase">${item.type}</div>
                                                    </div>
                                                    <div class="text-2xl flex-shrink-0">
                                                        ${item.type === 'contest' ? 'üé®' : item.type === 'merger' ? 'üîÄ' : '‚≠ê'}
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        ` : ''}
                        <div class="flex gap-2 justify-center ${isSelectItem ? 'flex-shrink-0' : ''}">
                            ${(state.modal.buttons || []).map(btn => {
                                const deleteContestMatch = btn.action.match(/confirmDeleteContest_(.+)/);
                                const banUserMatch = btn.action.match(/executeBanUser_(.+)/);
                                const removeImageMatch = btn.action.match(/confirmRemoveImage_(.+)/);
                                const editVoteMatch = btn.action.match(/confirmEditVote_(.+)_(.+)_(.+)_(.+)/);
                                const toggleBlockMatch = btn.action.match(/executeToggleBlockVote_(.+)_(.+)_(true|false)/);
                                let onclick;
                                if (deleteContestMatch) {
                                    onclick = `confirmDeleteContest('${deleteContestMatch[1]}')`;
                                } else if (banUserMatch) {
                                    onclick = `executeBanUser('${banUserMatch[1]}')`;
                                } else if (removeImageMatch) {
                                    onclick = `confirmRemoveImage(${removeImageMatch[1]})`;
                                } else if (editVoteMatch) {
                                    onclick = `confirmEditVote('${editVoteMatch[1]}', ${editVoteMatch[2]}, ${editVoteMatch[3]}, ${editVoteMatch[4]})`;
                                } else if (toggleBlockMatch) {
                                    onclick = `executeToggleBlockVote('${toggleBlockMatch[1]}', ${toggleBlockMatch[2]}, ${toggleBlockMatch[3]})`;
                                } else {
                                    onclick = `${btn.action}()`;
                                }

                                const isAddButton = btn.action === 'confirmAddMultipleItemsToFolder';
                                const isDisabled = isAddButton && state.selectedFolderItems.length === 0;

                                // Determine button color based on custom color property
                                let buttonClass = '';
                                if (isDisabled) {
                                    buttonClass = 'bg-gray-300 text-gray-500 cursor-not-allowed';
                                } else if (btn.color === 'pink') {
                                    buttonClass = 'bg-gradient-to-r from-pink-400 to-pink-600 text-white hover:from-pink-500 hover:to-pink-700';
                                } else if (btn.color === 'blue') {
                                    buttonClass = 'bg-gradient-to-r from-blue-400 to-blue-600 text-white hover:from-blue-500 hover:to-blue-700';
                                } else if (btn.color === 'red') {
                                    buttonClass = 'bg-gradient-to-r from-red-500 to-red-600 text-white hover:from-red-600 hover:to-red-700';
                                } else if (btn.color === 'red-outline') {
                                    buttonClass = 'border-2 border-red-500 text-red-500 hover:bg-red-50 bg-white';
                                } else if (btn.primary) {
                                    buttonClass = 'bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700';
                                } else {
                                    buttonClass = 'bg-gray-200 text-gray-800 hover:bg-gray-300';
                                }

                                return `
                                    <button
                                        ${isAddButton ? 'data-add-items-button' : ''}
                                        ${isDisabled ? 'disabled' : ''}
                                        onclick="${onclick}"
                                        class="px-5 py-2 rounded-lg font-semibold transition text-sm ${buttonClass}"
                                    >
                                        ${btn.text}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCreateExtract() {
            // Full page view for creating extract

            // Step 1: Select source (contest or merger)
            if (!state.extractSourceType) {
                return `
                    <div class="max-w-4xl mx-auto px-3 py-4">
                        <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                            <!-- Header -->
                            <div class="p-6 border-b border-gray-200">
                                <h3 class="text-2xl font-bold text-gray-800">Create Extract - Select Source</h3>
                                <p class="text-sm text-gray-600 mt-1">
                                    Choose a contest or merger to extract images from
                                </p>
                            </div>

                            <!-- Source Selection -->
                            <div class="p-6">

                                ${state.mergers.length > 0 ? `
                                    <div class="mb-4">
                                        <h4 class="font-semibold text-gray-700 mb-2">Mergers</h4>
                                        <div class="space-y-2">
                                            ${state.mergers.map(merger => {
                                                const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                                                const totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);
                                                return `
                                                    <div class="border border-gray-200 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-yellow-400 hover:bg-yellow-50"
                                                         onclick="selectExtractSource('merger', '${merger.id}')">
                                                        <img src="${merger.creatorAvatar}" alt="${merger.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                        <div class="flex-1 min-w-0">
                                                            <h5 class="font-semibold text-gray-800 truncate">${merger.name}</h5>
                                                            <p class="text-xs text-gray-500">
                                                                ${merger.creatorName} ‚Ä¢ ${totalImages} images from ${mergedContests.length} contests
                                                            </p>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}

                                <div>
                                    <h4 class="font-semibold text-gray-700 mb-2">Contests</h4>
                                    <div class="space-y-2">
                                        ${state.contests.map(contest => `
                                            <div class="border border-gray-200 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-yellow-400 hover:bg-yellow-50"
                                                 onclick="selectExtractSource('contest', '${contest.id}')">
                                                <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                <div class="flex-1 min-w-0">
                                                    <h5 class="font-semibold text-gray-800 truncate">${contest.title}</h5>
                                                    <p class="text-xs text-gray-500">
                                                        ${contest.creatorName} ‚Ä¢ ${contest.images.length} images
                                                    </p>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Step 2: Visual image picker with scale slider
            let sourceImages = [];
            let sourceName = '';
            let mergedContests = [];
            let showContestFilter = false;

            if (state.extractSourceType === 'contest') {
                const contest = state.contests.find(c => c.id === state.extractSourceId);
                if (contest) {
                    sourceImages = contest.images;
                    sourceName = contest.title;
                }
            } else if (state.extractSourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === state.extractSourceId);
                if (merger) {
                    mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceName = merger.name;
                    showContestFilter = true;

                    // Apply contest filter
                    if (state.extractContestFilter === 'all') {
                        sourceImages = mergedContests.flatMap(c => c.images);
                    } else {
                        const filteredContest = mergedContests.find(c => c.id === state.extractContestFilter);
                        sourceImages = filteredContest ? filteredContest.images : [];
                    }
                }
            }

            const selectedCount = (state.extractSelectedImages || []).length;
            const imageScale = state.extractImageScale || 100;

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <!-- Header -->
                        <div class="p-4 border-b border-gray-200">
                            <div class="flex items-center justify-between mb-3">
                                <div>
                                    <h3 class="text-2xl font-bold text-gray-800">Create Extract - Select Images</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        From: ${sourceName} (${selectedCount} selected)
                                    </p>
                                </div>
                            </div>
                            ${showContestFilter ? `
                                <div class="mt-4">
                                    <label class="text-sm font-medium text-gray-700 mb-2 block">Filter by Contest:</label>
                                    <select
                                        onchange="setExtractContestFilter(this.value)"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-yellow-400 focus:outline-none"
                                    >
                                        <option value="all" ${state.extractContestFilter === 'all' ? 'selected' : ''}>
                                            Show All Contests (${mergedContests.reduce((sum, c) => sum + c.images.length, 0)} images)
                                        </option>
                                        ${mergedContests.map(contest => `
                                            <option value="${contest.id}" ${state.extractContestFilter === contest.id ? 'selected' : ''}>
                                                ${contest.title} (${contest.images.length} images)
                                            </option>
                                        `).join('')}
                                    </select>
                                </div>
                            ` : ''}

                            <!-- Image Scale Slider -->
                            <div class="mt-3">
                                <label class="text-sm font-medium text-gray-700 mb-2 block">Image Scale</label>
                                <div class="flex items-center gap-2">
                                    <button
                                        onclick="adjustExtractImageScale(-1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Decrease scale by 1%"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        min="20"
                                        max="250"
                                        value="${imageScale}"
                                        oninput="updateExtractImageScale(this.value)"
                                        class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                                    />
                                    <button
                                        onclick="adjustExtractImageScale(1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Increase scale by 1%"
                                    >+</button>
                                    <span class="text-sm font-medium text-gray-700 w-12">${imageScale}%</span>
                                </div>
                            </div>
                        </div>

                        <!-- Image Grid -->
                        <div class="p-4">
                            <div class="flex flex-wrap gap-1">
                                ${sourceImages.map(image => {
                                    const isSelected = (state.extractSelectedImages || []).includes(image.id);
                                    const baseSize = 150;
                                    const imageHeight = Math.max(30, Math.min(500, Math.floor(baseSize * (imageScale / 100))));
                                    return `
                                        <div data-image-id="${image.id}">
                                            <div
                                                class="relative cursor-pointer rounded-lg overflow-hidden border-4 bg-gray-100 ${isSelected ? 'border-blue-500 bg-blue-50' : 'border-transparent hover:border-blue-300'}"
                                                onclick="toggleExtractImage(${image.id})"
                                                style="height: ${imageHeight}px;"
                                            >
                                                <img src="${image.url}" alt="" class="h-full w-auto object-cover" />
                                                <div class="absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 ${isSelected ? 'border-blue-500' : 'border-gray-300'}">
                                                ${isSelected ? `
                                                    <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                    </svg>
                                                ` : `
                                                    <div class="w-4 h-4 border-2 border-gray-400 rounded"></div>
                                                `}
                                            </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Name Input and Footer -->
                        <div class="p-4 border-t border-gray-200">
                            <div class="mb-4">
                                <label class="text-sm font-medium text-gray-700 mb-1 block">Extract Name</label>
                                <input
                                    id="extract-name-input"
                                    type="text"
                                    value="${state.newExtractName || ''}"
                                    oninput="setExtractName(this.value)"
                                    onblur="updateExtractNameOnBlur()"
                                    placeholder="Enter name for this extract..."
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-yellow-400 focus:outline-none"
                                />
                            </div>
                            <div class="flex gap-3">
                                <button
                                    data-extract-save
                                    onclick="saveExtract()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedCount > 0 && state.newExtractName ? 'bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedCount === 0 || !state.newExtractName ? 'disabled' : ''}
                                >
                                    Create Extract (${selectedCount} selected)
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderEditExtractModal() {
            // Full page view for editing extract
            const extract = state.extracts.find(e => e.id === state.editingExtractId);
            if (!extract) return '';

            // Get source images
            let sourceImages = [];
            let sourceName = '';

            if (extract.sourceType === 'contest') {
                const contest = state.contests.find(c => c.id === extract.sourceContestId);
                if (contest) {
                    sourceImages = contest.images;
                    sourceName = contest.title;
                }
            } else if (extract.sourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceImages = mergedContests.flatMap(c => c.images);
                    sourceName = merger.name;
                }
            }

            const selectedCount = (state.editExtractSelectedImages || []).length;
            const imageScale = state.extractImageScale || 100;

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <!-- Header -->
                        <div class="p-4 border-b border-gray-200">
                            <div class="mb-3">
                                <h3 class="text-2xl font-bold text-gray-800">Edit Extract - ${extract.name}</h3>
                                <p class="text-sm text-gray-600 mt-1">
                                    From: ${sourceName} (${selectedCount} selected)
                                </p>
                            </div>

                            <!-- Image Scale Slider -->
                            <div class="mt-3">
                                <label class="text-sm font-medium text-gray-700 mb-2 block">Image Scale</label>
                                <div class="flex items-center gap-2">
                                    <button
                                        onclick="adjustExtractImageScale(-1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Decrease scale by 1%"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        min="20"
                                        max="250"
                                        value="${imageScale}"
                                        oninput="updateExtractImageScale(this.value)"
                                        class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                                    />
                                    <button
                                        onclick="adjustExtractImageScale(1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Increase scale by 1%"
                                    >+</button>
                                    <span class="text-sm font-medium text-gray-700 w-12">${imageScale}%</span>
                                </div>
                            </div>
                        </div>

                        <!-- Image Grid -->
                        <div class="p-4">
                            <div class="flex flex-wrap gap-1">
                                ${sourceImages.map(image => {
                                    const isSelected = (state.editExtractSelectedImages || []).includes(image.id);
                                    const baseSize = 150;
                                    const imageHeight = Math.max(30, Math.min(500, Math.floor(baseSize * (imageScale / 100))));
                                    return `
                                        <div data-image-id="${image.id}">
                                            <div
                                                class="relative cursor-pointer rounded-lg overflow-hidden border-4 bg-gray-100 ${isSelected ? 'border-blue-500 bg-blue-50' : 'border-transparent hover:border-blue-300'}"
                                                onclick="toggleEditExtractImage(${image.id})"
                                                style="height: ${imageHeight}px;"
                                            >
                                                <img src="${image.url}" alt="" class="h-full w-auto object-cover" />
                                                <div class="absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 ${isSelected ? 'border-blue-500' : 'border-gray-300'}">
                                                ${isSelected ? `
                                                    <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                    </svg>
                                                ` : `
                                                    <div class="w-4 h-4 border-2 border-gray-400 rounded"></div>
                                                `}
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Footer -->
                        <div class="p-4 border-t border-gray-200">
                            <button
                                onclick="saveEditedExtract()"
                                class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedCount > 0 ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                ${selectedCount === 0 ? 'disabled' : ''}
                            >
                                Save Changes (${selectedCount} selected)
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCreateMergerModal() {
            if (!state.showCreateMergerModal) return '';

            // State for selected contests for merging
            const selectedContests = state.selectedContestsForMerge || [];

            // Check if any selected contest has an extract that includes it
            // This prevents duplicate images (extract + source contest)
            const hasExtractConflict = selectedContests.some(contestId => {
                const contest = state.contests.find(c => c.id === contestId);
                if (!contest) return false;

                // Check if any extract uses this contest as a source
                return state.extracts.some(extract => {
                    if (extract.sourceType === 'contest' && extract.sourceContestId === contestId) {
                        // Check if any selected contest is in the extract's images
                        return selectedContests.some(otherContestId => {
                            if (otherContestId === contestId) return false;
                            const otherContest = state.contests.find(c => c.id === otherContestId);
                            if (!otherContest) return false;
                            // Check if any image from other contest is in the extract
                            return otherContest.images.some(img => extract.imageIds.includes(img.id));
                        });
                    }
                    return false;
                });
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeCreateMergerModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">Create Merge</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        Select contests to merge together (${selectedContests.length} selected, min 2 required)
                                    </p>
                                </div>
                                <button onclick="closeCreateMergerModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Contest List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-2">
                            ${state.contests.map(contest => {
                                const isSelected = selectedContests.includes(contest.id);

                                return `
                                    <div class="border ${isSelected ? 'border-blue-400 bg-blue-50' : 'border-gray-200'} rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-blue-300"
                                         onclick="toggleContestForMerger('${contest.id}')">
                                        <input
                                            type="checkbox"
                                            ${isSelected ? 'checked' : ''}
                                            class="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
                                            onclick="event.stopPropagation()"
                                            onchange="toggleContestForMerger('${contest.id}')"
                                        />
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h4 class="font-semibold text-gray-800 truncate">${contest.title}</h4>
                                            </div>
                                            <p class="text-xs text-gray-500">
                                                ${contest.creatorName} ‚Ä¢ ${contest.images.length} images ‚Ä¢ ${contest.voterCount || 0} voters
                                            </p>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <!-- Name Input and Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${hasExtractConflict ? `
                                <div class="mb-4 bg-red-50 border border-red-300 text-red-700 p-3 rounded-lg text-sm">
                                    ‚ö†Ô∏è Warning: You've selected a contest and an extract that includes images from that contest. This will create duplicates.
                                </div>
                            ` : ''}
                            <div class="mb-4">
                                <label class="text-sm font-medium text-gray-700 mb-1 block">Merger Name</label>
                                <input
                                    id="merger-name-input"
                                    type="text"
                                    value="${state.newMergerName || ''}"
                                    oninput="setMergerName(this.value)"
                                    onblur="updateMergerNameOnBlur()"
                                    placeholder="Enter name for this merger..."
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-blue-400 focus:outline-none"
                                />
                            </div>
                            <div class="flex gap-3">
                                <button
                                    onclick="closeCreateMergerModal()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                                >
                                    Cancel
                                </button>
                                <button
                                    onclick="saveMerger()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedContests.length >= 2 && state.newMergerName && !hasExtractConflict ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedContests.length < 2 || !state.newMergerName || hasExtractConflict ? 'disabled' : ''}
                                >
                                    Create Merger
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderEditMergerModal() {
            if (!state.showEditMergerModal) return '';

            const merger = state.mergers.find(m => m.id === state.editingMergerId);
            if (!merger) return '';

            // State for selected contests for editing
            const selectedContests = state.editMergerSelectedContests || [];

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeEditMergerModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">Edit Merger - ${merger.name}</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        Select contests to include in this merger (${selectedContests.length} selected, min 2 required)
                                    </p>
                                </div>
                                <button onclick="closeEditMergerModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Contest List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-2">
                            ${state.contests.map(contest => {
                                const isSelected = selectedContests.includes(contest.id);

                                return `
                                    <div class="border ${isSelected ? 'border-purple-400 bg-purple-50' : 'border-gray-200'} rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-purple-300"
                                         onclick="toggleContestForEditMerger('${contest.id}')">
                                        <input
                                            type="checkbox"
                                            ${isSelected ? 'checked' : ''}
                                            class="w-5 h-5 rounded border-gray-300 text-purple-600 focus:ring-purple-500 cursor-pointer"
                                            onclick="event.stopPropagation()"
                                            onchange="toggleContestForEditMerger('${contest.id}')"
                                        />
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h4 class="font-semibold text-gray-800 truncate">${contest.title}</h4>
                                            </div>
                                            <p class="text-xs text-gray-500">
                                                ${contest.creatorName} ‚Ä¢ ${contest.images.length} images
                                            </p>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <!-- Footer -->
                        <div class="p-6 border-t border-gray-200">
                            <div class="flex gap-3">
                                <button
                                    onclick="closeEditMergerModal()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                                >
                                    Cancel
                                </button>
                                <button
                                    onclick="saveEditedMerger()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedContests.length >= 2 ? 'bg-gradient-to-r from-purple-500 to-purple-600 text-white hover:from-purple-600 hover:to-purple-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedContests.length < 2 ? 'disabled' : ''}
                                >
                                    Save Changes
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderUploadProgressModal() {
            if (!state.uploadProgress) return '';

            const allCompleted = state.uploadProgress.files.every(f => f.status === 'success' || f.status === 'failed');
            const successCount = state.uploadProgress.files.filter(f => f.status === 'success').length;
            const failedCount = state.uploadProgress.files.filter(f => f.status === 'failed').length;
            const uploadingCount = state.uploadProgress.files.filter(f => f.status === 'uploading').length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">
                                        ${allCompleted ? 'Upload Complete' : 'Uploading Images...'}
                                    </h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        ${successCount} succeeded, ${failedCount} failed, ${uploadingCount} in progress
                                    </p>
                                </div>
                                <div class="text-3xl">
                                    ${allCompleted ? (failedCount > 0 ? '‚ö†Ô∏è' : '‚úÖ') : '‚è≥'}
                                </div>
                            </div>
                        </div>

                        <!-- File List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-3">
                            ${state.uploadProgress.files.map((file, index) => `
                                <div class="border border-gray-200 rounded-lg p-4 ${
                                    file.status === 'success' ? 'bg-green-50 border-green-200' :
                                    file.status === 'failed' ? 'bg-red-50 border-red-200' :
                                    'bg-blue-50 border-blue-200'
                                }">
                                    <div class="flex items-start justify-between mb-2">
                                        <div class="flex-1 min-w-0">
                                            <p class="font-medium text-gray-800 truncate" title="${file.name}">
                                                ${file.name}
                                            </p>
                                            ${file.originalSize ? `
                                                <p class="text-xs text-gray-600 mt-1">${(file.originalSize / 1024).toFixed(0)}KB</p>
                                            ` : ''}
                                            ${file.error ? `
                                                <p class="text-xs text-red-600 mt-1">${file.error}</p>
                                            ` : ''}
                                        </div>
                                        <div class="ml-3 text-2xl flex-shrink-0">
                                            ${file.status === 'success' ? '‚úÖ' :
                                              file.status === 'failed' ? '‚ùå' :
                                              file.status === 'uploading' ? '‚è≥' : '‚è±Ô∏è'}
                                        </div>
                                    </div>

                                    <!-- Progress Bar -->
                                    ${file.status === 'uploading' || file.status === 'pending' ? `
                                        <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                                            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300"
                                                 style="width: ${file.progress || 0}%"></div>
                                        </div>
                                        <p class="text-xs text-gray-600">
                                            ${file.progress || 0}%
                                        </p>
                                    ` : ''}

                                    <!-- Retry Button -->
                                    ${file.status === 'failed' ? `
                                        <button onclick="retryUpload(${index})"
                                                class="mt-2 px-3 py-1 text-xs bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">
                                            üîÑ Retry Upload
                                        </button>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>

                        <!-- Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${allCompleted ? `
                                <button onclick="closeUploadProgress()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700">
                                    Done
                                </button>
                            ` : `
                                <button onclick="cancelAllUploads()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300">
                                    Cancel Remaining Uploads
                                </button>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }


        function renderLoadingOverlay() {
            if (!state.isLoading) return '';
            return `<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100]">
                <div class="bg-white rounded-lg p-6 flex flex-col items-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-mauve-500 mb-3"></div>
                    <p class="text-gray-700 font-semibold">${state.loadingMessage}</p>
                </div>
            </div>`;
        }

        function renderMultiModeLoadingModal() {
            if (!state.isLoadingMultiModeImages) return '';
            const loadedCount = state.multiModeLoadedImages;
            const totalCount = state.multiModeTotalImages;
            const progress = totalCount > 0 ? (loadedCount / totalCount * 100) : 0;

            return `<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100]">
                <div class="bg-white rounded-lg p-8 flex flex-col items-center max-w-md w-full mx-4">
                    <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-green-600 mb-4"></div>
                    <h3 class="text-xl font-bold text-gray-800 mb-2">Loading Multi-Mode View</h3>
                    <p class="text-gray-600 text-center mb-4">Loading ${loadedCount} of ${totalCount} images...</p>
                    <div class="w-full bg-gray-200 rounded-full h-3 overflow-hidden">
                        <div class="bg-gradient-to-r from-green-500 to-green-600 h-full rounded-full transition-all duration-300" style="width: ${progress.toFixed(1)}%"></div>
                    </div>
                    <p class="text-sm text-gray-500 mt-2">${progress.toFixed(0)}% complete</p>
                </div>
            </div>`;
        }

        function renderTransitionModal() {
            if (!state.isTransitioningVotingMode) return '';

            return `<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100]">
                <div class="bg-white rounded-lg p-8 flex flex-col items-center max-w-md w-full mx-4">
                    <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-mauve-600 mb-4"></div>
                    <h3 class="text-xl font-bold text-gray-800 mb-2">Switching View...</h3>
                    <p class="text-gray-600 text-center">Please wait a moment</p>
                </div>
            </div>`;
        }

        function renderHeader() {
            const showBackButton = state.view === 'results' || state.view === 'vote' || state.view === 'mergedResults' || state.view === 'createExtract' || state.view === 'editExtract';
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isVoting = state.view === 'vote';

            return `
                <header class="safe-header bg-gradient-to-r from-mauve-600 via-mauve-300 to-green-700 text-white shadow-lg">
                    <div class="max-w-7xl mx-auto px-3 py-2 sm:py-3 flex justify-between items-center gap-2">
                        <div class="flex items-center gap-2">
                            <div onclick="backToHome()" class="w-8 h-8 rounded-full flex items-center justify-center bg-gradient-to-br from-mauve-300 to-mauve-500 cursor-pointer hover:opacity-80 transition">
                                <span class="text-xl">üå∫</span>
                            </div>
                            <h1 onclick="backToHome()" class="text-xl font-bold cursor-pointer hover:opacity-80 transition">Peony</h1>
                            ${showBackButton ? `
                                <button onclick="backToHome()" class="ml-2 bg-white/20 hover:bg-white/30 text-white px-3 py-1.5 sm:py-1 rounded-lg font-semibold transition text-sm flex items-center gap-1 min-h-[36px] sm:min-h-0">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                                    </svg>
                                    Back
                                </button>
                            ` : ''}
                        </div>

                        ${isVoting ? `
                            <!-- Voting Mode Toggle Switch (centered on desktop, right-aligned on mobile) -->
                            <div class="sm:absolute sm:left-1/2 sm:transform sm:-translate-x-1/2 ml-auto flex items-center gap-2 bg-white/20 backdrop-blur-sm rounded-lg px-3 py-1.5">
                                <button
                                    onclick="toggleVotingMode()"
                                    class="flex items-center gap-2 focus:outline-none"
                                >
                                    <svg class="w-4 h-4 ${state.votingMode === 'single' ? 'text-white' : 'text-white/50'}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                    </svg>
                                    <div class="relative inline-block w-10 h-5 sm:w-12 sm:h-6">
                                        <div class="absolute inset-0 bg-white/30 rounded-full transition"></div>
                                        <div class="absolute top-0.5 left-0.5 bg-white rounded-full w-4 h-4 sm:w-5 sm:h-5 transition-transform ${state.votingMode === 'multi' ? 'transform translate-x-5 sm:translate-x-6' : ''}"></div>
                                    </div>
                                    <svg class="w-5 h-5 ${state.votingMode === 'multi' ? 'text-white' : 'text-white/50'}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"/>
                                    </svg>
                                </button>
                            </div>
                        ` : ''}

                        ${!state.isLoggedIn ? `
                            <button onclick="login()" class="bg-white text-mauve-500 px-4 py-2 rounded-lg font-semibold hover:bg-pink-50 transition text-sm min-h-[36px]">
                                Login with Discord
                            </button>
                        ` : `
                            <div class="flex items-center gap-2">
                                <div class="relative">
                                    <button onclick="toggleUserDropdown()" class="flex items-center gap-2 cursor-pointer hover:opacity-80 focus:outline-none">
                                        <img src="${state.user.avatar}" alt="Avatar" class="w-7 h-7 rounded-full" />
                                        <span class="font-medium text-sm hidden sm:inline">${state.user.username}</span>
                                        <svg class="w-4 h-4 transition-transform ${state.showUserDropdown ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                                        </svg>
                                    </button>
                                    ${state.showUserDropdown ? `
                                        <div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg py-1 z-50">
                                            ${isAdmin ? `
                                                <button onclick="showAdminDashboard()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    ‚öôÔ∏è Admin Dashboard
                                                </button>
                                                <button onclick="showAppSettings()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    üîß App Settings
                                                </button>
                                            ` : ''}
                                            <button onclick="toggleDarkTheme()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 ${isAdmin ? 'border-t border-gray-200' : ''} flex items-center justify-between">
                                                <span>üåô Dark Theme</span>
                                                <div class="relative inline-block w-10 h-5 transition duration-200 ease-in-out rounded-full ${state.darkTheme ? 'bg-purple-500' : 'bg-gray-300'}">
                                                    <span class="absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full transition-transform duration-200 ease-in-out ${state.darkTheme ? 'translate-x-5' : 'translate-x-0'}"></span>
                                                </div>
                                            </button>
                                            <button onclick="logout()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 border-t border-gray-200">
                                                Logout
                                            </button>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `}
                    </div>
                </header>
            `;
        }

        function renderLoginScreen() {
            return `
                <div class="max-w-md mx-auto mt-20 p-6 bg-white rounded-2xl shadow-xl fade-in">
                    ${state.pendingRoute ? `
                        <div class="bg-blue-50 border border-blue-300 rounded-lg p-3 mb-4">
                            <p class="text-sm text-blue-800 flex items-center gap-2">
                                <span class="text-lg">üîó</span>
                                <span><strong>Shared Link Detected!</strong> Please login to view this content. You'll be redirected automatically after logging in.</span>
                            </p>
                        </div>
                    ` : ''}
                    <div class="text-center mb-6">
                        <div class="w-16 h-16 bg-gradient-to-br from-mauve-300 to-mauve-500 rounded-full flex items-center justify-center mx-auto mb-4">
                            <span class="text-3xl">üå∫</span>
                        </div>
                        <h2 class="text-2xl font-bold text-gray-800 mb-2">Welcome to Peony</h2>
                        <p class="text-gray-600 text-sm">Create and vote on image contests</p>
                    </div>

                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
                        <p class="text-xs text-blue-800">
                            <strong>Privacy Notice:</strong> This app only accesses your Discord username and avatar. Contact me if you have any questions.
                        </p>
                    </div>

                    <button onclick="login()" class="w-full bg-gradient-to-r from-indigo-600 to-indigo-700 text-white py-3 rounded-lg font-semibold hover:from-indigo-700 hover:to-indigo-800 transition flex items-center justify-center gap-2 text-sm">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                        Login with Discord
                    </button>
                </div>
            `;
        }

        function setSortBy(sortBy) {
            state.filters.sortBy = sortBy;
            render();
        }

        function setFilterCreator(creatorId) {
            state.filters.createdBy = creatorId === 'all' ? null : creatorId;
            render();
        }

        function setSearchQuery(query) {
            state.filters.searchQuery = query;
            // Update URL parameter
            const url = new URL(window.location);
            if (query) {
                url.searchParams.set('search', query);
            } else {
                url.searchParams.delete('search');
            }
            window.history.replaceState({}, '', url);
            render();
        }

        function applySearch() {
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                setSearchQuery(searchInput.value);
            }
        }

        function clearAllFilters() {
            state.filters.createdBy = null;
            state.filters.sortBy = 'newest';
            state.filters.searchQuery = '';
            // Clear URL parameter
            const url = new URL(window.location);
            url.searchParams.delete('search');
            window.history.replaceState({}, '', url);
            render();
        }

        function renderHome() {
            // Get unique creators
            const creators = [...new Set(state.contests.map(c => ({ id: c.createdBy, name: c.creatorName })))];
            const uniqueCreators = Array.from(new Map(creators.map(c => [c.id, c])).values());

            // Filter contests
            let filteredContests = state.contests;
            let filteredMergers = state.mergers;
            let filteredExtracts = state.extracts;

            // Filter by creator
            if (state.filters.createdBy) {
                filteredContests = filteredContests.filter(c => c.createdBy === state.filters.createdBy);
                filteredMergers = filteredMergers.filter(m => m.createdBy === state.filters.createdBy);
                filteredExtracts = filteredExtracts.filter(e => e.createdBy === state.filters.createdBy);
            }

            // Filter by search query
            if (state.filters.searchQuery) {
                const searchLower = state.filters.searchQuery.toLowerCase();
                filteredContests = filteredContests.filter(c =>
                    c.title.toLowerCase().includes(searchLower) ||
                    (c.creatorName && c.creatorName.toLowerCase().includes(searchLower))
                );
                filteredMergers = filteredMergers.filter(m =>
                    m.name.toLowerCase().includes(searchLower) ||
                    (m.creatorName && m.creatorName.toLowerCase().includes(searchLower))
                );
                filteredExtracts = filteredExtracts.filter(e =>
                    e.name.toLowerCase().includes(searchLower) ||
                    (e.creatorName && e.creatorName.toLowerCase().includes(searchLower))
                );
            }

            // Sort contests
            filteredContests = [...filteredContests].sort((a, b) => {
                // Apply selected sort
                const voterCountA = a.voterCount || 0;
                const voterCountB = b.voterCount || 0;

                switch (state.filters.sortBy) {
                    case 'newest':
                    case 'dateDesc':
                        return (b.createdAt || 0) - (a.createdAt || 0);
                    case 'oldest':
                    case 'dateAsc':
                        return (a.createdAt || 0) - (b.createdAt || 0);
                    case 'titleAsc':
                        return a.title.toLowerCase().localeCompare(b.title.toLowerCase());
                    case 'titleDesc':
                        return b.title.toLowerCase().localeCompare(a.title.toLowerCase());
                    case 'mostVoted':
                    case 'votersDesc':
                        return voterCountB - voterCountA;
                    case 'leastVoted':
                    case 'votersAsc':
                        return voterCountA - voterCountB;
                    case 'imagesDesc':
                        return b.images.length - a.images.length;
                    case 'imagesAsc':
                        return a.images.length - b.images.length;
                    default:
                        return 0;
                }
            });

            const isBanned = state.bannedUsers.includes(state.user.id);

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    ${(() => {
                        // CONTINUE DRAFTS SECTION
                        // Show contests/mergers where user has autosaved votes but hasn't submitted fully
                        const draftItems = [];

                        filteredContests.forEach(contest => {
                            if (contest.isLocked) return;
                            const autosaveKey = `contest_${contest.id}`;
                            const autosaves = state.userAutosavedVotes[autosaveKey] || {};
                            const autosaveCount = Object.keys(autosaves).length;
                            if (autosaveCount === 0) return;
                            // Don't show if user has fully voted (submitted all)
                            const userVotes = state.userVotedContests[contest.id] || {};
                            const votedAll = Object.keys(userVotes).length === contest.images.length && contest.images.length > 0;
                            if (votedAll) return;
                            draftItems.push({ item: contest, type: 'contest', autosaveCount, totalImages: contest.images.length });
                        });

                        filteredMergers.forEach(merger => {
                            if (merger.isLocked) return;
                            const autosaveKey = `merger_${merger.id}`;
                            const autosaves = state.userAutosavedVotes[autosaveKey] || {};
                            const autosaveCount = Object.keys(autosaves).length;
                            if (autosaveCount === 0) return;
                            // Don't show if user has fully voted all merger contests
                            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                            const totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);
                            const totalVoted = mergedContests.reduce((sum, c) => {
                                return sum + Object.keys(state.userVotedContests[c.id] || {}).length;
                            }, 0);
                            if (totalVoted === totalImages && totalImages > 0) return;
                            draftItems.push({ item: merger, type: 'merger', autosaveCount, totalImages });
                        });

                        // Sort by most recently modified (newest first) ‚Äì use item createdAt as proxy
                        draftItems.sort((a, b) => {
                            const dateA = new Date(a.item.createdAt || a.item.created_at || 0);
                            const dateB = new Date(b.item.createdAt || b.item.created_at || 0);
                            return dateB - dateA;
                        });

                        if (draftItems.length > 0) {
                            const displayItems = state.isAutosaveDraftExpanded ? draftItems : draftItems.slice(0, 1);
                            return `
                                <div class="mb-4">
                                    <div class="bg-gradient-to-r from-orange-400 to-orange-600 p-2.5 md:p-3 rounded-lg shadow-lg mb-3">
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-3 flex-1">
                                                <button
                                                    onclick="toggleAutosaveDraftSection()"
                                                    class="text-white hover:bg-white/20 rounded-lg p-1 transition"
                                                >
                                                    <svg class="w-5 h-5 transition-transform ${state.isAutosaveDraftExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                    </svg>
                                                </button>
                                                <div class="flex-1">
                                                    <h3 class="text-lg font-bold text-white">üìù Continue Draft</h3>
                                                    <p class="text-xs text-orange-100">Resume your in-progress votes</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2 mb-2">
                                        ${displayItems.map(({ item, type }) => {
                                            if (type === 'contest') return renderContestCard(item, false, null);
                                            if (type === 'merger') return renderMergerCard(item, false, null);
                                            return '';
                                        }).join('')}
                                    </div>
                                    ${draftItems.length > 1 && !state.isAutosaveDraftExpanded ? `
                                        <button
                                            onclick="toggleAutosaveDraftSection()"
                                            class="w-full text-center text-sm text-orange-500 hover:text-orange-600 font-medium py-2 bg-orange-50 hover:bg-orange-100 rounded-lg transition"
                                        >
                                            Show ${draftItems.length - 1} more draft${draftItems.length - 1 > 1 ? 's' : ''}
                                        </button>
                                    ` : ''}
                                </div>
                            `;
                        }
                        return '';
                    })()}

                    ${(() => {
                        // COMPLETE VOTING SECTION
                        // Identify contests and mergers where user has partial votes
                        const itemsToComplete = [];

                        // Check contests for partial votes (skip locked)
                        filteredContests.forEach(contest => {
                            if (contest.isLocked) return;
                            const userVotes = state.userVotedContests[contest.id];
                            if (userVotes && Object.keys(userVotes).length > 0) {
                                const totalImages = contest.images.length;
                                const votedImages = Object.keys(userVotes).length;
                                if (votedImages < totalImages) {
                                    // User has partial votes
                                    itemsToComplete.push({ item: contest, type: 'contest', votedImages, totalImages });
                                }
                            }
                        });

                        // Check mergers for partial votes (skip locked)
                        filteredMergers.forEach(merger => {
                            if (merger.isLocked) return;
                            const mergerContestIds = merger.contestIds || [];
                            let totalImages = 0;
                            let votedImages = 0;

                            mergerContestIds.forEach(contestId => {
                                const contest = state.contests.find(c => c.id === contestId);
                                if (contest) {
                                    totalImages += contest.images.length;
                                    const userVotes = state.userVotedContests[contestId];
                                    if (userVotes) {
                                        votedImages += Object.keys(userVotes).length;
                                    }
                                }
                            });

                            if (votedImages > 0 && votedImages < totalImages) {
                                // User has partial votes in this merger
                                itemsToComplete.push({ item: merger, type: 'merger', votedImages, totalImages });
                            }
                        });

                        // Check extracts for partial votes (skip locked)
                        filteredExtracts.forEach(extract => {
                            if (extract.isLocked) return;
                            const extractImageIds = extract.imageIds || [];
                            const totalImages = extractImageIds.length;

                            // Get the source contest ID for this extract
                            let sourceContestId = null;
                            if (extract.sourceType === 'contest') {
                                sourceContestId = extract.sourceId;
                            } else if (extract.sourceType === 'merger') {
                                // For mergers, we need to check all merged contests
                                const merger = state.mergers.find(m => m.id === extract.sourceId);
                                if (merger && merger.contestIds && merger.contestIds.length > 0) {
                                    sourceContestId = merger.contestIds[0]; // Use first contest for simplicity
                                }
                            }

                            if (sourceContestId) {
                                const userVotes = state.userVotedContests[sourceContestId];
                                if (userVotes) {
                                    // Count how many extract images have been voted on
                                    const votedImages = extractImageIds.filter(imgId => userVotes[imgId]).length;
                                    if (votedImages > 0 && votedImages < totalImages) {
                                        itemsToComplete.push({ item: extract, type: 'extract', votedImages, totalImages });
                                    }
                                }
                            }
                        });

                        // Sort items by created_at (newest first)
                        itemsToComplete.sort((a, b) => {
                            const dateA = new Date(a.item.createdAt || a.item.created_at || 0);
                            const dateB = new Date(b.item.createdAt || b.item.created_at || 0);
                            return dateB - dateA;
                        });

                        if (itemsToComplete.length > 0) {
                            const displayItems = state.isCompleteVotingExpanded ? itemsToComplete : itemsToComplete.slice(0, 1);

                            return `
                                <div class="mb-4">
                                    <div class="bg-gradient-to-r from-yellow-500 to-yellow-600 p-2.5 md:p-3 rounded-lg shadow-lg mb-3">
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-3 flex-1">
                                                <button
                                                    onclick="toggleCompleteVotingSection()"
                                                    class="text-white hover:bg-white/20 rounded-lg p-1 transition"
                                                >
                                                    <svg class="w-5 h-5 transition-transform ${state.isCompleteVotingExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                    </svg>
                                                </button>
                                                <div class="flex-1">
                                                    <h3 class="text-lg font-bold text-white">üå† Complete Voting</h3>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2 mb-2">
                                        ${displayItems.map(({ item, type, votedImages, totalImages }) => {
                                            const unvotedCount = totalImages - votedImages;
                                            const unvotedLabel = unvotedCount === 1
                                                ? 'Just 1 more vote needed!'
                                                : `Just ${unvotedCount} more votes needed!`;

                                            if (type === 'contest') return renderContestCard(item, false, unvotedLabel);
                                            if (type === 'merger') return renderMergerCard(item, false, unvotedLabel);
                                            if (type === 'extract') return renderExtractCard(item, false, unvotedLabel);
                                            return '';
                                        }).join('')}
                                    </div>
                                    ${itemsToComplete.length > 1 && !state.isCompleteVotingExpanded ? `
                                        <button
                                            onclick="toggleCompleteVotingSection()"
                                            class="w-full text-center text-sm text-yellow-600 hover:text-yellow-700 font-medium py-2 bg-yellow-50 hover:bg-yellow-100 rounded-lg transition"
                                        >
                                            Show ${itemsToComplete.length - 1} more item${itemsToComplete.length - 1 > 1 ? 's' : ''} to complete
                                        </button>
                                    ` : ''}
                                </div>
                            `;
                        }
                        return '';
                    })()}

                    ${(() => {
                        // PINNED ITEMS SECTION
                        const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

                        // Create array of pinned items with their data and timestamp, sorted by timestamp
                        const allPinnedItems = state.pinnedItems
                            .map(p => {
                                let item = null;
                                if (p.item_type === 'contest') {
                                    item = state.contests.find(c => c.id === p.item_id);
                                } else if (p.item_type === 'merger') {
                                    item = state.mergers.find(m => m.id === p.item_id);
                                } else if (p.item_type === 'extract') {
                                    item = state.extracts.find(e => e.id === p.item_id);
                                }
                                return item ? { item, type: p.item_type, pinnedAt: p.pinned_at } : null;
                            })
                            .filter(Boolean)
                            // Sort by pinned timestamp (most recent first)
                            .sort((a, b) => new Date(b.pinnedAt) - new Date(a.pinnedAt));

                        if (allPinnedItems.length > 0) {
                            const displayItems = state.isPinnedSectionExpanded ? allPinnedItems : allPinnedItems.slice(0, 3);

                            return `
                                <div class="mb-4">
                                    <div class="bg-gradient-to-r from-red-500 to-red-600 p-2.5 md:p-3 rounded-lg shadow-lg mb-3">
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-3 flex-1">
                                                <button
                                                    onclick="togglePinnedSection()"
                                                    class="text-white hover:bg-white/20 rounded-lg p-1 transition"
                                                >
                                                    <svg class="w-5 h-5 transition-transform ${state.isPinnedSectionExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                    </svg>
                                                </button>
                                                <div class="flex-1">
                                                    <h3 class="text-lg font-bold text-white">üìå Pinned</h3>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2 mb-2">
                                        ${displayItems.map(({ item, type }) => {
                                            if (type === 'contest') return renderContestCard(item, true);
                                            if (type === 'merger') return renderMergerCard(item, true);
                                            if (type === 'extract') return renderExtractCard(item, true);
                                            return '';
                                        }).join('')}
                                    </div>
                                    ${allPinnedItems.length > 3 && !state.isPinnedSectionExpanded ? `
                                        <button
                                            onclick="togglePinnedSection()"
                                            class="w-full text-center text-sm text-red-600 hover:text-red-700 font-medium py-2 bg-red-50 hover:bg-red-100 rounded-lg transition"
                                        >
                                            Show ${allPinnedItems.length - 3} more pinned items
                                        </button>
                                    ` : ''}
                                </div>
                            `;
                        }
                        return '';
                    })()}

                    <div class="bg-gradient-to-r from-green-500 to-green-600 p-2.5 md:p-3 rounded-lg shadow-lg mb-2">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-3 flex-1">
                                <button
                                    onclick="toggleAllContestsSection()"
                                    class="text-white hover:bg-white/20 rounded-lg p-1 transition"
                                >
                                    <svg class="w-5 h-5 transition-transform ${state.isAllContestsSectionExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                    </svg>
                                </button>
                                <div class="flex-1">
                                    <h2 class="text-lg font-bold text-white">üìö All Votings</h2>
                                </div>
                            </div>
                            ${!isBanned ? `
                                <div class="flex items-center gap-2">
                                    <button onclick="toggleFilters()" class="bg-white text-green-700 p-2 rounded-lg font-semibold hover:bg-green-50 transition shadow-lg" title="Search & Filter">
                                        üîç
                                    </button>
                                    <button onclick="openUnifiedCreateModal()" class="bg-white text-green-700 px-4 py-2 rounded-lg font-semibold hover:bg-green-50 transition shadow-lg text-sm whitespace-nowrap">
                                        + Create
                                    </button>
                                </div>
                            ` : `
                                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded-lg text-sm">
                                    üö´ Your account has been restricted. Contact admin.
                                </div>
                            `}
                        </div>
                    </div>

                    ${state.isAllContestsSectionExpanded && state.showFilters ? `
                        <div class="bg-white rounded-lg shadow-md mb-4 overflow-hidden">
                                <div class="p-3">
                                    <div class="mb-3">
                                        <label class="text-xs font-medium text-gray-700 mb-1 block">Search Contests</label>
                                        <div class="flex gap-2">
                                            <input
                                                id="search-input"
                                                type="text"
                                                value="${state.filters.searchQuery || ''}"
                                                onkeypress="if(event.key==='Enter') applySearch()"
                                                placeholder="Search by contest title or creator name..."
                                                class="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none"
                                            />
                                            <button
                                                onclick="applySearch()"
                                                class="px-4 py-2 bg-mauve-500 text-white rounded-lg text-sm font-semibold hover:bg-mauve-600 transition"
                                            >
                                                Search
                                            </button>
                                        </div>
                                    </div>
                                    <div class="flex gap-3 flex-wrap">
                                    <div class="flex-1 min-w-[200px]">
                                        <label class="text-xs font-medium text-gray-700 mb-1 block">Sort By</label>
                                        <select onchange="setSortBy(this.value)" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none">
                                            <option value="newest" ${state.filters.sortBy === 'newest' || state.filters.sortBy === 'dateDesc' ? 'selected' : ''}>Newest First</option>
                                            <option value="oldest" ${state.filters.sortBy === 'oldest' || state.filters.sortBy === 'dateAsc' ? 'selected' : ''}>Oldest First</option>
                                            <option value="titleAsc" ${state.filters.sortBy === 'titleAsc' ? 'selected' : ''}>A-Z</option>
                                            <option value="titleDesc" ${state.filters.sortBy === 'titleDesc' ? 'selected' : ''}>Z-A</option>
                                            <option value="imagesDesc" ${state.filters.sortBy === 'imagesDesc' ? 'selected' : ''}>Most Images</option>
                                            <option value="imagesAsc" ${state.filters.sortBy === 'imagesAsc' ? 'selected' : ''}>Fewest Images</option>
                                        </select>
                                    </div>
                                    <div class="flex-1 min-w-[200px]">
                                        <label class="text-xs font-medium text-gray-700 mb-1 block">Filter by Creator</label>
                                        <select onchange="setFilterCreator(this.value)" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none">
                                            <option value="all" ${state.filters.createdBy === null ? 'selected' : ''}>All Creators</option>
                                            ${uniqueCreators.map(creator => `
                                                <option value="${creator.id}" ${state.filters.createdBy === creator.id ? 'selected' : ''}>${creator.name}</option>
                                            `).join('')}
                                        </select>
                                    </div>
                                    ${state.filters.createdBy || state.filters.sortBy !== 'newest' || state.filters.searchQuery ? `
                                        <div class="flex items-end">
                                            <button onclick="clearAllFilters()" class="bg-red-500 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-600 transition text-sm">
                                                Clear All Filters
                                            </button>
                                        </div>
                                    ` : ''}
                                    </div>
                                </div>
                        </div>
                    ` : ''}

                    ${state.isAllContestsSectionExpanded ? `
                        ${state.filters.createdBy || state.filters.searchQuery ? `
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 flex gap-2 items-center flex-wrap">
                                <span class="text-sm font-medium text-blue-800">Active Filters:</span>
                                ${state.filters.createdBy ? `
                                    <span class="bg-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs font-semibold flex items-center gap-1">
                                        Creator: ${uniqueCreators.find(c => c.id === state.filters.createdBy)?.name || 'Unknown'}
                                        <button onclick="setFilterCreator('all')" class="hover:text-blue-900">‚úï</button>
                                    </span>
                                ` : ''}
                                ${state.filters.searchQuery ? `
                                    <span class="bg-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs font-semibold flex items-center gap-1">
                                        Search: "${state.filters.searchQuery}"
                                        <button onclick="setSearchQuery('')" class="hover:text-blue-900">‚úï</button>
                                    </span>
                                ` : ''}
                            </div>
                        ` : ''}
                    ` : ''}

                    ${(() => {
                        // Combine filtered contests, mergers, and extracts into a unified list
                        // Mix them without any type priority
                        const allItems = [
                            ...filteredContests.map(c => ({ ...c, itemType: 'contest' })),
                            ...filteredMergers.map(m => ({ ...m, itemType: 'merger' })),
                            ...filteredExtracts.map(e => ({ ...e, itemType: 'extract' }))
                        ];

                        // Apply sorting based on selected sort option
                        allItems.sort((a, b) => {

                            // Get image/item counts
                            const getItemCount = (item) => {
                                if (item.images) return item.images.length;
                                if (item.imageIds) return item.imageIds.length;
                                // For mergers, calculate total images from all merged contests
                                if (item.itemType === 'merger' && item.contestIds) {
                                    const mergedContests = state.contests.filter(c => item.contestIds.includes(c.id));
                                    return mergedContests.reduce((sum, c) => sum + c.images.length, 0);
                                }
                                return 0;
                            };
                            const itemCountA = getItemCount(a);
                            const itemCountB = getItemCount(b);

                            // Get titles/names for sorting
                            const titleA = (a.title || a.name || '').toLowerCase();
                            const titleB = (b.title || b.name || '').toLowerCase();

                            // Get timestamps for date sorting
                            const getTimestamp = (item) => {
                                if (!item.createdAt) return 0;
                                return new Date(item.createdAt).getTime();
                            };

                            switch (state.filters.sortBy) {
                                case 'newest':
                                case 'dateDesc':
                                case 'withFolders':
                                    return getTimestamp(b) - getTimestamp(a);
                                case 'oldest':
                                case 'dateAsc':
                                    return getTimestamp(a) - getTimestamp(b);
                                case 'titleAsc':
                                    return titleA.localeCompare(titleB);
                                case 'titleDesc':
                                    return titleB.localeCompare(titleA);
                                case 'imagesDesc':
                                    return itemCountB - itemCountA;
                                case 'imagesAsc':
                                    return itemCountA - itemCountB;
                                default:
                                    return getTimestamp(b) - getTimestamp(a);
                            }
                        });

                        // Check if we should show folders (only when sort is withFolders and no filters)
                        const showFolders = state.filters.sortBy === 'withFolders' && !state.filters.createdBy && !state.filters.searchQuery;

                        if (showFolders && state.groups.length > 0 && state.isAllContestsSectionExpanded) {
                            // Get items that are in folders
                            const itemsInFolders = new Set();
                            state.groups.forEach(group => {
                                (group.items || []).forEach(item => {
                                    itemsInFolders.add(`${item.item_type}:${item.item_id}`);
                                });
                            });

                            // Get ungrouped items
                            const ungroupedItems = allItems.filter(item =>
                                !itemsInFolders.has(`${item.itemType}:${item.id}`)
                            );

                            // Sort folders
                            const sortedGroups = [...state.groups];

                            // Get unfoldered items position from app settings (default to bottom if not set)
                            const unfolderedPosition = state.appSettings.unfoldered_items_position !== undefined
                                ? parseInt(state.appSettings.unfoldered_items_position)
                                : sortedGroups.length;

                            // Helper function to render a folder
                            const renderFolder = (group) => {
                                const isExpanded = state.expandedFolderIds.includes(group.id);
                                // Get actual items for this folder
                                const folderItems = (group.items || []).map(item => {
                                    if (item.item_type === 'contest') {
                                        const contest = state.contests.find(c => c.id === item.item_id);
                                        return contest ? { ...contest, itemType: 'contest' } : null;
                                    } else if (item.item_type === 'merger') {
                                        const merger = state.mergers.find(m => m.id === item.item_id);
                                        return merger ? { ...merger, itemType: 'merger' } : null;
                                    } else if (item.item_type === 'extract') {
                                        const extract = state.extracts.find(e => e.id === item.item_id);
                                        return extract ? { ...extract, itemType: 'extract' } : null;
                                    }
                                    return null;
                                }).filter(Boolean);

                                const headerGradient = 'bg-gradient-to-r from-mauve-400 to-mauve-600 hover:from-mauve-500 hover:to-mauve-700';
                                const contentGradient = 'bg-gradient-to-b from-pink-50 to-pink-100';

                                return `
                                    <div class="bg-white rounded-xl shadow-lg overflow-hidden mb-2 md:mb-3 fade-in">
                                        <div class="${headerGradient} p-2.5 md:p-3 cursor-pointer transition" onclick="toggleFolderExpanded('${group.id}')">
                                            <div class="flex items-center gap-2 text-white">
                                                <svg class="w-5 h-5 transition-transform ${isExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                </svg>
                                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
                                                </svg>
                                                <div class="flex-1">
                                                    <h3 class="text-lg font-bold">${group.name}</h3>
                                                </div>
                                                <span class="text-sm opacity-90">${folderItems.length} items</span>
                                            </div>
                                        </div>
                                        ${isExpanded ? `
                                            <div class="p-2.5 md:p-3 ${contentGradient}">
                                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2">
                                                    ${folderItems.map(item => {
                                                        if (item.itemType === 'merger') {
                                                            return renderMergerCard(item);
                                                        } else if (item.itemType === 'extract') {
                                                            return renderExtractCard(item);
                                                        } else {
                                                            return renderContestCard(item);
                                                        }
                                                    }).join('')}
                                                </div>
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            };

                            // Helper function to render unfoldered items
                            const renderUnfolderedItems = () => {
                                if (ungroupedItems.length === 0) return '';
                                return `
                                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2 mb-2 md:mb-3">
                                        ${ungroupedItems.map(item => {
                                            if (item.itemType === 'merger') {
                                                return renderMergerCard(item);
                                            } else if (item.itemType === 'extract') {
                                                return renderExtractCard(item);
                                            } else {
                                                return renderContestCard(item);
                                            }
                                        }).join('')}
                                    </div>
                                `;
                            };

                            // Build the output with unfoldered items at the correct position
                            return `
                                ${(() => {
                                    let output = '';
                                    sortedGroups.forEach((group, index) => {
                                        // Insert unfoldered items before this folder if needed
                                        if (index === unfolderedPosition) {
                                            output += renderUnfolderedItems();
                                        }
                                        output += renderFolder(group);
                                    });
                                    // Insert unfoldered items at the end if position >= folder count
                                    if (unfolderedPosition >= sortedGroups.length) {
                                        output += renderUnfolderedItems();
                                    }
                                    return output;
                                })()}
                            `;
                        } else {
                            // Show flat list when not using default sort or when no folders exist
                            const displayItems = state.isAllContestsSectionExpanded ? allItems : allItems.slice(0, 6);

                            return `
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2 mb-2">
                                    ${displayItems.map(item => {
                                        if (item.itemType === 'merger') {
                                            return renderMergerCard(item);
                                        } else if (item.itemType === 'extract') {
                                            return renderExtractCard(item);
                                        } else {
                                            return renderContestCard(item);
                                        }
                                    }).join('')}
                                </div>
                                ${allItems.length > 6 && !state.isAllContestsSectionExpanded ? `
                                    <button
                                        onclick="toggleAllContestsSection()"
                                        class="w-full text-center text-sm text-green-600 hover:text-green-700 font-medium py-2 bg-green-50 hover:bg-green-100 rounded-lg transition"
                                    >
                                        Show ${allItems.length - 6} more items
                                    </button>
                                ` : ''}
                            `;
                        }
                    })()}
                </div>
            `;
        }

        function renderContestInfoModal() {
            if (!state.contestInfoModal) return '';

            const { item, itemType, voters } = state.contestInfoModal;
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === item.createdBy;
            const canManageSettings = isAdmin || isCreator;

            // Format date
            const createdDate = formatDate(item.createdAt);

            // Get voter count display from actual voters
            const voterCount = voters ? voters.length : 0;

            // Get merged contests info (for mergers) and calculate image count
            let mergedContestsHTML = '';
            let imageCount = item.images?.length || item.imageIds?.length || 0;

            if (itemType === 'merger' && item.contestIds && item.contestIds.length > 0) {
                const mergedContests = state.contests.filter(c => item.contestIds.includes(c.id));
                // Calculate total images from all merged contests
                imageCount = mergedContests.reduce((sum, c) => sum + (c.images?.length || 0), 0);
                mergedContestsHTML = `
                    <details class="mt-2">
                        <summary class="cursor-pointer font-semibold text-gray-700 hover:text-mauve-600 transition">
                            Merged Contests (${mergedContests.length})
                        </summary>
                        <ul class="mt-2 ml-4 space-y-1">
                            ${mergedContests.map(c => `
                                <li class="text-sm text-gray-600">‚Ä¢ ${c.title}</li>
                            `).join('')}
                        </ul>
                    </details>
                `;
            }

            // Get source info (for extracts)
            let sourceHTML = '';
            if (itemType === 'extract' && item.sourceType) {
                let sourceItem = null;
                let sourceName = 'Unknown';

                if (item.sourceType === 'contest') {
                    sourceItem = state.contests.find(c => c.id === item.sourceContestId);
                    sourceName = sourceItem ? sourceItem.title : 'Unknown Contest';
                } else if (item.sourceType === 'merger') {
                    sourceItem = state.mergers.find(m => m.id === item.sourceMergerId);
                    sourceName = sourceItem ? sourceItem.name : 'Unknown Merger';
                } else if (item.sourceType === 'extract') {
                    sourceItem = state.extracts.find(e => e.id === item.sourceContestId);
                    sourceName = sourceItem ? sourceItem.name : 'Unknown Extract';
                }

                const sourceTypeLabel = item.sourceType === 'contest' ? 'contest' : item.sourceType === 'merger' ? 'merger' : 'extract';
                sourceHTML = `
                    <div class="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                        <span class="text-sm text-yellow-800">This is an extract from ${sourceTypeLabel === 'contest' ? 'another contest' : sourceTypeLabel}: <strong>${sourceName}</strong></span>
                    </div>
                `;
            }

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeContestInfoModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200 flex-shrink-0">
                            <div class="flex items-start justify-between gap-4">
                                <h2 class="text-2xl font-bold text-gray-800 flex-1">${item.title || item.name}</h2>
                                <button onclick="closeContestInfoModal()" class="p-2 hover:bg-gray-100 rounded-lg transition flex-shrink-0">
                                    <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Scrollable Content -->
                        <div class="flex-1 overflow-y-auto p-6">
                            <!-- Main Info Section -->
                            <div class="mb-6">
                                <div class="flex items-center gap-3 mb-3">
                                    <img src="${item.creatorAvatar}" alt="${item.creatorName}" class="w-12 h-12 rounded-full cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="viewUserProfile('${item.createdBy}')" />
                                    <div>
                                        <div class="font-semibold text-gray-800 cursor-pointer hover:text-mauve-600 transition" onclick="viewUserProfile('${item.createdBy}')">${item.creatorName}</div>
                                        <div class="text-sm text-gray-500">${createdDate || 'Date unknown'}</div>
                                    </div>
                                </div>
                                <div class="text-sm">
                                    <div class="flex items-center justify-between gap-4">
                                        <div class="flex items-center gap-1 whitespace-nowrap">
                                            <span class="font-semibold text-gray-700">Voters:</span>
                                            <span class="text-gray-600">${voterCount}üë•</span>
                                        </div>
                                        <div class="flex items-center gap-1 whitespace-nowrap">
                                            <span class="font-semibold text-gray-700">Images:</span>
                                            <span class="text-gray-600">${imageCount}üñºÔ∏è</span>
                                        </div>
                                    </div>
                                </div>
                                ${mergedContestsHTML}
                                ${sourceHTML}
                            </div>

                            <!-- User Completion Status (for contests and extracts) -->
                            ${itemType === 'contest' || itemType === 'extract' ? (() => {
                                const userVotes = state.userVotedContests[item.id] || {};
                                const votedImageCount = Object.keys(userVotes).length;
                                const totalImageCount = imageCount;
                                const completionRate = totalImageCount > 0 ? Math.round((votedImageCount / totalImageCount) * 100) : 0;
                                const isComplete = votedImageCount === totalImageCount && totalImageCount > 0;
                                const badgeColor = isComplete ? 'bg-green-200 text-green-800' : 'bg-yellow-200 text-yellow-800';

                                return `
                                    <div class="mb-6 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
                                        <h3 class="font-semibold text-gray-800 dark:text-gray-100 mb-2">Your Voting Progress</h3>
                                        <div class="flex items-center justify-between">
                                            <div class="text-sm text-gray-700 dark:text-gray-300">
                                                <span class="font-medium">Images completed voting on:</span>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <span class="text-sm font-semibold px-2 py-1 ${badgeColor} rounded">${votedImageCount}/${totalImageCount}</span>
                                                <span class="text-sm text-gray-600 dark:text-gray-400">(${completionRate}%)</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            })() : ''}

                            <!-- Actions Section (visible to all) -->
                            <div class="mb-6 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
                                <h3 class="font-semibold text-gray-800 dark:text-gray-100 mb-3">Actions</h3>
                                <button
                                    onclick="shareContestFromModal()"
                                    class="w-full px-4 py-2 bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg font-semibold hover:from-purple-600 hover:to-purple-700 transition shadow-md flex items-center justify-center gap-2"
                                >
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/>
                                    </svg>
                                    Share
                                </button>
                            </div>

                            <!-- Admin/Creator Settings Section -->
                            ${canManageSettings ? `
                                <div class="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                                    <h3 class="font-semibold text-gray-800 mb-3">Settings (Creator/Admin Only)</h3>
                                    <div class="space-y-3">
                                        <!-- Lock Toggle -->
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-2">
                                                <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                                                </svg>
                                                <span class="font-medium text-gray-700">Lock Contest</span>
                                            </div>
                                            <button
                                                onclick="toggleContestLock('${item.id}'); closeContestInfoModal();"
                                                class="px-3 py-1 rounded-lg font-semibold transition text-sm ${item.isLocked ? 'bg-black text-white hover:bg-gray-900' : 'bg-green-500 text-white hover:bg-green-600'}"
                                            >
                                                ${item.isLocked ? 'üîí Locked' : 'üîì Unlocked'}
                                            </button>
                                        </div>
                                        <!-- Results Visibility Toggle -->
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-2">
                                                <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                                                </svg>
                                                <span class="font-medium text-gray-700">Results Visibility</span>
                                            </div>
                                            <button
                                                onclick="toggleResultsPublic('${item.id}'); closeContestInfoModal();"
                                                class="px-3 py-1 rounded-lg font-semibold transition text-sm ${item.resultsPublic !== false ? 'bg-green-500 text-white hover:bg-green-600' : 'bg-black text-white hover:bg-gray-900'}"
                                            >
                                                ${item.resultsPublic !== false ? 'üëÅÔ∏è Public' : 'üîí Private'}
                                            </button>
                                        </div>
                                        <!-- Edit Extract Button (Extract Only) -->
                                        ${itemType === 'extract' ? `
                                            <button
                                                onclick="openEditExtractModal('${item.id}'); closeContestInfoModal();"
                                                class="w-full px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition text-sm"
                                            >
                                                ‚úèÔ∏è Edit Extract
                                            </button>
                                        ` : ''}
                                        <!-- Edit Merger Button (Merger Only) -->
                                        ${itemType === 'merger' ? `
                                            <button
                                                onclick="openEditMergerModal('${item.id}'); closeContestInfoModal();"
                                                class="w-full px-4 py-2 bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg font-semibold hover:from-purple-600 hover:to-purple-700 transition text-sm"
                                            >
                                                ‚úèÔ∏è Edit Merger
                                            </button>
                                        ` : ''}
                                        <!-- Edit Contest Button (Contest Only) -->
                                        ${itemType === 'contest' ? `
                                            <button
                                                onclick="openEditContestModal('${item.id}'); closeContestInfoModal();"
                                                class="w-full px-4 py-2 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-lg font-semibold hover:from-green-600 hover:to-green-700 transition text-sm"
                                            >
                                                ‚úèÔ∏è Add More Images
                                            </button>
                                        ` : ''}
                                        <!-- Delete Button -->
                                        <button
                                            onclick="${itemType === 'contest' ? `deleteContest('${item.id}')` : itemType === 'merger' ? `deleteMerger('${item.id}')` : `deleteExtract('${item.id}')`}; closeContestInfoModal();"
                                            class="w-full px-4 py-2 bg-red-500 text-white rounded-lg font-semibold hover:bg-red-600 transition text-sm"
                                        >
                                            üóëÔ∏è Delete ${itemType === 'contest' ? 'Contest' : itemType === 'merger' ? 'Merger' : 'Extract'}
                                        </button>
                                    </div>
                                </div>
            ` : ''}

                            <!-- Voters Section -->
                            <div class="p-4 bg-blue-50 rounded-lg">
                                <h3 class="font-semibold text-gray-800 mb-3">Users that have voted (${voters.length})</h3>
                                ${voters.length > 0 ? `
                                    ${itemType === 'merger' ? `
                                        ${(() => {
                                            const fullyCompletedCount = voters.filter(v => v.completedContests === v.totalContests).length;
                                            const completionRate = voters.length > 0 ? Math.round((fullyCompletedCount / voters.length) * 100) : 0;
                                            return `
                                                <div class="mb-3 p-2 bg-white rounded-lg border border-blue-200">
                                                    <div class="text-sm font-semibold text-gray-700">
                                                        Completion rate: <span class="text-blue-600">${completionRate}%</span>
                                                        <span class="text-xs text-gray-500 ml-2">(${fullyCompletedCount}/${voters.length} users)</span>
                                                    </div>
                                                </div>
                                            `;
                                        })()}
                                        <div class="mb-2 flex items-center justify-between px-2">
                                            <span class="text-xs font-medium text-gray-600">User</span>
                                            <span class="text-xs font-medium text-gray-600">Contests completed voting on</span>
                                        </div>
                                        <div class="space-y-2 max-h-64 overflow-y-auto">
                                            ${voters.map(voter => {
                                                const isComplete = voter.completedContests === voter.totalContests;
                                                const badgeColor = isComplete ? 'bg-green-200 text-green-800' : 'bg-yellow-200 text-yellow-800';
                                                return `
                                                    <div class="flex items-center gap-3 p-2 hover:bg-blue-100 rounded-lg transition cursor-pointer" onclick="viewUserProfile('${voter.id}')">
                                                        <img src="${voter.avatar}" alt="${voter.username}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                        <span class="text-sm font-medium text-gray-700 flex-1">${voter.username}</span>
                                                        <span class="text-xs font-semibold px-2 py-1 ${badgeColor} rounded">${voter.completedContests}/${voter.totalContests}</span>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : `
                                        ${(() => {
                                            // Calculate overall completion rate for contests/extracts
                                            const fullyCompletedCount = voters.filter(v => v.completedImages === v.totalImages).length;
                                            const completionRate = voters.length > 0 ? Math.round((fullyCompletedCount / voters.length) * 100) : 0;
                                            return `
                                                <div class="mb-3 p-2 bg-white rounded-lg border border-blue-200">
                                                    <div class="text-sm font-semibold text-gray-700">
                                                        Completion rate: <span class="text-blue-600">${completionRate}%</span>
                                                        <span class="text-xs text-gray-500 ml-2">(${fullyCompletedCount}/${voters.length} users)</span>
                                                    </div>
                                                </div>
                                            `;
                                        })()}
                                        <div class="mb-2 flex items-center justify-between px-2">
                                            <span class="text-xs font-medium text-gray-600">User</span>
                                            <span class="text-xs font-medium text-gray-600">Images completed voting on</span>
                                        </div>
                                        <div class="space-y-2 max-h-64 overflow-y-auto">
                                            ${voters.map(voter => {
                                                const isComplete = voter.completedImages === voter.totalImages;
                                                const badgeColor = isComplete ? 'bg-green-200 text-green-800' : 'bg-yellow-200 text-yellow-800';
                                                return `
                                                    <div class="flex items-center gap-3 p-2 hover:bg-blue-100 rounded-lg transition cursor-pointer" onclick="viewUserProfile('${voter.id}')">
                                                        <img src="${voter.avatar}" alt="${voter.username}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                        <span class="text-sm font-medium text-gray-700 flex-1">${voter.username}</span>
                                                        <span class="text-xs font-semibold px-2 py-1 ${badgeColor} rounded">${voter.completedImages}/${voter.totalImages}</span>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    `}
                                ` : `
                                    <p class="text-sm text-gray-600 text-center py-4">No votes yet</p>
                                `}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderUserProfileModal() {
            if (!state.showUserProfileModal) return '';

            const userId = state.viewingUserId;
            if (!userId) {
                return '';
            }

            // Find user info from allUsers or from contest data
            let userInfo = state.allUsers.find(u => u.id === userId);

            // If not in allUsers, try to find from contest votes
            if (!userInfo) {
                // Look through all contests to find this user's votes
                for (const contest of state.contests) {
                    const votes = contest.votes || [];
                    const vote = votes.find(v => v.userId === userId);
                    if (vote) {
                        userInfo = { id: userId, username: vote.username, avatar: vote.avatar };
                        break;
                    }
                }
            }

            if (!userInfo) {
                return `
                    <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeUserProfileModal()">
                        <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 modal-content flex flex-col" onclick="event.stopPropagation()">
                            <div class="text-center">
                                <p class="text-xl font-bold text-gray-800 mb-4">User Not Found</p>
                                <p class="text-gray-600 mb-6">The requested user profile could not be loaded.</p>
                                <button onclick="closeUserProfileModal()" class="bg-mauve-500 text-white px-6 py-2 rounded-lg hover:bg-mauve-600 transition">
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Find items created by this user
            const createdContests = state.contests.filter(c => c.createdBy === userId);
            const createdMergers = state.mergers.filter(m => m.createdBy === userId);
            const createdExtracts = state.extracts.filter(e => e.createdBy === userId);

            // Find items voted on by this user (using fetched vote data)
            const userVotedContestIds = state.userProfileVotedContests || [];

            // Get contests this user has voted on (INCLUDING ones they created)
            const votedContests = state.contests.filter(contest =>
                userVotedContestIds.includes(contest.id)
            );

            // Get mergers where user voted on source contests (INCLUDING ones they created)
            const votedMergers = state.mergers.filter(merger => {
                const sourceContestIds = merger.contestIds || [];
                return sourceContestIds.some(contestId => userVotedContestIds.includes(contestId));
            });

            // Get extracts where user voted on source (INCLUDING ones they created)
            const votedExtracts = state.extracts.filter(extract => {
                if (extract.sourceType === 'contest') {
                    return userVotedContestIds.includes(extract.sourceContestId);
                } else if (extract.sourceType === 'merger') {
                    const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (!merger) return false;
                    const sourceContestIds = merger.contestIds || [];
                    return sourceContestIds.some(contestId => userVotedContestIds.includes(contestId));
                }
                return false;
            });

            const allCreatedItems = [
                ...createdContests.map(c => ({ ...c, itemType: 'contest' })),
                ...createdMergers.map(m => ({ ...m, itemType: 'merger' })),
                ...createdExtracts.map(e => ({ ...e, itemType: 'extract' }))
            ];

            const allVotedItems = [
                ...votedContests.map(c => ({ ...c, itemType: 'contest' })),
                ...votedMergers.map(m => ({ ...m, itemType: 'merger' })),
                ...votedExtracts.map(e => ({ ...e, itemType: 'extract' }))
            ];

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isBanned = state.bannedUsers.includes(userId);
            const isCurrentUser = state.user && state.user.id === userId;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeUserProfileModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden modal-content flex flex-col" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200 flex-shrink-0">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-2xl font-bold text-gray-800">User Profile</h3>
                                <button onclick="closeUserProfileModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="flex items-center gap-4">
                                <img src="${userInfo.avatar}" alt="${userInfo.username}" class="w-20 h-20 rounded-full" />
                                <div class="flex-1">
                                    <h2 class="text-2xl font-bold text-gray-800">${userInfo.username}</h2>
                                    <p class="text-gray-600">${isCurrentUser ? '(You)' : ''} ${isBanned ? 'üö´ BANNED' : ''}</p>
                                    <p class="text-sm text-gray-500 mt-1">
                                        Created ${allCreatedItems.length} ${allCreatedItems.length === 1 ? 'item' : 'items'} ‚Ä¢
                                        Voted in ${allVotedItems.length} ${allVotedItems.length === 1 ? 'item' : 'items'} ‚Ä¢
                                        ${state.userProfileTotalVotes || 0} image${(state.userProfileTotalVotes || 0) !== 1 ? 's' : ''} voted on
                                    </p>
                                </div>
                            </div>
                        </div>

                        <!-- Scrollable content -->
                        <div class="flex-1 overflow-y-auto p-6">
                            <!-- Created Items Section -->
                            ${allCreatedItems.length > 0 ? `
                                <div class="mb-6">
                                    <h3 class="text-lg font-bold text-gray-800 mb-3">Items Created (${allCreatedItems.length})</h3>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                        ${allCreatedItems.map(item => {
                                            const title = item.title || item.name;
                                            const colorClass = item.itemType === 'merger' ? 'text-blue-700' :
                                                              item.itemType === 'extract' ? 'text-yellow-700' :
                                                              'text-gray-700';
                                            const hoverClass = item.itemType === 'merger' ? 'hover:text-blue-900 hover:bg-blue-50' :
                                                              item.itemType === 'extract' ? 'hover:text-yellow-900 hover:bg-yellow-50' :
                                                              'hover:text-mauve-600 hover:bg-gray-50';
                                            return `
                                                <div class="text-sm ${colorClass} ${hoverClass} transition p-2 rounded font-medium">
                                                    ‚Ä¢ ${title}
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                            ` : ''}

                            <!-- Voting History Section -->
                            <div class="mb-4">
                                <h3 class="text-lg font-bold text-gray-800 mb-3">Items Voted On (${allVotedItems.length})</h3>
                            </div>

                            ${allVotedItems.length === 0 ? `
                                <div class="bg-gray-50 rounded-lg p-8 text-center">
                                    <p class="text-gray-500">No voting history yet</p>
                                </div>
                            ` : `
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                    ${allVotedItems.map(item => {
                                        const title = item.title || item.name;
                                        const colorClass = item.itemType === 'merger' ? 'text-blue-700' :
                                                          item.itemType === 'extract' ? 'text-yellow-700' :
                                                          'text-gray-700';
                                        const hoverClass = item.itemType === 'merger' ? 'hover:text-blue-900 hover:bg-blue-50' :
                                                          item.itemType === 'extract' ? 'hover:text-yellow-900 hover:bg-yellow-50' :
                                                          'hover:text-mauve-600 hover:bg-gray-50';
                                        return `
                                            <div class="text-sm ${colorClass} ${hoverClass} transition p-2 rounded font-medium">
                                                ‚Ä¢ ${title}
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            `}
                        </div>

                        <!-- Footer with ban button -->
                        ${isAdmin && !isCurrentUser && !isBanned ? `
                            <div class="p-4 border-t border-gray-200 flex-shrink-0">
                                <button onclick="confirmBanUser('${userId}', '${userInfo.username}')" class="w-full bg-red-500 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-600 transition">
                                    üö´ Ban User
                                </button>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function renderContestCard(contest, isPinned = false, unvotedLabel = null) {
                        try {
                                const userVotes = state.userVotedContests[contest.id] || {};
                                const votedImageCount = Object.keys(userVotes).length;
                                const totalImageCount = contest.images.length;
                                const hasVotedAll = votedImageCount === totalImageCount && totalImageCount > 0;
                                const hasVotedSome = votedImageCount > 0 && votedImageCount < totalImageCount;
                                const hasVotedNone = votedImageCount === 0;
                                const autosaveKey = `contest_${contest.id}`;
                                const autosaves = state.userAutosavedVotes[autosaveKey] || {};
                                const autosaveCount = Object.keys(autosaves).length;
                                const hasAutosaves = autosaveCount > 0 && !hasVotedAll;
                            const canDelete = canDeleteContest(contest);
                            const isBanned = state.bannedUsers.includes(state.user.id);
                            const createdDate = formatDate(contest.createdAt);
                            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

                            return `
                                <div class="bg-white rounded-xl shadow-lg overflow-visible hover:shadow-xl transition fade-in p-4 relative border-2 border-gray-300">
                                    ${unvotedLabel ? `
                                        <div class="absolute -top-2.5 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-white text-xs font-bold px-3 py-1 rounded-full shadow-lg whitespace-nowrap z-10">
                                            ${unvotedLabel}
                                        </div>
                                    ` : ''}
                                    ${isAdmin && state.appSettings.show_pin_icons ? `
                                        <button
                                            onclick="togglePin(event, 'contest', '${contest.id}', ${isPinned})"
                                            class="absolute top-1 right-1 ${isPinned ? 'bg-red-800 hover:bg-red-900' : 'bg-red-50 hover:bg-red-100'} ${isPinned ? 'text-white' : 'text-red-800'} p-1 rounded-full shadow-lg transition z-10"
                                            title="${isPinned ? 'Unpin contest' : 'Pin contest'}"
                                        >
                                            üìå
                                        </button>
                                    ` : ''}
                                    ${contest.isLocked ? `
                                        <div class="absolute top-1 ${isAdmin ? (contest.resultsPublic === false ? 'right-20' : 'right-11') : (contest.resultsPublic === false ? 'right-12' : 'right-1')} bg-black text-white p-1.5 rounded-full shadow-lg" title="Contest is locked">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                                            </svg>
                                        </div>
                                    ` : ''}
                                    ${contest.resultsPublic === false ? `
                                        <div class="absolute top-1 ${isAdmin ? 'right-11' : 'right-1'} bg-gray-800 text-white p-1.5 rounded-full shadow-lg" title="Results are hidden">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L6.5 6.5m12.975 12.975L16.121 16.12m0 0l-4.243-4.243m0 0L9.5 9.5M3.5 3.5l5.378 5.378m0 0a3 3 0 014.243 4.243L9.878 9.878z"/>
                                            </svg>
                                        </div>
                                    ` : ''}
                                    <div class="flex items-start gap-2 mb-2">
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${contest.createdBy}');" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h3 class="text-base font-bold text-gray-800 truncate">${contest.title}</h3>
                                            </div>
                                            <div class="text-xs text-gray-500 flex items-center gap-2 flex-wrap">
                                                <span class="truncate">by <span class="cursor-pointer hover:text-mauve-600 transition" onclick="event.stopPropagation(); viewUserProfile('${contest.createdBy}');">${contest.creatorName}</span></span>
                                                <span class="ml-auto whitespace-nowrap">${contest.voterCount || 0}üë• ${contest.images.length}üñºÔ∏è</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="flex gap-2">
                                        ${isBanned ? `
                                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                                üö´ Account restricted
                                            </div>
                                        ` : contest.isLocked ? `
                                            <button
                                                onclick='viewLockedResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : hasVotedAll ? `
                                            <button
                                                onclick='startRevoteFromHome(${safeStringify(contest)})'
                                                class="flex-[0.5] bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                                            >
                                                Revote
                                            </button>
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-[1.5] bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : hasAutosaves ? `
                                            <button
                                                onclick='continueVotingDraft("${contest.id}", "contest")'
                                                class="flex-1 bg-gradient-to-r from-orange-400 to-orange-600 text-white py-2 rounded-lg font-semibold hover:from-orange-500 hover:to-orange-700 transition shadow-md text-sm"
                                            >
                                                Continue Draft
                                            </button>
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : hasVotedSome ? `
                                            <button
                                                onclick='showContestVoteModal("${contest.id}")'
                                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                                            >
                                                Complete Voting
                                            </button>
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : hasVotedNone ? `
                                            <button
                                                onclick='startVoting(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                                            >
                                                Start Voting
                                            </button>
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : `
                                            <button
                                                onclick='startVoting(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                                            >
                                                Start Voting
                                            </button>
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        `}
                                        <button
                                            onclick='showContestInfoModal(${safeStringify(contest)}, "contest")'
                                            class="bg-gradient-to-r from-blue-500 to-blue-600 text-white px-3 py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm flex items-center gap-1"
                                            title="Contest Info"
                                        >
                                            ‚ÑπÔ∏è
                                        </button>
                                    </div>
                                </div>
                            `;
                            } catch (error) {
                                console.error('Error rendering contest:', contest?.id, error);
                                return ''; // Skip this contest and continue
                            }
        }

        function renderMergerCard(merger, isPinned = false, unvotedLabel = null) {
            // Get contest details for the merged contests
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
            const totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);

            // Check if user has voted on ALL images in ALL contests
            const contestVotingStatus = mergedContests.map(c => {
                const userVotes = state.userVotedContests[c.id] || {};
                const votedImageCount = Object.keys(userVotes).length;
                const totalImageCount = c.images.length;
                return {
                    contest: c,
                    hasVotedAll: votedImageCount === totalImageCount && totalImageCount > 0,
                    hasVotedSome: votedImageCount > 0 && votedImageCount < totalImageCount
                };
            });

            const fullyVotedContests = contestVotingStatus.filter(cs => cs.hasVotedAll);
            const partiallyVotedContests = contestVotingStatus.filter(cs => cs.hasVotedSome);

            const hasVotedAll = fullyVotedContests.length === mergedContests.length && mergedContests.length > 0;
            const hasVotedSome = (fullyVotedContests.length > 0 || partiallyVotedContests.length > 0) && !hasVotedAll;
            const hasVotedNone = fullyVotedContests.length === 0 && partiallyVotedContests.length === 0;

            const mergerAutosaveKey = `merger_${merger.id}`;
            const mergerAutosaves = state.userAutosavedVotes[mergerAutosaveKey] || {};
            const mergerAutosaveCount = Object.keys(mergerAutosaves).length;
            const hasMergerAutosaves = mergerAutosaveCount > 0 && !hasVotedAll;

            const isBanned = state.bannedUsers.includes(state.user.id);
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

            return `
                <div class="bg-blue-50 border-2 border-blue-300 rounded-xl shadow-lg overflow-visible hover:shadow-xl transition fade-in p-4 relative">
                    ${unvotedLabel ? `
                        <div class="absolute -top-2.5 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-white text-xs font-bold px-3 py-1 rounded-full shadow-lg whitespace-nowrap z-10">
                            ${unvotedLabel}
                        </div>
                    ` : ''}
                    ${isAdmin && state.appSettings.show_pin_icons ? `
                        <button
                            onclick="togglePin(event, 'merger', '${merger.id}', ${isPinned})"
                            class="absolute top-1 right-1 ${isPinned ? 'bg-red-800 hover:bg-red-900' : 'bg-red-50 hover:bg-red-100'} ${isPinned ? 'text-white' : 'text-red-800'} p-1 rounded-full shadow-lg transition z-10"
                            title="${isPinned ? 'Unpin merger' : 'Pin merger'}"
                        >
                            üìå
                        </button>
                    ` : ''}
                    ${merger.isLocked ? `
                        <div class="absolute top-1 ${isAdmin ? (merger.resultsPublic === false ? 'right-20' : 'right-11') : (merger.resultsPublic === false ? 'right-12' : 'right-1')} bg-black text-white p-1.5 rounded-full shadow-lg" title="Merger is locked">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                            </svg>
                        </div>
                    ` : ''}
                    ${merger.resultsPublic === false ? `
                        <div class="absolute top-1 ${isAdmin ? 'right-11' : 'right-1'} bg-gray-800 text-white p-1.5 rounded-full shadow-lg" title="Results are hidden">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L6.5 6.5m12.975 12.975L16.121 16.12m0 0l-4.243-4.243m0 0L9.5 9.5M3.5 3.5l5.378 5.378m0 0a3 3 0 014.243 4.243L9.878 9.878z"/>
                            </svg>
                        </div>
                    ` : ''}
                    <div class="flex items-start gap-2 mb-2">
                        <img src="${merger.creatorAvatar}" alt="${merger.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-blue-400 transition" onclick="event.stopPropagation(); viewUserProfile('${merger.createdBy}');" />
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h3 class="text-base font-bold text-blue-900 truncate">${merger.name}</h3>
                            </div>
                            <div class="text-xs text-blue-700 flex items-center gap-2 flex-wrap">
                                <span class="truncate">by <span class="cursor-pointer hover:text-blue-900 transition" onclick="event.stopPropagation(); viewUserProfile('${merger.createdBy}');">${merger.creatorName}</span></span>
                                <span class="ml-auto whitespace-nowrap">${merger.voterCount || 0}üë• ${totalImages}üñºÔ∏è</span>
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-2">
                        ${isBanned ? `
                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                üö´ Account restricted
                            </div>
                        ` : merger.isLocked ? `
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedAll ? `
                            <button
                                onclick='startRevoteFromHomeMerger(${safeStringify(merger)})'
                                class="flex-[0.5] bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                            >
                                Revote
                            </button>
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-[1.5] bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasMergerAutosaves ? `
                            <button
                                onclick='continueVotingDraft("${merger.id}", "merger")'
                                class="flex-1 bg-gradient-to-r from-orange-400 to-orange-600 text-white py-2 rounded-lg font-semibold hover:from-orange-500 hover:to-orange-700 transition shadow-md text-sm"
                            >
                                Continue Draft
                            </button>
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedSome ? `
                            <button
                                onclick='showMergerVoteModal("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                            >
                                Complete Voting
                            </button>
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedNone ? `
                            <button
                                onclick='startMergerVoting("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                            >
                                Start Voting
                            </button>
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : `
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        `}
                        <button
                            onclick='showContestInfoModal(${safeStringify(merger)}, "merger")'
                            class="bg-gradient-to-r from-blue-500 to-blue-600 text-white px-3 py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm flex items-center gap-1"
                            title="Merger Info"
                        >
                            ‚ÑπÔ∏è
                        </button>
                    </div>
                </div>
            `;
        }

        function renderExtractCard(extract, isPinned = false, unvotedLabel = null) {
            // Get source reference
            let sourceRef = 'Unknown';
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                sourceRef = sourceContest ? sourceContest.title : 'Unknown Contest';
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                sourceRef = sourceMerger ? sourceMerger.name : 'Unknown Merger';
            } else if (extract.sourceType === 'extract') {
                const sourceExtract = state.extracts.find(e => e.id === extract.sourceContestId);
                sourceRef = sourceExtract ? sourceExtract.name : 'Unknown Extract';
            }

            // Check if user has voted on this extract
            // For extracts, we need to check if user has voted on ALL images in the extract
            let hasVotedAll = false;
            let hasVotedSome = false;
            let hasVotedNone = true;
            let sourceFullyVoted = false; // Track if origin contest/merger was already fully voted
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

            if (extract.sourceType === 'contest' && extract.sourceContestId) {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                const userVotes = state.userVotedContests[extract.sourceContestId] || {};
                const votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
                const votedCount = extract.imageIds.filter(imageId => votedImageIds.includes(imageId)).length;

                // Check if the source contest itself has been fully voted
                if (sourceContest) {
                    const totalVotedInContest = Object.keys(userVotes).length;
                    sourceFullyVoted = totalVotedInContest === sourceContest.images.length && sourceContest.images.length > 0;
                }

                hasVotedAll = votedCount === extract.imageIds.length && extract.imageIds.length > 0;
                hasVotedSome = votedCount > 0 && votedCount < extract.imageIds.length;
                hasVotedNone = votedCount === 0;
            } else if (extract.sourceType === 'merger' && extract.sourceMergerId) {
                // For mergers, check if user has voted on all images from any of the merged contests
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    // Check if the source merger itself has been fully voted
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    const contestVotingStatus = mergedContests.map(c => {
                        const userVotes = state.userVotedContests[c.id] || {};
                        const votedImageCount = Object.keys(userVotes).length;
                        const totalImageCount = c.images.length;
                        return votedImageCount === totalImageCount && totalImageCount > 0;
                    });
                    sourceFullyVoted = contestVotingStatus.every(voted => voted) && mergedContests.length > 0;

                    // Check if user has voted on all extract images across all merged contests
                    let allVotedImageIds = [];
                    merger.contestIds.forEach(contestId => {
                        const userVotes = state.userVotedContests[contestId] || {};
                        allVotedImageIds.push(...Object.keys(userVotes).map(id => parseInt(id)));
                    });
                    const votedCount = extract.imageIds.filter(imageId => allVotedImageIds.includes(imageId)).length;

                    hasVotedAll = votedCount === extract.imageIds.length && extract.imageIds.length > 0;
                    hasVotedSome = votedCount > 0 && votedCount < extract.imageIds.length;
                    hasVotedNone = votedCount === 0;
                }
            }

            const imageCount = extract.imageIds.length;
            const isBanned = state.bannedUsers.includes(state.user.id);
            const createdDate = formatDate(extract.createdAt);

            // Check if source has private results
            let hasPrivateResults = false;
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                if (sourceContest && sourceContest.resultsPublic === false) {
                    hasPrivateResults = true;
                }
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (sourceMerger && sourceMerger.resultsPublic === false) {
                    hasPrivateResults = true;
                }
            }

            return `
                <div class="bg-yellow-50 border-2 border-yellow-400 rounded-xl shadow-lg overflow-visible hover:shadow-xl transition fade-in p-4 relative">
                    ${unvotedLabel ? `
                        <div class="absolute -top-2.5 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-white text-xs font-bold px-3 py-1 rounded-full shadow-lg whitespace-nowrap z-10">
                            ${unvotedLabel}
                        </div>
                    ` : ''}
                    ${isAdmin && state.appSettings.show_pin_icons ? `
                        <button
                            onclick="togglePin(event, 'extract', '${extract.id}', ${isPinned})"
                            class="absolute top-1 right-1 ${isPinned ? 'bg-red-800 hover:bg-red-900' : 'bg-red-50 hover:bg-red-100'} ${isPinned ? 'text-white' : 'text-red-800'} p-1 rounded-full shadow-lg transition z-10"
                            title="${isPinned ? 'Unpin extract' : 'Pin extract'}"
                        >
                            üìå
                        </button>
                    ` : ''}
                    ${extract.isLocked ? `
                        <div class="absolute top-1 ${isAdmin ? (extract.resultsPublic === false ? 'right-20' : 'right-11') : (extract.resultsPublic === false ? 'right-12' : 'right-1')} bg-black text-white p-1.5 rounded-full shadow-lg" title="Extract is locked">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                            </svg>
                        </div>
                    ` : ''}
                    ${extract.resultsPublic === false ? `
                        <div class="absolute top-1 ${isAdmin ? 'right-11' : 'right-1'} bg-gray-800 text-white p-1.5 rounded-full shadow-lg" title="Results are hidden">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L6.5 6.5m12.975 12.975L16.121 16.12m0 0l-4.243-4.243m0 0L9.5 9.5M3.5 3.5l5.378 5.378m0 0a3 3 0 014.243 4.243L9.878 9.878z"/>
                            </svg>
                        </div>
                    ` : ''}
                    <div class="flex items-start gap-2 mb-2">
                        <img src="${extract.creatorAvatar}" alt="${extract.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-yellow-400 transition" onclick="event.stopPropagation(); viewUserProfile('${extract.createdBy}');" />
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h3 class="text-base font-bold text-yellow-900 truncate">${extract.name}</h3>
                            </div>
                            <div class="text-xs text-yellow-700 flex items-center gap-2 flex-wrap">
                                <span class="truncate">by <span class="cursor-pointer hover:text-yellow-900 transition" onclick="event.stopPropagation(); viewUserProfile('${extract.createdBy}');">${extract.creatorName}</span></span>
                                <span class="ml-auto whitespace-nowrap">${extract.voterCount || 0}üë• ${imageCount}üñºÔ∏è</span>
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-2">
                        ${isBanned ? `
                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                üö´ Account restricted
                            </div>
                        ` : extract.isLocked ? `
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : sourceFullyVoted ? `
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedAll ? `
                            <button
                                onclick='startExtractVoting("${extract.id}", true)'
                                class="flex-[0.5] bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                            >
                                Revote
                            </button>
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-[1.5] bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedSome ? `
                            <button
                                onclick='startExtractVoting("${extract.id}", false)'
                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                            >
                                Complete Voting
                            </button>
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedNone ? `
                            <button
                                onclick='showExtractVotingRedirectModal("${extract.id}")'
                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                            >
                                Start Voting
                            </button>
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : `
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        `}
                        <button
                            onclick='showContestInfoModal(${safeStringify(extract)}, "extract")'
                            class="bg-gradient-to-r from-blue-400 to-blue-600 text-white px-3 py-2 rounded-lg font-semibold hover:from-blue-500 hover:to-blue-700 transition shadow-md text-sm flex items-center gap-1"
                            title="Extract Info"
                        >
                            ‚ÑπÔ∏è
                        </button>
                    </div>
                </div>
            `;
        }

        function renderCreateContest() {
            const isEditMode = !!state.editingContestId;
            const newImagesCount = isEditMode
                ? state.newContest.images.filter(img => !img.isExisting).length
                : state.newContest.images.length;

            return `
                <div class="max-w-5xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="flex justify-between items-center mb-4">
                            <div>
                                <h2 class="text-2xl font-bold text-gray-800">${isEditMode ? 'Edit Contest: ' : ''}${state.newContest.title}</h2>
                                ${isEditMode ? `<p class="text-sm text-gray-600 mt-1">Adding images to existing contest (${newImagesCount} new image(s))</p>` : ''}
                            </div>
                            <button onclick="${isEditMode ? 'cancelEditContest()' : 'cancelCreateContest()'}" class="text-gray-600 hover:text-gray-800 flex items-center gap-1 text-sm">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                                Cancel
                            </button>
                        </div>

                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                            <h3 class="font-bold text-blue-900 mb-2 flex items-center gap-2 text-sm">
                                <span class="text-xl">üì∏</span>
                                How to Add Images
                            </h3>
                            <p class="text-xs text-blue-800 mb-1">
                                üíª <strong>Desktop:</strong> Click image ‚Üí Right-click ‚Üí Copy image link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üì± <strong>Mobile:</strong> Open image ‚Üí Share ‚Üí Copy link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üìÅ <strong>Or:</strong> Click "Upload Image Files" or drag & drop files (max 1MB each, multiple files supported)
                            </p>
                            <p class="text-xs text-yellow-800 font-semibold">
                                ‚ö†Ô∏è Images must be under 1MB. Files exceeding this limit will be rejected.
                            </p>
                        </div>

                        <div class="bg-yellow-50 border border-yellow-300 rounded-lg p-3 mb-4">
                            <p class="text-xs text-yellow-800">
                                ‚ö†Ô∏è <strong>Warning:</strong> Discord image URLs expire after 24 hours. Use permanent image hosting (Imgur, etc.) or upload files directly.
                            </p>
                        </div>

                        <div class="mb-4">
                            <input type="url" id="contestUrlInput" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg text-sm mb-2" placeholder="Paste Discord image URL or any image URL...">
                            <div class="flex gap-2 mb-2">
                                <button onclick="clearUrlInput()" class="flex-1 bg-gray-500 text-white py-2 rounded-lg font-semibold hover:bg-gray-600 transition text-sm">
                                    Clear Text Field
                                </button>
                                <button onclick="addImageFromUrl('contestUrlInput')" class="flex-1 bg-gradient-to-r from-pink-500 to-rose-600 text-white py-2 rounded-lg font-semibold hover:from-pink-600 hover:to-rose-700 transition text-sm">
                                    Add URL
                                </button>
                            </div>
                            <div class="flex items-center gap-2 mb-3">
                                <span class="text-sm text-gray-600 font-medium">or</span>
                                <input type="file" id="contestFileInput" accept="image/jpeg,image/png,image/gif,image/webp" multiple class="hidden" onchange="handleFileSelect(this)">
                                <button onclick="document.getElementById('contestFileInput').click()" class="flex-1 bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-indigo-700 transition text-sm flex items-center justify-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                    </svg>
                                    Upload Image Files
                                </button>
                            </div>
                            <div
                                id="dropZone"
                                class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center bg-gray-50 hover:border-blue-400 hover:bg-blue-50 transition cursor-pointer"
                                ondragover="handleDragOver(event)"
                                ondragleave="handleDragLeave(event)"
                                ondrop="handleDrop(event)"
                                onclick="document.getElementById('contestFileInput').click()"
                            >
                                <svg class="w-12 h-12 mx-auto mb-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <p class="text-sm text-gray-600 font-medium mb-1">Drag & drop images here</p>
                                <p class="text-xs text-gray-500">or click to browse files</p>
                            </div>
                        </div>

                        <div class="flex items-center justify-between mb-3 p-3 bg-gray-50 rounded-lg">
                            <div class="text-sm font-semibold text-gray-800">
                                ${state.newContest.images.length} images added
                            </div>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 min-h-[100px]">
                            ${state.newContest.images.length === 0 ? `
                                <div class="col-span-full text-center text-gray-400 py-8 text-sm italic">
                                    No images added yet
                                </div>
                            ` : state.newContest.images.map((img, index) => `
                                <div class="relative group">
                                    <img src="${img.url}" class="w-full h-48 object-contain rounded-lg bg-gray-100" />
                                    ${img.isExisting ? `
                                        <div class="absolute top-1 right-1 bg-blue-500 text-white px-2 py-1 rounded text-xs shadow-lg">
                                            Existing
                                        </div>
                                    ` : `
                                        <button onclick="removeContestImage(${index})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition shadow-lg">
                                            √ó
                                        </button>
                                    `}
                                    ${img.fileSize ? `
                                        <div class="text-xs text-center text-gray-600 mt-1 font-medium">
                                            ${formatFileSize(img.fileSize)}
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>

                        <button
                            onclick="finishCreateContest()"
                            ${(isEditMode ? newImagesCount : state.newContest.images.length) === 0 ? 'disabled' : ''}
                            class="w-full bg-gradient-to-r from-green-500 to-green-700 text-white py-3 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                        >
                            ${isEditMode ? `Add Images (${newImagesCount} new)` : `Create Contest (${state.newContest.images.length} images)`}
                        </button>
                    </div>
                </div>
            `;
        }

        function renderMultiViewVoting() {
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);
            const isMergerVoting = state.currentMergerId && !state.currentContest;
            const votingTitle = isMergerVoting
                ? (state.mergers.find(m => m.id === state.currentMergerId)?.name || 'Merger Voting')
                : (state.currentContest?.title || 'Voting');

            // Calculate voting progress
            const votedCount = state.shuffledImages.filter(img => state.votes[img.id]).length;
            const totalCount = state.shuffledImages.length;

            // Get image scale (use state.imageScale if available, default to 100)
            const imageScale = state.multiVotingImageScale || 100;
            const baseSize = 150;
            const imageHeight = Math.max(30, Math.min(500, Math.floor(baseSize * (imageScale / 100))));

            // Calculate score circle size based on image scale
            const baseCircleSize = 28; // Base size in pixels (smaller than before)
            const circleSize = Math.max(16, Math.min(56, Math.floor(baseCircleSize * (imageScale / 100))));
            const baseFontSize = 14;
            const fontSize = Math.max(10, Math.min(20, Math.floor(baseFontSize * (imageScale / 100))));

            return `
                <div class="max-w-7xl mx-auto px-3 py-4 pb-32">
                    <!-- Voting Mode Info Label -->
                    <div class="bg-blue-50 border border-blue-200 rounded-lg px-3 py-2 mb-3 text-center">
                        <p class="text-xs text-blue-800 dark:text-blue-200">
                            üí° <strong>Tip:</strong> Use the toggle switch above to switch between single image and multi image voting views.
                        </p>
                    </div>
                    ${renderAutosaveStatusBar()}
                    <div class="bg-white dark:bg-gray-900 rounded-xl shadow-xl overflow-hidden fade-in">
                        <!-- Header with progress -->
                        <div class="bg-gray-50 dark:bg-gray-800 px-4 py-3 border-b border-gray-200 dark:border-gray-700">
                            <div class="flex justify-between items-center mb-2">
                                <h2 class="text-lg font-bold text-gray-800 dark:text-gray-100">${votingTitle}</h2>
                                <span class="text-gray-600 dark:text-gray-400 font-medium text-sm">${votedCount}/${totalCount} voted</span>
                            </div>
                            <!-- Progress bar -->
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                                <div class="bg-gradient-to-r from-green-500 to-green-600 h-2 rounded-full transition-all duration-300" style="width: ${(votedCount / totalCount * 100).toFixed(1)}%"></div>
                            </div>

                            <!-- Image Scale Slider -->
                            <div class="mt-3">
                                <label class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">Image Scale</label>
                                <div class="flex items-center gap-2">
                                    <button
                                        onclick="adjustMultiVotingImageScale(-1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 flex items-center justify-center font-bold text-gray-700 dark:text-gray-300 transition"
                                        title="Decrease scale by 1%"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        min="20"
                                        max="250"
                                        value="${imageScale}"
                                        oninput="updateMultiVotingImageScale(this.value)"
                                        class="flex-1 h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer slider"
                                    />
                                    <button
                                        onclick="adjustMultiVotingImageScale(1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 flex items-center justify-center font-bold text-gray-700 dark:text-gray-300 transition"
                                        title="Increase scale by 1%"
                                    >+</button>
                                    <span class="text-sm font-medium text-gray-700 dark:text-gray-300 w-12">${imageScale}%</span>
                                </div>
                            </div>

                            <!-- Filter and Sort Controls -->
                            <div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
                                <!-- Filter by Score -->
                                <div>
                                    <label class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">Filter by Score</label>
                                    <div class="flex gap-1.5 flex-wrap">
                                        ${['non-voted', 1, 2, 3, 4, 5].map(filter => {
                                            const isSelected = state.multiModeFilter.includes(filter);
                                            const label = filter === 'non-voted' ? '?' : filter;
                                            const bgColor = filter === 'non-voted' ? '#9ca3af' : getScoreColor(filter);
                                            return `
                                                <button
                                                    onclick="setMultiModeFilter(${typeof filter === 'string' ? `'${filter}'` : filter})"
                                                    class="px-3 py-1.5 rounded-lg text-white text-sm font-semibold transition ${isSelected ? 'ring-2 ring-offset-1 ring-gray-800 scale-105' : 'opacity-60 hover:opacity-100'}"
                                                    style="background-color: ${bgColor};"
                                                    title="Show ${filter === 'non-voted' ? 'non-voted' : 'score ' + filter} images"
                                                >
                                                    ${label}
                                                </button>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>

                                <!-- Sort -->
                                <div>
                                    <label class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">Sort</label>
                                    <select
                                        onchange="setMultiModeSort(this.value)"
                                        class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm focus:border-blue-400 focus:outline-none"
                                    >
                                        <option value="default" ${state.multiModeSort === 'default' ? 'selected' : ''}>Default Order</option>
                                        <option value="highest" ${state.multiModeSort === 'highest' ? 'selected' : ''}>Highest to Lowest</option>
                                        <option value="lowest" ${state.multiModeSort === 'lowest' ? 'selected' : ''}>Lowest to Highest</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- Image grid with flex-wrap layout -->
                        <div class="p-4">
                            <div class="flex flex-wrap gap-1">
                                ${(() => {
                                    // Apply filtering
                                    let filteredImages = state.shuffledImages;
                                    if (state.multiModeFilter.length > 0) {
                                        filteredImages = filteredImages.filter(img => {
                                            const vote = state.votes[img.id];
                                            // Check if non-voted filter is selected and image has no vote
                                            if (state.multiModeFilter.includes('non-voted') && !vote) {
                                                return true;
                                            }
                                            // Check if image's vote matches any selected score filter
                                            return vote && state.multiModeFilter.includes(vote);
                                        });
                                    }

                                    // Apply sorting
                                    if (state.multiModeSort === 'highest') {
                                        filteredImages = [...filteredImages].sort((a, b) => {
                                            const voteA = state.votes[a.id] || 0;
                                            const voteB = state.votes[b.id] || 0;
                                            return voteB - voteA;
                                        });
                                    } else if (state.multiModeSort === 'lowest') {
                                        filteredImages = [...filteredImages].sort((a, b) => {
                                            const voteA = state.votes[a.id] || 0;
                                            const voteB = state.votes[b.id] || 0;
                                            return voteA - voteB;
                                        });
                                    }
                                    // 'default' keeps the original order

                                    return filteredImages.map((image, idx) => {
                                        const currentVote = state.votes[image.id];
                                        const isHoverable = state.selectedScore !== null;
                                        const borderColor = currentVote ? getScoreColor(currentVote) : 'transparent';
                                        return `
                                        <div class="relative" style="height: ${imageHeight}px;">
                                            <div
                                                class="relative cursor-pointer rounded-lg overflow-hidden border-4 bg-gray-100 h-full ${isHoverable ? 'hover:border-blue-400' : ''}"
                                                onclick="voteImageMulti('${image.id}')"
                                                style="height: ${imageHeight}px; border-color: ${borderColor};"
                                            >
                                                <img src="${image.url}" alt="Image ${idx + 1}" class="h-full w-auto object-cover" />

                                                <!-- Score indicator circle (top-left) -->
                                                <div class="absolute top-2 left-2">
                                                    <div class="rounded-full flex items-center justify-center font-bold shadow-lg ${currentVote ? '' : 'score-indicator-unvoted'}"
                                                         style="width: ${circleSize}px; height: ${circleSize}px; font-size: ${fontSize}px; ${currentVote ? `background-color: ${getScoreColor(currentVote)}; color: white;` : 'background-color: white; color: #9ca3af;'}">
                                                        ${currentVote || '?'}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                    }).join('');
                                })()}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Fixed bottom voting panel -->
                <div class="fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-900 border-t-2 border-gray-300 dark:border-gray-700 shadow-2xl z-50">
                    <div class="max-w-4xl mx-auto px-4 py-4">
                        <!-- Mobile layout: stacked -->
                        <div class="flex flex-col sm:hidden items-center justify-center gap-4">
                            <!-- Info label -->
                            ${state.selectedScore !== null ? `
                                <span class="text-sm text-gray-600 font-medium">
                                    Click images to vote <span class="font-bold" style="color: ${getScoreColor(state.selectedScore)}">${state.selectedScore}</span>
                                </span>
                            ` : `
                                <span class="text-sm text-gray-500">
                                    Select a score below
                                </span>
                            `}

                            <!-- Score buttons -->
                            <div class="flex gap-2">
                                ${[1, 2, 3, 4, 5].map(score => {
                                    const isSelected = state.selectedScore === score;
                                    return `
                                        <button
                                            onclick="toggleScoreSelection(${score})"
                                            class="w-14 h-14 rounded-full font-bold text-white text-lg shadow-lg hover:scale-110 transition-transform relative ${isSelected ? 'ring-4 ring-offset-2 scale-110' : ''}"
                                            style="background-color: ${getScoreColor(score)}; ring-color: ${getScoreColor(score)};"
                                            title="Score ${score}${isSelected ? ' (selected - click images to vote)' : ''}"
                                        >
                                            ${score}
                                            ${isSelected ? `
                                                <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-blue-600 rounded-full p-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                </svg>
                                            ` : ''}
                                        </button>
                                    `;
                                }).join('')}
                            </div>

                            <!-- Submit button -->
                            ${allVoted ? `
                                <button onclick="submitVotes()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-6 py-3 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition flex items-center gap-2 shadow-lg whitespace-nowrap">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    Submit Votes
                                </button>
                            ` : ''}
                        </div>

                        <!-- Desktop layout: label left, buttons center, submit right -->
                        <div class="hidden sm:flex items-center justify-between gap-4">
                            <!-- Info label (left) -->
                            <div class="flex-shrink-0">
                                ${state.selectedScore !== null ? `
                                    <span class="text-sm text-gray-600 font-medium">
                                        Click images to vote <span class="font-bold" style="color: ${getScoreColor(state.selectedScore)}">${state.selectedScore}</span>
                                    </span>
                                ` : `
                                    <span class="text-sm text-gray-500">
                                        Select a score
                                    </span>
                                `}
                            </div>

                            <!-- Score buttons (center) -->
                            <div class="flex gap-2 flex-shrink-0">
                                ${[1, 2, 3, 4, 5].map(score => {
                                    const isSelected = state.selectedScore === score;
                                    return `
                                        <button
                                            onclick="toggleScoreSelection(${score})"
                                            class="w-14 h-14 rounded-full font-bold text-white text-lg shadow-lg hover:scale-110 transition-transform relative ${isSelected ? 'ring-4 ring-offset-2 scale-110' : ''}"
                                            style="background-color: ${getScoreColor(score)}; ring-color: ${getScoreColor(score)};"
                                            title="Score ${score}${isSelected ? ' (selected - click images to vote)' : ''}"
                                        >
                                            ${score}
                                            ${isSelected ? `
                                                <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-blue-600 rounded-full p-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                </svg>
                                            ` : ''}
                                        </button>
                                    `;
                                }).join('')}
                            </div>

                            <!-- Submit button (right) -->
                            <div class="flex-shrink-0">
                                ${allVoted ? `
                                    <button onclick="submitVotes()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-6 py-3 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition flex items-center gap-2 shadow-lg whitespace-nowrap">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        Submit Votes
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderVoting() {
            // Switch between single and multi view based on state.votingMode
            if (state.votingMode === 'multi') {
                return renderMultiViewVoting();
            }

            const currentImage = state.shuffledImages[state.currentImageIndex];
            const currentVote = state.votes[currentImage.id];
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);

            // Determine voting context (contest or merger)
            const isMergerVoting = state.currentMergerId && !state.currentContest;
            const votingTitle = isMergerVoting
                ? (state.mergers.find(m => m.id === state.currentMergerId)?.name || 'Merger Voting')
                : (state.currentContest?.title || 'Voting');

            // Adaptive progress bar logic - ensure EXACTLY segmentCount dashes
            const imageCount = state.shuffledImages.length;
            const segmentCount = Math.min(imageCount, 20);
            const imagesPerSegment = Math.ceil(imageCount / segmentCount);

            return `
                <div class="max-w-4xl mx-auto px-3 py-4">
                    <!-- Voting Mode Info Label -->
                    <div class="bg-blue-50 border border-blue-200 rounded-lg px-3 py-2 mb-3 text-center">
                        <p class="text-xs text-blue-800 dark:text-blue-200">
                            üí° <strong>Tip:</strong> Use the toggle switch above to switch between single image and multi image voting views.
                        </p>
                    </div>
                    ${renderAutosaveStatusBar()}
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <div class="bg-gray-200 h-3 flex gap-1 p-1">
                            ${Array.from({ length: segmentCount }, (_, segmentIdx) => {
                                const startIdx = segmentIdx * imagesPerSegment;
                                const endIdx = Math.min(startIdx + imagesPerSegment, imageCount);

                                // Skip segments that would start beyond our image count
                                if (startIdx >= imageCount) return '';

                                const segmentImages = state.shuffledImages.slice(startIdx, endIdx);

                                const votedCount = segmentImages.filter(img => state.votes[img.id]).length;
                                const totalCount = segmentImages.length;
                                const hasCurrentImage = state.currentImageIndex >= startIdx && state.currentImageIndex < endIdx;

                                // Determine color based on priority
                                let bgColor;
                                if (hasCurrentImage) {
                                    bgColor = 'bg-mauve-400';
                                } else if (votedCount === totalCount) {
                                    bgColor = 'bg-green-500';
                                } else if (votedCount > 0) {
                                    bgColor = 'bg-yellow-500';
                                } else {
                                    bgColor = 'bg-gray-300';
                                }

                                const imageRange = startIdx + 1 === endIdx ? `Image ${startIdx + 1}` : `Images ${startIdx + 1}-${endIdx}`;
                                const tooltip = `${imageRange} (${votedCount}/${totalCount} voted)`;

                                return `
                                    <div
                                        onclick="jumpToImage(${startIdx})"
                                        class="progress-segment flex-1 ${bgColor}"
                                        title="${tooltip}"
                                    ></div>
                                `;
                            }).join('')}
                        </div>

                        <div class="p-3">
                            <div class="flex justify-between items-center mb-3 gap-2">
                                <h2 class="text-lg font-bold text-gray-800">${votingTitle}</h2>
                                <span class="text-gray-600 font-medium text-sm">${state.currentImageIndex + 1}/${state.shuffledImages.length}</span>
                            </div>

                            <div class="relative mb-3 bg-gray-100 overflow-hidden flex items-center justify-center" style="height: 55vh;">
                                <img
                                    src="${currentImage.url}"
                                    alt="Image ${state.currentImageIndex + 1}"
                                    class="max-h-full max-w-full object-contain"
                                    style="max-height: 100%; max-width: 100%;"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                                ${currentVote ? `
                                    <div class="absolute top-2 right-2 bg-white dark:bg-gray-800 rounded-full px-3 py-1 shadow-lg flex items-center gap-1 text-sm">
                                        <svg class="w-4 h-4 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                                        </svg>
                                        <span class="font-semibold text-gray-800 dark:text-gray-200">Voted: ${currentVote}</span>
                                    </div>
                                ` : ''}
                            </div>

                            <div class="flex justify-center gap-2 mb-3">
                                ${[1, 2, 3, 4, 5].map(score => `
                                    <button 
                                        data-score="${score}"
                                        onclick="handleVote(${score})" 
                                        ${state.isAnimating ? 'disabled' : ''}
                                        class="w-12 h-12 sm:w-14 sm:h-14 rounded-full font-bold text-white text-base shadow-lg hover:scale-110 transition-transform relative ${currentVote === score ? 'ring-4 ring-offset-2' : ''} ${state.isAnimating ? 'opacity-70 cursor-not-allowed' : ''}"
                                        style="background-color: ${getScoreColor(score)}; transform: ${currentVote === score ? 'scale(1.15)' : 'scale(1)'}; ring-color: ${getScoreColor(score)};"
                                    >
                                        ${score}
                                        ${currentVote === score && state.showTickAnimation ? `
                                            <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-green-600 rounded-full p-1 tick-animation" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                            </svg>
                                        ` : currentVote === score ? `
                                            <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-green-600 rounded-full p-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                            </svg>
                                        ` : ''}
                                    </button>
                                `).join('')}
                            </div>

                            <div class="flex justify-between items-center gap-2">
                                <button
                                    onclick="navigateImage('prev')"
                                    ${state.currentImageIndex === 0 ? 'disabled' : ''}
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                                >
                                    ‚Üê Prev
                                </button>

                                ${allVoted ? `
                                    <button onclick="submitVotes()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition flex items-center gap-1 shadow-lg text-sm">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        Submit
                                    </button>
                                ` : '<div></div>'}

                                <button
                                    onclick="navigateImage('next')"
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition text-sm"
                                >
                                    Next ‚Üí
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleShortlist(imageId) {
            const index = state.shortlistedImageIds.indexOf(imageId);
            if (index > -1) {
                // Remove from shortlist
                state.shortlistedImageIds.splice(index, 1);
            } else {
                // Add to shortlist
                state.shortlistedImageIds.push(imageId);
            }
            render();
        }

        // Shared rendering function for both contest and merged results
        function renderResultsPageCommon(options) {
            const {
                icon = 'üéÜ',
                title = 'Final Ranking',
                customHeaderContent = '', // For merger's contest dropdown
                subtitle = '',
                isPrivate,
                isAdmin,
                isCreator,
                imageSize,
                fontSize
            } = options;

            const tabs = [
                { key: 'average', label: 'Total' },
                { key: 'divisive', label: 'Divisive' },
                { key: 'count', label: 'Count' },
                { key: 'userVotes', label: 'By User' },
                { key: 'byVoter', label: 'Average' }
            ];

            const canSwitchTabs = !isPrivate || isAdmin || isCreator;

            const subtitleMap = {
                average: 'Total votes from all participants',
                divisive: 'Images ranked by how divisive they are',
                count: 'Count of specific score votes',
                userVotes: 'Individual user votes',
                byVoter: 'Average scores per voter'
            };

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="text-center mb-4">
                            <div class="flex items-center justify-center gap-2 mb-2">
                                <span class="text-4xl">${icon}</span>
                                <h2 class="text-2xl font-bold text-gray-800">${title}</h2>
                            </div>
                            ${customHeaderContent}
                            <p class="text-gray-600 text-sm mb-1">${subtitle || subtitleMap[state.resultsView] || ''}</p>
                            <p class="text-xs text-gray-500">Click on any image to see the vote breakdown</p>

                            ${isPrivate ? `
                                <div class="mt-3 mb-2 max-w-2xl mx-auto">
                                    <div class="bg-yellow-50 border border-yellow-400 text-yellow-800 px-4 py-3 rounded-lg text-sm flex items-start gap-2">
                                        <span class="text-lg flex-shrink-0">‚ö†Ô∏è</span>
                                        <p class="flex-1">${isCreator ? "These results are private. Only you can view them." : "These results are private. Only you and the creator can view them."}</p>
                                    </div>
                                </div>
                            ` : ''}

                            <div class="mt-3 flex flex-col items-center justify-center gap-2">
                                ${renderGlobalFilters()}
                                <div class="flex items-center justify-center gap-1 sm:gap-2 flex-wrap">
                                    ${tabs.map(tab => `
                                        <button
                                            ${canSwitchTabs ? `onclick="setResultsView('${tab.key}')"` : 'disabled'}
                                            class="px-3 sm:px-4 py-1.5 sm:py-2 rounded-lg text-sm sm:text-base font-medium ${state.resultsView === tab.key ? 'bg-mauve-400 text-white' : 'bg-gray-200'} ${canSwitchTabs ? '' : 'opacity-50 cursor-not-allowed'}"
                                        >${tab.label}</button>
                                    `).join('')}
                                </div>

                                ${renderTabControls(isPrivate, isAdmin, isCreator)}
                            </div>
                        </div>

                        ${renderTabScaleSlider()}

                        ${renderTabContent(imageSize, fontSize, isPrivate, isAdmin, isCreator)}
                    </div>
                    ${state.showBreakdownModal ? (state.resultsView === 'divisive' ? renderDivisiveBreakdownModal() : renderBreakdownModal()) : ''}
                </div>
            `;
        }

        function renderResults() {
            // Check privacy settings
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === state.currentContest.createdBy;
            const isPrivate = state.currentContest.resultsPublic === false;
            const canViewPrivateResults = isAdmin || isCreator;

            // Block unauthorized users from viewing private results
            if (isPrivate && !canViewPrivateResults) {
                return `
                    <div class="max-w-7xl mx-auto px-3 py-4">
                        <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                            <div class="text-center mb-4">
                                <div class="flex items-center justify-center gap-2 mb-2">
                                    <span class="text-4xl">üéÜ</span>
                                    <h2 class="text-2xl font-bold text-gray-800">Final Ranking</h2>
                                </div>
                            </div>
                            <div class="mt-3 flex flex-col items-center justify-center gap-2 mb-4">
                                <div class="flex items-center justify-center gap-1 sm:gap-2 flex-wrap opacity-50">
                                    ${['Total','Divisive','Count','By User','Average'].map(t => `<button class="px-3 sm:px-4 py-1.5 sm:py-2 rounded-lg bg-gray-200 cursor-not-allowed text-sm sm:text-base font-medium" disabled>${t}</button>`).join('')}
                                </div>
                            </div>
                            <div class="text-center py-16">
                                <div class="text-8xl mb-6">üîí</div>
                                <h3 class="text-2xl font-bold text-gray-800 mb-3">Results are Private</h3>
                                <p class="text-gray-600 max-w-md mx-auto">Only the contest creator can view results.</p>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Handle comparison views for By User tab
            if (state.resultsView === 'userVotes' && state.comparisonView === 'table') {
                return renderComparisonTable() + (state.showBreakdownModal ? renderBreakdownModal() : '');
            }
            if (state.resultsView === 'userVotes' && state.comparisonView === 'detail') {
                return renderComparisonDetail() + (state.showBreakdownModal ? renderBreakdownModal() : '');
            }

            // Handle full-screen comparison views for Average tab
            if (state.resultsView === 'byVoter' && state.averageTabCompareAll) {
                return renderAverageTabCompareAll();
            }

            const baseSize = 150;
            const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
            const baseFontSize = 12;
            const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

            return renderResultsPageCommon({
                icon: 'üéÜ',
                title: 'Final Ranking',
                customHeaderContent: '',
                subtitle: '',
                isPrivate,
                isAdmin,
                isCreator,
                imageSize,
                fontSize
            });
        }

        function renderTabControls(isPrivate, isAdmin, isCreator) {
            let html = '';

            // Count tab: score selection + mode toggle
            if (state.resultsView === 'count') {
                html += `
                    <div class="flex items-center justify-center gap-2 mt-3">
                        <label class="text-xs font-medium text-gray-700">Select Scores:</label>
                        ${[1, 2, 3, 4, 5].map(score => {
                            const isSelected = state.countSelectedScores.includes(score);
                            return `<button onclick="toggleCountScore(${score})" class="px-4 py-2 rounded-lg font-bold text-white transition-all ${isSelected ? 'ring-4 ring-offset-2 ring-mauve-400 scale-110' : 'opacity-30 hover:opacity-100'}" style="background-color: ${getScoreColor(score)};">${score}</button>`;
                        }).join('')}
                    </div>
                    <div class="flex items-center justify-center gap-2 mt-2">
                        <label class="text-xs font-medium text-gray-700">Show:</label>
                        <button onclick="setCountMode('images')" class="px-3 py-1 rounded-lg text-xs font-medium ${state.countMode === 'images' ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Images</button>
                        <button onclick="setCountMode('users')" class="px-3 py-1 rounded-lg text-xs font-medium ${state.countMode === 'users' ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Users</button>
                    </div>
                `;
            }

            // Divisive tab: SD explanation
            if (state.resultsView === 'divisive') {
                html += `
                    <div class="mt-2 max-w-lg mx-auto">
                        <p class="text-xs text-gray-500 text-center">SD = Standard Deviation ‚Äî measures how much voters disagree on an image's score</p>
                    </div>
                `;
            }

            // User Votes tab: user selector + compare button
            if (state.resultsView === 'userVotes' && state.contestVoters.length > 0) {
                const canSelectUser = !isPrivate || isAdmin || isCreator;
                if (!canSelectUser) {
                    html += `<div class="flex justify-center items-center gap-2"><label class="text-xs font-medium text-gray-700">Viewing: Your Votes Only</label></div>`;
                } else {
                    html += `
                        <div class="flex justify-center items-center gap-2 flex-wrap">
                            <label class="text-xs font-medium text-gray-700">Select User:</label>
                            <select onchange="setResultsView('userVotes', this.value)" class="px-2 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm">
                                ${state.selectedVoterUserId === null ? '<option value="" selected disabled>Select a user...</option>' : ''}
                                ${state.contestVoters.map(voter => `<option value="${voter.userId}" ${state.selectedVoterUserId === voter.userId ? 'selected' : ''}>${voter.username}${voter.userId === (state.user && state.user.id) ? ' (You)' : ''}</option>`).join('')}
                            </select>
                            <button onclick="startComparison()" class="px-3 py-1 rounded-lg text-xs font-medium bg-blue-500 text-white hover:bg-blue-600 transition">Compare with others</button>
                        </div>
                    `;
                }
            }

            return html;
        }

        function renderTabScaleSlider() {
            if (state.resultsView === 'byVoter') return '';

            return `
                <div class="mb-4 max-w-md mx-auto">
                    <div class="flex items-center gap-2">
                        <label class="text-xs font-medium text-gray-700 whitespace-nowrap">Image Scale:</label>
                        <button onclick="adjustScale(-1)" class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition" title="Decrease scale">‚àí</button>
                        <input type="range" id="scaleSlider" min="20" max="250" value="${state.imageScale}" oninput="updateScale(this.value)" class="flex-1 h-2 bg-gray-200 rounded-lg cursor-pointer" />
                        <button onclick="adjustScale(1)" class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition" title="Increase scale">+</button>
                        <span class="text-xs font-medium text-gray-700 w-10">${state.imageScale}%</span>
                    </div>
                </div>
            `;
        }

        function renderTabContent(imageSize, fontSize, isPrivate, isAdmin, isCreator) {
            switch (state.resultsView) {
                case 'average': return renderTotalTab(imageSize, fontSize);
                case 'divisive': return renderDivisiveTab(imageSize, fontSize);
                case 'count': return renderCountTab(imageSize, fontSize);
                case 'userVotes': return renderByUserTab(imageSize, fontSize, isPrivate, isAdmin, isCreator);
                case 'byVoter': return renderAverageTab();
                default: return renderTotalTab(imageSize, fontSize);
            }
        }

        // ==================== TAB 1: TOTAL ====================
        function getResultsWithoutImageFilter() {
            if (!state.results) return [];
            let results = state.results;
            const filterIds = getFilteredUserIds();
            if (filterIds === null) return results;
            return results.map(img => {
                const filteredBreakdown = (img.breakdown || []).filter(v => !v.isBlocked && !v.isBanned && filterIds.has(v.userId));
                const scores = filteredBreakdown.map(v => v.score);
                const avg = scores.length > 0 ? parseFloat((scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2)) : 0;
                return { ...img, averageScore: avg, totalVotes: scores.length };
            });
        }

        function renderTotalTab(imageSize, fontSize) {
            const filteredResults = getFilteredResults();
            const grouped = groupByScoreRange(filteredResults);
            const sortedKeys = Object.keys(grouped).sort((a, b) => {
                const aMin = grouped[a].min;
                const bMin = grouped[b].min;
                return bMin - aMin;
            });
            const userFilterAsterisk = isUserFilterActive() ? '*' : '';
            const imageFilterIds = getFilteredImageIds();
            let allGrouped = null;
            if (imageFilterIds !== null) {
                allGrouped = groupByScoreRange(getResultsWithoutImageFilter());
            }

            if (sortedKeys.length === 0 && !allGrouped) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üì≠</div><h3 class="text-xl font-bold text-gray-800 mb-2">No Results</h3><p class="text-gray-600">No voting data available.</p></div>`;
            }

            // Check if all images are hidden by filter (only show message when NOT in editing mode)
            const isFilterEditing = state.imageFilterDropdownOpen;
            if (!isFilterEditing && imageFilterIds !== null && imageFilterIds.size === 0) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üîç</div><h3 class="text-xl font-bold text-gray-800 mb-2">All Images Hidden</h3><p class="text-gray-600">You've hidden all images using the image filter. Click the "Images" filter button above to show some images.</p></div>`;
            }

            // When image filter editing is open, show all images with checkboxes

            // Collect all keys from both filtered and unfiltered
            const sourceGrouped = isFilterEditing && allGrouped ? allGrouped : grouped;
            const allKeys = allGrouped ? [...new Set([...sortedKeys, ...Object.keys(allGrouped)])] : sortedKeys;
            allKeys.sort((a, b) => {
                const aMin = (grouped[a] || allGrouped[a]).min;
                const bMin = (grouped[b] || allGrouped[b]).min;
                return bMin - aMin;
            });

            return allKeys.map(key => {
                const group = grouped[key];
                const allGroup = allGrouped ? allGrouped[key] : null;
                const displayGroup = isFilterEditing ? (allGroup || group) : group;
                const visibleCount = group ? group.items.length : 0;
                const totalCount = allGroup ? allGroup.items.length : visibleCount;
                const hiddenCount = totalCount - visibleCount;
                if (!displayGroup || displayGroup.items.length === 0) return '';
                const refGroup = group || allGroup;
                const colorStyle = getCategoryColor(refGroup.min, refGroup.isMissing);
                const sectionKey = `total_${key}`;
                const collapsed = isSectionCollapsed(sectionKey);

                return `
                    <div class="mb-4">
                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg ${colorStyle.color} ${colorStyle.bg} w-full flex items-center cursor-pointer select-none" onclick="toggleSection('${sectionKey}')">
                            ${renderCollapseArrow(sectionKey)}
                            ${getCategoryLabel(refGroup.min, refGroup.max, refGroup.isMissing)}
                            <span class="text-xs font-normal ml-auto">Count: ${visibleCount}${hiddenCount > 0 ? ` <span class="opacity-70">(${hiddenCount} more hidden)</span>` : ''}</span>
                        </h3>
                        ${!collapsed && displayGroup ? `
                            <div class="flex flex-wrap gap-1">
                                ${displayGroup.items.map(item => {
                                    const isVisible = isImageVisibleInFilter(item.id);
                                    const allHiddenByFilter = imageFilterIds !== null && imageFilterIds.size === 0;
                                    if (!isFilterEditing && !isVisible && !allHiddenByFilter) return '';
                                    return `
                                    <div class="relative cursor-pointer ${isFilterEditing ? '' : !isVisible ? '' : 'hover:scale-105'} transition-transform rounded-lg overflow-hidden shadow-lg" style="height: ${imageSize}px; ${!isVisible ? 'opacity: 0.3; filter: grayscale(80%);' : ''}" onclick="${isFilterEditing ? `event.stopPropagation(); toggleImageFilterImage(${item.id})` : isVisible ? `showBreakdown(${item.id})` : `toggleImageFilterDropdown()`}">
                                        <img src="${item.url}" alt="Image" class="h-full w-auto object-cover" style="height: ${imageSize}px;" />
                                        <div class="absolute bottom-0 left-0 right-0 text-center py-1 font-bold score-text" style="font-size: ${fontSize}px; color: white;">
                                            ${item.averageScore}${userFilterAsterisk}
                                        </div>
                                        ${isFilterEditing ? `
                                            <div class="absolute top-1 left-1 w-6 h-6 rounded flex items-center justify-center text-xs font-bold ${isVisible ? 'bg-green-500 text-white' : 'bg-red-500 text-white'} shadow">
                                                ${isVisible ? '‚úì' : '‚úï'}
                                            </div>
                                        ` : ''}
                                    </div>`;
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // ==================== TAB 2: DIVISIVE ====================
        function renderDivisiveTab(imageSize, fontSize) {
            const imageFilterIds = getFilteredImageIds();
            // Check if all images are hidden by filter (only show message when NOT in editing mode)
            const isFilterEditing = state.imageFilterDropdownOpen;
            if (!isFilterEditing && imageFilterIds !== null && imageFilterIds.size === 0) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üîç</div><h3 class="text-xl font-bold text-gray-800 mb-2">All Images Hidden</h3><p class="text-gray-600">You've hidden all images using the image filter. Click the "Images" filter button above to show some images.</p></div>`;
            }

            const data = generateDivisiveData();

            if (data.allImages.length === 0) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üìä</div><h3 class="text-xl font-bold text-gray-800 mb-2">No Data</h3><p class="text-gray-600">Not enough votes to calculate divisiveness (need at least 2 votes per image).</p></div>`;
            }

            return data.categories.map(cat => {
                if (cat.items.length === 0) return '';
                const collapsed = isSectionCollapsed(cat.key);

                return `
                    <div class="mb-4">
                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg ${cat.color} w-full flex items-center cursor-pointer select-none" onclick="toggleSection('${cat.key}')">
                            ${renderCollapseArrow(cat.key)}
                            ${cat.label} <span class="text-xs font-normal"> (${cat.sublabel})</span>
                            <span class="text-xs font-normal ml-auto">Count: ${cat.items.length}</span>
                        </h3>
                        ${!collapsed ? `
                            <div class="flex flex-wrap gap-1">
                                ${cat.items.map(item => `
                                    <div onclick="showBreakdown(${item.id})" class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative" style="height: ${imageSize}px;">
                                        <img src="${item.url}" alt="Image" class="h-full w-auto object-cover" style="height: ${imageSize}px;" />
                                        <div class="absolute bottom-0 left-0 right-0 text-white text-center py-0.5 font-bold score-text" style="font-size: ${fontSize}px;">
                                            ${item.averageScore}
                                        </div>
                                        <div class="absolute top-0 right-0 px-1.5 py-0.5 rounded-bl-lg font-bold" style="background: rgba(0,0,0,0.7); color: ${cat.borderColor}; font-size: ${Math.max(8, fontSize - 1)}px;">
                                            SD ${item.sd}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // ==================== TAB 3: COUNT ====================
        function renderCountTab(imageSize, fontSize) {
            const imageFilterIds = getFilteredImageIds();
            // Check if all images are hidden by filter (only show message when NOT in editing mode)
            const isFilterEditing = state.imageFilterDropdownOpen;
            if (!isFilterEditing && imageFilterIds !== null && imageFilterIds.size === 0) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üîç</div><h3 class="text-xl font-bold text-gray-800 mb-2">All Images Hidden</h3><p class="text-gray-600">You've hidden all images using the image filter. Click the "Images" filter button above to show some images.</p></div>`;
            }

            if (state.countSelectedScores.length === 0) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üëÜ</div><h3 class="text-xl font-bold text-gray-800 mb-2">Select Score(s)</h3><p class="text-gray-600">Please select one or more scores from the buttons above to see the count breakdown.</p></div>`;
            }

            if (state.countMode === 'users') {
                return renderCountUsersMode(imageSize);
            }

            // Images mode with user filter
            const countData = isUserFilterActive() ? generateCountDataFiltered() : generateCountData();
            const userFilterAsterisk = isUserFilterActive() ? '*' : '';

            // Calculate hidden counts per count level for image filter
            let allCountData = null;
            if (imageFilterIds !== null) {
                allCountData = generateCountData();
            }

            if (!countData || countData.sortedCounts.length === 0) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üì≠</div><h3 class="text-xl font-bold text-gray-800 mb-2">No Results</h3><p class="text-gray-600">No images have received the selected score(s).</p></div>`;
            }

            const allCounts = allCountData ? [...new Set([...countData.sortedCounts, ...allCountData.sortedCounts])].sort((a, b) => b - a) : countData.sortedCounts;
            const effectiveMaxCount = allCountData ? Math.max(countData.maxCount, allCountData.maxCount) : countData.maxCount;

            return `<div class="space-y-3">
                ${allCounts.map(count => {
                    const images = countData.grouped[count] || [];
                    const allImagesForCount = allCountData ? (allCountData.grouped[count] || []) : images;
                    const displayImages = isFilterEditing ? allImagesForCount : images;
                    const hiddenCount = allImagesForCount.length - images.length;
                    if (displayImages.length === 0) return '';
                    const ratio = count / effectiveMaxCount;
                    const baseHue = 270 + (ratio * 330);
                    const hue = baseHue % 360;
                    const isDark = document.body.classList.contains('dark-theme');
                    const bgColor = isDark ? `hsl(${hue}, 85%, 60%)` : `hsl(${hue}, 70%, 45%)`;
                    const sectionKey = `count_${count}`;
                    const collapsed = isSectionCollapsed(sectionKey);

                    return `
                        <div class="flex items-stretch gap-2">
                            <div class="w-16 flex-shrink-0 rounded-lg flex items-center justify-center gap-1 text-white font-bold text-sm shadow-lg px-2 py-2 cursor-pointer select-none" style="background-color: ${bgColor};" onclick="toggleSection('${sectionKey}')">
                                ${renderCollapseArrow(sectionKey)}
                                <div class="text-xl">${count}</div>
                            </div>
                            ${!collapsed && displayImages.length > 0 ? `
                                <div class="flex-1 flex flex-wrap gap-1 items-start">
                                    ${!isFilterEditing && hiddenCount > 0 ? `<div class="text-xs text-gray-500 w-full opacity-70">(${hiddenCount} more hidden)</div>` : ''}
                                    ${displayImages.map(img => {
                                        const isVisible = isImageVisibleInFilter(img.id);
                                        if (!isFilterEditing && !isVisible) return '';
                                        return `
                                        <div class="relative cursor-pointer ${isFilterEditing ? '' : 'hover:opacity-90'} transition" style="height: ${imageSize}px; ${!isVisible ? 'opacity: 0.3; filter: grayscale(80%);' : ''}" onclick="${isFilterEditing ? `event.stopPropagation(); toggleImageFilterImage(${img.id})` : `showBreakdown(${img.id})`}">
                                            <div class="relative rounded-lg overflow-hidden shadow-lg bg-gray-100 h-full" style="height: ${imageSize}px; border: 3px solid ${bgColor};">
                                                <img src="${img.url}" alt="Image" class="h-full w-auto object-cover" style="height: ${imageSize}px;" />
                                                <div class="absolute bottom-0 left-0 right-0 text-center py-1 font-bold score-text" style="font-size: ${fontSize}px; color: white;">${img.averageScore}${userFilterAsterisk}</div>
                                            </div>
                                            ${isFilterEditing ? `
                                                <div class="absolute top-1 left-1 w-6 h-6 rounded flex items-center justify-center text-xs font-bold ${isVisible ? 'bg-green-500 text-white' : 'bg-red-500 text-white'} shadow">
                                                    ${isVisible ? '‚úì' : '‚úï'}
                                                </div>
                                            ` : ''}
                                        </div>`;
                                    }).join('')}
                                </div>
                            ` : `<div class="flex-1 flex items-center"><span class="text-xs text-gray-500">${!isFilterEditing && hiddenCount > 0 ? `(${hiddenCount} hidden)` : ''}</span></div>`}
                        </div>
                    `;
                }).join('')}
            </div>`;
        }

        function renderCountUsersMode(imageSize) {
            const data = generateCountDataUsers();
            if (!data || data.sortedCounts.length === 0) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üì≠</div><h3 class="text-xl font-bold text-gray-800 mb-2">No Results</h3><p class="text-gray-600">No users have given the selected score(s).</p></div>`;
            }

            // Scale user card size based on imageSize
            const cardScale = imageSize ? Math.max(0.6, Math.min(2.0, imageSize / 150)) : 1;
            const avatarSize = Math.round(32 * cardScale);
            const cardFontSize = Math.max(10, Math.round(14 * cardScale));

            return `<div class="space-y-3">
                ${data.sortedCounts.map(count => {
                    const users = data.grouped[count];
                    const ratio = count / data.maxCount;
                    const baseHue = 270 + (ratio * 330);
                    const hue = baseHue % 360;
                    const isDark = document.body.classList.contains('dark-theme');
                    const bgColor = isDark ? `hsl(${hue}, 85%, 60%)` : `hsl(${hue}, 70%, 45%)`;
                    const sectionKey = `count_users_${count}`;
                    const collapsed = isSectionCollapsed(sectionKey);

                    return `
                        <div class="flex items-stretch gap-2">
                            <div class="w-16 flex-shrink-0 rounded-lg flex items-center justify-center gap-1 text-white font-bold text-sm shadow-lg px-2 py-2 cursor-pointer select-none" style="background-color: ${bgColor};" onclick="toggleSection('${sectionKey}')">
                                ${renderCollapseArrow(sectionKey)}
                                <div class="text-xl">${count}</div>
                            </div>
                            ${!collapsed ? `
                                <div class="flex-1 flex flex-wrap gap-2 items-start">
                                    ${users.map(u => `
                                        <div class="flex items-center gap-2 bg-white rounded-lg shadow border border-gray-200 cursor-pointer hover:shadow-md transition" style="padding: ${Math.round(8 * cardScale)}px ${Math.round(12 * cardScale)}px;" onclick="viewUserProfile('${u.userId}')">
                                            <img src="${u.avatar}" class="rounded-full" style="width: ${avatarSize}px; height: ${avatarSize}px;" />
                                            <span class="font-medium" style="font-size: ${cardFontSize}px;">${u.username}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : '<div class="flex-1 text-sm text-gray-500 flex items-center">' + users.length + ' user' + (users.length !== 1 ? 's' : '') + '</div>'}
                        </div>
                    `;
                }).join('')}
            </div>`;
        }

        // ==================== TAB 4: BY USER ====================
        function renderByUserTab(imageSize, fontSize, isPrivate, isAdmin, isCreator) {
            if (!state.selectedVoterUserId) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üëÜ</div><h3 class="text-xl font-bold text-gray-800 mb-2">Select a User</h3><p class="text-gray-600">Please select a user from the dropdown above to view their votes.</p></div>`;
            }

            const selectedUserId = state.selectedVoterUserId;
            const imageFilterIds = getFilteredImageIds();
            const userVotesMap = {};
            const blockedVotesSet = new Set();
            state.results.forEach(imageResult => {
                if (imageFilterIds !== null && !imageFilterIds.has(imageResult.id)) return;
                const userVote = imageResult.breakdown.find(v => v.userId === selectedUserId);
                if (userVote) {
                    userVotesMap[imageResult.id] = userVote.score;
                    if (userVote.isBlocked) blockedVotesSet.add(imageResult.id);
                }
            });

            const displayResults = state.results
                .filter(img => imageFilterIds === null || imageFilterIds.has(img.id))
                .map(img => ({
                    ...img,
                    averageScore: userVotesMap[img.id] || 0,
                    userVoteScore: userVotesMap[img.id],
                    isBlocked: blockedVotesSet.has(img.id)
                })).filter(img => img.userVoteScore);

            if (displayResults.length === 0) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üì≠</div><h3 class="text-xl font-bold text-gray-800 mb-2">No Votes Yet</h3><p class="text-gray-600">This user hasn't voted on any images here yet.</p></div>`;
            }

            const grouped = groupMyVotesByScore(displayResults);
            const sortedKeys = Object.keys(grouped).sort((a, b) => parseInt(b) - parseInt(a));

            return sortedKeys.map(key => {
                const group = grouped[key];
                const score = group.score;
                const colorStyle = getScoreColor(score);
                const sectionKey = `byuser_${score}`;
                const collapsed = isSectionCollapsed(sectionKey);

                return `
                    <div class="mb-4">
                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg flex items-center cursor-pointer select-none" style="color: white; background-color: ${colorStyle};" onclick="toggleSection('${sectionKey}')">
                            ${renderCollapseArrow(sectionKey)}
                            Score ${score}
                            <span class="text-xs font-normal ml-auto">Count: ${group.items.length}</span>
                        </h3>
                        ${!collapsed ? `
                            <div class="flex flex-wrap gap-1">
                                ${group.items.map(item => `
                                    <div onclick="showBreakdown(${item.id})" class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative" style="height: ${imageSize}px;">
                                        ${item.isBlocked ? `<div class="absolute inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-10"><span class="text-4xl">üö´</span></div>` : ''}
                                        <img src="${item.url}" alt="Image" class="h-full w-auto object-cover ${item.isBlocked ? 'opacity-60' : ''}" style="height: ${imageSize}px;" />
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // ==================== TAB 5: AVERAGE (byVoter) ====================
        // ==================== AVERAGE TAB COMPARE-ALL (full-screen) ====================
        function renderAverageTabCompareAll() {
            // Detail view: individual user vs contest average
            if (state.averageTabCompareUserId) {
                const baseSize = 150;
                const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
                const baseFontSize = 12;
                const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

                const prevSelectedVoter = state.selectedVoterUserId;
                state.selectedVoterUserId = state.averageTabCompareUserId;
                const categories = generateContestAverageComparison(state.comparisonAvgView);
                state.selectedVoterUserId = prevSelectedVoter;

                const voter = state.contestVoters.find(v => v.userId === state.averageTabCompareUserId);
                const voterName = voter ? voter.username : 'Unknown';

                return `
                    <div class="max-w-7xl mx-auto px-3 py-4">
                        <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                            <div class="flex items-center gap-3 mb-4 flex-wrap">
                                <button onclick="backFromAverageCompareUser()" class="px-3 py-1 rounded-lg bg-gray-200 hover:bg-gray-300 text-sm font-medium transition flex items-center gap-1">
                                    <span>‚Üê</span> Back
                                </button>
                                <h2 class="text-lg font-bold text-gray-800">${voterName} vs Contest Average</h2>
                            </div>

                            <div class="flex items-center gap-2 mb-4">
                                <label class="text-xs font-medium text-gray-700">View:</label>
                                <button onclick="setComparisonAvgView('match')" class="px-3 py-1 rounded-lg text-xs font-medium ${state.comparisonAvgView === 'match' ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Match-based</button>
                                <button onclick="setComparisonAvgView('relative')" class="px-3 py-1 rounded-lg text-xs font-medium ${state.comparisonAvgView === 'relative' ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Relative</button>
                            </div>

                            <div class="mb-4 max-w-md">
                                <div class="flex items-center gap-2">
                                    <label class="text-xs font-medium text-gray-700 whitespace-nowrap">Image Scale:</label>
                                    <button onclick="adjustScale(-1)" class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition">‚àí</button>
                                    <input type="range" min="20" max="250" value="${state.imageScale}" oninput="updateScale(this.value)" class="flex-1 h-2 bg-gray-200 rounded-lg cursor-pointer" />
                                    <button onclick="adjustScale(1)" class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition">+</button>
                                    <span class="text-xs font-medium text-gray-700 w-10">${state.imageScale}%</span>
                                </div>
                            </div>

                            <div>
                                ${renderContestAvgCategories(categories, imageSize, fontSize)}
                            </div>
                        </div>
                    </div>
                `;
            }

            // Table view: all users vs contest average
            let comparisonData = generateContestAvgComparisonTable();
            const isMatch = state.comparisonTableView === 'match';

            const matchColumns = [
                { key: 'exactPct', label: 'Near Exact', bg: '#bbf7d0' },
                { key: 'closePct', label: 'Close (¬±0.51-1.00)', bg: '#fef08a' },
                { key: 'widePct', label: 'Wide (¬±1.01+)', bg: '#fecaca' }
            ];
            const relativeColumns = [
                { key: 'exactPct', label: 'Near Exact', bg: '#bbf7d0' },
                { key: 'abovePct', label: 'Above', bg: '#bfdbfe' },
                { key: 'belowPct', label: 'Below', bg: '#fed7aa' }
            ];
            const columns = isMatch ? matchColumns : relativeColumns;

            const getSortIndicator = (key) => {
                const sort = state.comparisonTableSortKeys.find(s => s.key === key);
                if (!sort) return '';
                return ` ${sort.direction === 'desc' ? '‚ñº' : '‚ñ≤'}`;
            };

            if (state.comparisonTableSortKeys.length > 0) {
                comparisonData = [...comparisonData].sort((a, b) => {
                    for (const sortKey of state.comparisonTableSortKeys) {
                        if (sortKey.key === 'username') {
                            const cmp = a.username.toLowerCase().localeCompare(b.username.toLowerCase());
                            const diff = sortKey.direction === 'desc' ? -cmp : cmp;
                            if (diff !== 0) return diff;
                        } else {
                            const aVal = parseFloat(a[sortKey.key] || 0);
                            const bVal = parseFloat(b[sortKey.key] || 0);
                            const diff = sortKey.direction === 'desc' ? bVal - aVal : aVal - bVal;
                            if (diff !== 0) return diff;
                        }
                    }
                    return 0;
                });
            }

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="flex items-center gap-3 mb-4 flex-wrap">
                            <button onclick="backFromAverageCompareAll()" class="px-3 py-1 rounded-lg bg-gray-200 hover:bg-gray-300 text-sm font-medium transition flex items-center gap-1">
                                <span>‚Üê</span> Back
                            </button>
                            <h2 class="text-lg font-bold text-gray-800">Comparing: Contest Average</h2>
                        </div>

                        <div class="flex items-center gap-2 mb-4">
                            <label class="text-xs font-medium text-gray-700">View:</label>
                            <button onclick="setComparisonTableView('match')" class="px-3 py-1 rounded-lg text-xs font-medium ${isMatch ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Match-based</button>
                            <button onclick="setComparisonTableView('relative')" class="px-3 py-1 rounded-lg text-xs font-medium ${!isMatch ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Relative</button>
                        </div>

                        <div class="overflow-x-auto">
                            <table class="w-full text-sm">
                                <thead>
                                    <tr class="border-b-2 border-gray-200">
                                        <th class="text-left py-2 px-2 cursor-pointer select-none" onclick="toggleComparisonTableSort('username')">User${getSortIndicator('username')}</th>
                                        ${columns.map(col => `
                                            <th class="text-center py-2 px-1 text-xs cursor-pointer select-none" onclick="toggleComparisonTableSort('${col.key}')">${col.label}${getSortIndicator(col.key)}</th>
                                        `).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${comparisonData.map(voter => `
                                        <tr class="border-b border-gray-100 cursor-pointer hover:bg-gray-50 transition" onclick="showAverageCompareUser('${voter.userId}')">
                                            <td class="py-2 px-2">
                                                <div class="flex items-center gap-2">
                                                    <img src="${voter.avatar}" class="w-6 h-6 rounded-full" />
                                                    <span class="font-medium truncate max-w-[120px]">${voter.username}</span>
                                                </div>
                                            </td>
                                            ${columns.map(col => `
                                                <td class="text-center py-2 px-1"><span class="inline-block px-2 py-0.5 rounded text-xs font-bold comparison-pct-badge" style="background: ${col.bg}; color: #1f2937;">${voter[col.key]}%</span></td>
                                            `).join('')}
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAverageTab() {
            // Normal Average tab view
            const voterStats = generateVoterStats();

            if (!voterStats || voterStats.length === 0) {
                return `<div class="text-center py-12"><div class="text-6xl mb-4">üë•</div><h3 class="text-xl font-bold text-gray-800 mb-2">No Voters Yet</h3><p class="text-gray-600">No voting data available for this contest.</p></div>`;
            }

            // Compute contest average respecting image filter
            const imageFilterIds = getFilteredImageIds();
            let totalVotes = 0, totalScore = 0;
            state.results.forEach(img => {
                if (imageFilterIds !== null && !imageFilterIds.has(img.id)) return;
                (img.breakdown || []).forEach(vote => { if (!vote.isBlocked && !vote.isBanned) { totalVotes++; totalScore += vote.score; } });
            });
            const contestAverage = totalVotes > 0 ? (totalScore / totalVotes).toFixed(2) : 0;

            return `
                <div class="mb-4 flex justify-center">
                    <div class="flex items-center gap-2">
                        <label class="text-xs font-medium text-gray-700">Sort by:</label>
                        <select onchange="setVoterSortBy(this.value)" class="px-3 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm">
                            <option value="scoreDesc" ${state.voterSortBy === 'scoreDesc' ? 'selected' : ''}>Score: High to Low</option>
                            <option value="scoreAsc" ${state.voterSortBy === 'scoreAsc' ? 'selected' : ''}>Score: Low to High</option>
                            <option value="nameAsc" ${state.voterSortBy === 'nameAsc' ? 'selected' : ''}>Name: A-Z</option>
                            <option value="nameDesc" ${state.voterSortBy === 'nameDesc' ? 'selected' : ''}>Name: Z-A</option>
                        </select>
                    </div>
                </div>
                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-2">
                    <div class="bg-gradient-to-br from-yellow-50 to-yellow-100 rounded-lg shadow-md p-3 flex flex-col items-center border-2 border-yellow-500">
                        <div class="text-2xl mb-1">üèÜ</div>
                        <div class="text-xs font-semibold text-gray-800 text-center mb-1 leading-tight">Contest<br class="sm:hidden"> Average</div>
                        <div class="text-xl font-bold text-white score-text">${contestAverage}</div>
                        <div class="text-xs text-gray-500 mb-1">${totalVotes} vote${totalVotes !== 1 ? 's' : ''}</div>
                        <button onclick="startAverageCompareAll()" class="px-2 py-0.5 rounded text-[10px] sm:text-xs font-medium bg-blue-500 text-white hover:bg-blue-600 transition whitespace-nowrap">Compare all</button>
                    </div>
                    ${voterStats.map(voter => `
                        <div class="bg-white rounded-lg shadow-md p-3 flex flex-col items-center hover:shadow-lg transition-shadow border-2 ${voter.isCurrentUser ? 'border-mauve-400' : 'border-transparent'}">
                            <img src="${voter.avatar}" alt="${voter.username}" class="w-12 h-12 rounded-full mb-2 cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');" />
                            <div class="text-xs font-semibold text-gray-800 truncate w-full text-center mb-1 cursor-pointer hover:text-mauve-600 transition" title="${voter.username}" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');">${voter.username}</div>
                            <div class="text-xl font-bold text-white score-text">${voter.averageScore}</div>
                            <div class="text-xs text-gray-500">${voter.totalImages} vote${voter.totalImages !== 1 ? 's' : ''}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // ==================== COMPARISON TABLE VIEW ====================
        function renderComparisonTable() {
            let comparisonData = generateComparisonTable();
            const selectedVoter = state.contestVoters.find(v => v.userId === state.selectedVoterUserId);
            const selectedName = selectedVoter ? selectedVoter.username : 'Unknown';
            const isMatch = state.comparisonTableView === 'match';

            // Compute contest average percentages
            const contestAvgPcts = (() => {
                const dataSource = getComparisonDataSource();
                if (dataSource.length === 0 || !state.selectedVoterUserId) return {};
                const userVotes = {};
                dataSource.forEach(img => {
                    const vote = (img.breakdown || []).find(v => v.userId === state.selectedVoterUserId && !v.isBlocked && !v.isBanned);
                    if (vote) userVotes[img.id] = vote.score;
                });
                let total = 0, exact = 0, close = 0, wide = 0, above = 0, below = 0;
                dataSource.forEach(img => {
                    if (userVotes[img.id] === undefined || img.averageScore === 0) return;
                    total++;
                    const diff = userVotes[img.id] - img.averageScore;
                    const absDiff = Math.abs(diff);
                    if (absDiff <= 0.50) exact++;
                    else if (absDiff <= 1.00) close++;
                    else wide++;
                    if (diff > 0.50) above++;
                    if (diff < -0.50) below++;
                });
                if (total === 0) return {};
                const exactRel = total > 0 ? Math.round((dataSource.filter(img => userVotes[img.id] !== undefined && img.averageScore !== 0 && Math.abs(userVotes[img.id] - img.averageScore) <= 0.005).length / total) * 100) : 0;
                return {
                    exactPct: ((exact / total) * 100).toFixed(0),
                    closePct: ((close / total) * 100).toFixed(0),
                    widePct: ((wide / total) * 100).toFixed(0),
                    abovePct: ((above / total) * 100).toFixed(0),
                    belowPct: ((below / total) * 100).toFixed(0)
                };
            })();

            // Apply sort
            if (state.comparisonTableSortKeys.length > 0) {
                comparisonData = [...comparisonData].sort((a, b) => {
                    for (const sortKey of state.comparisonTableSortKeys) {
                        if (sortKey.key === 'username') {
                            const cmp = a.username.toLowerCase().localeCompare(b.username.toLowerCase());
                            const diff = sortKey.direction === 'desc' ? -cmp : cmp;
                            if (diff !== 0) return diff;
                        } else {
                            const aVal = parseFloat(a[sortKey.key] || 0);
                            const bVal = parseFloat(b[sortKey.key] || 0);
                            const diff = sortKey.direction === 'desc' ? bVal - aVal : aVal - bVal;
                            if (diff !== 0) return diff;
                        }
                    }
                    return 0;
                });
            }

            const getSortIndicator = (key) => {
                const sort = state.comparisonTableSortKeys.find(s => s.key === key);
                if (!sort) return '';
                return ` ${sort.direction === 'desc' ? '‚ñº' : '‚ñ≤'}`;
            };

            const matchColumns = [
                { key: 'exactPct', label: 'Exact', bg: '#bbf7d0', darkBg: '#1a3a1a' },
                { key: 'closePct', label: 'Close (¬±1)', bg: '#fef08a', darkBg: '#3a3510' },
                { key: 'widePct', label: 'Wide (¬±2+)', bg: '#fecaca', darkBg: '#3a1a1a' }
            ];
            const relativeColumns = [
                { key: 'exactPct', label: 'Exact', bg: '#bbf7d0', darkBg: '#1a3a1a' },
                { key: 'abovePct', label: 'Above', bg: '#bfdbfe', darkBg: '#1a2a3a' },
                { key: 'belowPct', label: 'Below', bg: '#fed7aa', darkBg: '#3a2a1a' }
            ];
            const columns = isMatch ? matchColumns : relativeColumns;

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="flex items-center gap-3 mb-4 flex-wrap">
                            <button onclick="backFromComparison()" class="px-3 py-1 rounded-lg bg-gray-200 hover:bg-gray-300 text-sm font-medium transition flex items-center gap-1">
                                <span>‚Üê</span> Back to votes
                            </button>
                            <h2 class="text-lg font-bold text-gray-800">Comparing: ${selectedName}</h2>
                        </div>

                        <div class="flex items-center gap-2 mb-4">
                            <label class="text-xs font-medium text-gray-700">View:</label>
                            <button onclick="setComparisonTableView('match')" class="px-3 py-1 rounded-lg text-xs font-medium ${isMatch ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Match-based</button>
                            <button onclick="setComparisonTableView('relative')" class="px-3 py-1 rounded-lg text-xs font-medium ${!isMatch ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Relative</button>
                        </div>

                        <div class="overflow-x-auto">
                            <table class="w-full text-sm">
                                <thead>
                                    <tr class="border-b-2 border-gray-200">
                                        <th class="text-left py-2 px-2 cursor-pointer select-none" onclick="toggleComparisonTableSort('username')">User${getSortIndicator('username')}</th>
                                        ${columns.map(col => `
                                            <th class="text-center py-2 px-1 text-xs cursor-pointer select-none" onclick="toggleComparisonTableSort('${col.key}')">${col.label}${getSortIndicator(col.key)}</th>
                                        `).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="border-b border-gray-100 bg-yellow-50 cursor-pointer hover:bg-yellow-100 transition" onclick="showComparisonDetail('__contest_average__')">
                                        <td class="py-2 px-2">
                                            <div class="flex items-center gap-2">
                                                <span class="text-lg">üìä</span>
                                                <div>
                                                    <span class="font-medium text-yellow-800">Contest Average</span>
                                                    <div class="text-xs text-gray-500">Click to view detailed comparison</div>
                                                </div>
                                            </div>
                                        </td>
                                        ${columns.map(col => `
                                            <td class="text-center py-2 px-1"><span class="inline-block px-2 py-0.5 rounded text-xs font-bold comparison-pct-badge" style="background: ${col.bg}; color: #1f2937;">${contestAvgPcts[col.key] || 0}%</span></td>
                                        `).join('')}
                                    </tr>
                                    ${comparisonData.map(voter => `
                                        <tr class="border-b border-gray-100 cursor-pointer hover:bg-gray-50 transition" onclick="showComparisonDetail('${voter.userId}')">
                                            <td class="py-2 px-2">
                                                <div class="flex items-center gap-2">
                                                    <img src="${voter.avatar}" class="w-6 h-6 rounded-full" />
                                                    <span class="font-medium truncate max-w-[120px]">${voter.username}</span>
                                                </div>
                                            </td>
                                            ${columns.map(col => `
                                                <td class="text-center py-2 px-1"><span class="inline-block px-2 py-0.5 rounded text-xs font-bold comparison-pct-badge" style="background: ${col.bg}; color: #1f2937;">${voter[col.key]}%</span></td>
                                            `).join('')}
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        // ==================== COMPARISON DETAIL VIEW ====================
        function renderComparisonDetail() {
            const targetId = state.comparisonDetailUserId;
            const isContestAvg = targetId === '__contest_average__';
            const selectedVoter = state.contestVoters.find(v => v.userId === state.selectedVoterUserId);
            const selectedName = selectedVoter ? selectedVoter.username : 'Unknown';

            const baseSize = 150;
            const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
            const baseFontSize = 12;
            const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

            let targetName = '';
            let categories = [];

            if (isContestAvg) {
                targetName = 'Contest Average';
                categories = generateContestAverageComparison(state.comparisonAvgView);
            } else {
                const targetVoter = state.contestVoters.find(v => v.userId === targetId);
                targetName = targetVoter ? targetVoter.username : 'Unknown';
                const data = generateUserVsUserComparison(targetId);
                categories = state.comparisonDetailView === 'match' ? data.matchBased : data.relativeBased;
            }

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="flex items-center gap-3 mb-4 flex-wrap">
                            <button onclick="backFromComparisonDetail()" class="px-3 py-1 rounded-lg bg-gray-200 hover:bg-gray-300 text-sm font-medium transition flex items-center gap-1">
                                <span>‚Üê</span> Back to comparison
                            </button>
                            <h2 class="text-lg font-bold text-gray-800">${selectedName} vs ${isContestAvg ? 'üìä ' : ''}${targetName}</h2>
                        </div>

                        ${isContestAvg ? `
                            <div class="flex items-center gap-2 mb-4">
                                <label class="text-xs font-medium text-gray-700">View:</label>
                                <button onclick="setComparisonAvgView('match')" class="px-3 py-1 rounded-lg text-xs font-medium ${state.comparisonAvgView === 'match' ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Match-based</button>
                                <button onclick="setComparisonAvgView('relative')" class="px-3 py-1 rounded-lg text-xs font-medium ${state.comparisonAvgView === 'relative' ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Relative</button>
                            </div>
                        ` : `
                            <div class="flex items-center gap-2 mb-4">
                                <label class="text-xs font-medium text-gray-700">View:</label>
                                <button onclick="setComparisonDetailView('match')" class="px-3 py-1 rounded-lg text-xs font-medium ${state.comparisonDetailView === 'match' ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Match-based</button>
                                <button onclick="setComparisonDetailView('relative')" class="px-3 py-1 rounded-lg text-xs font-medium ${state.comparisonDetailView === 'relative' ? 'bg-mauve-400 text-white' : 'bg-gray-200 text-gray-800'}">Relative</button>
                            </div>
                        `}

                        <div class="mb-4 max-w-md">
                            <div class="flex items-center gap-2">
                                <label class="text-xs font-medium text-gray-700 whitespace-nowrap">Image Scale:</label>
                                <button onclick="adjustScale(-1)" class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition">‚àí</button>
                                <input type="range" min="20" max="250" value="${state.imageScale}" oninput="updateScale(this.value)" class="flex-1 h-2 bg-gray-200 rounded-lg cursor-pointer" />
                                <button onclick="adjustScale(1)" class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition">+</button>
                                <span class="text-xs font-medium text-gray-700 w-10">${state.imageScale}%</span>
                            </div>
                        </div>

                        ${renderImageFilterDropdown()}

                        <div style="overflow-y: auto;">
                            ${isContestAvg ? renderContestAvgCategories(categories, imageSize, fontSize) : renderUserVsUserCategories(categories, imageSize, fontSize)}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderComparisonCategories(categories, imageSize, fontSize, showRange) {
            const imageFilterIds = getFilteredImageIds();
            const breakdownFn = state.currentMergerId ? 'showBreakdownMerged' : 'showBreakdown';
            const isDark = document.body.classList.contains('dark-theme');
            return categories.map(cat => {
                const allItems = cat.items || [];
                const visibleItems = imageFilterIds !== null ? allItems.filter(item => imageFilterIds.has(item.imageId)) : allItems;
                const hiddenCount = allItems.length - visibleItems.length;
                if (visibleItems.length === 0 && hiddenCount === 0) return '';
                const collapsed = !!state.comparisonDetailCollapsed[cat.key];
                const catBgColor = cat.color;

                return `
                    <div class="mb-4">
                        <h3 class="text-sm font-bold mb-1 px-3 py-2 rounded-lg w-full flex items-center gap-1 cursor-pointer select-none comparison-cat-header" style="background-color: ${catBgColor};" onclick="toggleComparisonDetailSection('${cat.key}')">
                            <svg class="inline-block transition-transform duration-200 ${collapsed ? '' : 'rotate-90'} w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg> ${cat.label}${showRange && cat.range ? ` <span class="text-xs font-normal">(${cat.range})</span>` : ''}
                            <span class="text-xs font-normal ml-auto">Count: ${visibleItems.length}${hiddenCount > 0 ? ` <span class="opacity-70">(${hiddenCount} more hidden)</span>` : ''}</span>
                        </h3>
                        ${!collapsed ? `
                            <div class="space-y-2">
                                ${(cat.subcategories || []).map((sc, scIndex) => {
                                    const scVisibleItems = imageFilterIds !== null ? sc.items.filter(item => imageFilterIds.has(item.imageId)) : sc.items;
                                    const scHidden = sc.items.length - scVisibleItems.length;
                                    if (scVisibleItems.length === 0 && scHidden === 0) return '';
                                    const scCollapsed = !!state.comparisonDetailCollapsed[sc.key];
                                    // Gradual shade variation: in dark theme, get lighter; in light theme, get darker
                                    const totalSubs = cat.subcategories.length;
                                    const shadeStep = totalSubs > 1 ? (scIndex / (totalSubs - 1)) * 0.15 : 0;
                                    const subOpacity = isDark ? (0.85 + shadeStep) : (0.85 - shadeStep);
                                    return `
                                        <div class="flex items-stretch gap-2">
                                            <div class="w-16 flex-shrink-0 rounded-lg flex items-center justify-center text-xs font-bold shadow-lg px-1 py-2 cursor-pointer select-none comparison-cat-header" style="background-color: ${catBgColor}; opacity: ${subOpacity};" onclick="toggleComparisonDetailSection('${sc.key}')">
                                                <svg class="inline-block transition-transform duration-200 ${scCollapsed ? '' : 'rotate-90'} w-3 h-3 mr-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
                                                <div class="text-center leading-tight">${sc.label}<br><span class="font-normal text-[10px]">(${scVisibleItems.length}${scHidden > 0 ? `+${scHidden}` : ''})</span></div>
                                            </div>
                                            ${!scCollapsed ? `
                                                <div class="flex-1 flex flex-wrap gap-1 items-start">
                                                    ${scVisibleItems.map(item => `
                                                        <div onclick="${breakdownFn}(${item.imageId})" class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative" style="height: ${imageSize}px;">
                                                            <img src="${item.url}" alt="Image" class="h-full w-auto object-cover" style="height: ${imageSize}px;" />
                                                            <div class="absolute bottom-0 left-0 right-0 text-white text-center py-0.5 font-bold score-text" style="font-size: ${fontSize}px;">
                                                                ${item.averageScore}
                                                            </div>
                                                        </div>
                                                    `).join('')}
                                                </div>
                                            ` : '<div class="flex-1"></div>'}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        function renderContestAvgCategories(categories, imageSize, fontSize) {
            return renderComparisonCategories(categories, imageSize, fontSize, true);
        }

        function renderUserVsUserCategories(categories, imageSize, fontSize) {
            return renderComparisonCategories(categories, imageSize, fontSize, false);
        }

        // ==================== DIVISIVE BREAKDOWN MODAL ====================
        function renderDivisiveBreakdownModal() {
            const item = state.results.find(r => r.id === state.showBreakdownModal);
            if (!item) return '';

            const userFilterIds = getFilteredUserIds();
            const isFiltered = isUserFilterActive();

            const scores = item.breakdown.filter(v => !v.isBlocked && !v.isBanned && (userFilterIds === null || userFilterIds.has(v.userId))).map(v => v.score);
            const sd = calculateSD(scores);
            const avg = scores.length > 0 ? (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2) : 0;

            const voteCounts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
            scores.forEach(s => { voteCounts[s]++; });
            const maxVotes = Math.max(...Object.values(voteCounts), 1);

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-lg w-full max-h-[90vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Divisive Breakdown${isFiltered ? ' <span class="text-mauve-500 text-base" title="Filtered by user selection">*</span>' : ''}</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                                </button>
                            </div>
                        </div>
                        <div class="overflow-y-auto flex-1 p-4">
                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 300px;">
                                <img src="${item.url}" alt="Image" class="max-w-full max-h-[300px] object-contain" />
                            </div>
                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="flex justify-center gap-6">
                                    <div class="text-center">
                                        <div class="text-2xl font-bold text-gray-400">${avg}</div>
                                        <div class="text-xs text-gray-400">Average Score</div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-2xl font-bold" style="color: ${sd >= 1.5 ? '#ef4444' : sd >= 1.0 ? '#eab308' : '#22c55e'};">${sd.toFixed(2)}</div>
                                        <div class="text-xs text-gray-400">Std Deviation</div>
                                    </div>
                                </div>
                            </div>
                            <div class="space-y-2">
                                ${[5, 4, 3, 2, 1].map(score => {
                                    const count = voteCounts[score];
                                    const width = maxVotes > 0 ? (count / maxVotes) * 100 : 0;
                                    const stars = '‚òÖ'.repeat(score) + '‚òÜ'.repeat(5 - score);
                                    return `
                                        <div class="flex items-center gap-2">
                                            <span class="text-sm w-20 text-right" style="color: ${getScoreColor(score)};">${stars}</span>
                                            <div class="flex-1 bg-gray-200 rounded-full h-5 relative">
                                                <div class="h-5 rounded-full transition-all" style="width: ${width}%; background-color: ${getScoreColor(score)};"></div>
                                            </div>
                                            <span class="text-sm font-bold w-8 text-gray-700">${count}</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            <div class="mt-3 text-center text-xs text-gray-500">${scores.length} total votes</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderDivisiveBreakdownModalMerged() {
            if (!state.mergedResults || !state.mergedResults.images) return '';
            const item = state.mergedResults.images.find(img => img.id === state.showBreakdownModal);
            if (!item) return '';

            const userFilterIds = getFilteredUserIds();
            const isFiltered = isUserFilterActive();

            const scores = (item.voteBreakdown || []).filter(v => !v.isBlocked && !v.isBanned && (userFilterIds === null || userFilterIds.has(v.userId))).map(v => v.score);
            const sd = calculateSD(scores);
            const avg = scores.length > 0 ? (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2) : 0;

            const voteCounts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
            scores.forEach(s => { voteCounts[s]++; });
            const maxVotes = Math.max(...Object.values(voteCounts), 1);

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-lg w-full max-h-[90vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Divisive Breakdown${isFiltered ? ' <span class="text-mauve-500 text-base" title="Filtered by user selection">*</span>' : ''}</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                                </button>
                            </div>
                        </div>
                        <div class="overflow-y-auto flex-1 p-4">
                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 300px;">
                                <img src="${item.url}" alt="Image" class="max-w-full max-h-[300px] object-contain" />
                            </div>
                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="flex justify-center gap-6">
                                    <div class="text-center">
                                        <div class="text-2xl font-bold text-gray-400">${avg}</div>
                                        <div class="text-xs text-gray-400">Average Score</div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-2xl font-bold" style="color: ${sd >= 1.5 ? '#ef4444' : sd >= 1.0 ? '#eab308' : '#22c55e'};">${sd.toFixed(2)}</div>
                                        <div class="text-xs text-gray-400">Std Deviation</div>
                                    </div>
                                </div>
                            </div>
                            <div class="space-y-2">
                                ${[5, 4, 3, 2, 1].map(score => {
                                    const count = voteCounts[score];
                                    const width = maxVotes > 0 ? (count / maxVotes) * 100 : 0;
                                    const stars = '‚òÖ'.repeat(score) + '‚òÜ'.repeat(5 - score);
                                    return `
                                        <div class="flex items-center gap-2">
                                            <span class="text-sm w-20 text-right" style="color: ${getScoreColor(score)};">${stars}</span>
                                            <div class="flex-1 bg-gray-200 rounded-full h-5 relative">
                                                <div class="h-5 rounded-full transition-all" style="width: ${width}%; background-color: ${getScoreColor(score)};"></div>
                                            </div>
                                            <span class="text-sm font-bold w-8 text-gray-700">${count}</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            <div class="mt-3 text-center text-xs text-gray-500">${scores.length} total votes</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderBreakdownModal() {
            const item = state.results.find(r => r.id === state.showBreakdownModal);
            if (!item) return '';

            const userFilterIds = getFilteredUserIds();
            const isFiltered = isUserFilterActive();

            const votesByScore = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            item.breakdown.forEach(vote => {
                if (userFilterIds === null || userFilterIds.has(vote.userId)) {
                    votesByScore[vote.score].push(vote);
                }
            });

            Object.keys(votesByScore).forEach(score => {
                votesByScore[score].sort((a, b) => a.username.localeCompare(b.username));
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[85vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Vote Breakdown${isFiltered ? ' <span class="text-mauve-500 text-base" title="Filtered by user selection">*</span>' : ''}</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="overflow-y-auto flex-1 p-4">

                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 400px;">
                                <img
                                    src="${item.url}"
                                    alt="Image"
                                    class="max-w-full max-h-[400px] object-contain"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                            </div>

                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-gray-400">${item.averageScore}</div>
                                    <div class="text-xs text-gray-400">Average Score</div>
                                    <div class="text-xs text-gray-500 mt-1">${item.totalVotes} total votes</div>
                                </div>
                            </div>

                            <div class="space-y-3">
                                ${[5, 4, 3, 2, 1].map(score => `
                                    <div>
                                        <h4 class="text-sm font-bold mb-2 px-3 py-1 rounded-lg inline-block" style="color: ${getScoreColor(score)}; background-color: ${getScoreColor(score)}20;">
                                            Score ${score} (${votesByScore[score].length} ${votesByScore[score].length === 1 ? 'vote' : 'votes'})
                                        </h4>
                                        ${votesByScore[score].length > 0 ? `
                                            <div class="grid grid-cols-1 gap-2 mt-2">
                                                ${votesByScore[score].map(vote => {
                                                    const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                                                    return `
                                                    <div class="flex items-center gap-2 p-2 rounded-lg ${
                                                        vote.isBanned ? 'bg-red-100 opacity-60' :
                                                        vote.isBlocked ? 'bg-gray-300' :
                                                        vote.isCurrentUser ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'
                                                    }">
                                                        <img src="${vote.avatar}" alt="${vote.username}" class="w-8 h-8 rounded-full flex-shrink-0 ${vote.isBanned ? 'opacity-50' : ''} cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');" />
                                                        <span class="text-sm flex-1 truncate cursor-pointer ${
                                                            vote.isBanned ? 'line-through text-red-600' :
                                                            vote.isBlocked ? 'line-through text-gray-700' :
                                                            'text-gray-700 hover:text-mauve-600'
                                                        }" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');">
                                                            ${vote.username}${vote.isCurrentUser ? ' (You)' : ''}${vote.isBanned ? ' (BANNED)' : ''}
                                                        </span>
                                                        ${isAdmin ? `
                                                            <button
                                                                onclick="adminEditVote('${vote.userId}', ${item.id}, ${score})"
                                                                class="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-xs"
                                                                title="Edit vote"
                                                            >
                                                                ‚úèÔ∏è
                                                            </button>
                                                            <button
                                                                onclick="adminToggleBlockVote('${vote.userId}', ${item.id}, ${vote.isBlocked || false})"
                                                                class="px-2 py-1 ${vote.isBlocked ? 'bg-green-500 hover:bg-green-600' : 'bg-red-500 hover:bg-red-600'} text-white rounded text-xs"
                                                                title="${vote.isBlocked ? 'Unblock vote' : 'Block vote'}"
                                                            >
                                                                ${vote.isBlocked ? '‚úì' : 'üö´'}
                                                            </button>
                                                        ` : ''}
                                                    </div>
                                                `}).join('')}
                                            </div>
                                        ` : `
                                            <div class="text-gray-400 italic text-sm mt-2 ml-3">No votes</div>
                                        `}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAdminDashboard() {
            if (!state.showAdminDashboard) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get banned users info
            const bannedUsersInfo = state.bannedUsers.map(userId => {
                // Try to find user info from contests
                const contest = state.contests.find(c => c.createdBy === userId);
                if (contest) {
                    return {
                        id: userId,
                        username: contest.creatorName,
                        avatar: contest.creatorAvatar
                    };
                }
                // Fallback
                return {
                    id: userId,
                    username: 'User' + userId.substring(0, 4),
                    avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${userId}`
                };
            });

            // Calculate admin statistics
            const totalContests = state.contests.length;
            const totalVotes = state.adminStats.totalVotes;
            const totalUniqueVoters = state.adminStats.totalUniqueVoters;
            const totalBannedUsers = state.bannedUsers.length;
            const totalImages = state.contests.reduce((sum, contest) => sum + (contest.images?.length || 0), 0);

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-50 p-4" onclick="event.target === this && closeAdminDashboard()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-3xl w-full max-h-[90vh] overflow-y-auto modal-content" onclick="event.stopPropagation()">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-2xl font-bold text-gray-800">Admin Dashboard</h3>
                                <button onclick="closeAdminDashboard()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>

                            ${state.adminDashboardLoading ? `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">‚è≥</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">Loading Dashboard...</h3>
                                    <p class="text-gray-600">Please wait while we fetch the statistics.</p>
                                </div>
                            ` : `
                            <div class="space-y-4">
                                <div class="bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg p-4 border border-purple-200">
                                    <div class="flex justify-between items-center mb-3">
                                        <h4 class="font-bold text-gray-800">Statistics</h4>
                                        <button onclick="showActivityLogs()" class="bg-mauve-500 text-white px-4 py-2 rounded-lg text-sm font-semibold hover:bg-mauve-600 transition shadow-lg">
                                            üìä Recent Activity
                                        </button>
                                    </div>
                                    <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-purple-600">${totalContests}</div>
                                            <div class="text-xs text-gray-600">Total Contests</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-blue-600">${totalVotes}</div>
                                            <div class="text-xs text-gray-600">Total Votes</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-green-600">${totalUniqueVoters}</div>
                                            <div class="text-xs text-gray-600">Unique Voters</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-orange-600">${totalImages}</div>
                                            <div class="text-xs text-gray-600">Total Images</div>
                                        </div>
                                    </div>
                                </div>

                                <div class="bg-blue-50 rounded-lg p-4 border border-blue-200">
                                    <div class="flex items-center gap-2 mb-3">
                                        <h4 class="font-bold text-blue-800">üë• All Users</h4>
                                        ${totalBannedUsers > 0 ? `<span class="bg-red-500 text-white text-xs font-bold px-2 py-1 rounded">${totalBannedUsers} banned</span>` : ''}
                                    </div>
                                    ${state.allUsers.length > 0 ? `
                                        <div class="space-y-2 max-h-96 overflow-y-auto">
                                            ${[...state.allUsers].sort((a, b) => a.username.localeCompare(b.username)).map(user => {
                                                const isBanned = state.bannedUsers.includes(user.id);
                                                return `
                                                    <div class="flex items-center justify-between p-3 bg-white rounded-lg ${isBanned ? 'opacity-50' : ''}">
                                                        <div class="flex items-center gap-3">
                                                            <img src="${user.avatar}" alt="${user.username}" class="w-10 h-10 rounded-full cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${user.id}');" />
                                                            <div>
                                                                <div class="font-semibold text-gray-800 cursor-pointer hover:text-mauve-600 transition" onclick="event.stopPropagation(); viewUserProfile('${user.id}');">${user.username}</div>
                                                                <div class="text-xs text-gray-500">${user.id}</div>
                                                                ${isBanned ? '<span class="text-xs text-red-600 font-semibold">BANNED</span>' : ''}
                                                            </div>
                                                        </div>
                                                        ${isBanned ? `
                                                            <button onclick="unbanUser('${user.id}')" class="bg-green-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-green-600 transition text-sm">
                                                                Unban
                                                            </button>
                                                        ` : `
                                                            <button onclick="confirmBanUser('${user.id}')" class="bg-red-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-red-600 transition text-sm">
                                                                Ban
                                                            </button>
                                                        `}
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : '<p class="text-sm text-gray-500 italic">No users have logged in yet</p>'}
                                </div>
                            </div>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAppSettingsModal() {
            if (!state.showAppSettingsModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get current settings values (default to true if not set)
            const contestCreationEnabled = state.appSettings.contest_creation_enabled !== false;
            const revotingEnabled = state.appSettings.revoting_enabled !== false;
            const showPinIcons = state.appSettings.show_pin_icons === true;  // Default to false

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeAppSettings()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full modal-content" onclick="event.stopPropagation()">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h3 class="text-2xl font-bold text-gray-800">App Settings</h3>
                                <button onclick="closeAppSettings()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>

                            <div class="space-y-6">
                                <!-- Contest Creation Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Contest Creation</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Allow users to create new contests
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${contestCreationEnabled ? 'active' : ''}"
                                        onclick="toggleAppSetting('contest_creation_enabled')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <!-- Revoting Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Revoting</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Allow users to change their votes after submission
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${revotingEnabled ? 'active' : ''}"
                                        onclick="toggleAppSetting('revoting_enabled')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <!-- Show Pin Icons Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Show Pin Icons</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Display pin/unpin buttons on cards (admin only)
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${showPinIcons ? 'active' : ''}"
                                        onclick="toggleAppSetting('show_pin_icons')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <p class="text-sm text-blue-800">
                                        üí° <strong>Note:</strong> These settings affect all users globally. Disabled features will show informative messages to users.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderActivityLogsModal() {
            if (!state.showActivityLogsModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Helper function to format timestamp with exact date and time
            const formatTimestamp = (timestamp) => {
                const date = new Date(timestamp);
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = months[date.getMonth()];
                const day = date.getDate();
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${month} ${day}, ${hours}:${minutes}`;
            };

            // Get event type styling
            const getEventStyle = (type) => {
                switch(type) {
                    case 'contest':
                        return { bg: 'bg-green-100', hover: 'hover:bg-green-200', icon: 'üèÜ', text: 'Created contest' };
                    case 'merger':
                        return { bg: 'bg-blue-100', hover: 'hover:bg-blue-200', icon: 'üîÄ', text: 'Created merger' };
                    case 'extract':
                        return { bg: 'bg-yellow-100', hover: 'hover:bg-yellow-200', icon: '‚úÇÔ∏è', text: 'Created extract' };
                    case 'signup':
                        return { bg: 'bg-purple-100', hover: 'hover:bg-purple-200', icon: 'üë§', text: 'Joined the app' };
                    case 'vote_completed':
                        return { bg: 'bg-yellow-50', hover: 'hover:bg-yellow-100', icon: '‚úÖ', text: 'Completed voting on' };
                    default: // vote (partial)
                        return { bg: 'bg-gray-100', hover: 'hover:bg-gray-200', icon: 'üó≥Ô∏è', text: 'Voted on' };
                }
            };

            // Calculate date range (use state dates or default to last 7 days)
            const now = new Date();
            let weekStart, weekEnd;

            if (state.activityDateStart && state.activityDateEnd) {
                weekStart = new Date(state.activityDateStart);
                weekEnd = new Date(state.activityDateEnd);
            } else {
                weekStart = new Date(now);
                weekStart.setDate(now.getDate() - 7);
                weekEnd = new Date(now);
            }

            // Format date for input fields (YYYY-MM-DD)
            const formatDateInput = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const startDateInput = state.activityDateStart || formatDateInput(weekStart);
            const endDateInput = state.activityDateEnd || formatDateInput(weekEnd);

            const formatDate = (date) => {
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${months[date.getMonth()]} ${date.getDate()}`;
            };
            const weekRange = `${formatDate(weekStart)} - ${formatDate(weekEnd)}, ${weekEnd.getFullYear()}`;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeActivityLogs()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden modal-content flex flex-col" onclick="event.stopPropagation()">
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-2xl font-bold text-gray-800">üìä Recent Activity</h3>
                                <button onclick="closeActivityLogs()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="flex flex-wrap gap-3 items-end">
                                <div class="flex-1 min-w-[140px]">
                                    <label class="block text-xs font-semibold text-gray-600 mb-1">Start Date</label>
                                    <input
                                        type="date"
                                        id="activityStartDate"
                                        value="${startDateInput}"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-mauve-400 focus:border-mauve-400"
                                        onchange="setActivityStartDate(this.value)"
                                    />
                                </div>
                                <div class="flex-1 min-w-[140px]">
                                    <label class="block text-xs font-semibold text-gray-600 mb-1">End Date</label>
                                    <input
                                        type="date"
                                        id="activityEndDate"
                                        value="${endDateInput}"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-mauve-400 focus:border-mauve-400"
                                        onchange="setActivityEndDate(this.value)"
                                    />
                                </div>
                                <button
                                    onclick="loadActivityLogs()"
                                    class="bg-mauve-500 text-white px-4 py-2 rounded-lg text-sm font-semibold hover:bg-mauve-600 transition shadow-md disabled:opacity-50 disabled:cursor-not-allowed"
                                    ${state.activityLogsLoading ? 'disabled' : ''}
                                >
                                    ${state.activityLogsLoading ? '‚è≥ Loading...' : 'üîÑ Refresh'}
                                </button>
                            </div>
                            <div class="flex flex-wrap gap-3 items-center mt-3">
                                <div class="flex-1 min-w-[120px]">
                                    <label class="block text-xs font-semibold text-gray-600 mb-1">Filter by User</label>
                                    <select
                                        onchange="setActivityFilterUser(this.value)"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-mauve-400 focus:border-mauve-400"
                                    >
                                        <option value="">All Users</option>
                                        ${(() => {
                                            const uniqueUsers = new Map();
                                            state.activityLogs.forEach(log => {
                                                if (!uniqueUsers.has(log.userId)) {
                                                    uniqueUsers.set(log.userId, {
                                                        userId: log.userId,
                                                        username: log.username
                                                    });
                                                }
                                            });
                                            return Array.from(uniqueUsers.values())
                                                .sort((a, b) => a.username.localeCompare(b.username))
                                                .map(user => `
                                                    <option value="${user.userId}" ${state.activityFilterUser === user.userId ? 'selected' : ''}>
                                                        ${user.username}
                                                    </option>
                                                `).join('');
                                        })()}
                                    </select>
                                </div>
                                <div class="flex-1 min-w-[120px]">
                                    <label class="block text-xs font-semibold text-gray-600 mb-1">Filter by Contest</label>
                                    <select
                                        onchange="setActivityFilterContest(this.value)"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-mauve-400 focus:border-mauve-400"
                                    >
                                        <option value="">All Contests</option>
                                        ${(() => {
                                            const uniqueContests = new Map();
                                            state.activityLogs.forEach(log => {
                                                if (log.contestId && !uniqueContests.has(log.contestId)) {
                                                    uniqueContests.set(log.contestId, {
                                                        contestId: log.contestId,
                                                        contestTitle: log.contestTitle
                                                    });
                                                }
                                            });
                                            return Array.from(uniqueContests.values())
                                                .sort((a, b) => a.contestTitle.localeCompare(b.contestTitle))
                                                .map(contest => `
                                                    <option value="${contest.contestId}" ${state.activityFilterContest == contest.contestId ? 'selected' : ''}>
                                                        ${contest.contestTitle}
                                                    </option>
                                                `).join('');
                                        })()}
                                    </select>
                                </div>
                                <div class="flex-1 min-w-[120px]">
                                    <label class="block text-xs font-semibold text-gray-600 mb-1">Filter by Action</label>
                                    <select
                                        onchange="setActivityFilterAction(this.value)"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-mauve-400 focus:border-mauve-400"
                                    >
                                        <option value="">All Actions</option>
                                        <option value="vote" ${state.activityFilterAction === 'vote' ? 'selected' : ''}>Voted On</option>
                                        <option value="created" ${state.activityFilterAction === 'created' ? 'selected' : ''}>Created</option>
                                        <option value="signup" ${state.activityFilterAction === 'signup' ? 'selected' : ''}>Joined</option>
                                    </select>
                                </div>
                            </div>
                            <p class="text-xs text-gray-500 mt-3">Showing activity from ${weekRange}</p>
                        </div>

                        <div class="p-6 overflow-y-auto flex-1">
                            ${state.activityLogsLoading ? `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">‚è≥</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">Loading Activity...</h3>
                                    <p class="text-gray-600">Please wait while we fetch the activity logs.</p>
                                </div>
                            ` : state.activityLogs.length > 0 ? `
                                <div class="space-y-1">
                                    ${(() => {
                                        // Apply filters to activity logs
                                        let filteredLogs = state.activityLogs;

                                        // Filter by user
                                        if (state.activityFilterUser) {
                                            filteredLogs = filteredLogs.filter(log => log.userId === state.activityFilterUser);
                                        }

                                        // Filter by contest
                                        if (state.activityFilterContest) {
                                            filteredLogs = filteredLogs.filter(log => log.contestId == state.activityFilterContest);
                                        }

                                        // Filter by action type
                                        if (state.activityFilterAction) {
                                            if (state.activityFilterAction === 'created') {
                                                // "Created" includes contests, mergers, and extracts
                                                filteredLogs = filteredLogs.filter(log =>
                                                    log.type === 'contest' || log.type === 'merger' || log.type === 'extract'
                                                );
                                            } else {
                                                filteredLogs = filteredLogs.filter(log => log.type === state.activityFilterAction);
                                            }
                                        }

                                        if (filteredLogs.length === 0) {
                                            return `
                                                <div class="text-center py-12">
                                                    <div class="text-6xl mb-4">üîç</div>
                                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Results</h3>
                                                    <p class="text-gray-600">No activity matches the selected filters.</p>
                                                </div>
                                            `;
                                        }

                                        return filteredLogs.map(log => {
                                        const style = getEventStyle(log.type);
                                        const isSignup = log.type === 'signup';
                                        const isCreation = log.type !== 'vote' && log.type !== 'vote_completed' && log.type !== 'signup';
                                        const itemName = isCreation ? log.itemName : log.contestTitle;

                                        return `
                                            <div class="flex items-center gap-2 p-2 ${style.bg} rounded-lg ${style.hover} transition">
                                                <div class="text-lg flex-shrink-0">
                                                    ${style.icon}
                                                </div>
                                                <img
                                                    src="${log.avatar}"
                                                    alt="${log.username}"
                                                    class="w-6 h-6 rounded-full cursor-pointer hover:ring-2 hover:ring-mauve-400 transition flex-shrink-0"
                                                    onclick="event.stopPropagation(); viewUserProfile('${log.userId}');"
                                                />
                                                <div class="flex-1 min-w-0">
                                                    <div class="text-sm">
                                                        <span
                                                            class="font-semibold text-gray-800 cursor-pointer hover:text-mauve-600 transition"
                                                            onclick="event.stopPropagation(); viewUserProfile('${log.userId}');"
                                                        >
                                                            ${log.username}
                                                        </span>
                                                        <span class="text-gray-600">
                                                            ${isSignup ? style.text.toLowerCase() : `${style.text.toLowerCase()}: <span class="font-medium">${itemName}</span>`}
                                                        </span>
                                                    </div>
                                                </div>
                                                                <div class="text-xs text-gray-500 flex-shrink-0 sm:text-right">
                                                    <div class="sm:inline">${formatTimestamp(log.timestamp).split(', ')[0]},</div>
                                                    <div class="sm:inline sm:ml-1">${formatTimestamp(log.timestamp).split(', ')[1]}</div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('');
                                    })()}
                                </div>
                            ` : `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">üì≠</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Recent Activity</h3>
                                    <p class="text-gray-600">No activity recorded this week yet.</p>
                                </div>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderManageFoldersModal() {
            if (!state.showManageFoldersModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get all items that are already in folders
            const itemsInFolders = new Set();
            state.groups.forEach(group => {
                (group.items || []).forEach(item => {
                    itemsInFolders.add(`${item.item_type}:${item.item_id}`);
                });
            });

            // Calculate ungrouped items count
            const allItems = [...state.contests.map(c => ({ itemType: 'contest', id: c.id })),
                            ...state.mergers.map(m => ({ itemType: 'merger', id: m.id })),
                            ...state.extracts.map(e => ({ itemType: 'extract', id: e.id }))];
            const ungroupedItemsCount = allItems.filter(item =>
                !itemsInFolders.has(`${item.itemType}:${item.id}`)
            ).length;

            // Get unfoldered items position from app settings (default to bottom if not set)
            const unfolderedPosition = state.appSettings.unfoldered_items_position !== undefined
                ? parseInt(state.appSettings.unfoldered_items_position)
                : state.groups.length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeManageFoldersModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden modal-content flex flex-col" onclick="event.stopPropagation()">
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex justify-between items-center">
                                <h3 class="text-2xl font-bold text-gray-800">üìÅ Manage Folders</h3>
                                <button onclick="closeManageFoldersModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="p-6 overflow-y-auto flex-1">
                            <div class="mb-6">
                                <button onclick="showCreateFolderModal()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg">
                                    + Create New Folder
                                </button>
                            </div>

                            ${state.groups.length === 0 && ungroupedItemsCount === 0 ? `
                                <div class="text-center py-8 text-gray-500">
                                    <p class="text-lg mb-2">No folders yet</p>
                                    <p class="text-sm">Create a folder to organize your contests, mergers, and extracts</p>
                                </div>
                            ` : `
                                <div class="space-y-4" id="folders-list">
                                    ${(() => {
                                        // Build the sorted list with unfoldered items meta-item
                                        const items = [];
                                        state.groups.forEach((group, index) => {
                                            items.push({ type: 'folder', data: group, originalIndex: index });
                                        });
                                        // Insert unfoldered items meta-item at the specified position
                                        items.splice(unfolderedPosition, 0, { type: 'unfoldered', data: null });

                                        return items.map((item, index) => {
                                            if (item.type === 'unfoldered') {
                                                return `
                                                    <div class="border border-gray-300 rounded-lg overflow-hidden bg-gradient-to-r from-gray-100 to-gray-200" data-unfoldered="true">
                                                        <div class="bg-gray-100 p-4 flex items-center gap-3">
                                                            <div class="cursor-move text-gray-400 hover:text-gray-600">
                                                                ‚ãÆ‚ãÆ
                                                            </div>
                                                            <div class="flex-1">
                                                                <h4 class="font-semibold text-gray-700 flex items-center gap-2">
                                                                    <span>üìã</span>
                                                                    <span>Unfoldered Items</span>
                                                                </h4>
                                                                <p class="text-sm text-gray-600">${ungroupedItemsCount} items (not draggable within)</p>
                                                            </div>
                                                            <span class="text-xs text-gray-500 italic">Special Section</span>
                                                        </div>
                                                    </div>
                                                `;
                                            } else {
                                                const group = item.data;
                                                const isExpanded = state.expandedFolderIds.includes(group.id);
                                                return `
                                                    <div class="border border-gray-300 rounded-lg overflow-hidden" data-folder-id="${group.id}">
                                                        <div class="bg-gray-50 p-4 flex items-center gap-3">
                                                            <div class="cursor-move text-gray-400 hover:text-gray-600">
                                                                ‚ãÆ‚ãÆ
                                                            </div>
                                                            <button onclick="event.stopPropagation(); toggleFolderExpanded('${group.id}')" class="text-gray-600 hover:text-gray-800 transition">
                                                                <svg class="w-5 h-5 transition-transform ${isExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                                </svg>
                                                            </button>
                                                            <div class="flex-1">
                                                                <h4 class="font-semibold text-gray-800">${group.name}</h4>
                                                                <p class="text-sm text-gray-600">${(group.items || []).length} items</p>
                                                            </div>
                                                            <button onclick="addItemToFolder('${group.id}')" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 text-sm">
                                                                + Add Item
                                                            </button>
                                                            <button onclick="deleteFolder('${group.id}')" class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600 text-sm">
                                                                Delete
                                                            </button>
                                                        </div>
                                                        ${isExpanded && (group.items || []).length > 0 ? `
                                                            <div class="p-4 bg-white space-y-2" id="folder-items-${group.id}" data-folder-id="${group.id}">
                                                                ${(group.items || []).map(item => {
                                                                    // Find the actual item
                                                                    let itemData = null;
                                                                    let itemTitle = 'Unknown';
                                                                    if (item.item_type === 'contest') {
                                                                        itemData = state.contests.find(c => c.id === item.item_id);
                                                                        itemTitle = itemData?.title || 'Unknown Contest';
                                                                    } else if (item.item_type === 'merger') {
                                                                        itemData = state.mergers.find(m => m.id === item.item_id);
                                                                        itemTitle = itemData?.name || 'Unknown Merger';
                                                                    } else if (item.item_type === 'extract') {
                                                                        itemData = state.extracts.find(e => e.id === item.item_id);
                                                                        itemTitle = itemData?.name || 'Unknown Extract';
                                                                    }

                                                                    return `
                                                                        <div class="flex items-center gap-3 p-2 bg-gray-50 rounded">
                                                                            <div class="cursor-move text-gray-400 hover:text-gray-600 text-xs">
                                                                                ‚ãÆ‚ãÆ
                                                                            </div>
                                                                            <div class="flex-1">
                                                                                <span class="text-sm font-medium text-gray-800">${itemTitle}</span>
                                                                                <span class="text-xs text-gray-500 ml-2">[${item.item_type.toUpperCase()}]</span>
                                                                            </div>
                                                                            <button onclick="removeItemFromFolder('${group.id}', '${item.item_id}', '${item.item_type}')" class="text-red-500 hover:text-red-700 text-sm">
                                                                                Remove
                                                                            </button>
                                                                        </div>
                                                                    `;
                                                                }).join('')}
                                                            </div>
                                                        ` : ''}
                                                    </div>
                                                `;
                                            }
                                        }).join('');
                                    })()}
                                </div>
                            `}

                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-6">
                                <p class="text-sm text-blue-800">
                                    üí° <strong>Note:</strong> Folders organize your contests, mergers, and extracts on the home page.
                                    Drag the "Unfoldered Items" section to position it above or below specific folders.
                                    Click the arrow to expand/collapse folders and see their items.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderMergedResults() {
            if (!state.mergedResults) {
                return '<div class="text-center p-8">No merged results available</div>';
            }

            const { contestIds, contestTitles, images } = state.mergedResults;

            // Define admin, creator, and privacy status for merged contests
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const mergedContests = state.contests.filter(c => contestIds.includes(c.id));
            const merger = state.mergers.find(m => m.id === state.currentMergerId);
            const isCreator = merger && state.user && state.user.id === merger.createdBy;
            // Check if any of the merged contests have private results
            const isPrivate = mergedContests.some(c => c.resultsPublic === false);
            const canViewPrivateResults = isAdmin || isCreator;

            // Create results structure similar to single contest
            const mergedResultsData = images.map(img => ({
                id: img.id,
                url: img.url,
                contestId: img.contestId,
                averageScore: parseFloat(img.averageScore),
                totalVotes: img.totalVotes,
                breakdown: img.voteBreakdown || []
            }));

            // Extract all voters from merged results for dropdown
            const voterSet = new Set();
            mergedResultsData.forEach(img => {
                (img.breakdown || []).forEach(vote => {
                    if (!vote.isBlocked && !vote.isBanned) {
                        voterSet.add(JSON.stringify({ userId: vote.userId, username: vote.username, avatar: vote.avatar }));
                    }
                });
            });
            const mergedVoters = Array.from(voterSet)
                .map(v => JSON.parse(v))
                .sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));

            // Temporarily set state to use existing rendering functions
            const originalResults = state.results;
            const originalVoters = state.contestVoters;
            const originalContest = state.currentContest;
            state.results = mergedResultsData;
            state.contestVoters = mergedVoters;
            // Create a temporary contest object for compatibility
            state.currentContest = {
                ...state.currentContest,
                createdBy: merger?.createdBy,
                resultsPublic: !isPrivate
            };

            // Handle comparison views for By User tab
            if (state.resultsView === 'userVotes' && state.comparisonView === 'table') {
                const content = renderComparisonTable() + (state.showBreakdownModal ? renderBreakdownModal() : '');
                // Restore original state
                state.results = originalResults;
                state.contestVoters = originalVoters;
                state.currentContest = originalContest;
                return content;
            }
            if (state.resultsView === 'userVotes' && state.comparisonView === 'detail') {
                const content = renderComparisonDetail() + (state.showBreakdownModal ? renderBreakdownModal() : '');
                // Restore original state
                state.results = originalResults;
                state.contestVoters = originalVoters;
                state.currentContest = originalContest;
                return content;
            }

            // Handle full-screen "Compare all" view for Average tab (same as contest renderResults)
            if (state.resultsView === 'byVoter' && state.averageTabCompareAll) {
                const content = renderAverageTabCompareAll();
                // Restore original state
                state.results = originalResults;
                state.contestVoters = originalVoters;
                state.currentContest = originalContest;
                return content;
            }

            const baseSize = 150;
            const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
            const baseFontSize = 12;
            const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

            // Build contest dropdown HTML for merger header
            const contestDropdownHTML = `
                <div class="mb-1">
                    <button
                        onclick="toggleMergedContestsDropdown()"
                        class="text-gray-600 text-sm hover:bg-gray-100 px-3 py-1 rounded-lg border border-gray-300 transition-colors inline-flex items-center gap-1"
                    >
                        ${contestIds.length} contest${contestIds.length !== 1 ? 's' : ''}
                        <span class="text-xs">${state.showMergedContestsDropdown ? '‚ñ≤' : '‚ñº'}</span>
                    </button>
                    ${state.showMergedContestsDropdown ? `
                        <div class="mt-2 bg-gray-50 border border-gray-300 rounded-lg px-4 py-2 text-left max-w-md mx-auto contest-list-dropdown">
                            ${contestIds.map(id => `
                                <div class="text-sm text-gray-400 py-1 contest-list-item">
                                    ‚Ä¢ ${contestTitles[id]}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;

            const mainContent = renderResultsPageCommon({
                icon: 'üéÜ',
                title: 'Final Ranking',
                customHeaderContent: contestDropdownHTML,
                subtitle: '',
                isPrivate,
                isAdmin,
                isCreator,
                imageSize,
                fontSize
            });

            // Restore original state
            state.results = originalResults;
            state.contestVoters = originalVoters;
            state.currentContest = originalContest;

            return mainContent;
        }


        function renderLogoutConfirmModal() {
            if (!state.showLogoutConfirmModal) return '';

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && cancelLogout()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 modal-content" onclick="event.stopPropagation()">
                        <div class="text-center mb-4">
                            <div class="text-5xl mb-3">üö™</div>
                            <h3 class="text-xl font-bold text-gray-800 mb-2">Confirm Logout</h3>
                            <p class="text-gray-600">Are you sure you want to logout?</p>
                        </div>
                        <div class="flex gap-3 justify-center">
                            <button
                                onclick="cancelLogout()"
                                class="px-6 py-2 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                            >
                                Cancel
                            </button>
                            <button
                                onclick="confirmLogout()"
                                class="px-6 py-2 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-red-500 to-red-600 text-white hover:from-red-600 hover:to-red-700"
                            >
                                Logout
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function render() {
            const app = document.getElementById('app');

            if (!state.isLoggedIn) {
                app.innerHTML = renderHeader() + renderLoginScreen() + renderModal() + renderUploadProgressModal() + renderToast() + renderLoadingOverlay() + renderLogoutConfirmModal();
                return;
            }

            let content = '';
            switch(state.view) {
                case 'home':
                    content = renderHome();
                    break;
                case 'createContest':
                    content = renderCreateContest();
                    break;
                case 'vote':
                    content = renderVoting();
                    break;
                case 'results':
                    content = renderResults();
                    break;
                case 'mergedResults':
                    content = renderMergedResults();
                    break;
                case 'createExtract':
                    content = renderCreateExtract();
                    break;
                case 'editExtract':
                    content = renderEditExtractModal();
                    break;
                default:
                    content = renderHome();
            }

            app.innerHTML = renderHeader() + content + renderModal() + renderContestInfoModal() + renderCreateMergerModal() + renderEditMergerModal() + renderUserProfileModal() + renderUploadProgressModal() + renderUnifiedCreateModal() + (state.showAdminDashboard ? renderAdminDashboard() : '') + (state.showAppSettingsModal ? renderAppSettingsModal() : '') + (state.showActivityLogsModal ? renderActivityLogsModal() : '') + (state.showManageFoldersModal ? renderManageFoldersModal() : '') + renderToast() + renderLoadingOverlay() + renderMultiModeLoadingModal() + renderTransitionModal() + renderLogoutConfirmModal();
        }

        window.login = login;
        window.logout = logout;
        window.cancelLogout = cancelLogout;
        window.confirmLogout = confirmLogout;
        window.startCreateContest = startCreateContest;
        window.showContestCreationDisabledModal = showContestCreationDisabledModal;
        window.showRevotingDisabledModal = showRevotingDisabledModal;
        window.showContestInfoModal = showContestInfoModal;
        window.closeContestInfoModal = closeContestInfoModal;
        window.shareContestFromModal = shareContestFromModal;
        window.handleContestTitle = handleContestTitle;
        window.confirmCreateWithDuplicateTitle = confirmCreateWithDuplicateTitle;
        window.cancelCreateContest = cancelCreateContest;
        window.confirmCancelCreate = confirmCancelCreate;
        window.openEditContestModal = openEditContestModal;
        window.cancelEditContest = cancelEditContest;
        window.confirmCancelEdit = confirmCancelEdit;
        window.addImageFromUrl = addImageFromUrl;
        window.clearUrlInput = clearUrlInput;
        window.handleFileSelect = handleFileSelect;
        window.handleDragOver = handleDragOver;
        window.handleDragLeave = handleDragLeave;
        window.handleDrop = handleDrop;
        window.removeContestImage = removeContestImage;
        window.confirmRemoveImage = confirmRemoveImage;
        window.finishCreateContest = finishCreateContest;
        window.confirmFinishCreateContest = confirmFinishCreateContest;
        window.startVoting = startVoting;
        window.viewResults = viewResults;
        window.viewLockedResults = viewLockedResults;
        window.adminViewResults = adminViewResults;
        window.adminViewMergerResults = adminViewMergerResults;
        window.adminViewExtractResults = adminViewExtractResults;
        window.startRevote = startRevote;
        window.startRevoteFromHome = startRevoteFromHome;
        window.confirmRevote = confirmRevote;
        window.confirmRevoteWithPrefill = confirmRevoteWithPrefill;
        window.toggleUserDropdown = toggleUserDropdown;
        window.shareContest = shareContest;
        window.shareMerge = shareMerge;
        window.showBreakdownMerged = showBreakdownMerged;
        window.toggleContestLock = toggleContestLock;
        window.toggleResultsPublic = toggleResultsPublic;
        window.handleVote = handleVote;
        window.navigateImage = navigateImage;
        window.jumpToImage = jumpToImage;
        window.cancelVoting = cancelVoting;
        window.submitVotes = submitVotes;
        window.showBreakdown = showBreakdown;
        window.closeBreakdown = closeBreakdown;
        window.backToHome = backToHome;
        window.confirmBackToHome = confirmBackToHome;
        window.closeModal = closeModal;
        window.closeUploadProgress = closeUploadProgress;
        window.retryUpload = retryUpload;
        window.cancelAllUploads = cancelAllUploads;
        window.updateScale = updateScale;
        window.adjustScale = adjustScale;
        window.confirmSubmitVotes = confirmSubmitVotes;
        window.confirmCancelVoting = confirmCancelVoting;
        window.toggleVoteView = toggleVoteView;
        window.toggleVotingMode = toggleVotingMode;
        window.toggleFilters = toggleFilters;
        window.toggleScoreSelection = toggleScoreSelection;
        window.voteImageMulti = voteImageMulti;
        window.updateMultiVotingImageScale = updateMultiVotingImageScale;
        window.adjustMultiVotingImageScale = adjustMultiVotingImageScale;
        window.setMultiModeFilter = setMultiModeFilter;
        window.setMultiModeSort = setMultiModeSort;
        window.deleteContest = deleteContest;
        window.handleDeleteContestConfirmation = handleDeleteContestConfirmation;
        window.confirmDeleteContest = confirmDeleteContest;
        window.handleDeleteMergerConfirmation = handleDeleteMergerConfirmation;
        window.handleDeleteExtractConfirmation = handleDeleteExtractConfirmation;
        window.setSortBy = setSortBy;
        window.setFilterCreator = setFilterCreator;
        window.setSearchQuery = setSearchQuery;
        window.applySearch = applySearch;
        window.clearAllFilters = clearAllFilters;
        window.showAdminDashboard = showAdminDashboard;
        window.closeAdminDashboard = closeAdminDashboard;
        window.showAppSettings = showAppSettings;
        window.closeAppSettings = closeAppSettings;
        window.toggleAppSetting = toggleAppSetting;
        window.showActivityLogs = showActivityLogs;
        window.closeActivityLogs = closeActivityLogs;
        window.setActivityStartDate = setActivityStartDate;
        window.setActivityEndDate = setActivityEndDate;
        window.setActivityFilterUser = setActivityFilterUser;
        window.setActivityFilterContest = setActivityFilterContest;
        window.setActivityFilterAction = setActivityFilterAction;
        window.confirmBanUser = confirmBanUser;
        window.handleBanUserReason = handleBanUserReason;
        window.executeBanUser = executeBanUser;
        window.unbanUser = unbanUser;
        window.adminEditVote = adminEditVote;
        window.confirmEditVote = confirmEditVote;
        window.adminToggleBlockVote = adminToggleBlockVote;
        window.executeToggleBlockVote = executeToggleBlockVote;
        window.confirmAddDuplicateImage = confirmAddDuplicateImage;
        window.setResultsView = setResultsView;
        window.setVoterSortBy = setVoterSortBy;
        window.toggleCountScore = toggleCountScore;
        window.toggleMergedContestsDropdown = toggleMergedContestsDropdown;
        window.openCreateMergerModal = openCreateMergerModal;
        window.closeCreateMergerModal = closeCreateMergerModal;
        window.toggleContestForMerger = toggleContestForMerger;
        window.setMergerName = setMergerName;
        window.updateMergerNameOnBlur = updateMergerNameOnBlur;
        window.saveMerger = saveMerger;
        window.openEditMergerModal = openEditMergerModal;
        window.closeEditMergerModal = closeEditMergerModal;
        window.toggleContestForEditMerger = toggleContestForEditMerger;
        window.saveEditedMerger = saveEditedMerger;
        window.deleteMerger = deleteMerger;
        window.viewMergerResults = viewMergerResults;
        window.startMergerVoting = startMergerVoting;
        window.showMergerVoteModal = showMergerVoteModal;
        window.shareMerger = shareMerger;
        window.revoteMerge = revoteMerge;
        window.startRevoteFromHomeMerger = startRevoteFromHomeMerger;
        window.confirmRevoteMerger = confirmRevoteMerger;
        window.confirmRevoteMergerWithPrefill = confirmRevoteMergerWithPrefill;
        window.confirmRevoteAll = confirmRevoteAll;
        window.confirmVoteMissingOnly = confirmVoteMissingOnly;
        window.showContestVoteModal = showContestVoteModal;
        window.confirmContestVoteMissingOnly = confirmContestVoteMissingOnly;
        window.confirmContestRevoteAll = confirmContestRevoteAll;
        window.showExtractVotingRedirectModal = showExtractVotingRedirectModal;
        window.redirectToExtractSource = redirectToExtractSource;
        window.setExtractContestFilter = setExtractContestFilter;
        window.startContestVoting = startContestVoting;
        window.openCreateExtractModal = openCreateExtractModal;
        window.closeCreateExtractModal = closeCreateExtractModal;
        window.openUnifiedCreateModal = openUnifiedCreateModal;
        window.closeUnifiedCreateModal = closeUnifiedCreateModal;
        window.deleteExtract = deleteExtract;
        window.startExtractVoting = startExtractVoting;
        window.viewExtractResults = viewExtractResults;
        window.selectExtractSource = selectExtractSource;
        window.toggleExtractImage = toggleExtractImage;
        window.setExtractName = setExtractName;
        window.updateExtractNameOnBlur = updateExtractNameOnBlur;
        window.updateExtractImageScale = updateExtractImageScale;
        window.adjustExtractImageScale = adjustExtractImageScale;
        window.saveExtract = saveExtract;
        window.openEditExtractModal = openEditExtractModal;
        window.closeEditExtractModal = closeEditExtractModal;
        window.toggleEditExtractImage = toggleEditExtractImage;
        window.saveEditedExtract = saveEditedExtract;
        window.pinItem = pinItem;
        window.unpinItem = unpinItem;
        window.togglePin = togglePin;
        window.openManageFoldersModal = openManageFoldersModal;
        window.closeManageFoldersModal = closeManageFoldersModal;
        window.showCreateFolderModal = showCreateFolderModal;
        window.cancelCreateFolder = cancelCreateFolder;
        window.confirmCreateFolder = confirmCreateFolder;
        window.createFolder = createFolder;
        window.deleteFolder = deleteFolder;
        window.confirmDeleteFolder = confirmDeleteFolder;
        window.executeDeleteFolder = executeDeleteFolder;
        window.addItemToFolder = addItemToFolder;
        window.selectFolderItem = selectFolderItem;
        window.toggleFolderItemSelection = toggleFolderItemSelection;
        window.confirmAddMultipleItemsToFolder = confirmAddMultipleItemsToFolder;
        window.removeItemFromFolder = removeItemFromFolder;
        window.toggleFolderExpanded = toggleFolderExpanded;
        window.viewUserProfile = viewUserProfile;
        window.closeUserProfileModal = closeUserProfileModal;
        window.confirmDeleteMerger = confirmDeleteMerger;
        window.handleDeleteMergerConfirmation = handleDeleteMergerConfirmation;
        window.confirmDeleteExtract = confirmDeleteExtract;
        window.executeDeleteExtract = executeDeleteExtract;
        window.toggleDarkTheme = toggleDarkTheme;
        window.loadActivityLogs = loadActivityLogs;
        window.loadAllUserAutosaves = loadAllUserAutosaves;
        window.continueVotingDraft = continueVotingDraft;
        window.confirmResumeDraft = confirmResumeDraft;
        window.confirmDiscardDraft = confirmDiscardDraft;
        window.cancelDiscardDraft = cancelDiscardDraft;
        window.executeDiscardDraft = executeDiscardDraft;
        window.toggleAutosaveDraftSection = toggleAutosaveDraftSection;
        window.manualSaveVotes = manualSaveVotes;
        window.discardCurrentDraftFromVoting = discardCurrentDraftFromVoting;
        window.executeDiscardDraftFromVoting = executeDiscardDraftFromVoting;
        // Results tab enhancements
        window.toggleSection = toggleSection;
        window.toggleUserFilterDropdown = toggleUserFilterDropdown;
        window.toggleUserFilterUser = toggleUserFilterUser;
        window.selectAllFilterUsers = selectAllFilterUsers;
        window.unselectAllFilterUsers = unselectAllFilterUsers;
        window.toggleImageFilterDropdown = toggleImageFilterDropdown;
        window.toggleImageFilterImage = toggleImageFilterImage;
        window.selectAllFilterImages = selectAllFilterImages;
        window.unselectAllFilterImages = unselectAllFilterImages;
        window.setCountMode = setCountMode;
        window.startComparison = startComparison;
        window.backFromComparison = backFromComparison;
        window.showComparisonDetail = showComparisonDetail;
        window.backFromComparisonDetail = backFromComparisonDetail;
        window.setComparisonDetailView = setComparisonDetailView;
        window.setComparisonTableView = setComparisonTableView;
        window.setComparisonAvgView = setComparisonAvgView;
        window.toggleComparisonTableSort = toggleComparisonTableSort;
        window.toggleComparisonDetailSection = toggleComparisonDetailSection;
        window.startAverageCompareAll = startAverageCompareAll;
        window.backFromAverageCompareAll = backFromAverageCompareAll;
        window.showAverageCompareUser = showAverageCompareUser;
        window.backFromAverageCompareUser = backFromAverageCompareUser;

        // Initialize app
        // Check for existing session on load
        (async function init() {
            // Load voting mode preference from localStorage
            const savedVotingMode = localStorage.getItem('peony_voting_mode');
            if (savedVotingMode === 'single' || savedVotingMode === 'multi') {
                state.votingMode = savedVotingMode;
            }

            const storedUser = localStorage.getItem('peony_user');
            if (storedUser) {
                try {
                    const user = JSON.parse(storedUser);

                    // Check if user is banned and get ban reason, also load dark theme preference
                    // Only clear auth on confirmed ban, not on network errors
                    try {
                        const banCheckResponse = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${user.id}&select=is_banned,ban_reason,dark_theme`, {
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Cache-Control': 'no-cache'
                            }
                        });

                        if (banCheckResponse.ok) {
                            const userData = await banCheckResponse.json();

                            // If user is banned, log them out with reason
                            if (userData && userData.length > 0 && userData[0].is_banned === true) {
                                const banReason = userData[0].ban_reason || 'No reason provided';
                                localStorage.removeItem('peony_user');
                                showAlert(`Your account has been banned from Peony.\n\nReason: ${banReason}`, 'üö´');
                                return; // Exit early, don't proceed with login
                            }

                            // Load dark theme preference
                            if (userData && userData.length > 0 && userData[0].dark_theme === true) {
                                state.darkTheme = true;
                                document.body.classList.add('dark-theme');
                            }
                        } else {
                            // Network error or API issue - don't log out, just warn
                            console.warn('Failed to check ban status, proceeding with cached session');
                        }
                    } catch (banCheckError) {
                        // Network error checking ban status - don't log out the user
                        console.warn('Ban check failed, proceeding with cached session:', banCheckError);
                    }

                    // User not banned (or ban check failed), proceed with login
                    state.isLoggedIn = true;
                    // AFTER: ensure user exists, then continue
                    state.user = {
                        id: user.id,
                        username: user.username,
                        avatar: user.avatar
                    };

                    // Ensure the row exists in public.users, then continue
                    ensureLocalUser(state.user)
                        .then(async () => {
                            // proceed normally once the user row is present (or insertion attempted)
                            await loadContests();
                            await loadPinnedItems();

                            render();
                        })
                        .catch(async (err) => {
                            // should not happen because ensureLocalUser swallows errors, but safe fallback
                            console.error('ensureLocalUser unexpected error:', err);
                            await loadContests();
                            await loadPinnedItems();
                            render();
                        });
                } catch (e) {
                    // Only clear localStorage if it's a JSON parse error (corrupted data)
                    // Don't clear on network errors or other transient issues
                    console.error('Error loading user session:', e);
                    if (e instanceof SyntaxError) {
                        // JSON parse error - clear corrupted data
                        localStorage.removeItem('peony_user');
                    }
                }
            }

            // Check for pending route from shared link
            const pendingRoute = localStorage.getItem('peony_pending_route');
            if (pendingRoute && !state.isLoggedIn) {
                state.pendingRoute = pendingRoute;
            }

            // Set initialization flag to prevent premature rendering
            state.isInitializing = true;
            setLoading('Loading...');

            await Promise.all([
                loadContests(),
                loadMergers(),
                loadExtracts(),
                loadAppSettings()
            ]);

            // Load voter counts after all contests, mergers, and extracts are loaded
            await loadVoterCounts();

            if (state.user) {
                await loadUserVotes();
                await loadAllUserAutosaves();
            }

            // Parse URL search parameter
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('search');
            if (searchQuery) {
                state.filters.searchQuery = searchQuery;
            }

            // Clear initialization flag and render
            state.isInitializing = false;
            clearLoading();
            render();

            // Setup hash change listener for browser back/forward
            window.addEventListener('hashchange', handleHashChange);

            // Check for shared contest link on initial load
            if (window.location.hash && state.isLoggedIn) {
                handleHashChange();
            }
        })();
        }); // End DOMContentLoaded event listener
    </script>
</body>
</html>
