<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <!-- PWA Configuration -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Peony">

    <!-- Favicon for browsers -->
    <link rel="icon" type="image/x-icon" href="favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">

    <!-- Apple Touch Icon for iOS home screen -->
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">

    <!-- Android Chrome Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="favicon/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="favicon/android-chrome-512x512.png">
    <!-- PWA Manifest -->
    <link rel="manifest" href="favicon/site.webmanifest">

    <!-- Canonical URL for GitHub Pages PWA -->
    <link rel="canonical" href="https://bicipikay.github.io/peony/">

    <!-- Theme color for mobile browsers -->
    <meta name="theme-color" content="#C77BA6">

    <title>Peony</title>

    <!-- Supabase JS Client for Realtime -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- SortableJS for drag-and-drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'mauve': {
                            300: '#D88FB8',
                            400: '#C77BA6',
                            500: '#B76E9E',
                            600: '#A86590',
                            700: '#995C82'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lilita+One&display=swap');
        
        @keyframes tickAppear {
            0% { transform: scale(0) rotate(-45deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(0deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        .tick-animation {
            animation: tickAppear 0.6s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal-overlay {
            animation: modalFadeIn 0.2s ease-out;
            background: rgba(0, 0, 0, 0.7);
        }
        @keyframes modalSlideIn {
            from { transform: scale(0.9) translateY(-20px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }
        .modal-content {
            animation: modalSlideIn 0.3s ease-out;
        }
        body {
            background: linear-gradient(to bottom,
                rgba(250, 232, 255, 0.3),
                rgba(220, 252, 231, 0.3)
            );
            min-height: 100vh;
        }
        body.modal-open {
            overflow: hidden;
        }
        .image-loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        @keyframes toastSlideIn {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes toastFadeOut {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-20px); opacity: 0; }
        }
        .toast-notification {
            animation: toastSlideIn 0.3s ease-out;
        }
        .toast-notification.fade-out {
            animation: toastFadeOut 0.3s ease-out;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        input[type="range"]::-webkit-slider-track {
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, rgb(199, 123, 166) 0%, rgb(34, 197, 94) 100%);
        }
        input[type="range"]::-moz-range-track {
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, rgb(199, 123, 166) 0%, rgb(34, 197, 94) 100%);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            border: 2px solid rgb(199, 123, 166);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            border: 2px solid rgb(199, 123, 166);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .upload-area {
            border: 3px dashed #C77BA6;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            border-color: #B76E9E;
            background: rgba(199, 123, 166, 0.05);
        }
        .upload-area.dragover {
            border-color: #22C55E;
            background: rgba(34, 197, 94, 0.1);
            transform: scale(1.02);
        }
        .score-text {
            font-family: 'Lilita One', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), -1px -1px 2px rgba(0,0,0,0.8), 1px -1px 2px rgba(0,0,0,0.8), -1px 1px 2px rgba(0,0,0,0.8);
        }
        .progress-segment {
            height: 8px;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .progress-segment:hover {
            transform: scaleY(1.3);
        }
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background-color: #ccc;
            border-radius: 30px;
            cursor: pointer;
            transition: background-color 0.3s;
            display: inline-block;
        }
        .toggle-switch.active {
            background-color: #C77BA6;
        }
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(30px);
        }
        .voting-image {
            max-height: 50vh;
        }
        @media (min-width: 640px) {
            .voting-image {
                max-height: min(40vh, 500px);
            }
        }
        /* PWA safe area support for iOS and Android fullscreen mode */
        .safe-header {
            padding-top: env(safe-area-inset-top);
        }
        /* Realtime toast notifications - slide in from right */
        @keyframes slideInRight {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background-color: #ccc;
            border-radius: 26px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .toggle-switch.active {
            background-color: #4CAF50;
        }
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="app"></div>

    <script>
        // Emergency error handler to catch JavaScript errors
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e);
            const app = document.getElementById('app');
            if (app && !app.innerHTML) {
                app.innerHTML = `
                    <div style="padding: 2rem; font-family: sans-serif; max-width: 800px; margin: 0 auto;">
                        <h1 style="color: #ef4444; margin-bottom: 1rem;">‚ö†Ô∏è Error Loading App</h1>
                        <div style="background: #fee; border: 1px solid #fcc; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <p><strong>Error:</strong> ${e.message || 'Unknown error'}</p>
                            <p><strong>File:</strong> ${e.filename || 'Unknown'}</p>
                            <p><strong>Line:</strong> ${e.lineno || 'Unknown'}:${e.colno || 'Unknown'}</p>
                        </div>
                        <p style="margin-bottom: 0.5rem;"><strong>What to do:</strong></p>
                        <ol style="line-height: 1.6;">
                            <li>Open browser console (F12) for detailed error information</li>
                            <li>Check for JavaScript syntax errors in index.html</li>
                            <li>Verify Supabase is loading correctly</li>
                            <li>Clear browser cache and reload the page</li>
                        </ol>
                    </div>
                `;
            }
        });

        // Supabase Configuration
        const SUPABASE_URL = 'https://tbduuuzwbiidjgztupfp.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRiZHV1dXp3YmlpZGpnenR1cGZwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0NTI3NjcsImV4cCI6MjA4MDAyODc2N30.lMDbB1I7vNoMFCncGw7_i9hUtWp-mO9rsmFLgd3GMMQ';

        // Discord OAuth Configuration
        const DISCORD_CLIENT_ID = '1442282566810861568';  // Replace with your actual Discord Client ID
        const DISCORD_REDIRECT_URI = 'https://bicipikay.github.io/peony/auth/callback';  // Replace with YOUR actual GitHub Pages URL + /auth/callback

        // Admin Discord ID - Replace with your actual Discord user ID after first login
        const ADMIN_DISCORD_ID = '719271552247529571';

        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        let state = {
            isLoggedIn: false,
            user: null,
            view: 'home',
            contests: [],
            currentContest: null,
            currentImageIndex: 0,
            votes: {},
            userVotedContests: {},
            hasSubmitted: false,
            showBreakdownModal: null,
            showTickAnimation: false,
            isAnimating: false,
            modal: null,
            modalProcessing: false,
            imageScale: 100,
            results: null,
            scaleUpdateTimeout: null,
            newContest: { title: '', images: [], labelsEnabled: false },
            showMyVotes: false,  // Deprecated, use resultsView
            resultsView: 'average',  // 'average', 'userVotes', or 'byVoter'
            selectedVoterUserId: null,  // For user votes dropdown (null = current user)
            contestVoters: [],  // List of all users who voted in current contest(s)
            shuffledImages: [],
            nextContestId: 1,
            bannedUsers: [], // Array of user IDs who are banned from app
            allUsers: [], // Track all users who have logged in
            uploadProgress: null, // Upload progress tracking: { files: [{name, status, error, progress}], completed: false }
            showUserList: false, // Show user list modal (admin only)
            showAdminDashboard: false, // Show admin dashboard modal
            showAppSettingsModal: false, // Show app settings modal (admin only)
            adminStats: { totalVotes: 0, totalUniqueVoters: 0 }, // Admin dashboard statistics
            filters: {
                createdBy: null,           // Username or null
                sortBy: 'newest',          // 'newest', 'oldest', 'mostVoted', 'leastVoted'
                searchQuery: ''            // Search term for contest titles
            },
            selectedContestsForMerge: [], // Array of contest IDs selected for merging
            mergedResults: null, // Results from merged contests
            showMergeModal: false, // Show merge contest selection modal
            mergers: [], // Array of merger objects from database
            extracts: [], // Array of extract objects from database
            groups: [], // Array of group objects from database
            showCreateMergerModal: false, // Show create merger modal
            showCreateExtractModal: false, // Show create extract modal
            showManageFoldersModal: false, // Show manage folders modal
            newMergerName: '', // Name for new merger being created
            newExtractName: '', // Name for new extract being created
            extractSourceType: null, // 'contest' or 'merger'
            extractSourceId: null, // ID of source contest/merger
            extractSelectedImages: [], // Array of image IDs selected for extract
            selectedFolderId: null, // Currently selected folder for viewing
            expandedFolderIds: [], // Array of folder IDs that are expanded
            appSettings: {}, // Global app settings (contest creation enabled, revoting enabled)
            view: 'home', // Can also be 'userProfile'
            viewingUserId: null, // User ID being viewed in profile
            toast: null, // Toast notification { message, icon }
            isLoading: false,
            loadingMessage: '',
            showUserDropdown: false,  // User menu dropdown state
            showMergedContestsDropdown: false  // Merged contests dropdown state
        };

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function formatVoterCount(voterCount, voterCountMin, voterCountMax) {
            if (voterCountMin !== undefined && voterCountMax !== undefined && voterCountMin !== voterCountMax) {
                return `${voterCountMin}-${voterCountMax}`;
            }
            return voterCount;
        }

        function setLoading(message) {
            state.isLoading = true;
            state.loadingMessage = message;
            render();
        }

        function clearLoading() {
            state.isLoading = false;
            state.loadingMessage = '';
            render();
        }

        // ==================== TOAST NOTIFICATIONS ====================

        /**
         * Show toast notification (lightweight, non-disruptive)
         * Used for user actions (ban/unban, vote submission, etc.)
         * @param {string} message - Message to display
         * @param {string} type - 'info', 'success', 'error', or 'warning'
         * @param {number} duration - Display duration in ms (default 3000)
         */
        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            const bgColors = {
                info: 'bg-blue-500',
                success: 'bg-green-500',
                error: 'bg-red-500',
                warning: 'bg-yellow-500'
            };

            toast.className = `fixed top-20 right-4 z-50 px-4 py-3 rounded-lg shadow-lg text-white text-sm font-medium transition-all transform translate-x-0 ${bgColors[type] || 'bg-gray-700'}`;
            toast.textContent = message;
            toast.style.animation = 'slideInRight 0.3s ease-out';

            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // ==================== END TOAST NOTIFICATIONS ====================

        function getScoreColor(score) {
            const colors = {
                1: 'rgb(220, 38, 38)',
                2: 'rgb(249, 115, 22)',
                3: 'rgb(234, 179, 8)',
                4: 'rgb(132, 204, 22)',
                5: 'rgb(34, 197, 94)'
            };
            return colors[score] || 'rgb(156, 163, 175)';
        }

        function getCategoryLabel(min, max, isMissing) {
            if (isMissing) return 'Votes Missing';
            if (min === 4.5) return '4.5 - 5.0';
            return `${min.toFixed(1)} - ${max.toFixed(2)}`;
        }

        function getCategoryColor(min, isMissing) {
            // Special styling for missing votes - black text on dark gray background
            if (isMissing) return { color: 'text-black', bg: 'bg-gray-400', textColor: 'rgb(0, 0, 0)', bgColor: 'rgb(156, 163, 175)' };

            // Bright green with cyan/blue undertone for top scores
            if (min >= 4.5) return { color: 'text-emerald-700', bg: 'bg-emerald-100', textColor: 'rgb(16, 185, 129)', bgColor: 'rgb(209, 250, 229)' };
            // Lime green
            if (min >= 4.0) return { color: 'text-lime-600', bg: 'bg-lime-50', textColor: 'rgb(77, 124, 15)', bgColor: 'rgb(236, 252, 203)' };
            // Yellow-green blend
            if (min >= 3.5) return { color: 'text-lime-500', bg: 'bg-lime-100', textColor: 'rgb(163, 230, 53)', bgColor: 'rgb(220, 252, 231)' };
            // Yellow with green hint
            if (min >= 3.0) return { color: 'text-lime-600', bg: 'bg-yellow-50', textColor: 'rgb(101, 163, 13)', bgColor: 'rgb(254, 252, 232)' };
            // Orange-yellow blend
            if (min >= 2.5) return { color: 'text-orange-500', bg: 'bg-orange-200', textColor: 'rgb(251, 146, 60)', bgColor: 'rgb(254, 215, 170)' };
            // Orange
            if (min >= 2.0) return { color: 'text-orange-600', bg: 'bg-orange-100', textColor: 'rgb(234, 88, 12)', bgColor: 'rgb(255, 237, 213)' };
            // Red-orange blend
            if (min >= 1.5) return { color: 'text-red-500', bg: 'bg-red-100', textColor: 'rgb(239, 68, 68)', bgColor: 'rgb(254, 226, 226)' };
            // Red
            if (min >= 1.0) return { color: 'text-red-600', bg: 'bg-red-200', textColor: 'rgb(220, 38, 38)', bgColor: 'rgb(254, 202, 202)' };
            // Fallback for any edge cases
            return { color: 'text-gray-600', bg: 'bg-gray-200', textColor: 'rgb(75, 85, 99)', bgColor: 'rgb(229, 231, 235)' };
        }


        async function loadResults() {
            setLoading('Loading results...');
            try {
                console.log('üîç DEBUG: Loading results for contest:', state.currentContest.id);
                console.log('üîç DEBUG: Current user:', state.user);

                // Fetch ALL votes with voter info including ban status for breakdown display with aggressive cache-busting
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?contest_id=eq.${state.currentContest.id}&limit=2000&select=*,voter:users!votes_user_id_fkey(username,avatar,is_banned)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const allVotes = await response.json();
                console.log('üîç DEBUG: Fetched votes:', allVotes);

                // Check if votes response is valid
                if (!Array.isArray(allVotes)) {
                    console.error('Invalid votes response:', allVotes);
                    showAlert('Error loading votes: ' + (allVotes.message || 'Invalid response'), '‚ùå');
                    return;
                }

                console.log('üîç DEBUG: Number of votes:', allVotes.length);

                // Warn if we hit the vote limit
                if (allVotes.length === 2000) {
                    console.warn('‚ö†Ô∏è Hit vote limit of 2000 - may be missing votes');
                }

                // Build list of unique voters for dropdown (exclude banned users)
                const votersMap = new Map();
                allVotes.forEach(vote => {
                    const voterIsBanned = vote.voter?.is_banned || false;
                    if (!votersMap.has(vote.user_id) && !voterIsBanned) {
                        votersMap.set(vote.user_id, {
                            userId: vote.user_id,
                            username: vote.voter.username,
                            avatar: vote.voter.avatar
                        });
                    }
                });
                state.contestVoters = Array.from(votersMap.values()).sort((a, b) =>
                    a.username.localeCompare(b.username)
                );

                const imageScores = {};
                allVotes.forEach(vote => {
                    console.log('üîç DEBUG: Processing vote:', vote);
                    if (!imageScores[vote.image_id]) {
                        imageScores[vote.image_id] = {
                            scores: [],
                            breakdown: []
                        };
                    }

                    const isBlocked = vote.is_blocked || false;
                    const voterIsBanned = vote.voter?.is_banned || false;

                    // Only include non-blocked AND non-banned votes in score calculations
                    if (!isBlocked && !voterIsBanned) {
                        imageScores[vote.image_id].scores.push(vote.score);
                    }

                    // Include ALL votes in breakdown (blocked, banned, and non-blocked)
                    imageScores[vote.image_id].breakdown.push({
                        userId: vote.user_id,
                        username: vote.voter.username,
                        avatar: vote.voter.avatar,
                        score: vote.score,
                        isCurrentUser: vote.user_id === state.user?.id,
                        isBlocked: isBlocked,
                        isBanned: voterIsBanned
                    });
                });

                console.log('üîç DEBUG: Image scores:', imageScores);
                console.log('üîç DEBUG: Contest images:', state.currentContest.images);

                // Map images with their scores
                state.results = state.currentContest.images.map(img => {
                    const scores = imageScores[img.id]?.scores || [];
                    const sum = scores.reduce((acc, s) => acc + s, 0);
                    const average = scores.length > 0 ? parseFloat((sum / scores.length).toFixed(2)) : 0;

                    console.log(`üîç DEBUG: Image ${img.id} - scores:`, scores, 'average:', average);

                    return {
                        ...img,
                        averageScore: average,
                        totalVotes: scores.length,
                        breakdown: imageScores[img.id]?.breakdown || []
                    };
                }).sort((a, b) => b.averageScore - a.averageScore);

                console.log('üîç DEBUG: Final results:', state.results);
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        // Temporary stub for merge functionality - returns empty results
        // TODO: Implement proper async merge functionality with database queries
        function groupByScoreRange(results) {
            const ranges = [
                { min: 4.5, max: 5.0 },
                { min: 4.0, max: 4.49 },
                { min: 3.5, max: 3.99 },
                { min: 3.0, max: 3.49 },
                { min: 2.5, max: 2.99 },
                { min: 2.0, max: 2.49 },
                { min: 1.5, max: 1.99 },
                { min: 1.0, max: 1.49 }
            ];

            const grouped = {};

            // Check for images with missing votes (averageScore === 0 or null)
            const missingVotes = results.filter(r => !r.averageScore || r.averageScore === 0);
            if (missingVotes.length > 0) {
                grouped['missing'] = {
                    items: missingVotes,
                    min: 0,
                    max: 0,
                    isMissing: true
                };
            }

            // Group images by score ranges (only those with actual votes)
            ranges.forEach(range => {
                const key = `${range.min}-${range.max}`;
                const items = results.filter(r => r.averageScore > 0 && r.averageScore >= range.min && r.averageScore <= range.max);
                if (items.length > 0) {
                    grouped[key] = {
                        items: items.sort((a, b) => b.averageScore - a.averageScore),
                        min: range.min,
                        max: range.max
                    };
                }
            });

            return grouped;
        }

        function groupMyVotesByScore(results) {
            const grouped = {};

            [5, 4, 3, 2, 1].forEach(score => {
                const items = results.filter(r => r.averageScore === score);
                if (items.length > 0) {
                    grouped[score] = {
                        items: items,
                        score: score
                    };
                }
            });

            return grouped;
        }

        /**
         * Generate voter statistics from loaded results
         * Calculates each voter's average score across all images they voted on
         * Uses only data from state.results (already loaded from database)
         *
         * @returns {Array} Array of voter objects with calculated averages, sorted by average score (highest first)
         */
        function generateVoterStats() {
            if (!state.results) return [];

            // Accumulator for voter data
            // Structure: { userId: { votes: [], totalScore: 0, totalImages: 0, username, avatar, etc. } }
            const voterVotes = {};

            // Collect votes from all images in loaded results
            state.results.forEach(imageResult => {
                if (!imageResult.breakdown) return;

                imageResult.breakdown.forEach(vote => {
                    // Skip blocked votes
                    if (vote.isBlocked) return;

                    if (!voterVotes[vote.userId]) {
                        voterVotes[vote.userId] = {
                            userId: vote.userId,
                            username: vote.username,
                            avatar: vote.avatar,
                            isCurrentUser: vote.isCurrentUser || false,
                            votes: [],
                            totalScore: 0,
                            totalImages: 0
                        };
                    }

                    voterVotes[vote.userId].votes.push(vote.score);
                    voterVotes[vote.userId].totalScore += vote.score;
                    voterVotes[vote.userId].totalImages++;
                });
            });

            // Calculate averages and sort alphabetically by username
            return Object.values(voterVotes)
                .map(voter => ({
                    ...voter,
                    averageScore: voter.totalImages > 0
                        ? parseFloat((voter.totalScore / voter.totalImages).toFixed(2))
                        : 0
                }))
                .sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
        }

        function showModal(config) {
            if (state.modalProcessing) return;
            state.modal = config;
            document.body.classList.add('modal-open');
            render();
        }

        function closeModal() {
            if (state.modalProcessing) return;
            state.modal = null;
            state.modalProcessing = false;
            document.body.classList.remove('modal-open');
            render();
        }

        function showAlert(message, icon = 'üö®') {
            showModal({
                type: 'alert',
                icon,
                message,
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showConfirm(message, onConfirmName, icon = 'üö®') {
            showModal({
                type: 'confirm',
                icon,
                message,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Confirm', action: onConfirmName, primary: true }
                ]
            });
        }

        function showToast(message, icon = '‚úÖ') {
            state.toast = { message, icon };
            render();

            // Auto-dismiss after 2.5 seconds
            setTimeout(() => {
                const toastEl = document.querySelector('.toast-notification');
                if (toastEl) {
                    toastEl.classList.add('fade-out');
                }
                setTimeout(() => {
                    state.toast = null;
                    render();
                }, 300);
            }, 2500);
        }

        function showInputModal(title, placeholder, onConfirmAction, allowEmpty = false) {
            showModal({
                type: 'input',
                icon: '‚úèÔ∏è',
                title,
                placeholder,
                allowEmpty,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Continue', action: onConfirmAction, primary: true }
                ]
            });
        }

        async function confirmSubmitVotes() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            render(); // Close modal immediately before async work

            setLoading('Submitting votes...');

            const votesToSubmit = [];
            state.shuffledImages.forEach(img => {
                if (state.votes[img.id]) {
                    votesToSubmit.push({
                        user_id: state.user.id,
                        image_id: img.id,
                        contest_id: state.currentContest.id,
                        score: state.votes[img.id]
                    });
                }
            });

            try {
                // Check if votes already exist for this user and contest
                const existingVotesResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/votes?user_id=eq.${state.user.id}&contest_id=eq.${state.currentContest.id}&select=*`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                if (!existingVotesResponse.ok) {
                    throw new Error('Failed to check existing votes');
                }

                const existingVotes = await existingVotesResponse.json();

                if (existingVotes.length > 0) {
                    // Votes exist - update them using PATCH
                    // We need to update each vote individually by matching user_id, contest_id, and image_id
                    const updatePromises = votesToSubmit.map(async (vote) => {
                        const response = await fetch(
                            `${SUPABASE_URL}/rest/v1/votes?user_id=eq.${vote.user_id}&contest_id=eq.${vote.contest_id}&image_id=eq.${vote.image_id}`,
                            {
                                method: 'PATCH',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'apikey': SUPABASE_ANON_KEY,
                                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                    'Prefer': 'return=minimal',
                                    'Cache-Control': 'no-cache'
                                },
                                body: JSON.stringify({ score: vote.score })
                            }
                        );

                        if (!response.ok) {
                            throw new Error(`Failed to update vote for image ${vote.image_id}`);
                        }
                    });

                    await Promise.all(updatePromises);
                } else {
                    // No existing votes - insert new ones using POST
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/votes`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Prefer': 'return=minimal',
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify(votesToSubmit)
                    });

                    if (!response.ok) {
                        throw new Error('Failed to submit votes');
                    }
                }

                await loadUserVotes();
                state.hasSubmitted = true;
                state.view = 'results';
                await loadResults();

                // Refresh contest list to update voter counts
                await loadContests();

                state.modalProcessing = false;
                render();
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Failed to submit votes: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            } finally {
                clearLoading();
            }
        }

        function confirmCancelVoting() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.view = 'home';
            state.currentContest = null;
            state.modalProcessing = false;
            render();
        }

        function canDeleteContest(contest) {
            if (!state.user) return false;

            // Check if user is contest creator
            if (contest.createdBy === state.user.id) return true;

            // Admin check
            return state.user.id === ADMIN_DISCORD_ID;
        }

        function deleteContest(contestId) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) return;

            // Store contest info for validation
            state.contestToDelete = contest;

            showInputModal(
                `Type "${contest.title}" to confirm deletion`,
                'Enter contest title exactly...',
                'handleDeleteContestConfirmation',
                false
            );
        }

        function handleDeleteContestConfirmation() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const enteredTitle = input ? input.value.trim() : '';

            if (!state.contestToDelete) {
                showAlert('Contest information not found.', '‚ùå');
                return;
            }

            if (enteredTitle !== state.contestToDelete.title) {
                showAlert('Title does not match. Deletion cancelled.', '‚ùå');
                return;
            }

            // Title matches, proceed with deletion
            confirmDeleteContest(state.contestToDelete.id);
        }

        async function confirmDeleteContest(contestId) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            setLoading('Deleting contest...');

            try {
                // First, fetch contest images to clean up storage
                const contest = state.contests.find(c => c.id === contestId);
                if (contest && contest.images) {
                    const filesToDelete = [];

                    for (const image of contest.images) {
                        // Only delete images that were uploaded to storage (not external URLs)
                        if (image.isFileUpload && image.url) {
                            // Extract file path from Supabase storage URL
                            // URL format: https://{project}.supabase.co/storage/v1/object/public/contest-images/{fileName}
                            const urlParts = image.url.split('/contest-images/');
                            if (urlParts.length === 2) {
                                filesToDelete.push(urlParts[1]);
                            }
                        }
                    }

                    // Delete files from storage if there are any
                    if (filesToDelete.length > 0) {
                        console.log('Deleting files from storage:', filesToDelete);
                        const { data, error } = await supabase.storage
                            .from('contest-images')
                            .remove(filesToDelete);

                        if (error) {
                            console.warn('Storage cleanup error:', error);
                            // Don't fail the entire deletion if storage cleanup fails
                        } else {
                            console.log('Successfully deleted files from storage:', data);
                        }
                    }
                }

                // Now delete the contest from database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete contest');
                }

                await loadContests();
                delete state.userVotedContests[contestId];
                state.modalProcessing = false;
                showAlert('Contest deleted successfully!', '‚úÖ');
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Failed to delete contest: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            } finally {
                clearLoading();
            }
        }

        function startCreateContest() {
            showInputModal('Contest Title', 'Enter contest title...', 'handleContestTitle', false);
        }

        function handleContestTitle() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const title = input ? input.value.trim() : '';

            if (!title || title.length === 0) {
                showAlert('Contest title cannot be empty.', '‚ùå');
                return;
            }
            if (title.length > 100) {
                showAlert('Contest title is too long (max 100 characters).', '‚ùå');
                return;
            }

            // Check for duplicate title - BLOCK creation entirely
            const existingContest = state.contests.find(c => c.title.toLowerCase() === title.toLowerCase());
            if (existingContest) {
                showAlert('A contest with this title already exists. Please choose a different title.', '‚ùå');
                return;
            }

            state.modalProcessing = true;
            state.newContest.title = title;
            state.newContest.images = [];
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.view = 'createContest';
            state.modalProcessing = false;
            render();
        }

        function confirmCreateWithDuplicateTitle() {
            state.modalProcessing = true;
            const title = state.tempContestTitle;
            state.tempContestTitle = null;
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.newContest.title = title;
            state.newContest.images = [];
            state.view = 'createContest';
            state.modalProcessing = false;
            render();
        }

        function cancelCreateContest() {
            showConfirm(
                'Your progress will be lost if you proceed. Are you sure?',
                'confirmCancelCreate',
                'üö®'
            );
        }

        function confirmCancelCreate() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URLs to free memory
            state.newContest.images.forEach(img => {
                if (img.isLocalFile && img.url.startsWith('blob:')) {
                    URL.revokeObjectURL(img.url);
                }
            });

            state.view = 'home';
            state.newContest = { title: '', images: [] };
            state.modalProcessing = false;
            render();
        }

        async function addImageFromUrl(urlInputId) {
            const input = document.getElementById(urlInputId);
            let url = input.value.trim();

            if (!url) {
                showAlert('Please enter an image URL!', '‚ùå');
                return;
            }

            // Convert Discord CDN URLs to media.discordapp.net for compatibility
            url = url.replace(/cdn\.discordapp\.com/g, 'media.discordapp.net');
            url = url.replace(/images-ext-\d+\.discordapp\.net/g, 'media.discordapp.net');

            // Check for duplicate URL
            const isDuplicate = state.newContest.images.some(img => img.url === url);

            if (isDuplicate) {
                console.log('‚ö†Ô∏è Duplicate image URL detected:', url);
                state.tempDuplicateUrl = url;
                state.tempDuplicateUrlInputId = urlInputId;
                showConfirm(
                    '‚ö†Ô∏è This image URL already exists in the contest. Do you want to add it anyway?',
                    'confirmAddDuplicateImage',
                    '‚ö†Ô∏è'
                );
                return;
            }

            // Admin can bypass 50-image limit
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (state.newContest.images.length >= 50 && !isAdmin) {
                showAlert('Maximum 50 images per contest!', '‚ùå');
                return;
            }

            try {
                const img = await loadImageFromUrl(url);
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random(),
                    url,
                    author: null,
                    isFileUpload: false,
                    label: `${imageCount}`
                });
                input.value = '';
                showToast('Image added successfully!', '‚úÖ');
                render();
            } catch (error) {
                showAlert(`Failed to load image: ${error.message}`, '‚ùå');
            }
        }

        async function confirmAddDuplicateImage() {
            const url = state.tempDuplicateUrl;
            const urlInputId = state.tempDuplicateUrlInputId;

            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            if (!url) {
                state.modalProcessing = false;
                return;
            }

            console.log('‚úÖ User confirmed adding duplicate URL:', url);

            // Admin can bypass 50-image limit
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (state.newContest.images.length >= 50 && !isAdmin) {
                showAlert('Maximum 50 images per contest!', '‚ùå');
                state.tempDuplicateUrl = null;
                state.tempDuplicateUrlInputId = null;
                state.modalProcessing = false;
                return;
            }

            try {
                const img = await loadImageFromUrl(url);
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random(),
                    url,
                    author: null,
                    isFileUpload: false,
                    label: `${imageCount}`
                });

                const input = document.getElementById(urlInputId);
                if (input) {
                    input.value = '';
                }

                showToast('Duplicate image added!', '‚úÖ');
            } catch (error) {
                showAlert(`Failed to load image: ${error.message}`, '‚ùå');
            }

            state.tempDuplicateUrl = null;
            state.tempDuplicateUrlInputId = null;
            state.modalProcessing = false;
            render();
        }

        function clearUrlInput() {
            const input = document.getElementById('contestUrlInput');
            if (input) {
                input.value = '';
            }
        }

        async function compressImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = (e) => {
                    const img = new Image();

                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // Calculate new dimensions (max 1920px width, maintain aspect ratio)
                        const maxWidth = 1920;
                        let width = img.width;
                        let height = img.height;

                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }

                        canvas.width = width;
                        canvas.height = height;

                        // Draw resized image
                        ctx.drawImage(img, 0, 0, width, height);

                        // Smart dynamic quality - calculate starting quality based on original size
                        const originalSizeKB = file.size / 1024;
                        const targetSizeKB = 150; // Target 150KB
                        let quality = Math.max(0.3, Math.min(0.8, (targetSizeKB / originalSizeKB) * 1.5));

                        // Iteratively compress with decreasing quality (max 5 attempts)
                        let attempts = 0;
                        const maxAttempts = 5;

                        const tryCompress = (currentQuality) => {
                            canvas.toBlob((blob) => {
                                attempts++;
                                const compressedSizeKB = blob.size / 1024;

                                if (blob.size <= 200 * 1024) {
                                    // Success - under 200KB
                                    const compressedFile = new File([blob], file.name, {
                                        type: 'image/jpeg',
                                        lastModified: Date.now()
                                    });
                                    resolve({
                                        file: compressedFile,
                                        originalSize: file.size,
                                        compressedSize: blob.size
                                    });
                                } else if (attempts < maxAttempts && currentQuality > 0.3) {
                                    // Still too large, try again with lower quality
                                    const newQuality = Math.max(0.3, currentQuality - 0.1);
                                    tryCompress(newQuality);
                                } else {
                                    // Failed after max attempts or reached minimum quality
                                    reject(new Error('Image too large to compress under 200KB. Please use a smaller image.'));
                                }
                            }, 'image/jpeg', currentQuality);
                        };

                        tryCompress(quality);
                    };

                    img.onerror = () => reject(new Error('Failed to load image for compression'));
                    img.src = e.target.result;
                };

                reader.onerror = () => reject(new Error('Failed to read image file'));
                reader.readAsDataURL(file);
            });
        }

        async function handleFileSelect(fileInput) {
            const files = Array.from(fileInput.files);
            if (files.length === 0) return;

            const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            const maxSizeBeforeCompression = 1 * 1024 * 1024; // 1MB - reject if too large even before compression

            // Validate file types
            const invalidTypeFiles = files.filter(file => !validTypes.includes(file.type));
            if (invalidTypeFiles.length > 0) {
                showAlert(`${invalidTypeFiles.length} file(s) are not valid image types (JPG, PNG, GIF, or WebP)`, '‚ùå');
                fileInput.value = '';
                return;
            }

            // Check for files that are too large even before compression
            const tooLargeFiles = files.filter(file => file.size > maxSizeBeforeCompression);
            if (tooLargeFiles.length > 0) {
                showAlert(`${tooLargeFiles.length} file(s) exceed 1MB. Please use smaller images.`, '‚ùå');
                fileInput.value = '';
                return;
            }

            // Check if adding all files would exceed the 50 image limit (admin can bypass)
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const totalImages = state.newContest.images.length + files.length;
            if (totalImages > 50 && !isAdmin) {
                const availableSlots = 50 - state.newContest.images.length;
                showAlert(`Cannot add ${files.length} images. Only ${availableSlots} slot(s) remaining (max 50 total)`, '‚ùå');
                fileInput.value = '';
                return;
            }

            // Show warning if any files need compression
            const largeFiles = files.filter(file => file.size > 200 * 1024);
            if (largeFiles.length > 0) {
                showToast('‚ö†Ô∏è Image will be compressed during contest creation', 'info');
            }

            // Store files locally with preview URLs (no upload yet)
            files.forEach(file => {
                const previewUrl = URL.createObjectURL(file);
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random(),
                    url: previewUrl,
                    localFile: file,
                    isLocalFile: true,
                    author: null,
                    isFileUpload: true,
                    label: `${imageCount}`
                });
            });

            fileInput.value = '';
            showToast(`${files.length} image${files.length !== 1 ? 's' : ''} added successfully!`, 'success');
            render();
        }

        async function uploadImageFile(file, progressCallback) {
            // Always use .jpg extension for compressed images
            const fileExt = 'jpg';

            // Generate unique filename
            const fileName = `contest-${Date.now()}-${Math.random().toString(36).substring(2, 9)}.${fileExt}`;

            // Simulate progress updates (Supabase doesn't provide native progress)
            let progressInterval;
            if (progressCallback) {
                let simulatedProgress = 10;
                progressInterval = setInterval(() => {
                    if (simulatedProgress < 90) {
                        simulatedProgress += 10;
                        progressCallback(simulatedProgress);
                    }
                }, 200);
            }

            try {
                // Upload to Supabase Storage
                const { data, error } = await supabase.storage
                    .from('contest-images')
                    .upload(fileName, file, {
                        cacheControl: '3600',
                        upsert: false
                    });

                if (progressInterval) clearInterval(progressInterval);

                if (error) {
                    console.error('Supabase storage error:', error);
                    throw new Error(error.message || 'Failed to upload image to storage');
                }

                if (progressCallback) progressCallback(95);

                // Get public URL
                const { data: urlData } = supabase.storage
                    .from('contest-images')
                    .getPublicUrl(fileName);

                if (!urlData || !urlData.publicUrl) {
                    throw new Error('Failed to get public URL for uploaded image');
                }

                if (progressCallback) progressCallback(100);

                return urlData.publicUrl;
            } catch (error) {
                if (progressInterval) clearInterval(progressInterval);
                console.error('Upload error:', error);
                throw error;
            }
        }

        async function uploadImageFileWithRetry(file, fileIndex, maxRetries = 3) {
            const updateProgress = (progress) => {
                if (state.uploadProgress && state.uploadProgress.files[fileIndex]) {
                    state.uploadProgress.files[fileIndex].progress = progress;
                    render();
                }
            };

            let lastError;
            const retryCount = state.uploadProgress?.files[fileIndex]?.retryCount || 0;

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    // Exponential backoff: wait before retry (0ms, 1s, 2s, 4s)
                    if (attempt > 0) {
                        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 4000);
                        console.log(`Retrying upload for ${file.name} after ${delay}ms (attempt ${attempt + 1}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        updateProgress(5);
                    }

                    const imageUrl = await uploadImageFile(file, updateProgress);
                    return imageUrl;
                } catch (error) {
                    lastError = error;
                    console.error(`Upload attempt ${attempt + 1} failed for ${file.name}:`, error);

                    // Don't retry on certain errors
                    const errorMsg = error.message || String(error);
                    if (errorMsg.includes('413') || errorMsg.includes('Payload Too Large') ||
                        errorMsg.includes('401') || errorMsg.includes('403')) {
                        throw error; // Don't retry auth or size errors
                    }

                    // Continue to next retry if available
                    if (attempt < maxRetries - 1) {
                        updateProgress(0);
                    }
                }
            }

            // All retries failed
            throw lastError || new Error('Upload failed after multiple attempts');
        }

        // Upload progress modal helper functions
        function closeUploadProgress() {
            // Add successfully uploaded images to the contest
            const successfulUploads = state.uploadProgress.files.filter(f => f.status === 'success' && f.imageUrl);
            successfulUploads.forEach((file, index) => {
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random() + index,
                    url: file.imageUrl,
                    author: null,
                    isFileUpload: true,
                    label: `${imageCount}`
                });
            });

            state.uploadProgress = null;
            render();

            if (successfulUploads.length > 0) {
                showToast(`${successfulUploads.length} image${successfulUploads.length > 1 ? 's' : ''} added to contest!`, '‚úÖ');
            }
        }

        async function retryUpload(fileIndex) {
            const fileData = state.uploadProgress.files[fileIndex];
            if (!fileData || !fileData.originalFile) return;

            // Reset file status
            fileData.status = 'pending';
            fileData.progress = 0;
            fileData.error = null;
            fileData.retryCount = (fileData.retryCount || 0) + 1;
            render();

            try {
                // Re-compress if needed (using original file)
                if (fileData.needsCompression) {
                    fileData.status = 'compressing';
                    fileData.progress = 5;
                    render();

                    const compressed = await compressImage(fileData.originalFile);
                    fileData.file = compressed.file;
                    fileData.compressedSize = compressed.compressedSize;
                    fileData.progress = 10;
                    render();
                } else {
                    fileData.file = fileData.originalFile;
                    fileData.compressedSize = fileData.originalFile.size;
                }

                // Upload the file
                fileData.status = 'uploading';
                fileData.progress = 15;
                render();

                const imageUrl = await uploadImageFileWithRetry(fileData.file, fileIndex);
                fileData.status = 'success';
                fileData.imageUrl = imageUrl;
                fileData.progress = 100;
            } catch (error) {
                fileData.status = 'failed';
                fileData.error = getFriendlyErrorMessage(error);
            }

            render();
        }

        function cancelAllUploads() {
            // Mark all pending/uploading files as cancelled
            state.uploadProgress.files.forEach(file => {
                if (file.status === 'pending' || file.status === 'uploading') {
                    file.status = 'failed';
                    file.error = 'Cancelled by user';
                }
            });
            render();
        }

        function getFriendlyErrorMessage(error) {
            const errorMsg = error.message || String(error);

            if (errorMsg.includes('Failed to fetch') || errorMsg.includes('ERR_HTTP2_PROTOCOL_ERROR')) {
                return 'Network error - please check your connection and try again';
            } else if (errorMsg.includes('timeout') || errorMsg.includes('timed out')) {
                return 'Upload timed out - file may be too large or connection too slow';
            } else if (errorMsg.includes('413') || errorMsg.includes('Payload Too Large')) {
                return 'File is too large for upload';
            } else if (errorMsg.includes('401') || errorMsg.includes('403')) {
                return 'Authentication error - please try logging in again';
            } else if (errorMsg.includes('storage')) {
                return 'Storage error: ' + errorMsg;
            }

            return errorMsg;
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.add('border-blue-500', 'bg-blue-100');
                dropZone.classList.remove('border-gray-300', 'bg-gray-50');
            }
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-100');
                dropZone.classList.add('border-gray-300', 'bg-gray-50');
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();

            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-100');
                dropZone.classList.add('border-gray-300', 'bg-gray-50');
            }

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                // Create a mock file input object to reuse handleFileSelect logic
                const mockInput = {
                    files: files,
                    value: ''
                };
                handleFileSelect(mockInput);
            }
        }

        function removeContestImage(index) {
            showConfirm(
                'Delete this image from the contest?',
                `confirmRemoveImage_${index}`,
                'üö®'
            );
        }

        function confirmRemoveImage(index) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URL if it's a local file
            const img = state.newContest.images[index];
            if (img && img.isLocalFile && img.url.startsWith('blob:')) {
                URL.revokeObjectURL(img.url);
            }

            state.newContest.images.splice(index, 1);
            state.modalProcessing = false;
            render();

            // Show success message
            showAlert('Image successfully removed!', '‚úÖ');
        }

        function toggleImageLabels() {
            state.newContest.labelsEnabled = !state.newContest.labelsEnabled;
            render();
        }

        function toggleUserDropdown() {
            state.showUserDropdown = !state.showUserDropdown;
            render();
        }

        function toggleMergedContestsDropdown() {
            state.showMergedContestsDropdown = !state.showMergedContestsDropdown;
            render();
        }

        async function shareContest(contestId) {
            try {
                const shareUrl = `${window.location.origin}${window.location.pathname}#contest=${contestId}`;

                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                showToast('üîó Contest link copied!', 'success');
            } catch (error) {
                console.error('Failed to copy link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        function toggleContestSelection(contestId) {
            const index = state.selectedContestsForMerge.indexOf(contestId);
            if (index > -1) {
                state.selectedContestsForMerge.splice(index, 1);
            } else {
                state.selectedContestsForMerge.push(contestId);
            }
            render();
        }

        function openMergeModal() {
            // Initialize with current contest pre-selected
            if (state.currentContest) {
                state.selectedContestsForMerge = [state.currentContest.id];
            }
            state.showMergeModal = true;
            render();
        }

        function closeMergeModal() {
            state.showMergeModal = false;
            state.selectedContestsForMerge = [];
            render();
        }

        async function viewSelectedMerge() {
            if (state.selectedContestsForMerge.length < 2) {
                showAlert('Please select at least 2 contests to merge', '‚ùå');
                return;
            }

            state.showMergeModal = false;
            await loadSharedMerge(state.selectedContestsForMerge.join(','));
        }

        async function copyMergeLink() {
            if (!state.mergedResults || !state.mergedResults.contestIds) {
                showAlert('No merge data available', '‚ùå');
                return;
            }

            try {
                const shareUrl = `${window.location.origin}${window.location.pathname}#merge=${state.mergedResults.contestIds.join(',')}`;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                showToast('üîó Merge link copied!', 'success');
            } catch (error) {
                console.error('Failed to copy merge link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        function showBreakdownMerged(imageId) {
            state.showBreakdownModal = imageId;
            render();
        }

        function renderBreakdownModalMerged() {
            if (!state.mergedResults || !state.mergedResults.images) return '';

            const item = state.mergedResults.images.find(img => img.id === state.showBreakdownModal);
            if (!item) return '';

            const votesByScore = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            (item.voteBreakdown || []).forEach(vote => {
                if (votesByScore[vote.score]) {
                    votesByScore[vote.score].push(vote);
                }
            });

            Object.keys(votesByScore).forEach(score => {
                votesByScore[score].sort((a, b) => a.username.localeCompare(b.username));
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[85vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Vote Breakdown</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="overflow-y-auto flex-1 p-4">

                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 400px;">
                                <img
                                    src="${item.url}"
                                    alt="Image"
                                    class="max-w-full max-h-[400px] object-contain"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                            </div>

                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-gray-800">${item.averageScore}</div>
                                    <div class="text-xs text-gray-600">Average Score</div>
                                    <div class="text-xs text-gray-500 mt-1">${item.totalVotes} total votes</div>
                                </div>
                            </div>

                            <div class="space-y-3">
                                ${[5, 4, 3, 2, 1].map(score => {
                                    const votes = votesByScore[score] || [];
                                    return `
                                    <div>
                                        <h4 class="text-sm font-bold mb-2 px-3 py-1 rounded-lg inline-block" style="color: ${getScoreColor(score)}; background-color: ${getScoreColor(score)}20;">
                                            Score ${score} (${votes.length} ${votes.length === 1 ? 'vote' : 'votes'})
                                        </h4>
                                        ${votes.length > 0 ? `
                                            <div class="grid grid-cols-1 gap-2 mt-2">
                                                ${votes.map(vote => `
                                                    <div class="flex items-center gap-2 p-2 rounded-lg ${
                                                        vote.isBlocked ? 'bg-gray-300' :
                                                        vote.isCurrentUser ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'
                                                    }">
                                                        <img src="${vote.avatar}" alt="${vote.username}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                        <span class="text-sm flex-1 truncate ${
                                                            vote.isBlocked ? 'line-through text-gray-700' : 'text-gray-700'
                                                        }">
                                                            ${vote.username}${vote.isCurrentUser ? ' (You)' : ''}
                                                        </span>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        ` : `
                                            <div class="text-gray-400 italic text-sm mt-2 ml-3">No votes</div>
                                        `}
                                    </div>
                                `}).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        async function shareMerge() {
            if (state.selectedContestsForMerge.length < 2) {
                showAlert('Please select at least 2 contests to merge', '‚ùå');
                return;
            }

            try {
                // Convert contest IDs to contest numbers for shorter URLs
                const contestNumbers = state.selectedContestsForMerge.map(id => {
                    const contest = state.contests.find(c => c.id === id);
                    return contest ? contest.contestNumber : null;
                }).filter(n => n !== null);

                const shareUrl = `${window.location.origin}${window.location.pathname}#merge=${contestNumbers.join(',')}`;

                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                showToast('üîó Merge link copied!', 'success');
            } catch (error) {
                console.error('Failed to copy merge link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        async function viewMerge() {
            if (state.selectedContestsForMerge.length < 2) {
                showAlert('Please select at least 2 contests to merge', '‚ùå');
                return;
            }

            // Convert UUIDs to contest numbers for the URL
            const contestNumbers = state.selectedContestsForMerge.map(id => {
                const contest = state.contests.find(c => c.id === id);
                return contest ? contest.contestNumber : null;
            }).filter(n => n !== null);

            await loadSharedMerge(contestNumbers.join(','));
        }

        async function loadSharedMerge(contestIdsStr) {
            try {
                console.log('Loading merged contests:', contestIdsStr);

                const inputIds = contestIdsStr.split(',').map(id => id.trim());

                if (inputIds.length < 2) {
                    showAlert('At least 2 contests are required for merging', '‚ùå');
                    return;
                }

                state.isLoading = true;
                state.loadingMessage = 'Loading merged results...';
                render();

                // Check if inputs are contest numbers (numeric) or UUIDs
                const isNumeric = inputIds.every(id => /^\d+$/.test(id));
                let contestIds;

                if (isNumeric) {
                    // Convert contest numbers to UUIDs
                    const contestNumbers = inputIds.map(n => parseInt(n));
                    const lookupResponse = await fetch(`${SUPABASE_URL}/rest/v1/contests?contest_number=in.(${contestNumbers.join(',')})&select=id,contest_number`, {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    });

                    if (!lookupResponse.ok) {
                        throw new Error('Failed to lookup contests by number');
                    }

                    const contestsData = await lookupResponse.json();
                    contestIds = contestsData.map(c => c.id);

                    if (contestIds.length < 2) {
                        showAlert('Could not find all contests. Please check the contest numbers.', '‚ùå');
                        state.isLoading = false;
                        render();
                        return;
                    }
                } else {
                    // Already UUIDs, use as-is
                    contestIds = inputIds;
                }

                // Call the PostgreSQL function to get merged results
                const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/get_merged_contest_results`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify({ contest_ids: contestIds })
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch merged results: ${response.statusText}`);
                }

                const mergedData = await response.json();

                if (!mergedData || mergedData.length === 0) {
                    showAlert('No results found for the selected contests', '‚ùå');
                    state.isLoading = false;
                    render();
                    return;
                }

                // Fetch contest details for titles
                const contestDetailsResponse = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=in.(${contestIds.join(',')})&select=id,title`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                const contestDetails = await contestDetailsResponse.json();
                const contestTitles = {};
                contestDetails.forEach(c => {
                    contestTitles[c.id] = c.title;
                });

                // Transform the data for display
                state.mergedResults = {
                    contestIds: contestIds,
                    contestTitles: contestTitles,
                    images: mergedData.map(item => ({
                        id: item.image_id,
                        url: item.image_url,
                        contestId: item.contest_id,
                        averageScore: parseFloat(item.average_score).toFixed(2),
                        totalVotes: item.total_votes,
                        voteBreakdown: item.vote_breakdown
                    }))
                };

                state.view = 'mergedResults';
                state.isLoading = false;

                // Update URL hash with merge
                window.location.hash = `merge=${contestIds.join(',')}`;

                render();
            } catch (error) {
                console.error('Error loading merged results:', error);
                showAlert('Failed to load merged results: ' + error.message, '‚ùå');
                state.isLoading = false;
                render();
            }
        }

        async function loadSharedContest(contestId) {
            try {
                console.log('Loading shared contest:', contestId);

                // Fetch contest from database with aggressive cache-busting
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}&select=*,images(*),creator:users!contests_created_by_fkey(username,avatar)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const contests = await response.json();

                if (!contests || contests.length === 0) {
                    showAlert('Contest not found. It may have been deleted.', '‚ùå');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                const contestData = contests[0];
                const contest = {
                    id: contestData.id,
                    title: contestData.title,
                    isLocked: contestData.is_locked,
                    resultsPublic: contestData.results_public,
                    createdBy: contestData.created_by,
                    creatorName: contestData.creator.username,
                    creatorAvatar: contestData.creator.avatar,
                    createdAt: contestData.created_at,
                    images: contestData.images
                        .sort((a, b) => a.image_order - b.image_order)
                        .map(img => ({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            isFileUpload: img.is_file_upload
                        }))
                };

                // Check if user is banned
                if (state.bannedUsers.includes(state.user?.id)) {
                    showAlert('Your account has been restricted. You cannot access this contest.', 'üö´');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Check if user has already voted
                const hasVoted = state.userVotedContests[contest.id];

                if (hasVoted || contest.isLocked) {
                    // Show results
                    await viewResults(contest);
                } else {
                    // Start voting
                    startVoting(contest);
                }
            } catch (error) {
                console.error('Error loading shared contest:', error);
                showAlert('Failed to load contest: ' + error.message, '‚ùå');
                window.location.hash = '';
                state.view = 'home';
                render();
            }
        }


        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove '#'

            console.log('üîó [NAVIGATION] Hash changed:', hash);

            // Check for merge link: #merge=1,2,3
            if (hash.startsWith('merge=')) {
                const mergeValue = hash.replace('merge=', '');

                // Check if it's a new-style merge (comma-separated numbers)
                if (/^\d+(,\d+)*$/.test(mergeValue)) {
                    console.log('üîó [NAVIGATION] Detected new-style merge link');
                    const contestNumbers = mergeValue.split(',').map(n => parseInt(n.trim()));
                    loadMergedContestsFromNumbers(contestNumbers);
                    return;
                }
                // Old-style merge (UUID) - kept for backward compatibility
                else {
                    console.log('üîó [NAVIGATION] Detected old-style merge link');
                    if (state.isLoggedIn) {
                        loadSharedMerge(mergeValue);
                    }
                    return;
                }
            }

            // Check for single contest share: #contest={uuid}
            const params = new URLSearchParams(hash);
            const contestId = params.get('contest');
            if (contestId && state.isLoggedIn) {
                console.log('üîó [NAVIGATION] Detected contest share link');
                loadSharedContest(contestId);
            }
        }

        function updateImageLabel(index, label) {
            if (state.newContest.images[index]) {
                // Convert Discord CDN URLs to media.discordapp.net for compatibility
                label = label.replace(/cdn\.discordapp\.com/g, 'media.discordapp.net');
                label = label.replace(/images-ext-\d+\.discordapp\.net/g, 'media.discordapp.net');
                state.newContest.images[index].label = label;
            }
        }

        function finishCreateContest() {
            if (state.newContest.images.length === 0) {
                showAlert('Add at least one image!', '‚ùå');
                return;
            }

            // Check for duplicate title
            const duplicateTitle = state.contests.some(c =>
                c.title.toLowerCase().trim() === state.newContest.title.toLowerCase().trim()
            );

            if (duplicateTitle) {
                showAlert('A contest with this title already exists. Please choose a different title.', '‚ùå');
                return;
            }

            // Show confirmation popup
            showConfirm(
                `Create contest "${state.newContest.title}" with ${state.newContest.images.length} images?`,
                'confirmFinishCreateContest',
                'üö®'
            );
        }

        async function confirmFinishCreateContest() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const uploadedUrls = [];
            const localFilesToUpload = state.newContest.images.filter(img => img.isLocalFile);

            try {
                // Step 1: Upload all local files first
                if (localFilesToUpload.length > 0) {
                    setLoading(`Uploading images (0/${localFilesToUpload.length})...`);

                    for (let i = 0; i < localFilesToUpload.length; i++) {
                        const img = localFilesToUpload[i];
                        setLoading(`Uploading images (${i + 1}/${localFilesToUpload.length})...`);

                        // Compress if needed
                        let fileToUpload = img.localFile;
                        if (img.localFile.size > 200 * 1024) {
                            setLoading(`Compressing image ${i + 1}/${localFilesToUpload.length}...`);
                            const compressed = await compressImage(img.localFile);
                            fileToUpload = compressed.file;
                        }

                        // Upload to storage
                        const uploadedUrl = await uploadImageFile(fileToUpload);
                        uploadedUrls.push(uploadedUrl);

                        // Update the image URL in state
                        img.url = uploadedUrl;
                        img.isLocalFile = false;
                        delete img.localFile;
                    }
                }

                // Step 2: Insert contest - database auto-generates UUID
                setLoading('Creating contest...');
                const contestResponse = await fetch(`${SUPABASE_URL}/rest/v1/contests`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        title: state.newContest.title,
                        created_by: state.user.id
                    })
                });

                if (!contestResponse.ok) {
                    const errorData = await contestResponse.json();
                    console.error('Contest creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create contest');
                }

                const createdContests = await contestResponse.json();
                const contestId = createdContests[0].id;

                // Step 3: Insert images
                const imagesToInsert = state.newContest.images.map((img, i) => ({
                    contest_id: contestId,
                    url: img.url,
                    is_file_upload: img.isFileUpload,
                    author: img.author,
                    image_order: i
                }));

                const imagesResponse = await fetch(`${SUPABASE_URL}/rest/v1/images`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify(imagesToInsert)
                });

                if (!imagesResponse.ok) {
                    const errorData = await imagesResponse.json();
                    console.error('Image insertion failed:', errorData);
                    throw new Error(errorData.message || 'Failed to add images');
                }

                // Revoke all Object URLs after successful creation
                state.newContest.images.forEach(img => {
                    if (img.url.startsWith('blob:')) {
                        URL.revokeObjectURL(img.url);
                    }
                });

                state.newContest = { title: '', images: [] };
                await loadContests();
                state.view = 'home';
                state.modalProcessing = false;

                // Show success message
                showAlert('Contest created successfully!', '‚ú®');

            } catch (error) {
                console.error('Full contest creation error:', error);

                // Clean up uploaded files if contest creation failed
                if (uploadedUrls.length > 0) {
                    console.log('Cleaning up uploaded files due to error...');
                    for (const url of uploadedUrls) {
                        try {
                            const fileName = url.split('/').pop();
                            await supabase.storage
                                .from('contest-images')
                                .remove([fileName]);
                        } catch (cleanupError) {
                            console.error('Failed to cleanup file:', cleanupError);
                        }
                    }
                }

                state.modalProcessing = false;
                showAlert('Failed to create contest: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        async function loadImageFromUrl(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                let timedOut = false;

                // Network timeout with specific message
                const timeoutId = setTimeout(() => {
                    timedOut = true;
                    reject(new Error('‚è±Ô∏è Network timeout: Image took too long to load. Possible causes: slow connection, large file size, or server issues. Try a different image or check your internet connection.'));
                }, 10000);

                img.onload = () => {
                    if (!timedOut) {
                        clearTimeout(timeoutId);
                        resolve(img);
                    }
                };

                img.onerror = () => {
                    if (timedOut) return; // Already handled by timeout
                    clearTimeout(timeoutId);

                    // Provide specific error details
                    let errorMsg = '‚ùå Failed to load image.\n\n';

                    // Check URL validity
                    try {
                        new URL(url);
                    } catch {
                        reject(new Error(errorMsg + 'üîó Invalid URL format. Please enter a valid image URL.'));
                        return;
                    }

                    // Check file extension
                    const extension = url.split('?')[0].split('.').pop().toLowerCase();
                    const validExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'];

                    // Provide likely causes based on URL analysis
                    if (url.includes('discord')) {
                        errorMsg += 'üí¨ Discord CDN issue: The link may be expired, deleted, or have restricted access. Try re-uploading the image to Discord and getting a fresh link.';
                    } else if (url.startsWith('http://')) {
                        errorMsg += 'üîí CORS/Security issue: HTTP URLs often have cross-origin restrictions. Try using an HTTPS URL instead, or upload the image to a public image host.';
                    } else if (!validExtensions.includes(extension)) {
                        errorMsg += 'üìÅ Unsupported format: The URL doesn\'t end with a recognized image extension (.jpg, .png, .gif, .webp). Make sure you\'re linking directly to an image file.';
                    } else if (url.includes('imgur') && !url.includes('i.imgur')) {
                        errorMsg += 'üñºÔ∏è Imgur link issue: Use direct image links (i.imgur.com) instead of gallery links. Right-click the image and select "Copy image address".';
                    } else {
                        errorMsg += 'üåê Possible causes:\n‚Ä¢ CORS restrictions from the image host\n‚Ä¢ Broken or expired link\n‚Ä¢ Image was deleted or moved\n‚Ä¢ Server is down or blocking requests\n‚Ä¢ Private/restricted access image\n\nTry uploading to a public image host like Imgur or Discord.';
                    }

                    reject(new Error(errorMsg));
                };

                img.src = url;
            });
        }

        function login() {
            const authUrl = `https://discord.com/oauth2/authorize?client_id=${DISCORD_CLIENT_ID}&redirect_uri=${encodeURIComponent(DISCORD_REDIRECT_URI)}&response_type=token&scope=identify`;
            window.location.href = authUrl;
        }

        function logout() {
            localStorage.removeItem('peony_user');
            state.isLoggedIn = false;
            state.user = null;
            state.view = 'home';
            render();
        }

        async function loadContests() {
            setLoading('Loading contests...');
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?select=*,images(*),creator:users!contests_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const contests = await response.json();

                // Check if contests response is valid
                if (!Array.isArray(contests)) {
                    console.error('Invalid contests response:', contests);
                    throw new Error(contests.message || 'Failed to load contests');
                }

                // Fetch voter counts from the pre-calculated PostgreSQL view
                const voterCountsResponse = await fetch(`${SUPABASE_URL}/rest/v1/contest_voter_counts?select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                if (!voterCountsResponse.ok) {
                    console.error('Failed to fetch voter counts');
                    throw new Error('Failed to load voter counts');
                }

                const voterCountsArray = await voterCountsResponse.json();

                // Check if voter counts response is valid
                if (!Array.isArray(voterCountsArray)) {
                    console.error('Invalid voter counts response:', voterCountsArray);
                    throw new Error(voterCountsArray.message || 'Failed to load voter counts');
                }

                // Create a map of contest_id to voter_count for efficient lookup
                const voterCountsMap = {};
                voterCountsArray.forEach(row => {
                    voterCountsMap[row.contest_id] = row.voter_count;
                });

                // Map contests with their voter counts from the view
                state.contests = contests.map(contest => ({
                    id: contest.id,
                    contestNumber: contest.contest_number,
                    title: contest.title,
                    isLocked: contest.is_locked,
                    resultsPublic: contest.results_public,
                    createdBy: contest.created_by,
                    creatorName: contest.creator.username,
                    creatorAvatar: contest.creator.avatar,
                    createdAt: contest.created_at,
                    voterCount: voterCountsMap[contest.id] || 0,
                    images: contest.images
                        .sort((a, b) => a.image_order - b.image_order)
                        .map(img => ({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            isFileUpload: img.is_file_upload
                        }))
                }));

                render();
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        async function loadMergers() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?select=*,creator:users!mergers_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const mergers = await response.json();
                if (Array.isArray(mergers)) {
                    state.mergers = mergers.map(m => ({
                        id: m.id,
                        name: m.name,
                        createdBy: m.created_by,
                        creatorName: m.creator.username,
                        creatorAvatar: m.creator.avatar,
                        createdAt: m.created_at,
                        contestIds: m.contest_ids,
                        voterCountMin: m.voter_count_min,
                        voterCountMax: m.voter_count_max,
                        type: 'merger'
                    }));
                }
            } catch (error) {
                console.error('Error loading mergers:', error);
            }
        }

        async function loadExtracts() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?select=*,creator:users!extracts_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const extracts = await response.json();
                if (Array.isArray(extracts)) {
                    state.extracts = extracts.map(e => ({
                        id: e.id,
                        name: e.name,
                        createdBy: e.created_by,
                        creatorName: e.creator.username,
                        creatorAvatar: e.creator.avatar,
                        createdAt: e.created_at,
                        sourceContestId: e.source_contest_id,
                        sourceMergerId: e.source_merger_id,
                        sourceType: e.source_type,
                        imageIds: e.image_ids,
                        type: 'extract'
                    }));
                }
            } catch (error) {
                console.error('Error loading extracts:', error);
            }
        }

        async function loadGroups() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?select=*,items:contest_groups(*)&order=display_order.asc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const groups = await response.json();
                if (Array.isArray(groups)) {
                    state.groups = groups;
                }
            } catch (error) {
                console.error('Error loading groups:', error);
            }
        }

        async function loadAppSettings() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const settings = await response.json();
                if (Array.isArray(settings)) {
                    settings.forEach(s => {
                        state.appSettings[s.setting_name] = s.value;
                    });
                }
            } catch (error) {
                console.error('Error loading app settings:', error);
            }
        }

        async function loadUserVotes() {
            if (!state.user) return;

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${state.user.id}&select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const votes = await response.json();

                state.userVotedContests = {};
                votes.forEach(vote => {
                    if (!state.userVotedContests[vote.contest_id]) {
                        state.userVotedContests[vote.contest_id] = {};
                    }
                    state.userVotedContests[vote.contest_id][vote.image_id] = vote.score;
                });
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            }
        }

        // --- ADD: ensureLocalUser (insert this near other helper functions) ---
        function ensureLocalUser(user) {
            // returns a Promise that resolves when the user exists (or after insertion)
            console.log('üë§ Ensuring user exists in database:', user.id, user.username);
            return fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${user.id}`, {
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'Cache-Control': 'no-cache'
                }
            })
            .then(r => r.json())
            .then(rows => {
                if (rows.length === 0) {
                    console.log('üë§ User not found in database, creating new user');
                    // create the user row in public.users
                    return fetch(`${SUPABASE_URL}/rest/v1/users`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify({
                            id: user.id,
                            username: user.username,
                            avatar: user.avatar
                        })
                    }).then(resp => {
                        // If the insert fails, still let caller continue but log error
                        if (!resp.ok) {
                            return resp.text().then(t => {
                                console.error('‚ùå Failed to insert local user:', t);
                                console.error('‚ùå Response status:', resp.status);
                                console.error('‚ùå User data:', { id: user.id, username: user.username, avatar: user.avatar });
                                // swallow error to avoid locking login flow; caller can handle later
                                return;
                            });
                        } else {
                            console.log('‚úÖ User successfully created in database');
                        }
                    });
                } else {
                    console.log('‚úÖ User already exists in database');
                }
                // user already exists: resolve immediately
                return;
            })
            .catch(err => {
                console.error('‚ùå ensureLocalUser error:', err);
                // resolve anyway so login flow continues; caller may show an error later
                return;
            });
        }
        // --- END ADD ---


        function startVoting(contest) {
            state.currentContest = contest;
            state.shuffledImages = shuffleArray(contest.images);
            state.votes = {};
            state.currentImageIndex = 0;
            state.hasSubmitted = false;
            state.results = null;
            state.view = 'vote';

            // Update URL hash for shareable link
            window.location.hash = `contest=${contest.id}`;

            render();
        }

        async function viewResults(contest) {
            // Check if contest still exists in the database
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contest.id}&select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                const contests = await response.json();

                // If contest doesn't exist (deleted), refresh the page
                if (!contests || contests.length === 0) {
                    console.log('Contest no longer exists, refreshing...');
                    showAlert('Contest was deleted. Refreshing...', 'üîÑ');
                    setTimeout(() => location.reload(), 1500);
                    return;
                }

                state.currentContest = contest;
                const userVotes = state.userVotedContests[contest.id] || {};
                state.votes = userVotes;
                await loadResults();
                state.showMyVotes = false;
                state.view = 'results';

                // Update URL hash for shareable link
                window.location.hash = `contest=${contest.id}`;

                render();
            } catch (error) {
                console.error('Error checking contest existence:', error);
                showAlert('Error loading results: ' + error.message, '‚ùå');
            }
        }

        async function viewLockedResults(contest) {
            state.currentContest = contest;
            state.votes = {};
            await loadResults();
            state.showMyVotes = false;
            state.view = 'results';
            render();
        }

        function startRevote() {
            // Show confirmation modal
            state.modal = {
                type: 'confirm',
                icon: 'üîÑ',
                message: 'Re-vote from scratch? Your new votes will replace your old ones when submitted.',
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Start Revote', action: 'confirmRevote', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function confirmRevote() {
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Reset voting state with clean slate
            state.votes = {};
            state.hasSubmitted = false;
            state.shuffledImages = shuffleArray(state.currentContest.images);
            state.currentImageIndex = 0;
            state.view = 'vote';

            render();
        }

        async function toggleContestLock(contestId) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) return;

            // Only the creator or admin can lock/unlock
            if (contest.createdBy !== state.user.id && state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Only the creator or admin can lock/unlock this contest.', 'üîí');
                return;
            }

            const newLockStatus = !contest.isLocked;

            try {
                // Update database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_locked: newLockStatus
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Lock status update failed:', errorData);
                    throw new Error(errorData.message || 'Failed to update lock status');
                }

                // Update local state only if database update succeeded
                contest.isLocked = newLockStatus;
                showAlert(contest.isLocked ? 'üîí Contest locked - Users cannot vote' : 'üîì Contest unlocked - Users can now vote', contest.isLocked ? 'üö®' : '‚úÖ');
                render();
            } catch (error) {
                console.error('Full lock toggle error:', error);
                showAlert('Failed to update lock status: ' + error.message, '‚ùå');
            }
        }

        // ==================== MERGER SYSTEM FUNCTIONS ====================

        function openCreateMergerModal() {
            state.showCreateMergerModal = true;
            state.selectedContestsForMerge = [];
            state.newMergerName = '';
            document.body.classList.add('modal-open');
            render();
        }

        function closeCreateMergerModal() {
            state.showCreateMergerModal = false;
            state.selectedContestsForMerge = [];
            state.newMergerName = '';
            document.body.classList.remove('modal-open');
            render();
        }

        function toggleContestForMerger(contestId) {
            if (!state.selectedContestsForMerge) {
                state.selectedContestsForMerge = [];
            }

            const index = state.selectedContestsForMerge.indexOf(contestId);
            if (index > -1) {
                state.selectedContestsForMerge.splice(index, 1);
            } else {
                state.selectedContestsForMerge.push(contestId);
            }
            render();
        }

        function setMergerName(name) {
            state.newMergerName = name;
            render();
        }

        async function saveMerger() {
            if (state.selectedContestsForMerge.length < 2) {
                showToast('Please select at least 2 contests', 'error');
                return;
            }

            if (!state.newMergerName || state.newMergerName.trim() === '') {
                showToast('Please enter a name for the merger', 'error');
                return;
            }

            setLoading('Creating merger...');

            try {
                // Calculate voter count min/max across selected contests
                const selectedContests = state.contests.filter(c => state.selectedContestsForMerge.includes(c.id));
                const voterCounts = selectedContests.map(c => c.voterCount || 0);
                const voterCountMin = Math.min(...voterCounts);
                const voterCountMax = Math.max(...voterCounts);

                // Save to mergers table
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify({
                        name: state.newMergerName.trim(),
                        created_by: state.user.id,
                        contest_ids: state.selectedContestsForMerge,
                        voter_count_min: voterCountMin,
                        voter_count_max: voterCountMax
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Merger creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create merger');
                }

                // Reload mergers
                await loadMergers();

                showToast('Merger created successfully!', 'success');
                closeCreateMergerModal();
            } catch (error) {
                console.error('Error creating merger:', error);
                showToast('Failed to create merger: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        async function deleteMerger(mergerId) {
            if (!confirm('Are you sure you want to delete this merger? This action cannot be undone.')) {
                return;
            }

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?id=eq.${mergerId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Merger deletion failed:', errorData);
                    throw new Error(errorData.message || 'Failed to delete merger');
                }

                // Reload mergers
                await loadMergers();

                showToast('Merger deleted successfully', 'success');
                render();
            } catch (error) {
                console.error('Error deleting merger:', error);
                showToast('Failed to delete merger: ' + error.message, 'error');
            }
        }

        async function viewMergerResults(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Load merged results
            state.selectedContestsForMerge = merger.contestIds;
            await viewSelectedMerge();
        }

        async function startMergerVoting(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Filter out locked contests
            const unlockedContests = mergedContests.filter(c => !c.isLocked);

            if (unlockedContests.length === 0) {
                showToast('All contests in this merger are locked', 'error');
                return;
            }

            // Start voting on the first unlocked contest
            startVoting(unlockedContests[0]);
        }

        function showMergerVoteModal(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Find which contests user hasn't voted in
            const unvotedContests = mergedContests.filter(c => !state.userVotedContests[c.id]);
            const votedContests = mergedContests.filter(c => state.userVotedContests[c.id]);

            // Show modal with options
            const message = `You've voted in ${votedContests.length} out of ${mergedContests.length} contests.\n\nUnvoted contests:\n${unvotedContests.map(c => '‚Ä¢ ' + c.title).join('\n')}\n\nWhat would you like to do?`;

            state.modal = {
                title: 'Partial Votes - ' + merger.name,
                message: message,
                actions: [
                    {
                        text: 'Vote Missing Only',
                        style: 'primary',
                        action: () => {
                            state.modal = null;
                            document.body.classList.remove('modal-open');
                            if (unvotedContests.length > 0) {
                                startVoting(unvotedContests[0]);
                            }
                        }
                    },
                    {
                        text: 'Revote All',
                        style: 'warning',
                        action: () => {
                            state.modal = null;
                            document.body.classList.remove('modal-open');
                            if (mergedContests.length > 0) {
                                startVoting(mergedContests[0]);
                            }
                        }
                    },
                    {
                        text: 'Cancel',
                        style: 'secondary',
                        action: () => {
                            state.modal = null;
                            document.body.classList.remove('modal-open');
                            render();
                        }
                    }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        async function shareMerger(mergerId) {
            try {
                const shareUrl = `${window.location.origin}${window.location.pathname}#merge=${mergerId}`;

                if (navigator.share) {
                    await navigator.share({
                        title: 'Peony - Merger',
                        text: 'Check out this merged contest!',
                        url: shareUrl
                    });
                    showToast('Share successful!', 'success');
                } else {
                    await navigator.clipboard.writeText(shareUrl);
                    showToast('Link copied to clipboard!', 'success');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Share error:', error);
                    showToast('Failed to share', 'error');
                }
            }
        }

        // ==================== END MERGER SYSTEM FUNCTIONS ====================

        // ==================== EXTRACT SYSTEM FUNCTIONS ====================

        function openCreateExtractModal() {
            state.showCreateExtractModal = true;
            state.extractSourceType = null;
            state.extractSourceId = null;
            state.extractSelectedImages = [];
            state.newExtractName = '';
            document.body.classList.add('modal-open');
            render();
        }

        function closeCreateExtractModal() {
            state.showCreateExtractModal = false;
            state.extractSourceType = null;
            state.extractSourceId = null;
            state.extractSelectedImages = [];
            state.newExtractName = '';
            document.body.classList.remove('modal-open');
            render();
        }

        function selectExtractSource(sourceType, sourceId) {
            state.extractSourceType = sourceType;
            state.extractSourceId = sourceId;
            state.extractSelectedImages = [];
            render();
        }

        function toggleExtractImage(imageId) {
            if (!state.extractSelectedImages) {
                state.extractSelectedImages = [];
            }

            const index = state.extractSelectedImages.indexOf(imageId);
            if (index > -1) {
                state.extractSelectedImages.splice(index, 1);
            } else {
                state.extractSelectedImages.push(imageId);
            }
            render();
        }

        function setExtractName(name) {
            state.newExtractName = name;
            render();
        }

        async function saveExtract() {
            if (!state.extractSelectedImages || state.extractSelectedImages.length === 0) {
                showToast('Please select at least one image', 'error');
                return;
            }

            if (!state.newExtractName || state.newExtractName.trim() === '') {
                showToast('Please enter a name for the extract', 'error');
                return;
            }

            setLoading('Creating extract...');

            try {
                const extractData = {
                    name: state.newExtractName.trim(),
                    created_by: state.user.id,
                    source_type: state.extractSourceType,
                    image_ids: state.extractSelectedImages
                };

                if (state.extractSourceType === 'contest') {
                    extractData.source_contest_id = state.extractSourceId;
                    extractData.source_merger_id = null;
                } else if (state.extractSourceType === 'merger') {
                    extractData.source_contest_id = null;
                    extractData.source_merger_id = state.extractSourceId;
                }

                // Save to extracts table
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify(extractData)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create extract');
                }

                // Reload extracts
                await loadExtracts();

                showToast('Extract created successfully!', 'success');
                closeCreateExtractModal();
            } catch (error) {
                console.error('Error creating extract:', error);
                showToast('Failed to create extract: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        async function deleteExtract(extractId) {
            if (!confirm('Are you sure you want to delete this extract? This action cannot be undone.')) {
                return;
            }

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?id=eq.${extractId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract deletion failed:', errorData);
                    throw new Error(errorData.message || 'Failed to delete extract');
                }

                // Reload extracts
                await loadExtracts();

                showToast('Extract deleted successfully', 'success');
                render();
            } catch (error) {
                console.error('Error deleting extract:', error);
                showToast('Failed to delete extract: ' + error.message, 'error');
            }
        }

        async function startExtractVoting(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Get source contest to find the images
            let sourceContest = null;
            if (extract.sourceType === 'contest') {
                sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
            } else if (extract.sourceType === 'merger') {
                // For mergers, we need to get all images from all merged contests
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    // Create a temporary contest object with all merged images
                    const allImages = mergedContests.flatMap(c => c.images);
                    sourceContest = {
                        id: 'extract_' + extractId,
                        title: extract.name,
                        images: allImages.filter(img => extract.imageIds.includes(img.id)),
                        createdBy: extract.createdBy,
                        creatorName: extract.creatorName,
                        creatorAvatar: extract.creatorAvatar
                    };
                }
            }

            if (!sourceContest) {
                showToast('Source not found', 'error');
                return;
            }

            // Filter images to only those in the extract
            const extractImages = sourceContest.images.filter(img => extract.imageIds.includes(img.id));

            // Create a temporary contest object for voting
            const extractContest = {
                ...sourceContest,
                images: extractImages,
                title: extract.name,
                id: extract.sourceContestId || sourceContest.id
            };

            startVoting(extractContest);
        }

        async function viewExtractResults(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Get source contest
            let sourceContest = null;
            if (extract.sourceType === 'contest') {
                sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
            } else if (extract.sourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    const allImages = mergedContests.flatMap(c => c.images);
                    sourceContest = {
                        id: 'extract_' + extractId,
                        title: extract.name,
                        images: allImages.filter(img => extract.imageIds.includes(img.id)),
                        createdBy: extract.createdBy,
                        creatorName: extract.creatorName,
                        creatorAvatar: extract.creatorAvatar
                    };
                }
            }

            if (!sourceContest) {
                showToast('Source not found', 'error');
                return;
            }

            // Filter images to only those in the extract
            const extractImages = sourceContest.images.filter(img => extract.imageIds.includes(img.id));

            // Create a temporary contest object for results
            const extractContest = {
                ...sourceContest,
                images: extractImages,
                title: extract.name,
                id: extract.sourceContestId || sourceContest.id
            };

            viewResults(extractContest);
        }

        // ==================== END EXTRACT SYSTEM FUNCTIONS ====================

        function handleVote(score) {
            if (state.isAnimating) return;
            
            state.isAnimating = true;
            const currentImage = state.shuffledImages[state.currentImageIndex];
            state.votes[currentImage.id] = score;
            state.showTickAnimation = true;
            
            render();

            setTimeout(() => {
                state.showTickAnimation = false;
                state.isAnimating = false;
                if (state.currentImageIndex < state.shuffledImages.length - 1) {
                    state.currentImageIndex++;
                }
                render();
            }, 500);
        }

        function navigateImage(direction) {
            if (direction === 'next') {
                if (state.currentImageIndex < state.shuffledImages.length - 1) {
                    state.currentImageIndex++;
                }
            } else if (direction === 'prev' && state.currentImageIndex > 0) {
                state.currentImageIndex--;
            }
            render();
        }

        function jumpToImage(index) {
            if (state.isAnimating) return;
            state.currentImageIndex = index;
            render();
        }

        function cancelVoting() {
            showConfirm(
                'Your progress will be lost if you proceed. Are you sure?',
                'confirmCancelVoting',
                'üö®'
            );
        }

        function submitVotes() {
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);
            if (!allVoted) {
                showAlert('Please vote on all images before submitting!', '‚ùå');
                return;
            }
            showConfirm(
                'Your votes cannot be changed after submission. If you made a mistake, you can contact me.',
                'confirmSubmitVotes',
                'üó≥Ô∏è'
            );
        }

        function showBreakdown(imageId) {
            state.showBreakdownModal = imageId;
            document.body.classList.add('modal-open');
            render();
        }

        function showVoterVotes(username) {
            // Set viewing specific user
            state.viewingSpecificUser = username;
            state.showMyVotes = false;
            state.showVoterBreakdown = false;

            // Filter mockResults to show only images with this user's votes
            // and update the results to show this user's score as the primary score
            state.results = state.results.map(img => {
                const vote = img.breakdown.find(v => v.username === username);
                if (vote) {
                    return {
                        ...img,
                        averageScore: vote.score,
                        userSpecificScore: vote.score
                    };
                }
                return null;
            }).filter(img => img !== null)
            .sort((a, b) => b.averageScore - a.averageScore);

            render();
        }

        function viewUserVotes(username) {
            // Alias for showVoterVotes for clarity
            showVoterVotes(username);
        }

        async function clearUserVotesView() {
            state.viewingSpecificUser = null;
            state.showVoterBreakdown = true;
            // Regenerate full results
            if (state.currentContest) {
                await loadResults();
            }
            render();
        }

        function closeBreakdown() {
            state.showBreakdownModal = null;
            document.body.classList.remove('modal-open');
            render();
        }

        // Admin vote editing
        async function adminEditVote(userId, imageId, currentScore) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Admin access required', 'üîí');
                return;
            }

            // Show modal with score buttons
            const voteData = state.results.find(r => r.id === imageId)?.breakdown.find(v => v.userId === userId);
            if (!voteData) return;

            showModal({
                type: 'custom',
                title: `Edit ${voteData.username}'s Vote`,
                icon: '‚úèÔ∏è',
                message: `Current score: ${currentScore}\nSelect new score:`,
                buttons: [1, 2, 3, 4, 5].map(score => ({
                    text: score.toString(),
                    primary: false,
                    action: `confirmEditVote_${userId}_${imageId}_${currentScore}_${score}`
                })).concat([{
                    text: 'Cancel',
                    primary: false,
                    action: 'closeModal'
                }])
            });
        }

        async function confirmEditVote(userId, imageId, oldScore, newScore) {
            try {
                // Close modal FIRST before setting modalProcessing
                state.modal = null;
                document.body.classList.remove('modal-open');
                render();

                state.modalProcessing = true;
                setLoading('Updating vote...');

                // Find the contest ID for this image
                const contestId = state.currentContest.id;

                // Update vote in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&image_id=eq.${imageId}&contest_id=eq.${contestId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({ score: parseInt(newScore) })
                });

                if (!response.ok) {
                    throw new Error('Failed to update vote');
                }

                showToast(`Vote updated from ${oldScore} to ${newScore}`, 'success');

                // Reload results to get fresh data
                await loadResults();
                clearLoading();

            } catch (error) {
                console.error('Error updating vote:', error);
                clearLoading();
                showAlert('Failed to update vote: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            }
        }

        // Admin vote blocking
        async function adminToggleBlockVote(userId, imageId, currentlyBlocked) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Admin access required', 'üîí');
                return;
            }

            const voteData = state.results.find(r => r.id === imageId)?.breakdown.find(v => v.userId === userId);
            if (!voteData) return;

            const action = currentlyBlocked ? 'unblock' : 'block';
            showConfirm(
                `Are you sure you want to ${action} ${voteData.username}'s vote?`,
                `executeToggleBlockVote_${userId}_${imageId}_${!currentlyBlocked}`,
                'üö´'
            );
        }

        async function executeToggleBlockVote(userId, imageId, shouldBlock) {
            try {
                // Close modal FIRST before setting modalProcessing
                state.modal = null;
                document.body.classList.remove('modal-open');
                render();

                state.modalProcessing = true;
                setLoading(shouldBlock ? 'Blocking vote...' : 'Unblocking vote...');

                // Find the contest ID for this image
                const contestId = state.currentContest.id;

                // Update vote in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&image_id=eq.${imageId}&contest_id=eq.${contestId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({ is_blocked: shouldBlock })
                });

                if (!response.ok) {
                    throw new Error('Failed to update vote block status');
                }

                showToast(`Vote ${shouldBlock ? 'blocked' : 'unblocked'}`, 'success');

                // Reload results to get fresh data with updated ban status
                await loadResults();

                // Re-render to refresh the breakdown modal
                render();

            } catch (error) {
                console.error('Error toggling vote block:', error);
                showAlert('Failed to toggle vote block: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
                state.modalProcessing = false;
            }
        }


        async function backToHome() {
            console.log('üè† [NAVIGATION] Returning to home from view:', state.view);

            if (state.view === 'vote' && !state.hasSubmitted && state.currentContest && state.currentContest.images) {
                showConfirm(
                    'Your progress will be lost if you proceed. Are you sure?',
                    'confirmBackToHome',
                    'üö®'
                );
                return;
            }

            // Refresh contest list (this now includes fresh voter counts)
            console.log('üîÑ [CLEANUP] Refreshing contest list');
            await loadContests();

            // Reset all contest-related state
            state.view = 'home';
            state.currentContest = null;
            state.showBreakdownModal = null;
            state.results = null;
            state.mergedResults = null;
            state.showMyVotes = false;
            state.resultsView = 'average';
            state.selectedVoterUserId = null;
            state.contestVoters = [];

            // Clear URL hash
            window.location.hash = '';

            console.log('‚úÖ [NAVIGATION] Successfully returned to home');

            render();
        }

        function confirmBackToHome() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Reset all contest-related state with null checks
            state.view = 'home';
            state.currentContest = null;
            state.showBreakdownModal = null;
            state.results = null;
            state.showMyVotes = false;
            state.resultsView = 'average';
            state.selectedVoterUserId = null;
            state.contestVoters = [];

            state.modalProcessing = false;
            render();
        }

        function toggleVoteView() {
            state.showMyVotes = !state.showMyVotes;
            render();
        }

        function setResultsView(view, userId = null) {
            state.resultsView = view;
            state.showMyVotes = view === 'userVotes';  // Backwards compatibility

            // Reset selected voter when changing views
            if (view !== 'userVotes') {
                state.selectedVoterUserId = null;
            } else if (userId !== null) {
                // If userId provided, select that user
                state.selectedVoterUserId = userId;
            } else if (state.selectedVoterUserId === null) {
                // Default to current user if not already selected
                state.selectedVoterUserId = state.user?.id || null;
            }

            render();
        }

        function updateScale(value) {
            clearTimeout(state.scaleUpdateTimeout);
            state.scaleUpdateTimeout = setTimeout(() => {
                state.imageScale = parseInt(value);
                render();
            }, 200);
        }

        function adjustScale(delta) {
            const newScale = Math.max(40, Math.min(200, state.imageScale + delta));
            state.imageScale = newScale;
            render();
        }

        async function showAdminDashboard() {
            try {
                // Load all users from database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?select=*&order=username.asc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Failed to load users:', errorData);
                    throw new Error(errorData.message || 'Failed to load users');
                }

                const users = await response.json();
                console.log('üìä Loaded users from database:', users);

                // Update state with all users (including current user, banned users, etc.)
                state.allUsers = users.map(user => ({
                    id: user.id,
                    username: user.username,
                    avatar: user.avatar,
                    isBanned: user.is_banned || false
                }));

                console.log('üìä All users in state:', state.allUsers);

                // Fetch admin statistics from database with aggressive cache-busting
                const voterResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?select=user_id`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const votes = await voterResponse.json();

                // Check if votes response is valid
                if (!Array.isArray(votes)) {
                    console.error('Invalid votes response:', votes);
                    throw new Error(votes.message || 'Failed to load voter statistics');
                }

                // Count unique voters from users table
                const totalUniqueVoters = users.length;

                // Count total votes using COUNT(*)
                const votesCountResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'count=exact',
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                // Parse count from Content-Range header (e.g., "0-99/150" means 150 total)
                const contentRange = votesCountResponse.headers.get('Content-Range');
                const totalVotes = contentRange ? parseInt(contentRange.split('/')[1]) : 0;

                state.adminStats = { totalVotes, totalUniqueVoters };

                state.showAdminDashboard = true;
                document.body.classList.add('modal-open');
                render();
            } catch (error) {
                console.error('Error loading admin dashboard:', error);
                showAlert('Failed to load admin dashboard: ' + error.message, '‚ùå');
            }
        }

        function closeAdminDashboard() {
            state.showAdminDashboard = false;
            document.body.classList.remove('modal-open');
            render();
        }

        async function showAppSettings() {
            state.showAppSettingsModal = true;
            state.showUserDropdown = false;
            document.body.classList.add('modal-open');
            render();
        }

        function closeAppSettings() {
            state.showAppSettingsModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        async function toggleAppSetting(settingName) {
            try {
                // Get current value (default to true if not set)
                const currentValue = state.appSettings[settingName] !== false;
                const newValue = !currentValue;

                // Update in database
                // First, check if setting exists
                const checkResponse = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                const existingSettings = await checkResponse.json();

                if (existingSettings.length > 0) {
                    // Update existing setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update setting');
                    }
                } else {
                    // Insert new setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            setting_name: settingName,
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create setting');
                    }
                }

                // Update local state
                state.appSettings[settingName] = newValue;

                showToast(
                    `${settingName.replace(/_/g, ' ')} ${newValue ? 'enabled' : 'disabled'}`,
                    'success'
                );
                render();
            } catch (error) {
                console.error('Error toggling app setting:', error);
                showToast('Failed to update setting: ' + error.message, 'error');
            }
        }

        // ==================== FOLDER MANAGEMENT ====================

        async function openManageFoldersModal() {
            state.showManageFoldersModal = true;
            state.showUserDropdown = false;
            document.body.classList.add('modal-open');
            await loadGroups();
            render();
        }

        function closeManageFoldersModal() {
            state.showManageFoldersModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        async function createFolder() {
            const folderName = prompt('Enter folder name:');
            if (!folderName || !folderName.trim()) return;

            try {
                setLoading('Creating folder...');
                const maxOrder = state.groups.length > 0 ? Math.max(...state.groups.map(g => g.display_order || 0)) : 0;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        name: folderName.trim(),
                        display_order: maxOrder + 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to create folder');
                }

                await loadGroups();
                showToast('Folder created successfully', 'success');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error creating folder:', error);
                showToast('Failed to create folder: ' + error.message, 'error');
                clearLoading();
            }
        }

        async function deleteFolder(folderId) {
            if (!confirm('Delete this folder? Items will not be deleted, only ungrouped.')) return;

            try {
                setLoading('Deleting folder...');

                // First delete all contest_groups entries for this folder
                await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${folderId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                // Then delete the group itself
                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?id=eq.${folderId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete folder');
                }

                await loadGroups();
                showToast('Folder deleted successfully', 'success');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error deleting folder:', error);
                showToast('Failed to delete folder: ' + error.message, 'error');
                clearLoading();
            }
        }

        async function addItemToFolder(folderId) {
            // Get all available items
            const allItems = [
                ...state.contests.map(c => ({ id: c.id, type: 'contest', title: c.title })),
                ...state.mergers.map(m => ({ id: m.id, type: 'merger', title: m.name })),
                ...state.extracts.map(e => ({ id: e.id, type: 'extract', title: e.name }))
            ];

            // Filter out items already in this folder
            const folder = state.groups.find(g => g.id === folderId);
            const folderItemIds = folder?.items?.map(i => `${i.item_type}:${i.item_id}`) || [];
            const availableItems = allItems.filter(item => !folderItemIds.includes(`${item.type}:${item.id}`));

            if (availableItems.length === 0) {
                showToast('No items available to add', 'info');
                return;
            }

            // Create a simple selection dialog
            const itemsHTML = availableItems.map(item =>
                `<option value="${item.type}:${item.id}">[${item.type.toUpperCase()}] ${item.title}</option>`
            ).join('');

            const selection = prompt('Enter item number from console (check browser console for list)');
            console.log('Available items:', availableItems.map((item, idx) => `${idx}: [${item.type.toUpperCase()}] ${item.title}`));

            if (!selection) return;

            const idx = parseInt(selection);
            if (isNaN(idx) || idx < 0 || idx >= availableItems.length) {
                showToast('Invalid selection', 'error');
                return;
            }

            const selectedItem = availableItems[idx];

            try {
                setLoading('Adding item to folder...');
                const maxOrder = folder?.items?.length > 0 ? Math.max(...folder.items.map(i => i.display_order || 0)) : 0;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        group_id: folderId,
                        item_id: selectedItem.id,
                        item_type: selectedItem.type,
                        display_order: maxOrder + 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to add item to folder');
                }

                await loadGroups();
                showToast('Item added to folder successfully', 'success');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error adding item to folder:', error);
                showToast('Failed to add item to folder: ' + error.message, 'error');
                clearLoading();
            }
        }

        async function removeItemFromFolder(groupId, itemId, itemType) {
            try {
                setLoading('Removing item from folder...');

                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${groupId}&item_id=eq.${itemId}&item_type=eq.${itemType}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to remove item from folder');
                }

                await loadGroups();
                showToast('Item removed from folder', 'success');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error removing item from folder:', error);
                showToast('Failed to remove item: ' + error.message, 'error');
                clearLoading();
            }
        }

        async function saveFolderOrder(folderId, newOrder) {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?id=eq.${folderId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify({
                        display_order: newOrder
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to update folder order');
                }
            } catch (error) {
                console.error('Error saving folder order:', error);
            }
        }

        function toggleFolderExpanded(folderId) {
            const index = state.expandedFolderIds.indexOf(folderId);
            if (index > -1) {
                state.expandedFolderIds.splice(index, 1);
            } else {
                state.expandedFolderIds.push(folderId);
            }
            render();
        }


        function viewAllByCreator(userId) {
            state.filters.createdBy = userId;
            state.view = 'home';
            render();
        }

        async function banUser(userId, banReason) {
            try {
                // Update database with ban status and reason
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${userId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_banned: true,
                        ban_reason: banReason
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to ban user in database');
                }

                // Update local state
                if (!state.bannedUsers.includes(userId)) {
                    state.bannedUsers.push(userId);
                }

                // Update allUsers state
                const userIndex = state.allUsers.findIndex(u => u.id === userId);
                if (userIndex !== -1) {
                    state.allUsers[userIndex].isBanned = true;
                    state.allUsers[userIndex].banReason = banReason;
                }

                // Reload results to refresh vote data with updated ban status
                if (state.view === 'results' && state.currentContest) {
                    await loadResults();
                }

                showAlert('User has been banned.', '‚úÖ');
                render();
            } catch (error) {
                console.error('Error banning user:', error);
                showAlert('Failed to ban user: ' + error.message, '‚ùå');
            }
        }

        async function unbanUser(userId) {
            try {
                // Update database - clear ban status and reason
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${userId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_banned: false,
                        ban_reason: null
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to unban user in database');
                }

                // Update local state
                state.bannedUsers = state.bannedUsers.filter(id => id !== userId);

                // Update allUsers state
                const userIndex = state.allUsers.findIndex(u => u.id === userId);
                if (userIndex !== -1) {
                    state.allUsers[userIndex].isBanned = false;
                    state.allUsers[userIndex].banReason = null;
                }

                // Reload results to refresh vote data with updated ban status
                if (state.view === 'results' && state.currentContest) {
                    await loadResults();
                }

                showAlert('User has been unbanned. Their votes will now be included in results.', '‚úÖ');
                render();
            } catch (error) {
                console.error('Error unbanning user:', error);
                showAlert('Failed to unban user: ' + error.message, '‚ùå');
            }
        }

        function confirmBanUser(userId) {
            // Store userId for later use
            state.userToBan = userId;
            showInputModal(
                'Ban User - Enter Reason',
                'e.g., spam, inappropriate content, etc.',
                'handleBanUserReason',
                false
            );
        }

        function handleBanUserReason() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const banReason = input ? input.value.trim() : '';

            if (!banReason || banReason.length === 0) {
                showAlert('Ban reason cannot be empty.', '‚ùå');
                return;
            }
            if (banReason.length > 500) {
                showAlert('Ban reason is too long (max 500 characters).', '‚ùå');
                return;
            }

            // Proceed with ban
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            banUser(state.userToBan, banReason);
            state.userToBan = null;
            state.modalProcessing = false;
        }

        function executeBanUser(userId) {
            // This function is no longer used, but kept for backwards compatibility
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            banUser(userId, 'No reason provided');
            state.modalProcessing = false;
        }


        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (state.showBreakdownModal) {
                    closeBreakdown();
                } else if (state.modal) {
                    closeModal();
                }
            }
        });

        function renderToast() {
            if (!state.toast) return '';

            return `
                <div class="fixed top-4 left-1/2 transform -translate-x-1/2 z-[70] toast-notification">
                    <div class="bg-white rounded-lg shadow-2xl px-6 py-3 flex items-center gap-3 border-2 border-green-500">
                        <span class="text-2xl">${state.toast.icon}</span>
                        <span class="text-sm font-semibold text-gray-800">${state.toast.message}</span>
                    </div>
                </div>
            `;
        }

        function renderModal() {
            if (!state.modal) return '';

            const isInput = state.modal.type === 'input';

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 modal-content" onclick="event.stopPropagation()">
                        <div class="text-center mb-2">
                            <div class="text-5xl mb-2">${state.modal.icon}</div>
                            ${isInput ? `
                                <h3 class="text-xl font-bold text-gray-800 mb-2">${state.modal.title}</h3>
                                <input type="text" class="modal-input w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-mauve-400 focus:outline-none" placeholder="${state.modal.placeholder}" />
                            ` : `
                                <p class="text-base font-bold text-gray-800 whitespace-pre-line">${state.modal.message}</p>
                            `}
                        </div>
                        <div class="flex gap-2 justify-center">
                            ${state.modal.buttons.map(btn => {
                                const deleteContestMatch = btn.action.match(/confirmDeleteContest_(.+)/);
                                const banUserMatch = btn.action.match(/executeBanUser_(.+)/);
                                const removeImageMatch = btn.action.match(/confirmRemoveImage_(.+)/);
                                const editVoteMatch = btn.action.match(/confirmEditVote_(.+)_(.+)_(.+)_(.+)/);
                                const toggleBlockMatch = btn.action.match(/executeToggleBlockVote_(.+)_(.+)_(true|false)/);
                                let onclick;
                                if (deleteContestMatch) {
                                    onclick = `confirmDeleteContest('${deleteContestMatch[1]}')`;
                                } else if (banUserMatch) {
                                    onclick = `executeBanUser('${banUserMatch[1]}')`;
                                } else if (removeImageMatch) {
                                    onclick = `confirmRemoveImage(${removeImageMatch[1]})`;
                                } else if (editVoteMatch) {
                                    onclick = `confirmEditVote('${editVoteMatch[1]}', ${editVoteMatch[2]}, ${editVoteMatch[3]}, ${editVoteMatch[4]})`;
                                } else if (toggleBlockMatch) {
                                    onclick = `executeToggleBlockVote('${toggleBlockMatch[1]}', ${toggleBlockMatch[2]}, ${toggleBlockMatch[3]})`;
                                } else {
                                    onclick = `${btn.action}()`;
                                }
                                return `
                                    <button
                                        onclick="${onclick}"
                                        class="px-5 py-2 rounded-lg font-semibold transition text-sm ${
                                            btn.primary
                                                ? 'bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700'
                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                        }"
                                    >
                                        ${btn.text}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderMergeModal() {
            if (!state.showMergeModal) return '';

            const selectedCount = state.selectedContestsForMerge.length;
            const currentContestId = state.currentContest?.id;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeMergeModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">Merge Contests</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        Select contests to merge (${selectedCount} selected, min 2 required)
                                    </p>
                                </div>
                                <button onclick="closeMergeModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Contest List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-2">
                            ${state.contests.map(contest => {
                                const isCurrentContest = contest.id === currentContestId;
                                const isSelected = state.selectedContestsForMerge.includes(contest.id);
                                const isDisabled = isCurrentContest;

                                return `
                                    <div class="border ${isSelected ? 'border-blue-400 bg-blue-50' : 'border-gray-200'} rounded-lg p-3 flex items-center gap-3 ${isDisabled ? 'opacity-75' : 'cursor-pointer hover:border-blue-300'}"
                                         ${!isDisabled ? `onclick="toggleContestSelection('${contest.id}')"` : ''}>
                                        <input
                                            type="checkbox"
                                            ${isSelected ? 'checked' : ''}
                                            ${isDisabled ? 'disabled' : ''}
                                            class="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500 ${isDisabled ? 'cursor-not-allowed' : 'cursor-pointer'}"
                                            onclick="event.stopPropagation()"
                                            onchange="toggleContestSelection('${contest.id}')"
                                        />
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h4 class="font-semibold text-gray-800 truncate">${contest.title}</h4>
                                                ${isCurrentContest ? '<span class="text-xs bg-blue-500 text-white px-2 py-0.5 rounded">Current</span>' : ''}
                                            </div>
                                            <p class="text-xs text-gray-500">
                                                ${contest.creatorName} ‚Ä¢ ${contest.imageCount || 0} images ‚Ä¢ ${contest.voterCount || 0} voters
                                            </p>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <!-- Footer -->
                        <div class="p-6 border-t border-gray-200 flex gap-3">
                            <button
                                onclick="closeMergeModal()"
                                class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                            >
                                Cancel
                            </button>
                            <button
                                onclick="viewSelectedMerge()"
                                class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedCount >= 2 ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                ${selectedCount < 2 ? 'disabled' : ''}
                            >
                                Merge & View Results
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCreateExtractModal() {
            if (!state.showCreateExtractModal) return '';

            // Step 1: Select source (contest or merger)
            if (!state.extractSourceType) {
                return `
                    <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeCreateExtractModal()">
                        <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                            <!-- Header -->
                            <div class="p-6 border-b border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <h3 class="text-xl font-bold text-gray-800">Create Extract - Select Source</h3>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Choose a contest or merger to extract images from
                                        </p>
                                    </div>
                                    <button onclick="closeCreateExtractModal()" class="text-gray-500 hover:text-gray-700">
                                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>

                            <!-- Source Selection -->
                            <div class="flex-1 overflow-y-auto p-6">
                                <div class="mb-4">
                                    <h4 class="font-semibold text-gray-700 mb-2">Contests</h4>
                                    <div class="space-y-2">
                                        ${state.contests.map(contest => `
                                            <div class="border border-gray-200 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-yellow-400 hover:bg-yellow-50"
                                                 onclick="selectExtractSource('contest', '${contest.id}')">
                                                <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                <div class="flex-1 min-w-0">
                                                    <h5 class="font-semibold text-gray-800 truncate">${contest.title}</h5>
                                                    <p class="text-xs text-gray-500">
                                                        ${contest.creatorName} ‚Ä¢ ${contest.images.length} images
                                                    </p>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>

                                ${state.mergers.length > 0 ? `
                                    <div>
                                        <h4 class="font-semibold text-gray-700 mb-2">Mergers</h4>
                                        <div class="space-y-2">
                                            ${state.mergers.map(merger => {
                                                const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                                                const totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);
                                                return `
                                                    <div class="border border-gray-200 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-yellow-400 hover:bg-yellow-50"
                                                         onclick="selectExtractSource('merger', '${merger.id}')">
                                                        <img src="${merger.creatorAvatar}" alt="${merger.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                        <div class="flex-1 min-w-0">
                                                            <h5 class="font-semibold text-gray-800 truncate">${merger.name}</h5>
                                                            <p class="text-xs text-gray-500">
                                                                ${merger.creatorName} ‚Ä¢ ${totalImages} images from ${mergedContests.length} contests
                                                            </p>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }

            // Step 2: Visual image picker
            let sourceImages = [];
            let sourceName = '';

            if (state.extractSourceType === 'contest') {
                const contest = state.contests.find(c => c.id === state.extractSourceId);
                if (contest) {
                    sourceImages = contest.images;
                    sourceName = contest.title;
                }
            } else if (state.extractSourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === state.extractSourceId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceImages = mergedContests.flatMap(c => c.images);
                    sourceName = merger.name;
                }
            }

            const selectedCount = (state.extractSelectedImages || []).length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeCreateExtractModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">Create Extract - Select Images</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        From: ${sourceName} (${selectedCount} selected)
                                    </p>
                                </div>
                                <button onclick="closeCreateExtractModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Image Grid -->
                        <div class="flex-1 overflow-y-auto p-6">
                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                                ${sourceImages.map(image => {
                                    const isSelected = (state.extractSelectedImages || []).includes(image.id);
                                    return `
                                        <div
                                            class="relative cursor-pointer rounded-lg overflow-hidden border-2 ${isSelected ? 'border-yellow-500 ring-2 ring-yellow-300' : 'border-transparent hover:border-yellow-400'}"
                                            onclick="toggleExtractImage('${image.id}')"
                                        >
                                            <img src="${image.url}" alt="${image.label || ''}" class="w-full h-32 object-cover" />
                                            ${image.label ? `
                                                <div class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-70 text-white text-xs p-1 truncate">
                                                    ${image.label}
                                                </div>
                                            ` : ''}
                                            ${isSelected ? `
                                                <div class="absolute top-1 right-1 bg-yellow-500 text-white rounded-full w-6 h-6 flex items-center justify-center">
                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                    </svg>
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Name Input and Footer -->
                        <div class="p-6 border-t border-gray-200">
                            <div class="mb-4">
                                <label class="text-sm font-medium text-gray-700 mb-1 block">Extract Name</label>
                                <input
                                    type="text"
                                    value="${state.newExtractName || ''}"
                                    oninput="setExtractName(this.value)"
                                    placeholder="Enter name for this extract..."
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-yellow-400 focus:outline-none"
                                />
                            </div>
                            <div class="flex gap-3">
                                <button
                                    onclick="closeCreateExtractModal()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                                >
                                    Cancel
                                </button>
                                <button
                                    onclick="saveExtract()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedCount > 0 && state.newExtractName ? 'bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedCount === 0 || !state.newExtractName ? 'disabled' : ''}
                                >
                                    Create Extract
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCreateMergerModal() {
            if (!state.showCreateMergerModal) return '';

            // State for selected contests for merging
            const selectedContests = state.selectedContestsForMerge || [];

            // Check if any selected contest has an extract that includes it
            // This prevents duplicate images (extract + source contest)
            const hasExtractConflict = selectedContests.some(contestId => {
                const contest = state.contests.find(c => c.id === contestId);
                if (!contest) return false;

                // Check if any extract uses this contest as a source
                return state.extracts.some(extract => {
                    if (extract.sourceType === 'contest' && extract.sourceContestId === contestId) {
                        // Check if any selected contest is in the extract's images
                        return selectedContests.some(otherContestId => {
                            if (otherContestId === contestId) return false;
                            const otherContest = state.contests.find(c => c.id === otherContestId);
                            if (!otherContest) return false;
                            // Check if any image from other contest is in the extract
                            return otherContest.images.some(img => extract.imageIds.includes(img.id));
                        });
                    }
                    return false;
                });
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeCreateMergerModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">Create Merge</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        Select contests to merge together (${selectedContests.length} selected, min 2 required)
                                    </p>
                                </div>
                                <button onclick="closeCreateMergerModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Contest List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-2">
                            ${state.contests.map(contest => {
                                const isSelected = selectedContests.includes(contest.id);

                                return `
                                    <div class="border ${isSelected ? 'border-blue-400 bg-blue-50' : 'border-gray-200'} rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-blue-300"
                                         onclick="toggleContestForMerger('${contest.id}')">
                                        <input
                                            type="checkbox"
                                            ${isSelected ? 'checked' : ''}
                                            class="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
                                            onclick="event.stopPropagation()"
                                            onchange="toggleContestForMerger('${contest.id}')"
                                        />
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h4 class="font-semibold text-gray-800 truncate">${contest.title}</h4>
                                            </div>
                                            <p class="text-xs text-gray-500">
                                                ${contest.creatorName} ‚Ä¢ ${contest.images.length} images ‚Ä¢ ${contest.voterCount || 0} voters
                                            </p>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <!-- Name Input and Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${hasExtractConflict ? `
                                <div class="mb-4 bg-red-50 border border-red-300 text-red-700 p-3 rounded-lg text-sm">
                                    ‚ö†Ô∏è Warning: You've selected a contest and an extract that includes images from that contest. This will create duplicates.
                                </div>
                            ` : ''}
                            <div class="mb-4">
                                <label class="text-sm font-medium text-gray-700 mb-1 block">Merger Name</label>
                                <input
                                    type="text"
                                    value="${state.newMergerName || ''}"
                                    oninput="setMergerName(this.value)"
                                    placeholder="Enter name for this merger..."
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-blue-400 focus:outline-none"
                                />
                            </div>
                            <div class="flex gap-3">
                                <button
                                    onclick="closeCreateMergerModal()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                                >
                                    Cancel
                                </button>
                                <button
                                    onclick="saveMerger()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedContests.length >= 2 && state.newMergerName && !hasExtractConflict ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedContests.length < 2 || !state.newMergerName || hasExtractConflict ? 'disabled' : ''}
                                >
                                    Create Merger
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderUploadProgressModal() {
            if (!state.uploadProgress) return '';

            const allCompleted = state.uploadProgress.files.every(f => f.status === 'success' || f.status === 'failed');
            const successCount = state.uploadProgress.files.filter(f => f.status === 'success').length;
            const failedCount = state.uploadProgress.files.filter(f => f.status === 'failed').length;
            const uploadingCount = state.uploadProgress.files.filter(f => f.status === 'uploading' || f.status === 'compressing').length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">
                                        ${allCompleted ? 'Upload Complete' : 'Uploading Images...'}
                                    </h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        ${successCount} succeeded, ${failedCount} failed, ${uploadingCount} in progress
                                    </p>
                                </div>
                                <div class="text-3xl">
                                    ${allCompleted ? (failedCount > 0 ? '‚ö†Ô∏è' : '‚úÖ') : '‚è≥'}
                                </div>
                            </div>
                        </div>

                        <!-- File List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-3">
                            ${state.uploadProgress.files.map((file, index) => `
                                <div class="border border-gray-200 rounded-lg p-4 ${
                                    file.status === 'success' ? 'bg-green-50 border-green-200' :
                                    file.status === 'failed' ? 'bg-red-50 border-red-200' :
                                    'bg-blue-50 border-blue-200'
                                }">
                                    <div class="flex items-start justify-between mb-2">
                                        <div class="flex-1 min-w-0">
                                            <p class="font-medium text-gray-800 truncate" title="${file.name}">
                                                ${file.name}
                                            </p>
                                            ${file.needsCompression ? `
                                                <p class="text-xs text-gray-600 mt-1">
                                                    Original: ${(file.originalSize / 1024).toFixed(0)}KB
                                                    ${file.compressedSize ? `‚Üí Compressed: ${(file.compressedSize / 1024).toFixed(0)}KB (${Math.round((1 - file.compressedSize / file.originalSize) * 100)}% smaller)` : '‚Üí Compressing...'}
                                                </p>
                                            ` : file.originalSize ? `
                                                <p class="text-xs text-gray-600 mt-1">Size: ${(file.originalSize / 1024).toFixed(0)}KB</p>
                                            ` : ''}
                                            ${file.status === 'compressing' ? `
                                                <p class="text-xs text-blue-600 mt-1">üîÑ Compressing...</p>
                                            ` : ''}
                                            ${file.error ? `
                                                <p class="text-xs text-red-600 mt-1">${file.error}</p>
                                            ` : ''}
                                        </div>
                                        <div class="ml-3 text-2xl flex-shrink-0">
                                            ${file.status === 'success' ? '‚úÖ' :
                                              file.status === 'failed' ? '‚ùå' :
                                              file.status === 'compressing' ? 'üîÑ' :
                                              file.status === 'uploading' ? '‚è≥' : '‚è±Ô∏è'}
                                        </div>
                                    </div>

                                    <!-- Progress Bar -->
                                    ${file.status === 'uploading' || file.status === 'compressing' || file.status === 'pending' ? `
                                        <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                                            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300"
                                                 style="width: ${file.progress || 0}%"></div>
                                        </div>
                                        <p class="text-xs text-gray-600">
                                            ${file.status === 'compressing' ? 'Compressing...' : `${file.progress || 0}%`}
                                        </p>
                                    ` : ''}

                                    <!-- Retry Button -->
                                    ${file.status === 'failed' ? `
                                        <button onclick="retryUpload(${index})"
                                                class="mt-2 px-3 py-1 text-xs bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">
                                            üîÑ Retry Upload
                                        </button>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>

                        <!-- Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${allCompleted ? `
                                <button onclick="closeUploadProgress()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700">
                                    Done
                                </button>
                            ` : `
                                <button onclick="cancelAllUploads()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300">
                                    Cancel Remaining Uploads
                                </button>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderLoadingOverlay() {
            if (!state.isLoading) return '';
            return `<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100]">
                <div class="bg-white rounded-lg p-6 flex flex-col items-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-mauve-500 mb-3"></div>
                    <p class="text-gray-700 font-semibold">${state.loadingMessage}</p>
                </div>
            </div>`;
        }

        function renderHeader() {
            const showBackButton = state.view === 'results' || state.view === 'vote' || state.view === 'mergedResults';
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

            return `
                <header class="safe-header bg-gradient-to-r from-mauve-600 via-mauve-300 to-green-700 text-white shadow-lg">
                    <div class="max-w-7xl mx-auto px-3 py-2 sm:py-3 flex justify-between items-center gap-2">
                        <div class="flex items-center gap-2">
                            <div class="w-8 h-8 rounded-full flex items-center justify-center bg-gradient-to-br from-mauve-300 to-mauve-500">
                                <span class="text-xl">üå∫</span>
                            </div>
                            <h1 class="text-xl font-bold">Peony</h1>
                            ${showBackButton ? `
                                <button onclick="backToHome()" class="ml-2 bg-white/20 hover:bg-white/30 text-white px-3 py-1.5 sm:py-1 rounded-lg font-semibold transition text-sm flex items-center gap-1 min-h-[36px] sm:min-h-0">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                                    </svg>
                                    Back
                                </button>
                            ` : ''}
                        </div>
                        
                        ${!state.isLoggedIn ? `
                            <button onclick="login()" class="bg-white text-mauve-500 px-4 py-2 rounded-lg font-semibold hover:bg-pink-50 transition text-sm min-h-[36px]">
                                Login with Discord
                            </button>
                        ` : `
                            <div class="flex items-center gap-2">
                                <div class="relative">
                                    <button onclick="toggleUserDropdown()" class="flex items-center gap-2 cursor-pointer hover:opacity-80 focus:outline-none">
                                        <img src="${state.user.avatar}" alt="Avatar" class="w-7 h-7 rounded-full" />
                                        <span class="font-medium text-sm hidden sm:inline">${state.user.username}</span>
                                        <svg class="w-4 h-4 transition-transform ${state.showUserDropdown ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                                        </svg>
                                    </button>
                                    ${state.showUserDropdown ? `
                                        <div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg py-1 z-50">
                                            ${isAdmin ? `
                                                <button onclick="showAdminDashboard()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    ‚öôÔ∏è Admin Dashboard
                                                </button>
                                                <button onclick="showAppSettings()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    üîß App Settings
                                                </button>
                                                <button onclick="openManageFoldersModal()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    üìÅ Manage Folders
                                                </button>
                                            ` : ''}
                                            <button onclick="logout()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 ${isAdmin ? 'border-t border-gray-200' : ''}">
                                                Logout
                                            </button>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `}
                    </div>
                </header>
            `;
        }

        function renderLoginScreen() {
            return `
                <div class="max-w-md mx-auto mt-20 p-6 bg-white rounded-2xl shadow-xl fade-in">
                    <div class="text-center mb-6">
                        <div class="w-16 h-16 bg-gradient-to-br from-mauve-300 to-mauve-500 rounded-full flex items-center justify-center mx-auto mb-4">
                            <span class="text-3xl">üå∫</span>
                        </div>
                        <h2 class="text-2xl font-bold text-gray-800 mb-2">Welcome to Peony</h2>
                        <p class="text-gray-600 text-sm">Create and vote on image contests</p>
                    </div>
                    
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
                        <p class="text-xs text-blue-800">
                            <strong>Privacy Notice:</strong> This app only accesses your Discord username and avatar. Contact me if you have any questions.
                        </p>
                    </div>
                    
                    <button onclick="login()" class="w-full bg-gradient-to-r from-indigo-600 to-indigo-700 text-white py-3 rounded-lg font-semibold hover:from-indigo-700 hover:to-indigo-800 transition flex items-center justify-center gap-2 text-sm">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                        Login with Discord
                    </button>
                </div>
            `;
        }

        function setSortBy(sortBy) {
            state.filters.sortBy = sortBy;
            render();
        }

        function setFilterCreator(creatorId) {
            state.filters.createdBy = creatorId === 'all' ? null : creatorId;
            render();
        }

        function setSearchQuery(query) {
            state.filters.searchQuery = query;
            // Update URL parameter
            const url = new URL(window.location);
            if (query) {
                url.searchParams.set('search', query);
            } else {
                url.searchParams.delete('search');
            }
            window.history.replaceState({}, '', url);
            render();
        }

        function clearAllFilters() {
            state.filters.createdBy = null;
            state.filters.sortBy = 'newest';
            state.filters.searchQuery = '';
            // Clear URL parameter
            const url = new URL(window.location);
            url.searchParams.delete('search');
            window.history.replaceState({}, '', url);
            render();
        }

        function renderHome() {
            // Get unique creators
            const creators = [...new Set(state.contests.map(c => ({ id: c.createdBy, name: c.creatorName })))];
            const uniqueCreators = Array.from(new Map(creators.map(c => [c.id, c])).values());

            // Filter contests
            let filteredContests = state.contests;

            // Filter by creator
            if (state.filters.createdBy) {
                filteredContests = filteredContests.filter(c => c.createdBy === state.filters.createdBy);
            }

            // Filter by search query
            if (state.filters.searchQuery) {
                const searchLower = state.filters.searchQuery.toLowerCase();
                filteredContests = filteredContests.filter(c =>
                    c.title.toLowerCase().includes(searchLower) ||
                    (c.creatorName && c.creatorName.toLowerCase().includes(searchLower))
                );
            }

            // Sort contests
            filteredContests = [...filteredContests].sort((a, b) => {
                const voterCountA = a.voterCount || 0;
                const voterCountB = b.voterCount || 0;

                switch (state.filters.sortBy) {
                    case 'newest':
                    case 'dateDesc':
                        return (b.createdAt || 0) - (a.createdAt || 0);
                    case 'oldest':
                    case 'dateAsc':
                        return (a.createdAt || 0) - (b.createdAt || 0);
                    case 'titleAsc':
                        return a.title.toLowerCase().localeCompare(b.title.toLowerCase());
                    case 'titleDesc':
                        return b.title.toLowerCase().localeCompare(a.title.toLowerCase());
                    case 'mostVoted':
                    case 'votersDesc':
                        return voterCountB - voterCountA;
                    case 'leastVoted':
                    case 'votersAsc':
                        return voterCountA - voterCountB;
                    case 'imagesDesc':
                        return b.images.length - a.images.length;
                    case 'imagesAsc':
                        return a.images.length - b.images.length;
                    default:
                        return 0;
                }
            });

            const isBanned = state.bannedUsers.includes(state.user.id);

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="flex justify-between items-center mb-4 gap-2 flex-wrap">
                        <h2 class="text-2xl font-bold text-gray-800">All Contests</h2>
                        <div class="flex gap-2 flex-wrap">
                            ${isBanned ? `
                                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded-lg text-sm">
                                    üö´ Your account has been restricted. Contact admin.
                                </div>
                            ` : (() => {
                                const contestCreationEnabled = state.appSettings.contest_creation_enabled !== false;
                                const isAdmin = state.user.id === ADMIN_DISCORD_ID;

                                if (!contestCreationEnabled && !isAdmin) {
                                    return `
                                        <div class="bg-yellow-100 border border-yellow-400 text-yellow-800 px-4 py-2 rounded-lg text-sm">
                                            ‚ÑπÔ∏è Contest creation is currently disabled
                                        </div>
                                    `;
                                }

                                return `
                                    <button onclick="startCreateContest()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg text-sm">
                                        + Create Contest
                                    </button>
                                `;
                            })()}
                            ${state.user.id === ADMIN_DISCORD_ID ? `
                                <button onclick="openCreateMergerModal()" class="bg-gradient-to-r from-blue-500 to-blue-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-800 transition shadow-lg text-sm">
                                    Create Merge
                                </button>
                                <button onclick="openCreateExtractModal()" class="bg-gradient-to-r from-yellow-500 to-yellow-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-800 transition shadow-lg text-sm">
                                    Create Extract +
                                </button>
                            ` : ''}
                        </div>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-3 mb-4">
                        <div class="mb-3">
                            <label class="text-xs font-medium text-gray-700 mb-1 block">Search Contests</label>
                            <input
                                type="text"
                                value="${state.filters.searchQuery || ''}"
                                oninput="setSearchQuery(this.value)"
                                placeholder="Search by contest title or creator name..."
                                class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none"
                            />
                        </div>
                        <div class="flex gap-3 flex-wrap">
                        <div class="flex-1 min-w-[200px]">
                            <label class="text-xs font-medium text-gray-700 mb-1 block">Sort By</label>
                            <select onchange="setSortBy(this.value)" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none">
                                <option value="newest" ${state.filters.sortBy === 'newest' || state.filters.sortBy === 'dateDesc' ? 'selected' : ''}>Newest First</option>
                                <option value="oldest" ${state.filters.sortBy === 'oldest' || state.filters.sortBy === 'dateAsc' ? 'selected' : ''}>Oldest First</option>
                                <option value="titleAsc" ${state.filters.sortBy === 'titleAsc' ? 'selected' : ''}>A-Z</option>
                                <option value="titleDesc" ${state.filters.sortBy === 'titleDesc' ? 'selected' : ''}>Z-A</option>
                                <option value="mostVoted" ${state.filters.sortBy === 'mostVoted' || state.filters.sortBy === 'votersDesc' ? 'selected' : ''}>Most Voters</option>
                                <option value="leastVoted" ${state.filters.sortBy === 'leastVoted' || state.filters.sortBy === 'votersAsc' ? 'selected' : ''}>Fewest Voters</option>
                                <option value="imagesDesc" ${state.filters.sortBy === 'imagesDesc' ? 'selected' : ''}>Most Images</option>
                                <option value="imagesAsc" ${state.filters.sortBy === 'imagesAsc' ? 'selected' : ''}>Fewest Images</option>
                            </select>
                        </div>
                        <div class="flex-1 min-w-[200px]">
                            <label class="text-xs font-medium text-gray-700 mb-1 block">Filter by Creator</label>
                            <select onchange="setFilterCreator(this.value)" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none">
                                <option value="all" ${state.filters.createdBy === null ? 'selected' : ''}>All Creators</option>
                                ${uniqueCreators.map(creator => `
                                    <option value="${creator.id}" ${state.filters.createdBy === creator.id ? 'selected' : ''}>${creator.name}</option>
                                `).join('')}
                            </select>
                        </div>
                        ${state.filters.createdBy || state.filters.sortBy !== 'newest' || state.filters.searchQuery ? `
                            <div class="flex items-end">
                                <button onclick="clearAllFilters()" class="bg-red-500 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-600 transition text-sm">
                                    Clear All Filters
                                </button>
                            </div>
                        ` : ''}
                        </div>
                    </div>

                    ${state.filters.createdBy || state.filters.searchQuery ? `
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 flex gap-2 items-center flex-wrap">
                            <span class="text-sm font-medium text-blue-800">Active Filters:</span>
                            ${state.filters.createdBy ? `
                                <span class="bg-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs font-semibold flex items-center gap-1">
                                    Creator: ${uniqueCreators.find(c => c.id === state.filters.createdBy)?.name || 'Unknown'}
                                    <button onclick="setFilterCreator('all')" class="hover:text-blue-900">‚úï</button>
                                </span>
                            ` : ''}
                            ${state.filters.searchQuery ? `
                                <span class="bg-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs font-semibold flex items-center gap-1">
                                    Search: "${state.filters.searchQuery}"
                                    <button onclick="setSearchQuery('')" class="hover:text-blue-900">‚úï</button>
                                </span>
                            ` : ''}
                        </div>
                    ` : ''}

                    ${(() => {
                        // Combine contests, mergers, and extracts into a unified list
                        const allItems = [
                            ...state.mergers.map(m => ({ ...m, itemType: 'merger' })),
                            ...state.extracts.map(e => ({ ...e, itemType: 'extract' })),
                            ...filteredContests.map(c => ({ ...c, itemType: 'contest' }))
                        ];

                        // Sort by creation date (newest first by default)
                        allItems.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));

                        // Check if we should show folders (only when sort is newest and no filters)
                        const showFolders = state.filters.sortBy === 'newest' && !state.filters.createdBy && !state.filters.searchQuery;

                        if (showFolders && state.groups.length > 0) {
                            // Get items that are in folders
                            const itemsInFolders = new Set();
                            state.groups.forEach(group => {
                                (group.items || []).forEach(item => {
                                    itemsInFolders.add(`${item.item_type}:${item.item_id}`);
                                });
                            });

                            // Get ungrouped items
                            const ungroupedItems = allItems.filter(item =>
                                !itemsInFolders.has(`${item.itemType}:${item.id}`)
                            );

                            return `
                                ${state.groups.map(group => {
                                    const isExpanded = state.expandedFolderIds.includes(group.id);
                                    // Get actual items for this folder
                                    const folderItems = (group.items || []).map(item => {
                                        if (item.item_type === 'contest') {
                                            const contest = state.contests.find(c => c.id === item.item_id);
                                            return contest ? { ...contest, itemType: 'contest' } : null;
                                        } else if (item.item_type === 'merger') {
                                            const merger = state.mergers.find(m => m.id === item.item_id);
                                            return merger ? { ...merger, itemType: 'merger' } : null;
                                        } else if (item.item_type === 'extract') {
                                            const extract = state.extracts.find(e => e.id === item.item_id);
                                            return extract ? { ...extract, itemType: 'extract' } : null;
                                        }
                                        return null;
                                    }).filter(Boolean);

                                    return `
                                        <div class="bg-white rounded-xl shadow-lg overflow-hidden mb-4 fade-in">
                                            <div class="bg-gradient-to-r from-mauve-400 to-mauve-600 p-4 cursor-pointer hover:from-mauve-500 hover:to-mauve-700 transition" onclick="toggleFolderExpanded(${group.id})">
                                                <div class="flex items-center gap-3 text-white">
                                                    <svg class="w-5 h-5 transition-transform ${isExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                    </svg>
                                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
                                                    </svg>
                                                    <h3 class="text-lg font-bold flex-1">${group.name}</h3>
                                                    <span class="text-sm opacity-90">${folderItems.length} items</span>
                                                </div>
                                            </div>
                                            ${isExpanded ? `
                                                <div class="p-4">
                                                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                                        ${folderItems.map(item => {
                                                            if (item.itemType === 'merger') {
                                                                return renderMergerCard(item);
                                                            } else if (item.itemType === 'extract') {
                                                                return renderExtractCard(item);
                                                            } else {
                                                                return renderContestCard(item);
                                                            }
                                                        }).join('')}
                                                    </div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }).join('')}

                                ${ungroupedItems.length > 0 ? `
                                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                        ${ungroupedItems.map(item => {
                                            if (item.itemType === 'merger') {
                                                return renderMergerCard(item);
                                            } else if (item.itemType === 'extract') {
                                                return renderExtractCard(item);
                                            } else {
                                                return renderContestCard(item);
                                            }
                                        }).join('')}
                                    </div>
                                ` : ''}
                            `;
                        } else {
                            // Show flat list when not using default sort or when no folders exist
                            return `
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                    ${allItems.map(item => {
                                        if (item.itemType === 'merger') {
                                            return renderMergerCard(item);
                                        } else if (item.itemType === 'extract') {
                                            return renderExtractCard(item);
                                        } else {
                                            return renderContestCard(item);
                                        }
                                    }).join('')}
                                </div>
                            `;
                        }
                    })()}
                </div>
            `;
        }

        function renderContestCard(contest) {
                        try {
                                const hasVoted = state.userVotedContests[contest.id];
                                const voterCount = contest.voterCount || 0;
                            const canDelete = canDeleteContest(contest);
                            const isBanned = state.bannedUsers.includes(state.user.id);
                            // Format date as "day month year" (e.g., "30 Nov 2025")
                            const createdDate = contest.createdAt ? (() => {
                                const date = new Date(contest.createdAt);
                                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                                return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
                            })() : '';

                            return `
                                <div class="bg-white rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative">
                                    ${(contest.createdBy === state.user.id || state.user.id === ADMIN_DISCORD_ID) ? `
                                        <button
                                            onclick='toggleContestLock("${contest.id}")'
                                            class="absolute top-3 right-3 p-1.5 rounded-full shadow-lg transition-all hover:scale-110 ${contest.isLocked ? 'bg-black hover:bg-gray-900' : 'bg-green-500 hover:bg-green-600'}"
                                            title="${contest.isLocked ? 'Click to unlock contest' : 'Click to lock contest'}"
                                        >
                                            ${contest.isLocked ? `
                                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                                                </svg>
                                            ` : `
                                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M8 11V7a4 4 0 118 0m-4 8v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2z"/>
                                                </svg>
                                            `}
                                        </button>
                                    ` : contest.isLocked ? `
                                        <div class="absolute top-3 right-3 bg-black text-white p-1.5 rounded-full shadow-lg" title="Contest is locked">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                                            </svg>
                                        </div>
                                    ` : ''}
                                    <div class="flex items-start gap-2 mb-2">
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h3 class="text-base font-bold text-gray-800 truncate">${contest.title}</h3>
                                            </div>
                                            <div class="text-xs text-gray-500 flex items-center gap-2 flex-wrap">
                                                <span class="truncate">by ${contest.creatorName}${createdDate ? ` ‚Ä¢ ${createdDate}` : ''}</span>
                                                <span class="ml-auto whitespace-nowrap">${voterCount}üë• ${contest.images.length}üñºÔ∏è</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="flex gap-2">
                                        ${contest.isLocked ? `
                                            <button
                                                onclick='viewLockedResults(${JSON.stringify(contest).replace(/'/g, "&apos;")})'
                                                class="flex-1 bg-gradient-to-r from-green-500 to-green-600 text-white py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-700 transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : (hasVoted || contest.createdBy === state.user.id) && (contest.voterCount > 0) ? `
                                            ${contest.createdBy === state.user.id && !hasVoted ? `
                                                <button
                                                    onclick='startVoting(${JSON.stringify(contest).replace(/'/g, "&apos;")})'
                                                    class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                                                >
                                                    Start Voting
                                                </button>
                                            ` : ''}
                                            <button
                                                onclick='viewResults(${JSON.stringify(contest).replace(/'/g, "&apos;")})'
                                                class="flex-1 bg-gradient-to-r from-green-500 to-green-600 text-white py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-700 transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : isBanned ? `
                                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                                üö´ Account restricted
                                            </div>
                                        ` : `
                                            <button
                                                onclick='startVoting(${JSON.stringify(contest).replace(/'/g, "&apos;")})'
                                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                                            >
                                                Start Voting
                                            </button>
                                        `}
                                        <button
                                            onclick='shareContest("${contest.id}")'
                                            class="bg-gradient-to-r from-purple-500 to-purple-600 text-white px-3 py-2 rounded-lg font-semibold hover:from-purple-600 hover:to-purple-700 transition shadow-md text-sm flex items-center gap-1"
                                            title="Share contest"
                                        >
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/>
                                            </svg>
                                        </button>
                                        ${canDelete ? `
                                            <button
                                                onclick="deleteContest('${contest.id}')"
                                                class="bg-red-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-red-600 transition text-sm"
                                                title="Delete Contest"
                                            >
                                                üóëÔ∏è
                                            </button>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                            } catch (error) {
                                console.error('Error rendering contest:', contest?.id, error);
                                return ''; // Skip this contest and continue
                            }
        }

        function renderMergerCard(merger) {
            // Get contest details for the merged contests
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
            const totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);
            const voterRange = merger.voterCountMin && merger.voterCountMax
                ? `${merger.voterCountMin}-${merger.voterCountMax}üë•`
                : '0üë•';

            // Check if user has voted in all, some, or no merged contests
            const votedContests = mergedContests.filter(c => state.userVotedContests[c.id]);
            const hasVotedAll = votedContests.length === mergedContests.length && mergedContests.length > 0;
            const hasVotedSome = votedContests.length > 0 && votedContests.length < mergedContests.length;
            const hasVotedNone = votedContests.length === 0;

            const isBanned = state.bannedUsers.includes(state.user.id);
            const createdDate = merger.createdAt ? (() => {
                const date = new Date(merger.createdAt);
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
            })() : '';

            return `
                <div class="bg-blue-50 border-2 border-blue-300 rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative">
                    <div class="absolute top-2 left-2 bg-blue-500 text-white px-2 py-0.5 rounded text-xs font-bold">MERGE</div>
                    ${state.user.id === ADMIN_DISCORD_ID ? `
                        <button
                            onclick="deleteMerger('${merger.id}')"
                            class="absolute top-3 right-3 bg-red-500 text-white px-2 py-1 rounded-lg font-semibold hover:bg-red-600 transition text-xs"
                            title="Delete Merger"
                        >
                            üóëÔ∏è
                        </button>
                    ` : ''}
                    <div class="flex items-start gap-2 mb-2 mt-6">
                        <img src="${merger.creatorAvatar}" alt="${merger.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h3 class="text-base font-bold text-blue-900 truncate">${merger.name}</h3>
                            </div>
                            <div class="text-xs text-blue-700 flex items-center gap-2 flex-wrap">
                                <span class="truncate">by ${merger.creatorName}${createdDate ? ` ‚Ä¢ ${createdDate}` : ''}</span>
                                <span class="ml-auto whitespace-nowrap">${voterRange} ${totalImages}üñºÔ∏è</span>
                            </div>
                        </div>
                    </div>

                    <!-- Dropdown of merged contests -->
                    <details class="mb-2">
                        <summary class="cursor-pointer text-xs text-blue-700 hover:text-blue-900 font-semibold">
                            Merged Contests (${mergedContests.length})
                        </summary>
                        <div class="mt-1 pl-2 space-y-1">
                            ${mergedContests.map(c => `
                                <div class="text-xs text-blue-600">‚Ä¢ ${c.title}</div>
                            `).join('')}
                        </div>
                    </details>

                    <div class="flex gap-2">
                        ${isBanned ? `
                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                üö´ Account restricted
                            </div>
                        ` : hasVotedAll ? `
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-green-500 to-green-600 text-white py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-700 transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedNone ? `
                            <button
                                onclick='startMergerVoting("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                            >
                                Start Voting
                            </button>
                        ` : `
                            <button
                                onclick='showMergerVoteModal("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                            >
                                Partial Votes
                            </button>
                        `}
                        <button
                            onclick='shareMerger("${merger.id}")'
                            class="bg-gradient-to-r from-purple-500 to-purple-600 text-white px-3 py-2 rounded-lg font-semibold hover:from-purple-600 hover:to-purple-700 transition shadow-md text-sm flex items-center gap-1"
                            title="Share merger"
                        >
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `;
        }

        function renderExtractCard(extract) {
            // Get source reference
            let sourceRef = 'Unknown';
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                sourceRef = sourceContest ? sourceContest.title : 'Unknown Contest';
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                sourceRef = sourceMerger ? sourceMerger.name : 'Unknown Merger';
            }

            const imageCount = extract.imageIds.length;
            const isBanned = state.bannedUsers.includes(state.user.id);
            const createdDate = extract.createdAt ? (() => {
                const date = new Date(extract.createdAt);
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
            })() : '';

            return `
                <div class="bg-yellow-50 border-2 border-yellow-400 rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative">
                    <div class="absolute top-2 left-2 bg-yellow-500 text-white px-2 py-0.5 rounded text-xs font-bold">EXTRACT</div>
                    ${state.user.id === ADMIN_DISCORD_ID ? `
                        <button
                            onclick="deleteExtract('${extract.id}')"
                            class="absolute top-3 right-3 bg-red-500 text-white px-2 py-1 rounded-lg font-semibold hover:bg-red-600 transition text-xs"
                            title="Delete Extract"
                        >
                            üóëÔ∏è
                        </button>
                    ` : ''}
                    <div class="flex items-start gap-2 mb-2 mt-6">
                        <img src="${extract.creatorAvatar}" alt="${extract.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h3 class="text-base font-bold text-yellow-900 truncate">${extract.name}</h3>
                            </div>
                            <div class="text-xs text-yellow-700 flex items-center gap-2 flex-wrap">
                                <span class="truncate">by ${extract.creatorName}${createdDate ? ` ‚Ä¢ ${createdDate}` : ''}</span>
                                <span class="ml-auto whitespace-nowrap">${imageCount}üñºÔ∏è</span>
                            </div>
                            <div class="text-xs text-yellow-600 mt-1">
                                From: ${sourceRef}
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-2">
                        ${isBanned ? `
                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                üö´ Account restricted
                            </div>
                        ` : `
                            <button
                                onclick='startExtractVoting("${extract.id}")'
                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                            >
                                Start Voting
                            </button>
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r from-green-500 to-green-600 text-white py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-700 transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        `}
                    </div>
                </div>
            `;
        }

        function renderCreateContest() {
            return `
                <div class="max-w-5xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="flex justify-between items-center mb-4">
                            <div>
                                <h2 class="text-2xl font-bold text-gray-800">${state.newContest.title}</h2>
                            </div>
                            <button onclick="cancelCreateContest()" class="text-gray-600 hover:text-gray-800 flex items-center gap-1 text-sm">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                                Cancel
                            </button>
                        </div>

                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                            <h3 class="font-bold text-blue-900 mb-2 flex items-center gap-2 text-sm">
                                <span class="text-xl">üì∏</span>
                                How to Add Images
                            </h3>
                            <p class="text-xs text-blue-800 mb-1">
                                üíª <strong>Desktop:</strong> Click image ‚Üí Right-click ‚Üí Copy image link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üì± <strong>Mobile:</strong> Open image ‚Üí Share ‚Üí Copy link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üìÅ <strong>Or:</strong> Click "Upload Image Files" or drag & drop files (max 10MB each, multiple files supported)
                            </p>
                            <p class="text-xs text-green-800 font-semibold">
                                ‚ö° Uploaded files are automatically compressed to optimize loading speed
                            </p>
                        </div>

                        <div class="bg-yellow-50 border border-yellow-300 rounded-lg p-3 mb-4">
                            <p class="text-xs text-yellow-800">
                                ‚ö†Ô∏è <strong>Warning:</strong> Discord image URLs expire after 24 hours. Use permanent image hosting (Imgur, etc.) or upload files directly.
                            </p>
                        </div>

                        <div class="mb-4">
                            <input type="url" id="contestUrlInput" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg text-sm mb-2" placeholder="Paste Discord image URL or any image URL...">
                            <div class="flex gap-2 mb-2">
                                <button onclick="clearUrlInput()" class="flex-1 bg-gray-500 text-white py-2 rounded-lg font-semibold hover:bg-gray-600 transition text-sm">
                                    Clear Text Field
                                </button>
                                <button onclick="addImageFromUrl('contestUrlInput')" class="flex-1 bg-gradient-to-r from-pink-500 to-rose-600 text-white py-2 rounded-lg font-semibold hover:from-pink-600 hover:to-rose-700 transition text-sm">
                                    Add URL
                                </button>
                            </div>
                            <div class="flex items-center gap-2 mb-3">
                                <span class="text-sm text-gray-600 font-medium">or</span>
                                <input type="file" id="contestFileInput" accept="image/jpeg,image/png,image/gif,image/webp" multiple class="hidden" onchange="handleFileSelect(this)">
                                <button onclick="document.getElementById('contestFileInput').click()" class="flex-1 bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-indigo-700 transition text-sm flex items-center justify-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                    </svg>
                                    Upload Image Files
                                </button>
                            </div>
                            <div
                                id="dropZone"
                                class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center bg-gray-50 hover:border-blue-400 hover:bg-blue-50 transition cursor-pointer"
                                ondragover="handleDragOver(event)"
                                ondragleave="handleDragLeave(event)"
                                ondrop="handleDrop(event)"
                                onclick="document.getElementById('contestFileInput').click()"
                            >
                                <svg class="w-12 h-12 mx-auto mb-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <p class="text-sm text-gray-600 font-medium mb-1">Drag & drop images here</p>
                                <p class="text-xs text-gray-500">or click to browse files</p>
                            </div>
                        </div>

                        <div class="flex items-center justify-between mb-3 p-3 bg-gray-50 rounded-lg">
                            <div class="text-sm font-semibold text-gray-800">
                                ${state.newContest.images.length} / 50 images added
                            </div>
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="checkbox" ${state.newContest.labelsEnabled ? 'checked' : ''} onchange="toggleImageLabels()" class="w-4 h-4 text-mauve-500 rounded focus:ring-mauve-400">
                                <span class="text-sm font-medium text-gray-700">Enable Image Labels</span>
                            </label>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 min-h-[100px]">
                            ${state.newContest.images.length === 0 ? `
                                <div class="col-span-full text-center text-gray-400 py-8 text-sm italic">
                                    No images added yet
                                </div>
                            ` : state.newContest.images.map((img, index) => `
                                <div class="relative group">
                                    <img src="${img.url}" class="w-full h-48 object-contain rounded-lg bg-gray-100" />
                                    <button onclick="removeContestImage(${index})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition shadow-lg">
                                        √ó
                                    </button>
                                    ${state.newContest.labelsEnabled ? `
                                        <input
                                            type="text"
                                            value="${img.label || ''}"
                                            onchange="updateImageLabel(${index}, this.value)"
                                            maxlength="30"
                                            placeholder="Label (optional)"
                                            class="w-full mt-2 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:border-pink-500"
                                        />
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>

                        <button 
                            onclick="finishCreateContest()" 
                            ${state.newContest.images.length === 0 ? 'disabled' : ''}
                            class="w-full bg-gradient-to-r from-green-500 to-green-700 text-white py-3 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                        >
                            Create Contest (${state.newContest.images.length} images)
                        </button>
                    </div>
                </div>
            `;
        }

        function renderVoting() {
            const currentImage = state.shuffledImages[state.currentImageIndex];
            const currentVote = state.votes[currentImage.id];
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);

            // Adaptive progress bar logic - ensure EXACTLY segmentCount dashes
            const imageCount = state.shuffledImages.length;
            const segmentCount = Math.min(imageCount, 20);
            const imagesPerSegment = Math.ceil(imageCount / segmentCount);

            return `
                <div class="max-w-4xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <div class="bg-gray-200 h-3 flex gap-1 p-1">
                            ${Array.from({ length: segmentCount }, (_, segmentIdx) => {
                                const startIdx = segmentIdx * imagesPerSegment;
                                const endIdx = Math.min(startIdx + imagesPerSegment, imageCount);

                                // Skip segments that would start beyond our image count
                                if (startIdx >= imageCount) return '';

                                const segmentImages = state.shuffledImages.slice(startIdx, endIdx);

                                const votedCount = segmentImages.filter(img => state.votes[img.id]).length;
                                const totalCount = segmentImages.length;
                                const hasCurrentImage = state.currentImageIndex >= startIdx && state.currentImageIndex < endIdx;

                                // Determine color based on priority
                                let bgColor;
                                if (hasCurrentImage) {
                                    bgColor = 'bg-mauve-400';
                                } else if (votedCount === totalCount) {
                                    bgColor = 'bg-green-500';
                                } else if (votedCount > 0) {
                                    bgColor = 'bg-yellow-500';
                                } else {
                                    bgColor = 'bg-gray-300';
                                }

                                const imageRange = startIdx + 1 === endIdx ? `Image ${startIdx + 1}` : `Images ${startIdx + 1}-${endIdx}`;
                                const tooltip = `${imageRange} (${votedCount}/${totalCount} voted)`;

                                return `
                                    <div
                                        onclick="jumpToImage(${startIdx})"
                                        class="progress-segment flex-1 ${bgColor}"
                                        title="${tooltip}"
                                    ></div>
                                `;
                            }).join('')}
                        </div>

                        <div class="p-3">
                            <div class="flex justify-between items-center mb-3 gap-2">
                                <h2 class="text-lg font-bold text-gray-800">${state.currentContest.title}</h2>
                                <span class="text-gray-600 font-medium text-sm">${state.currentImageIndex + 1}/${state.shuffledImages.length}</span>
                            </div>

                            <div class="relative mb-3 bg-gray-100 overflow-hidden flex items-center justify-center" style="height: 55vh;">
                                ${state.currentContest.labelsEnabled && currentImage.label ? `
                                    <div class="absolute top-0 left-0 right-0 bg-white px-4 py-2 text-center border-b border-gray-200 z-10">
                                        <span class="text-sm font-semibold text-gray-800">${currentImage.label}</span>
                                    </div>
                                ` : ''}
                                <img
                                    src="${currentImage.url}"
                                    alt="Image ${state.currentImageIndex + 1}"
                                    class="max-h-full max-w-full object-contain"
                                    style="max-height: 100%; max-width: 100%;"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                                ${currentVote ? `
                                    <div class="absolute top-2 right-2 bg-white rounded-full px-3 py-1 shadow-lg flex items-center gap-1 text-sm">
                                        <svg class="w-4 h-4 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                                        </svg>
                                        <span class="font-semibold">Voted: ${currentVote}</span>
                                    </div>
                                ` : ''}
                            </div>

                            <div class="flex justify-center gap-2 mb-3">
                                ${[1, 2, 3, 4, 5].map(score => `
                                    <button 
                                        data-score="${score}"
                                        onclick="handleVote(${score})" 
                                        ${state.isAnimating ? 'disabled' : ''}
                                        class="w-12 h-12 sm:w-14 sm:h-14 rounded-full font-bold text-white text-base shadow-lg hover:scale-110 transition-transform relative ${currentVote === score ? 'ring-4 ring-offset-2' : ''} ${state.isAnimating ? 'opacity-70 cursor-not-allowed' : ''}"
                                        style="background-color: ${getScoreColor(score)}; transform: ${currentVote === score ? 'scale(1.15)' : 'scale(1)'}; ring-color: ${getScoreColor(score)};"
                                    >
                                        ${score}
                                        ${currentVote === score && state.showTickAnimation ? `
                                            <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-green-600 rounded-full p-1 tick-animation" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                            </svg>
                                        ` : currentVote === score ? `
                                            <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-green-600 rounded-full p-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                            </svg>
                                        ` : ''}
                                    </button>
                                `).join('')}
                            </div>

                            <div class="flex justify-between items-center gap-2">
                                <button 
                                    onclick="navigateImage('prev')" 
                                    ${state.currentImageIndex === 0 ? 'disabled' : ''}
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                                >
                                    ‚Üê Prev
                                </button>

                                ${allVoted ? `
                                    <button onclick="submitVotes()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition flex items-center gap-1 shadow-lg text-sm">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        Submit
                                    </button>
                                ` : '<div></div>'}

                                <button 
                                    onclick="navigateImage('next')" 
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition text-sm"
                                >
                                    Next ‚Üí
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderResults() {
            let displayResults, grouped, sortedKeys, voterStats;

            // === BY VOTER VIEW ===
            // Shows statistics for each voter, including their average score across all images
            if (state.resultsView === 'byVoter') {
                voterStats = generateVoterStats();
            }
            // === USER VOTES VIEW ===
            // Shows images grouped by a selected user's vote scores
            else if (state.resultsView === 'userVotes') {
                const selectedUserId = state.selectedVoterUserId || state.user?.id;

                // Find all votes by the selected user from the loaded results (including blocked ones)
                const userVotesMap = {};
                const blockedVotesSet = new Set();
                state.results.forEach(imageResult => {
                    const userVote = imageResult.breakdown.find(v => v.userId === selectedUserId);
                    if (userVote) {
                        userVotesMap[imageResult.id] = userVote.score;
                        if (userVote.isBlocked) {
                            blockedVotesSet.add(imageResult.id);
                        }
                    }
                });

                const hasVotes = Object.keys(userVotesMap).length > 0;

                // Map the selected user's votes onto the images
                displayResults = state.results.map(img => ({
                    ...img,
                    averageScore: userVotesMap[img.id] || 0,
                    userVoteScore: userVotesMap[img.id],
                    isBlocked: blockedVotesSet.has(img.id)
                })).filter(img => img.userVoteScore); // Only show images the user voted on

                grouped = groupMyVotesByScore(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => parseInt(b) - parseInt(a));
            }
            // === AVERAGE VIEW ===
            // Shows images grouped by average score ranges (e.g., 4.5-5.0, 4.0-4.49, etc.)
            else {
                displayResults = state.results;
                grouped = groupByScoreRange(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => {
                    const aMin = grouped[a].min;
                    const bMin = grouped[b].min;
                    return bMin - aMin;
                });
            }
            
            const baseSize = 150;
            const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
            const baseFontSize = 12;
            const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="text-center mb-4">
                            <div class="flex items-center justify-center gap-2 mb-2">
                                <span class="text-4xl">üéÜ</span>
                                <h2 class="text-2xl font-bold text-gray-800">Final Ranking</h2>
                            </div>
                            <p class="text-gray-600 text-sm mb-1">${
                                state.resultsView === 'byVoter' ? 'Average scores per voter' :
                                state.resultsView === 'userVotes' ? 'Individual user votes' :
                                'Total votes from all participants'
                            }</p>
                            <p class="text-xs text-gray-500">Click on any image to see the vote breakdown</p>

                            <div class="mt-3 flex flex-col items-center justify-center gap-2">
                                <!-- First row: View tabs -->
                                <div class="flex items-center justify-center gap-3">
                                    <button
                                        onclick="setResultsView('average')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'average' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        Total
                                    </button>
                                    <button
                                        onclick="setResultsView('userVotes')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'userVotes' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        By User
                                    </button>
                                    <button
                                        onclick="setResultsView('byVoter')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'byVoter' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        Average
                                    </button>
                                </div>
                                <!-- Second row: Action buttons (only show if user has voted or contest is locked) -->
                                ${state.userVotedContests[state.currentContest.id] || state.currentContest.isLocked ? `
                                    <div class="flex items-center justify-center gap-3">
                                        ${state.userVotedContests[state.currentContest.id] && !state.currentContest.isLocked ? `
                                            <button
                                                onclick="startRevote()"
                                                class="px-3 py-1 rounded-lg bg-purple-500 text-white hover:bg-purple-600 transition text-sm"
                                                title="Re-vote from scratch"
                                            >
                                                üîÑ Revote
                                            </button>
                                        ` : ''}
                                        <button
                                            onclick="openMergeModal()"
                                            class="px-3 py-1 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition text-sm"
                                            title="Merge with other contests"
                                        >
                                            üîó Merge with Other Contests
                                        </button>
                                    </div>
                                ` : ''}
                            </div>
                                <!-- User selector dropdown for User Votes view -->
                                ${state.resultsView === 'userVotes' && state.contestVoters.length > 0 ? `
                                    <div class="flex items-center gap-2">
                                        <label class="text-xs font-medium text-gray-700">Select User:</label>
                                        <select
                                            onchange="setResultsView('userVotes', this.value)"
                                            class="px-2 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                        >
                                            ${state.contestVoters.map(voter => {
                                                const isSelected = (state.selectedVoterUserId || state.user?.id) === voter.userId;
                                                const isCurrent = voter.userId === state.user?.id;
                                                return `
                                                    <option value="${voter.userId}" ${isSelected ? 'selected' : ''}>
                                                        ${voter.username}${isCurrent ? ' (You)' : ''}
                                                    </option>
                                                `;
                                            }).join('')}
                                        </select>
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        ${state.resultsView !== 'byVoter' ? `
                        <div class="mb-4 max-w-md mx-auto">
                            <div class="flex items-center gap-2">
                                <label class="text-xs font-medium text-gray-700 whitespace-nowrap">Image Scale:</label>
                                <button
                                    onclick="adjustScale(-1)"
                                    class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                    title="Decrease scale"
                                >‚àí</button>
                                <input
                                    type="range"
                                    id="scaleSlider"
                                    min="40"
                                    max="200"
                                    value="${state.imageScale}"
                                    oninput="updateScale(this.value)"
                                    class="flex-1 h-2 bg-gray-200 rounded-lg cursor-pointer"
                                />
                                <button
                                    onclick="adjustScale(1)"
                                    class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                    title="Increase scale"
                                >+</button>
                                <span class="text-xs font-medium text-gray-700 w-10">${state.imageScale}%</span>
                            </div>
                        </div>
                        ` : ''}

                        ${state.resultsView === 'byVoter' ? `
                            ${voterStats && voterStats.length > 0 ? `
                                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-2">
                                    ${(() => {
                                        // Calculate contest average from all non-blocked votes
                                        let totalVotes = 0;
                                        let totalScore = 0;
                                        state.results.forEach(img => {
                                            img.breakdown.forEach(vote => {
                                                if (!vote.isBlocked) {
                                                    totalVotes++;
                                                    totalScore += vote.score;
                                                }
                                            });
                                        });
                                        const contestAverage = totalVotes > 0 ? (totalScore / totalVotes).toFixed(2) : 0;

                                        return `
                                            <div class="bg-gradient-to-br from-yellow-50 to-yellow-100 rounded-lg shadow-md p-3 flex flex-col items-center border-2 border-yellow-500">
                                                <div class="text-2xl mb-2">üèÜ</div>
                                                <div class="text-xs font-semibold text-gray-800 text-center mb-1">
                                                    Contest Average
                                                </div>
                                                <div class="text-xl font-bold text-white score-text">
                                                    ${contestAverage}
                                                </div>
                                                <div class="text-xs text-gray-500">
                                                    ${totalVotes} vote${totalVotes !== 1 ? 's' : ''}
                                                </div>
                                            </div>
                                        `;
                                    })()}
                                    ${voterStats.map(voter => `
                                        <div class="bg-white rounded-lg shadow-md p-3 flex flex-col items-center hover:shadow-lg transition-shadow cursor-pointer border-2 ${voter.isCurrentUser ? 'border-mauve-400' : 'border-transparent'}">
                                            <img src="${voter.avatar}" alt="${voter.username}" class="w-12 h-12 rounded-full mb-2" />
                                            <div class="text-xs font-semibold text-gray-800 truncate w-full text-center mb-1" title="${voter.username}">
                                                ${voter.username}
                                            </div>
                                            <div class="text-xl font-bold text-white score-text">
                                                ${voter.averageScore}
                                            </div>
                                            <div class="text-xs text-gray-500">
                                                ${voter.totalImages} vote${voter.totalImages !== 1 ? 's' : ''}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">üë•</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Voters Yet</h3>
                                    <p class="text-gray-600">No voting data available for this contest.</p>
                                </div>
                            `}
                        ` : state.resultsView === 'userVotes' && (!displayResults || displayResults.length === 0) ? `
                            <div class="text-center py-12">
                                <div class="text-6xl mb-4">üì≠</div>
                                <h3 class="text-xl font-bold text-gray-800 mb-2">No Votes Yet</h3>
                                <p class="text-gray-600">This user hasn't voted on this contest yet.</p>
                            </div>
                        ` : sortedKeys.map(key => {
                            const group = grouped[key];

                            if (state.resultsView === 'userVotes') {
                                const score = group.score;
                                const colorStyle = getScoreColor(score);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg inline-block" style="color: white; background-color: ${colorStyle};">
                                            Score ${score}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdown(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    ${item.isBlocked ? `
                                                        <div class="absolute inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-10">
                                                            <span class="text-4xl">üö´</span>
                                                        </div>
                                                    ` : ''}
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover ${item.isBlocked ? 'opacity-60' : ''}"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            } else {
                                const colorStyle = getCategoryColor(group.min, group.isMissing);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg ${colorStyle.color} ${colorStyle.bg} w-full block">
                                            ${getCategoryLabel(group.min, group.max, group.isMissing)}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdown(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                    <div class="absolute bottom-0 left-0 right-0 text-white text-center py-1 font-bold score-text" style="font-size: ${fontSize}px;">
                                                        ${item.averageScore}
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>

                    ${state.showBreakdownModal ? renderBreakdownModal() : ''}
                </div>
            `;
        }

        function renderBreakdownModal() {
            const item = state.results.find(r => r.id === state.showBreakdownModal);
            if (!item) return '';

            const votesByScore = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            item.breakdown.forEach(vote => {
                votesByScore[vote.score].push(vote);
            });

            Object.keys(votesByScore).forEach(score => {
                votesByScore[score].sort((a, b) => a.username.localeCompare(b.username));
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[85vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Vote Breakdown</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="overflow-y-auto flex-1 p-4">

                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 400px;">
                                <img
                                    src="${item.url}"
                                    alt="Image"
                                    class="max-w-full max-h-[400px] object-contain"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                            </div>

                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-gray-800">${item.averageScore}</div>
                                    <div class="text-xs text-gray-600">Average Score</div>
                                    <div class="text-xs text-gray-500 mt-1">${item.totalVotes} total votes</div>
                                </div>
                            </div>

                            <div class="space-y-3">
                                ${[5, 4, 3, 2, 1].map(score => `
                                    <div>
                                        <h4 class="text-sm font-bold mb-2 px-3 py-1 rounded-lg inline-block" style="color: ${getScoreColor(score)}; background-color: ${getScoreColor(score)}20;">
                                            Score ${score} (${votesByScore[score].length} ${votesByScore[score].length === 1 ? 'vote' : 'votes'})
                                        </h4>
                                        ${votesByScore[score].length > 0 ? `
                                            <div class="grid grid-cols-1 gap-2 mt-2">
                                                ${votesByScore[score].map(vote => {
                                                    const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                                                    return `
                                                    <div class="flex items-center gap-2 p-2 rounded-lg ${
                                                        vote.isBanned ? 'bg-red-100 opacity-60' :
                                                        vote.isBlocked ? 'bg-gray-300' :
                                                        vote.isCurrentUser ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'
                                                    }">
                                                        <img src="${vote.avatar}" alt="${vote.username}" class="w-8 h-8 rounded-full flex-shrink-0 ${vote.isBanned ? 'opacity-50' : ''}" />
                                                        <span class="text-sm flex-1 truncate ${
                                                            vote.isBanned ? 'line-through text-red-600' :
                                                            vote.isBlocked ? 'line-through text-gray-700' :
                                                            'text-gray-700'
                                                        }">
                                                            ${vote.username}${vote.isCurrentUser ? ' (You)' : ''}${vote.isBanned ? ' (BANNED)' : ''}
                                                        </span>
                                                        ${isAdmin ? `
                                                            <button
                                                                onclick="adminEditVote('${vote.userId}', ${item.id}, ${score})"
                                                                class="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-xs"
                                                                title="Edit vote"
                                                            >
                                                                ‚úèÔ∏è
                                                            </button>
                                                            <button
                                                                onclick="adminToggleBlockVote('${vote.userId}', ${item.id}, ${vote.isBlocked || false})"
                                                                class="px-2 py-1 ${vote.isBlocked ? 'bg-green-500 hover:bg-green-600' : 'bg-red-500 hover:bg-red-600'} text-white rounded text-xs"
                                                                title="${vote.isBlocked ? 'Unblock vote' : 'Block vote'}"
                                                            >
                                                                ${vote.isBlocked ? '‚úì' : 'üö´'}
                                                            </button>
                                                        ` : ''}
                                                    </div>
                                                `}).join('')}
                                            </div>
                                        ` : `
                                            <div class="text-gray-400 italic text-sm mt-2 ml-3">No votes</div>
                                        `}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAdminDashboard() {
            if (!state.showAdminDashboard) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get banned users info
            const bannedUsersInfo = state.bannedUsers.map(userId => {
                // Try to find user info from contests
                const contest = state.contests.find(c => c.createdBy === userId);
                if (contest) {
                    return {
                        id: userId,
                        username: contest.creatorName,
                        avatar: contest.creatorAvatar
                    };
                }
                // Fallback
                return {
                    id: userId,
                    username: 'User' + userId.substring(0, 4),
                    avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${userId}`
                };
            });

            // Calculate admin statistics
            const totalContests = state.contests.length;
            const totalVotes = state.adminStats.totalVotes;
            const totalUniqueVoters = state.adminStats.totalUniqueVoters;
            const totalBannedUsers = state.bannedUsers.length;
            const totalImages = state.contests.reduce((sum, contest) => sum + (contest.images?.length || 0), 0);

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-50 p-4" onclick="event.target === this && closeAdminDashboard()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-3xl w-full max-h-[90vh] overflow-y-auto modal-content" onclick="event.stopPropagation()">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-2xl font-bold text-gray-800">Admin Dashboard</h3>
                                <button onclick="closeAdminDashboard()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>

                            <div class="space-y-4">
                                <div class="bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg p-4 border border-purple-200">
                                    <h4 class="font-bold text-gray-800 mb-3">Statistics</h4>
                                    <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-purple-600">${totalContests}</div>
                                            <div class="text-xs text-gray-600">Total Contests</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-blue-600">${totalVotes}</div>
                                            <div class="text-xs text-gray-600">Total Votes</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-green-600">${totalUniqueVoters}</div>
                                            <div class="text-xs text-gray-600">Unique Voters</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-orange-600">${totalImages}</div>
                                            <div class="text-xs text-gray-600">Total Images</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-red-600">${totalBannedUsers}</div>
                                            <div class="text-xs text-gray-600">Banned Users</div>
                                        </div>
                                    </div>
                                </div>

                                <div class="bg-blue-50 rounded-lg p-4 border border-blue-200">
                                    <h4 class="font-bold text-blue-800 mb-3">üë• All Users</h4>
                                    ${state.allUsers.length > 0 ? `
                                        <div class="space-y-2 max-h-96 overflow-y-auto">
                                            ${[...state.allUsers].sort((a, b) => a.username.localeCompare(b.username)).map(user => {
                                                const isBanned = state.bannedUsers.includes(user.id);
                                                return `
                                                    <div class="flex items-center justify-between p-3 bg-white rounded-lg ${isBanned ? 'opacity-50' : ''}">
                                                        <div class="flex items-center gap-3">
                                                            <img src="${user.avatar}" alt="${user.username}" class="w-10 h-10 rounded-full" />
                                                            <div>
                                                                <div class="font-semibold text-gray-800">${user.username}</div>
                                                                <div class="text-xs text-gray-500">${user.id}</div>
                                                                ${isBanned ? '<span class="text-xs text-red-600 font-semibold">BANNED</span>' : ''}
                                                            </div>
                                                        </div>
                                                        ${isBanned ? `
                                                            <button onclick="unbanUser('${user.id}')" class="bg-green-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-green-600 transition text-sm">
                                                                Unban
                                                            </button>
                                                        ` : `
                                                            <button onclick="confirmBanUser('${user.id}')" class="bg-red-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-red-600 transition text-sm">
                                                                Ban
                                                            </button>
                                                        `}
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : '<p class="text-sm text-gray-500 italic">No users have logged in yet</p>'}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAppSettingsModal() {
            if (!state.showAppSettingsModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get current settings values (default to true if not set)
            const contestCreationEnabled = state.appSettings.contest_creation_enabled !== false;
            const revotingEnabled = state.appSettings.revoting_enabled !== false;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeAppSettings()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full modal-content" onclick="event.stopPropagation()">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h3 class="text-2xl font-bold text-gray-800">App Settings</h3>
                                <button onclick="closeAppSettings()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>

                            <div class="space-y-6">
                                <!-- Contest Creation Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Contest Creation</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Allow users to create new contests
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${contestCreationEnabled ? 'active' : ''}"
                                        onclick="toggleAppSetting('contest_creation_enabled')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <!-- Revoting Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Revoting</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Allow users to change their votes after submission
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${revotingEnabled ? 'active' : ''}"
                                        onclick="toggleAppSetting('revoting_enabled')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <p class="text-sm text-blue-800">
                                        üí° <strong>Note:</strong> These settings affect all users globally. Disabled features will show informative messages to users.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderManageFoldersModal() {
            if (!state.showManageFoldersModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get all items that are already in folders
            const itemsInFolders = new Set();
            state.groups.forEach(group => {
                (group.items || []).forEach(item => {
                    itemsInFolders.add(`${item.item_type}:${item.item_id}`);
                });
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeManageFoldersModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden modal-content flex flex-col" onclick="event.stopPropagation()">
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex justify-between items-center">
                                <h3 class="text-2xl font-bold text-gray-800">üìÅ Manage Folders</h3>
                                <button onclick="closeManageFoldersModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="p-6 overflow-y-auto flex-1">
                            <div class="mb-6">
                                <button onclick="createFolder()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg">
                                    + Create New Folder
                                </button>
                            </div>

                            ${state.groups.length === 0 ? `
                                <div class="text-center py-8 text-gray-500">
                                    <p class="text-lg mb-2">No folders yet</p>
                                    <p class="text-sm">Create a folder to organize your contests, mergers, and extracts</p>
                                </div>
                            ` : `
                                <div class="space-y-4" id="folders-list">
                                    ${state.groups.map(group => `
                                        <div class="border border-gray-300 rounded-lg overflow-hidden">
                                            <div class="bg-gray-50 p-4 flex items-center gap-3">
                                                <div class="cursor-move text-gray-400 hover:text-gray-600">
                                                    ‚ãÆ‚ãÆ
                                                </div>
                                                <div class="flex-1">
                                                    <h4 class="font-semibold text-gray-800">${group.name}</h4>
                                                    <p class="text-sm text-gray-600">${(group.items || []).length} items</p>
                                                </div>
                                                <button onclick="addItemToFolder(${group.id})" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 text-sm">
                                                    + Add Item
                                                </button>
                                                <button onclick="deleteFolder(${group.id})" class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600 text-sm">
                                                    Delete
                                                </button>
                                            </div>
                                            ${(group.items || []).length > 0 ? `
                                                <div class="p-4 bg-white space-y-2">
                                                    ${(group.items || []).map(item => {
                                                        // Find the actual item
                                                        let itemData = null;
                                                        let itemTitle = 'Unknown';
                                                        if (item.item_type === 'contest') {
                                                            itemData = state.contests.find(c => c.id === item.item_id);
                                                            itemTitle = itemData?.title || 'Unknown Contest';
                                                        } else if (item.item_type === 'merger') {
                                                            itemData = state.mergers.find(m => m.id === item.item_id);
                                                            itemTitle = itemData?.name || 'Unknown Merger';
                                                        } else if (item.item_type === 'extract') {
                                                            itemData = state.extracts.find(e => e.id === item.item_id);
                                                            itemTitle = itemData?.name || 'Unknown Extract';
                                                        }

                                                        return `
                                                            <div class="flex items-center gap-3 p-2 bg-gray-50 rounded">
                                                                <div class="cursor-move text-gray-400 hover:text-gray-600 text-xs">
                                                                    ‚ãÆ‚ãÆ
                                                                </div>
                                                                <div class="flex-1">
                                                                    <span class="text-sm font-medium text-gray-800">${itemTitle}</span>
                                                                    <span class="text-xs text-gray-500 ml-2">[${item.item_type.toUpperCase()}]</span>
                                                                </div>
                                                                <button onclick="removeItemFromFolder(${group.id}, '${item.item_id}', '${item.item_type}')" class="text-red-500 hover:text-red-700 text-sm">
                                                                    Remove
                                                                </button>
                                                            </div>
                                                        `;
                                                    }).join('')}
                                                </div>
                                            ` : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            `}

                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-6">
                                <p class="text-sm text-blue-800">
                                    üí° <strong>Note:</strong> Folders organize your contests, mergers, and extracts on the home page.
                                    They appear as expandable cards when "Newest First" sort is selected.
                                    Any other sort option will show all items in a flat list.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderMergedResults() {
            if (!state.mergedResults) {
                return '<div class="text-center p-8">No merged results available</div>';
            }

            const { contestIds, contestTitles, images } = state.mergedResults;

            // Create results structure similar to single contest
            const mergedResultsData = images.map(img => ({
                id: img.id,
                url: img.url,
                contestId: img.contestId,
                averageScore: parseFloat(img.averageScore),
                totalVotes: img.totalVotes,
                breakdown: img.voteBreakdown || []
            }));

            let displayResults, grouped, sortedKeys, voterStats;

            // === BY VOTER VIEW ===
            if (state.resultsView === 'byVoter') {
                // Generate voter stats from breakdown data
                const voterMap = {};
                mergedResultsData.forEach(imageResult => {
                    (imageResult.breakdown || []).forEach(vote => {
                        if (!vote.isBlocked) {
                            if (!voterMap[vote.userId]) {
                                voterMap[vote.userId] = {
                                    userId: vote.userId,
                                    username: vote.username,
                                    avatar: vote.avatar,
                                    totalScore: 0,
                                    totalImages: 0,
                                    isCurrentUser: vote.userId === state.user?.id
                                };
                            }
                            voterMap[vote.userId].totalScore += vote.score;
                            voterMap[vote.userId].totalImages++;
                        }
                    });
                });

                voterStats = Object.values(voterMap).map(voter => ({
                    ...voter,
                    averageScore: (voter.totalScore / voter.totalImages).toFixed(2)
                })).sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
            }
            // === USER VOTES VIEW ===
            else if (state.resultsView === 'userVotes') {
                const selectedUserId = state.selectedVoterUserId || state.user?.id;

                const userVotesMap = {};
                mergedResultsData.forEach(imageResult => {
                    const userVote = (imageResult.breakdown || []).find(v => v.userId === selectedUserId && !v.isBlocked);
                    if (userVote) {
                        userVotesMap[imageResult.id] = userVote.score;
                    }
                });

                displayResults = mergedResultsData.map(img => ({
                    ...img,
                    averageScore: userVotesMap[img.id] || 0,
                    userVoteScore: userVotesMap[img.id]
                })).filter(img => img.userVoteScore);

                grouped = groupMyVotesByScore(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => parseInt(b) - parseInt(a));
            }
            // === AVERAGE VIEW ===
            else {
                displayResults = mergedResultsData;
                grouped = groupByScoreRange(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => {
                    const aMin = grouped[a].min;
                    const bMin = grouped[b].min;
                    return bMin - aMin;
                });
            }

            // Get all voters for dropdown
            const voterSet = new Set();
            mergedResultsData.forEach(img => {
                (img.breakdown || []).forEach(vote => {
                    if (!vote.isBlocked) {
                        voterSet.add(JSON.stringify({ userId: vote.userId, username: vote.username, avatar: vote.avatar }));
                    }
                });
            });
            const mergedVoters = Array.from(voterSet).map(v => JSON.parse(v));

            const baseSize = 150;
            const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
            const baseFontSize = 12;
            const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

            // Build title
            const titleText = contestIds.length <= 3
                ? contestIds.map(id => contestTitles[id]).join(', ')
                : `${contestIds.length} contests`;

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="text-center mb-4">
                            <div class="flex items-center justify-center gap-2 mb-2">
                                <span class="text-4xl">üîÄ</span>
                                <h2 class="text-2xl font-bold text-gray-800">Merged Results</h2>
                            </div>
                            <div class="mb-1">
                                <button
                                    onclick="toggleMergedContestsDropdown()"
                                    class="text-gray-600 text-sm hover:bg-gray-100 px-3 py-1 rounded-lg border border-gray-300 transition-colors inline-flex items-center gap-1"
                                >
                                    ${contestIds.length} contest${contestIds.length !== 1 ? 's' : ''}
                                    <span class="text-xs">${state.showMergedContestsDropdown ? '‚ñ≤' : '‚ñº'}</span>
                                </button>
                                ${state.showMergedContestsDropdown ? `
                                    <div class="mt-2 bg-gray-50 border border-gray-300 rounded-lg px-4 py-2 text-left max-w-md mx-auto">
                                        ${contestIds.map(id => `
                                            <div class="text-sm text-gray-700 py-1">
                                                ‚Ä¢ ${contestTitles[id]}
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                            <p class="text-xs text-gray-500">Click on any image to see the vote breakdown</p>

                            <div class="mt-3 flex flex-col items-center justify-center gap-2">
                                <!-- First row: View tabs -->
                                <div class="flex items-center justify-center gap-3">
                                    <button
                                        onclick="setResultsView('average')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'average' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        Total
                                    </button>
                                    <button
                                        onclick="setResultsView('userVotes')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'userVotes' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        By User
                                    </button>
                                    <button
                                        onclick="setResultsView('byVoter')"
                                        class="px-3 py-1 rounded-lg ${state.resultsView === 'byVoter' ? 'bg-mauve-400 text-white' : 'bg-gray-200'}"
                                    >
                                        Average
                                    </button>
                                </div>
                                <!-- Share button row -->
                                <div class="flex items-center justify-center gap-3">
                                    <button
                                        onclick="copyMergeLink()"
                                        class="px-3 py-1 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition text-sm"
                                        title="Copy merge link to clipboard"
                                    >
                                        üìã Share Merge Link
                                    </button>
                                </div>
                                <!-- User selector dropdown for User Votes view -->
                                ${state.resultsView === 'userVotes' && mergedVoters.length > 0 ? `
                                    <div class="flex items-center gap-2">
                                        <label class="text-xs font-medium text-gray-700">Select User:</label>
                                        <select
                                            onchange="setResultsView('userVotes', this.value)"
                                            class="px-2 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                        >
                                            ${mergedVoters.map(voter => {
                                                const isSelected = (state.selectedVoterUserId || state.user?.id) === voter.userId;
                                                const isCurrent = voter.userId === state.user?.id;
                                                return `
                                                    <option value="${voter.userId}" ${isSelected ? 'selected' : ''}>
                                                        ${voter.username}${isCurrent ? ' (You)' : ''}
                                                    </option>
                                                `;
                                            }).join('')}
                                        </select>
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        ${state.resultsView !== 'byVoter' ? `
                        <div class="mb-4 max-w-md mx-auto">
                            <div class="flex items-center gap-2">
                                <label class="text-xs font-medium text-gray-700 whitespace-nowrap">Image Scale:</label>
                                <button
                                    onclick="adjustScale(-1)"
                                    class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                    title="Decrease scale"
                                >‚àí</button>
                                <input
                                    type="range"
                                    id="scaleSlider"
                                    min="40"
                                    max="200"
                                    value="${state.imageScale}"
                                    oninput="updateScale(this.value)"
                                    class="flex-1 h-2 bg-gray-200 rounded-lg cursor-pointer"
                                />
                                <button
                                    onclick="adjustScale(1)"
                                    class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                    title="Increase scale"
                                >+</button>
                                <span class="text-xs font-medium text-gray-700 w-10">${state.imageScale}%</span>
                            </div>
                        </div>
                        ` : ''}

                        ${state.resultsView === 'byVoter' ? `
                            ${voterStats && voterStats.length > 0 ? `
                                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-2">
                                    ${(() => {
                                        let totalVotes = 0;
                                        let totalScore = 0;
                                        mergedResultsData.forEach(img => {
                                            (img.breakdown || []).forEach(vote => {
                                                if (!vote.isBlocked) {
                                                    totalVotes++;
                                                    totalScore += vote.score;
                                                }
                                            });
                                        });
                                        const contestAverage = totalVotes > 0 ? (totalScore / totalVotes).toFixed(2) : 0;

                                        return `
                                            <div class="bg-gradient-to-br from-yellow-50 to-yellow-100 rounded-lg shadow-md p-3 flex flex-col items-center border-2 border-yellow-500">
                                                <div class="text-2xl mb-2">üèÜ</div>
                                                <div class="text-xs font-semibold text-gray-800 text-center mb-1">
                                                    Contest Average
                                                </div>
                                                <div class="text-xl font-bold text-white score-text">
                                                    ${contestAverage}
                                                </div>
                                                <div class="text-xs text-gray-500">
                                                    ${totalVotes} vote${totalVotes !== 1 ? 's' : ''}
                                                </div>
                                            </div>
                                        `;
                                    })()}
                                    ${voterStats.map(voter => `
                                        <div class="bg-white rounded-lg shadow-md p-3 flex flex-col items-center hover:shadow-lg transition-shadow cursor-pointer border-2 ${voter.isCurrentUser ? 'border-mauve-400' : 'border-transparent'}">
                                            <img src="${voter.avatar}" alt="${voter.username}" class="w-12 h-12 rounded-full mb-2" />
                                            <div class="text-xs font-semibold text-gray-800 truncate w-full text-center mb-1" title="${voter.username}">
                                                ${voter.username}
                                            </div>
                                            <div class="text-xl font-bold text-white score-text">
                                                ${voter.averageScore}
                                            </div>
                                            <div class="text-xs text-gray-500">
                                                ${voter.totalImages} vote${voter.totalImages !== 1 ? 's' : ''}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">üë•</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Voters Yet</h3>
                                    <p class="text-gray-600">No voting data available for merged contests.</p>
                                </div>
                            `}
                        ` : state.resultsView === 'userVotes' && (!displayResults || displayResults.length === 0) ? `
                            <div class="text-center py-12">
                                <div class="text-6xl mb-4">üì≠</div>
                                <h3 class="text-xl font-bold text-gray-800 mb-2">No Votes Yet</h3>
                                <p class="text-gray-600">This user hasn't voted on any images in these contests.</p>
                            </div>
                        ` : sortedKeys.map(key => {
                            const group = grouped[key];

                            if (state.resultsView === 'userVotes') {
                                const score = group.score;
                                const colorStyle = getScoreColor(score);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg inline-block" style="color: white; background-color: ${colorStyle};">
                                            Score ${score}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdownMerged(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            } else {
                                const colorStyle = getCategoryColor(group.min, group.isMissing);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg ${colorStyle.color} ${colorStyle.bg} w-full block">
                                            ${getCategoryLabel(group.min, group.max, group.isMissing)}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdownMerged(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                    <div class="absolute bottom-0 left-0 right-0 text-white text-center py-1 font-bold score-text" style="font-size: ${fontSize}px;">
                                                        ${item.averageScore}
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>

                    ${state.showBreakdownModal ? renderBreakdownModalMerged() : ''}
                </div>
            `;
        }

        function render() {
            const app = document.getElementById('app');
            
            if (!state.isLoggedIn) {
                app.innerHTML = renderHeader() + renderLoginScreen() + renderModal() + renderUploadProgressModal() + renderToast() + renderLoadingOverlay();
                return;
            }

            let content = '';
            switch(state.view) {
                case 'home':
                    content = renderHome();
                    break;
                case 'createContest':
                    content = renderCreateContest();
                    break;
                case 'vote':
                    content = renderVoting();
                    break;
                case 'results':
                    content = renderResults();
                    break;
                case 'mergedResults':
                    content = renderMergedResults();
                    break;
                default:
                    content = renderHome();
            }

            app.innerHTML = renderHeader() + content + renderModal() + renderMergeModal() + renderCreateMergerModal() + renderCreateExtractModal() + renderUploadProgressModal() + (state.showAdminDashboard ? renderAdminDashboard() : '') + (state.showAppSettingsModal ? renderAppSettingsModal() : '') + (state.showManageFoldersModal ? renderManageFoldersModal() : '') + renderToast() + renderLoadingOverlay();
        }

        window.login = login;
        window.logout = logout;
        window.startCreateContest = startCreateContest;
        window.handleContestTitle = handleContestTitle;
        window.confirmCreateWithDuplicateTitle = confirmCreateWithDuplicateTitle;
        window.cancelCreateContest = cancelCreateContest;
        window.confirmCancelCreate = confirmCancelCreate;
        window.addImageFromUrl = addImageFromUrl;
        window.clearUrlInput = clearUrlInput;
        window.handleFileSelect = handleFileSelect;
        window.handleDragOver = handleDragOver;
        window.handleDragLeave = handleDragLeave;
        window.handleDrop = handleDrop;
        window.removeContestImage = removeContestImage;
        window.confirmRemoveImage = confirmRemoveImage;
        window.finishCreateContest = finishCreateContest;
        window.confirmFinishCreateContest = confirmFinishCreateContest;
        window.startVoting = startVoting;
        window.viewResults = viewResults;
        window.viewLockedResults = viewLockedResults;
        window.startRevote = startRevote;
        window.confirmRevote = confirmRevote;
        window.toggleUserDropdown = toggleUserDropdown;
        window.shareContest = shareContest;
        window.toggleContestSelection = toggleContestSelection;
        window.shareMerge = shareMerge;
        window.viewMerge = viewMerge;
        window.openMergeModal = openMergeModal;
        window.closeMergeModal = closeMergeModal;
        window.viewSelectedMerge = viewSelectedMerge;
        window.copyMergeLink = copyMergeLink;
        window.showBreakdownMerged = showBreakdownMerged;
        window.toggleContestLock = toggleContestLock;
        window.handleVote = handleVote;
        window.navigateImage = navigateImage;
        window.jumpToImage = jumpToImage;
        window.cancelVoting = cancelVoting;
        window.submitVotes = submitVotes;
        window.showBreakdown = showBreakdown;
        window.closeBreakdown = closeBreakdown;
        window.backToHome = backToHome;
        window.confirmBackToHome = confirmBackToHome;
        window.closeModal = closeModal;
        window.closeUploadProgress = closeUploadProgress;
        window.retryUpload = retryUpload;
        window.cancelAllUploads = cancelAllUploads;
        window.updateScale = updateScale;
        window.adjustScale = adjustScale;
        window.confirmSubmitVotes = confirmSubmitVotes;
        window.confirmCancelVoting = confirmCancelVoting;
        window.toggleVoteView = toggleVoteView;
        window.deleteContest = deleteContest;
        window.handleDeleteContestConfirmation = handleDeleteContestConfirmation;
        window.confirmDeleteContest = confirmDeleteContest;
        window.setSortBy = setSortBy;
        window.setFilterCreator = setFilterCreator;
        window.setSearchQuery = setSearchQuery;
        window.clearAllFilters = clearAllFilters;
        window.toggleImageLabels = toggleImageLabels;
        window.updateImageLabel = updateImageLabel;
        window.showAdminDashboard = showAdminDashboard;
        window.closeAdminDashboard = closeAdminDashboard;
        window.showAppSettings = showAppSettings;
        window.closeAppSettings = closeAppSettings;
        window.toggleAppSetting = toggleAppSetting;
        window.confirmBanUser = confirmBanUser;
        window.handleBanUserReason = handleBanUserReason;
        window.executeBanUser = executeBanUser;
        window.unbanUser = unbanUser;
        window.adminEditVote = adminEditVote;
        window.confirmEditVote = confirmEditVote;
        window.adminToggleBlockVote = adminToggleBlockVote;
        window.executeToggleBlockVote = executeToggleBlockVote;
        window.confirmAddDuplicateImage = confirmAddDuplicateImage;
        window.setResultsView = setResultsView;
        window.openCreateMergerModal = openCreateMergerModal;
        window.closeCreateMergerModal = closeCreateMergerModal;
        window.toggleContestForMerger = toggleContestForMerger;
        window.setMergerName = setMergerName;
        window.saveMerger = saveMerger;
        window.deleteMerger = deleteMerger;
        window.viewMergerResults = viewMergerResults;
        window.startMergerVoting = startMergerVoting;
        window.showMergerVoteModal = showMergerVoteModal;
        window.shareMerger = shareMerger;
        window.openCreateExtractModal = openCreateExtractModal;
        window.closeCreateExtractModal = closeCreateExtractModal;
        window.deleteExtract = deleteExtract;
        window.startExtractVoting = startExtractVoting;
        window.viewExtractResults = viewExtractResults;
        window.selectExtractSource = selectExtractSource;
        window.toggleExtractImage = toggleExtractImage;
        window.setExtractName = setExtractName;
        window.saveExtract = saveExtract;
        window.openManageFoldersModal = openManageFoldersModal;
        window.closeManageFoldersModal = closeManageFoldersModal;
        window.createFolder = createFolder;
        window.deleteFolder = deleteFolder;
        window.addItemToFolder = addItemToFolder;
        window.removeItemFromFolder = removeItemFromFolder;
        window.toggleFolderExpanded = toggleFolderExpanded;

        // Initialize app
        // Check for existing session on load
        (async function init() {
            const storedUser = localStorage.getItem('peony_user');
            if (storedUser) {
                try {
                    const user = JSON.parse(storedUser);

                    // Check if token is expired
                    if (user.expiresAt && Date.now() < user.expiresAt) {
                        // Check if user is banned and get ban reason
                        const banCheckResponse = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${user.id}&select=is_banned,ban_reason`, {
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Cache-Control': 'no-cache'
                            }
                        });

                        const userData = await banCheckResponse.json();

                        // If user is banned, log them out with reason
                        if (userData && userData.length > 0 && userData[0].is_banned === true) {
                            const banReason = userData[0].ban_reason || 'No reason provided';
                            localStorage.removeItem('peony_user');
                            showAlert(`Your account has been banned from Peony.\n\nReason: ${banReason}`, 'üö´');
                        } else {
                            // User not banned, proceed with login
                            state.isLoggedIn = true;
                            // AFTER: ensure user exists, then continue
                            state.user = { 
                                id: user.id, 
                                username: user.username, 
                                avatar: user.avatar 
                            };

                            // Ensure the row exists in public.users, then continue
                            ensureLocalUser(state.user)
                                .then(async () => {
                                    // proceed normally once the user row is present (or insertion attempted)
                                    await loadContests();

                                    render();
                                })
                                .catch(async (err) => {
                                    // should not happen because ensureLocalUser swallows errors, but safe fallback
                                    console.error('ensureLocalUser unexpected error:', err);
                                    await loadContests();
                                    render();
                                });
                        }
                    } else {
                        // Token expired, clear it
                        localStorage.removeItem('peony_user');
                    }
                } catch (e) {
                    console.error('Error loading user session:', e);
                    localStorage.removeItem('peony_user');
                }
            }

            await Promise.all([
                loadContests(),
                loadMergers(),
                loadExtracts(),
                loadGroups(),
                loadAppSettings()
            ]);
            if (state.user) {
                await loadUserVotes();
            }

            // Parse URL search parameter
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('search');
            if (searchQuery) {
                state.filters.searchQuery = searchQuery;
            }

            render();

            // Setup hash change listener for browser back/forward
            window.addEventListener('hashchange', handleHashChange);

            // Check for shared contest link on initial load
            if (window.location.hash && state.isLoggedIn) {
                handleHashChange();
            }
        })();
    </script>
</body>
</html>
