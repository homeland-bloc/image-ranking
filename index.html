<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <!-- PWA Configuration -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Peony">

    <!-- Favicon for browsers -->
    <link rel="icon" type="image/x-icon" href="favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">

    <!-- Apple Touch Icon for iOS home screen -->
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">

    <!-- Android Chrome Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="favicon/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="favicon/android-chrome-512x512.png">
    <!-- PWA Manifest -->
    <link rel="manifest" href="favicon/site.webmanifest">

    <!-- Canonical URL for GitHub Pages PWA -->
    <link rel="canonical" href="https://bicipikay.github.io/peony/">

    <!-- Theme color for mobile browsers -->
    <meta name="theme-color" content="#C77BA6">

    <title>Peony</title>

    <!-- Supabase JS Client for Realtime -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- SortableJS for drag-and-drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'mauve': {
                            300: '#D88FB8',
                            400: '#C77BA6',
                            500: '#B76E9E',
                            600: '#A86590',
                            700: '#995C82'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lilita+One&display=swap');
        
        @keyframes tickAppear {
            0% { transform: scale(0) rotate(-45deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(0deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        .tick-animation {
            animation: tickAppear 0.6s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal-overlay {
            animation: modalFadeIn 0.2s ease-out;
            background: rgba(0, 0, 0, 0.7);
        }
        @keyframes modalSlideIn {
            from { transform: scale(0.9) translateY(-20px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }
        .modal-content {
            animation: modalSlideIn 0.3s ease-out;
        }
        body {
            background: linear-gradient(to bottom,
                rgba(250, 232, 255, 0.3),
                rgba(220, 252, 231, 0.3)
            );
            min-height: 100vh;
        }
        body.modal-open {
            overflow: hidden;
        }
        .image-loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        @keyframes toastSlideIn {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes toastFadeOut {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-20px); opacity: 0; }
        }
        .toast-notification {
            animation: toastSlideIn 0.3s ease-out;
        }
        .toast-notification.fade-out {
            animation: toastFadeOut 0.3s ease-out;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        input[type="range"]::-webkit-slider-track {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, rgb(180, 90, 145) 0%, rgb(34, 197, 94) 100%);
            border: 2px solid rgba(0, 0, 0, 0.25);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        input[type="range"]::-moz-range-track {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, rgb(180, 90, 145) 0%, rgb(34, 197, 94) 100%);
            border: 2px solid rgba(0, 0, 0, 0.25);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 3px solid rgb(180, 90, 145);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 3px solid rgb(180, 90, 145);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .upload-area {
            border: 3px dashed #C77BA6;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            border-color: #B76E9E;
            background: rgba(199, 123, 166, 0.05);
        }
        .upload-area.dragover {
            border-color: #22C55E;
            background: rgba(34, 197, 94, 0.1);
            transform: scale(1.02);
        }
        .score-text {
            font-family: 'Lilita One', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), -1px -1px 2px rgba(0,0,0,0.8), 1px -1px 2px rgba(0,0,0,0.8), -1px 1px 2px rgba(0,0,0,0.8);
        }
        .progress-segment {
            height: 8px;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .progress-segment:hover {
            transform: scaleY(1.3);
        }
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background-color: #ccc;
            border-radius: 30px;
            cursor: pointer;
            transition: background-color 0.3s;
            display: inline-block;
        }
        .toggle-switch.active {
            background-color: #C77BA6;
        }
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(30px);
        }
        .voting-image {
            max-height: 50vh;
        }
        @media (min-width: 640px) {
            .voting-image {
                max-height: min(40vh, 500px);
            }
        }
        /* PWA safe area support for iOS and Android fullscreen mode */
        .safe-header {
            padding-top: env(safe-area-inset-top);
        }
        /* Realtime toast notifications - slide in from right */
        @keyframes slideInRight {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background-color: #ccc;
            border-radius: 26px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .toggle-switch.active {
            background-color: #4CAF50;
        }
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        /* Dark Theme Styles */
        body.dark-theme {
            background: linear-gradient(to bottom,
                rgba(60, 55, 65, 0.95),
                rgba(55, 65, 60, 0.95)
            );
            color: #e0e0e0;
        }

        body.dark-theme .bg-white:not(.rounded-full) {
            background-color: #1e1e2e !important;
        }

        /* Keep voting mode switch circle white */
        body.dark-theme .bg-white.rounded-full {
            background-color: white !important;
        }

        /* Loading spinner should be transparent, not white */
        body.dark-theme .animate-spin.rounded-full {
            background-color: transparent !important;
        }

        body.dark-theme .bg-blue-50 {
            background-color: #1a2540 !important;
        }

        /* Extract cards - blueish tint */
        body.dark-theme .bg-yellow-50:not(button):not(.hover\:bg-yellow-100) {
            background-color: #2a3550 !important;
        }

        /* Don't change text color for most text elements */
        body.dark-theme .text-gray-800,
        body.dark-theme .text-gray-600 {
            color: #e0e0e0 !important;
        }

        body.dark-theme .text-gray-700 {
            color: #e0e0e0 !important;
        }

        /* Keep text dark on gray backgrounds for readability */
        body.dark-theme .bg-gray-50 .text-gray-800,
        body.dark-theme .bg-gray-50 .text-gray-700,
        body.dark-theme .bg-gray-50 .text-gray-600 {
            color: #374151 !important;
        }

        /* Keep text dark on buttons and controls with bg-gray-200 */
        body.dark-theme button.bg-gray-200.text-gray-700,
        body.dark-theme .bg-gray-200 .text-gray-700 {
            color: #374151 !important;
        }

        body.dark-theme .text-blue-900,
        body.dark-theme .text-blue-700 {
            color: #a0c4ff !important;
        }

        body.dark-theme .text-yellow-900,
        body.dark-theme .text-yellow-700 {
            color: #ffd68a !important;
        }

        body.dark-theme .border-gray-200,
        body.dark-theme .border-gray-300 {
            border-color: #3a3a4a !important;
        }

        body.dark-theme .border-yellow-400 {
            border-color: #6a5a2a !important;
        }

        /* Merger cards - more blueish border */
        body.dark-theme .border-blue-300 {
            border-color: #4a5a7a !important;
        }

        body.dark-theme .shadow-lg,
        body.dark-theme .shadow-xl {
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5) !important;
        }

        body.dark-theme .hover\:bg-gray-100:hover {
            background-color: #2a2a3a !important;
        }

        body.dark-theme input[type="text"],
        body.dark-theme input[type="number"],
        body.dark-theme textarea,
        body.dark-theme select {
            background-color: #2a2a3a !important;
            color: #e0e0e0 !important;
            border-color: #3a3a4a !important;
        }

        body.dark-theme input::placeholder,
        body.dark-theme textarea::placeholder {
            color: #888 !important;
        }

        body.dark-theme .modal-overlay {
            background: rgba(0, 0, 0, 0.85) !important;
        }

        body.dark-theme .image-loading {
            background: linear-gradient(90deg, #2a2a3a 25%, #3a3a4a 50%, #2a2a3a 75%);
        }

        /* Keep navigation buttons (bg-gray-200) visible in dark theme */
        body.dark-theme button.bg-gray-200,
        body.dark-theme button.bg-gray-300 {
            background-color: #d0d0d0 !important;
        }

        /* Keep theme switch background gray in dark mode */
        body.dark-theme .bg-gray-300.rounded-full {
            background-color: #6b7280 !important; /* Proper gray that contrasts with white circle */
        }

        body.dark-theme button.hover\:bg-gray-300:hover {
            background-color: #e0e0e0 !important;
        }

        /* Progress bar container should be dark */
        body.dark-theme .bg-gray-200.h-3 {
            background-color: #1a1a1a !important;
        }

        /* Keep text on navigation buttons dark for visibility */
        body.dark-theme .bg-gray-200.text-gray-700 {
            color: #374151 !important;
        }

        /* Keep voting mode switch circle white */
        body.dark-theme .toggle-slider {
            background-color: white !important;
        }

        /* Use gray gradient for card action buttons */
        body.dark-theme .bg-gradient-to-r.from-blue-500.to-blue-600,
        body.dark-theme .bg-gradient-to-r.from-blue-400.to-blue-600 {
            background: linear-gradient(to right, #4a5568, #2d3748) !important;
        }

        /* Adapt "Show more" button sections to dark theme */
        body.dark-theme button.bg-yellow-50,
        body.dark-theme .bg-yellow-50.hover\:bg-yellow-100 {
            background-color: #3a3520 !important;
        }

        body.dark-theme button.bg-red-50,
        body.dark-theme .bg-red-50.hover\:bg-red-100 {
            background-color: #3a2020 !important;
        }

        body.dark-theme button.bg-green-50,
        body.dark-theme .bg-green-50.hover\:bg-green-100 {
            background-color: #203a20 !important;
        }

        /* Keep activity list backgrounds in their original colors */
        body.dark-theme .modal-content .bg-yellow-50,
        body.dark-theme .modal-content .bg-yellow-100,
        body.dark-theme .modal-content .bg-green-100,
        body.dark-theme .modal-content .bg-blue-100,
        body.dark-theme .modal-content .bg-purple-100,
        body.dark-theme .modal-content .bg-gray-50 {
            background-color: revert !important;
        }

        body.dark-theme .text-yellow-600,
        body.dark-theme .text-red-600,
        body.dark-theme .text-green-600 {
            color: #d0d0d0 !important;
        }

        body.dark-theme .hover\:text-yellow-700:hover,
        body.dark-theme .hover\:text-red-700:hover,
        body.dark-theme .hover\:text-green-700:hover {
            color: #e0e0e0 !important;
        }

        body.dark-theme .hover\:bg-yellow-100:hover:not(.modal-content *) {
            background-color: #4a4530 !important;
        }

        body.dark-theme .hover\:bg-red-100:hover:not(.modal-content *) {
            background-color: #4a3030 !important;
        }

        body.dark-theme .hover\:bg-green-100:hover:not(.modal-content *) {
            background-color: #304a30 !important;
        }

        body.dark-theme .hover\:bg-blue-200:hover:not(.modal-content *) {
            background-color: #304050 !important;
        }

        body.dark-theme .hover\:bg-purple-200:hover:not(.modal-content *) {
            background-color: #403050 !important;
        }

        body.dark-theme .hover\:bg-yellow-200:hover:not(.modal-content *) {
            background-color: #4a4530 !important;
        }

        /* Keep images with white backgrounds visible */
        body.dark-theme img:not(.rounded-full):not(.avatar) {
            background-color: white !important;
        }

        /* Keep avatar circles with their background */
        body.dark-theme .rounded-full {
            background-color: white !important;
        }

        /* Keep tabs text black on results page */
        body.dark-theme button[onclick*="setResultsView"] {
            color: #000 !important;
        }

        /* Statistics label and numbers should keep their default colors in dark theme */
        /* Removed forced dark colors to allow proper visibility */

        /* Keep info buttons gray instead of blue */
        body.dark-theme button[onclick*="showContestInfoModal"].bg-blue-500,
        body.dark-theme button[onclick*="showContestInfoModal"].hover\:bg-blue-600 {
            background: linear-gradient(to right, #4a5568, #2d3748) !important;
        }

        /* Activity list text should keep default colors for readability */
        /* Removed forced dark text colors on light backgrounds */

        /* Polish folder header colors for dark theme */
        body.dark-theme .bg-gradient-to-r.from-yellow-400.to-yellow-500 {
            background: linear-gradient(to right, #b8860b, #daa520) !important;
        }

        /* Polish "Complete Voting" section header */
        body.dark-theme .bg-gradient-to-r.from-yellow-300.to-yellow-400 {
            background: linear-gradient(to right, #b8860b, #daa520) !important;
        }

        /* Polish top bar gradient */
        body.dark-theme .bg-gradient-to-r.from-mauve-400.to-purple-500,
        body.dark-theme .bg-gradient-to-r.from-mauve-500.to-purple-600 {
            background: linear-gradient(to right, #6b5b95, #8b7bb8) !important;
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="app"></div>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            // Emergency error handler to catch JavaScript errors
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e);
            const app = document.getElementById('app');
            if (app && !app.innerHTML) {
                app.innerHTML = `
                    <div style="padding: 2rem; font-family: sans-serif; max-width: 800px; margin: 0 auto;">
                        <h1 style="color: #ef4444; margin-bottom: 1rem;">‚ö†Ô∏è Error Loading App</h1>
                        <div style="background: #fee; border: 1px solid #fcc; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <p><strong>Error:</strong> ${e.message || 'Unknown error'}</p>
                            <p><strong>File:</strong> ${e.filename || 'Unknown'}</p>
                            <p><strong>Line:</strong> ${e.lineno || 'Unknown'}:${e.colno || 'Unknown'}</p>
                        </div>
                        <p style="margin-bottom: 0.5rem;"><strong>What to do:</strong></p>
                        <ol style="line-height: 1.6;">
                            <li>Open browser console (F12) for detailed error information</li>
                            <li>Check for JavaScript syntax errors in index.html</li>
                            <li>Verify Supabase is loading correctly</li>
                            <li>Clear browser cache and reload the page</li>
                        </ol>
                    </div>
                `;
            }
        });

        // Supabase Configuration
        const SUPABASE_URL = 'https://tbduuuzwbiidjgztupfp.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRiZHV1dXp3YmlpZGpnenR1cGZwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0NTI3NjcsImV4cCI6MjA4MDAyODc2N30.lMDbB1I7vNoMFCncGw7_i9hUtWp-mO9rsmFLgd3GMMQ';

        // Discord OAuth Configuration
        const DISCORD_CLIENT_ID = '1442282566810861568';  // Replace with your actual Discord Client ID
        const DISCORD_REDIRECT_URI = 'https://bicipikay.github.io/peony/auth/callback';  // Replace with YOUR actual GitHub Pages URL + /auth/callback

        // Admin Discord ID - Replace with your actual Discord user ID after first login
        const ADMIN_DISCORD_ID = '719271552247529571';

        // Initialize Supabase client (only if not already initialized to prevent duplicate declaration errors)
        if (typeof window.supabaseClient === 'undefined') {
            window.supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }
        const supabase = window.supabaseClient;

        let state = {
            isLoggedIn: false,
            user: null,
            view: 'home',
            contests: [],
            currentContest: null,
            currentShortcake: null,
            currentImageIndex: 0,
            votes: {},
            shortlistedImageIds: [],
            userVotedContests: {},
            hasSubmitted: false,
            showBreakdownModal: null,
            showTickAnimation: false,
            isAnimating: false,
            modal: null,
            modalProcessing: false,
            imageScale: 100,
            results: null,
            scaleUpdateTimeout: null,
            newContest: { title: '', images: [] },
            newShortcake: { title: '', images: [], min: 5, max: 20 },
            showMyVotes: false,  // Deprecated, use resultsView
            resultsView: 'average',  // 'average', 'userVotes', or 'byVoter'
            voterSortBy: 'scoreDesc',  // 'scoreDesc', 'scoreAsc', 'nameAsc', 'nameDesc' for byVoter view
            selectedVoterUserId: null,  // For user votes dropdown (null = current user)
            contestVoters: [],  // List of all users who voted in current contest(s)
            shuffledImages: [],
            nextContestId: 1,
            bannedUsers: [], // Array of user IDs who are banned from app
            allUsers: [], // Track all users who have logged in
            uploadProgress: null, // Upload progress tracking: { files: [{name, status, error, progress}], completed: false }
            compressionProgress: null, // Compression progress: { files: [{name, status, originalSize, compressedSize, progress, error, canCompressMore, file, previewUrl, currentQuality, currentMaxDimension}], allComplete: false }
            showUserList: false, // Show user list modal (admin only)
            showAdminDashboard: false, // Show admin dashboard modal
            showAppSettingsModal: false, // Show app settings modal (admin only)
            showActivityLogsModal: false, // Show activity logs modal (admin only)
            activityLogs: [], // Recent vote submission activity
            activityLogsLoading: false, // Loading state for activity logs modal
            activityDateStart: null, // Start date for activity logs (null = default to 7 days ago)
            activityDateEnd: null, // End date for activity logs (null = default to today)
            activityFilterUser: null, // Filter activity by specific user ID (null = all users)
            activityFilterContest: null, // Filter activity by specific contest ID (null = all contests)
            adminStats: { totalVotes: 0, totalUniqueVoters: 0 }, // Admin dashboard statistics
            adminDashboardLoading: false, // Loading state for admin dashboard modal
            showFilters: false, // Toggle for search/sort/filter section
            filters: {
                createdBy: null,           // Username or null
                sortBy: 'newest',          // 'newest', 'oldest', 'mostVoted', 'leastVoted', etc.
                searchQuery: ''            // Search term for contest titles
            },
            mergedResults: null, // Results from merged contests
            mergers: [], // Array of merger objects from database
            extracts: [], // Array of extract objects from database
            shortcakes: [], // Array of shortcake objects from database
            groups: [], // Array of group objects from database
            showCreateMergerModal: false, // Show create merger modal
            showCreateExtractModal: false, // Show create extract modal
            showManageFoldersModal: false, // Show manage folders modal
            newMergerName: '', // Name for new merger being created
            newExtractName: '', // Name for new extract being created
            extractSourceType: null, // 'contest', 'merger', or 'shortcake'
            extractSourceId: null, // ID of source contest/merger
            isInitializing: false, // Flag to prevent rendering during initialization
            extractSelectedImages: [], // Array of image IDs selected for extract
            selectedFolderId: null, // Currently selected folder for viewing
            expandedFolderIds: [], // Array of folder IDs that are expanded
            appSettings: {}, // Global app settings (contest creation enabled, revoting enabled)
            view: 'home',
            viewingUserId: null, // User ID being viewed in profile
            showUserProfileModal: false, // Show user profile modal
            toast: null, // Toast notification { message, icon }
            isLoading: false,
            loadingMessage: '',
            showUserDropdown: false,  // User menu dropdown state
            showMergedContestsDropdown: false,  // Merged contests dropdown state
            currentMergerId: null,  // ID of current merger being voted on
            mergerContestIds: [],  // Array of contest IDs in current merger voting session
            selectedFolderItems: [],  // Array of indices for multi-select in Add Item modal
            votingMode: 'multi',  // 'single' or 'multi' - voting view mode (default: multi)
            selectedScore: null,  // Currently selected score in multi-mode voting (1-5 or null)
            multiVotingImageScale: 67,  // Image scale for multi-mode voting (20-200%)
            multiModeFilter: null,  // Filter for multi-mode voting: null, 1-5, or 'non-voted'
            multiModeSort: 'default',  // Sort for multi-mode voting: 'default', 'highest', 'lowest'
            showUnifiedCreateModal: false,  // Show unified creation modal
            extractImageScale: 100,  // Image scale for extract image selection pages (100-400%)
            pinnedItems: [],  // Array of pinned items from database
            isPinnedSectionExpanded: false,  // Whether pinned section is expanded (default: folded)
            isCompleteVotingExpanded: false,  // Whether Complete Voting section is expanded (default: folded, show 1 item)
            showPinIcons: false,  // Whether to show pin icons (admin only, default: false)
            isAllContestsSectionExpanded: true,  // Whether All Contests section is expanded (default: expanded)
            lastClickedImageId: null,  // Last clicked image ID in multi-mode voting
            isLoadingMultiModeImages: false,  // Whether images are loading in multi mode
            multiModeLoadedImages: 0,  // Number of images loaded in multi mode
            multiModeTotalImages: 0,  // Total images to load in multi mode
            showLogoutConfirmModal: false,  // Show logout confirmation modal
            sessionExpired: false,  // Whether session has expired (show banner on login screen)
            darkTheme: false,  // Dark theme enabled
            themeToggling: false,  // Prevent theme toggle spam
            pendingRoute: null  // Store route to redirect after login (e.g., '#contest=uuid')
        };

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function formatVoterCount(voterCount, voterCountMin, voterCountMax) {
            if (voterCountMin !== undefined && voterCountMax !== undefined && voterCountMin !== voterCountMax) {
                return `${voterCountMin}-${voterCountMax}`;
            }
            return voterCount;
        }

        function setLoading(message) {
            state.isLoading = true;
            state.loadingMessage = message;
            render();
        }

        function clearLoading() {
            state.isLoading = false;
            state.loadingMessage = '';
            render();
        }

        // ==================== HELPER FUNCTIONS ====================

        // Generic Supabase fetch with cache-busting headers
        async function fetchFromSupabase(endpoint, options = {}) {
            const defaultHeaders = {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                'Pragma': 'no-cache',
                'Expires': '0'
            };

            return fetch(`${SUPABASE_URL}${endpoint}`, {
                ...options,
                headers: { ...defaultHeaders, ...options.headers }
            });
        }

        // Format date as "day month year" (e.g., "30 Nov 2025")
        function formatDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
        }

        // Safely stringify JSON for HTML attributes
        function safeStringify(obj) {
            return JSON.stringify(obj).replace(/'/g, "&apos;");
        }

        // ==================== TOAST NOTIFICATIONS ====================

        /**
         * Show toast notification (lightweight, non-disruptive)
         * Used for user actions (ban/unban, vote submission, etc.)
         * @param {string} message - Message to display
         * @param {string} type - 'info', 'success', 'error', or 'warning'
         * @param {number} duration - Display duration in ms (default 3000)
         */
        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            const bgColors = {
                info: 'bg-blue-500',
                success: 'bg-green-500',
                error: 'bg-red-500',
                warning: 'bg-yellow-500'
            };

            toast.className = `fixed top-20 right-4 z-50 px-4 py-3 rounded-lg shadow-lg text-white text-sm font-medium transition-all transform translate-x-0 ${bgColors[type] || 'bg-gray-700'}`;
            toast.textContent = message;
            toast.style.animation = 'slideInRight 0.3s ease-out';

            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // ==================== END TOAST NOTIFICATIONS ====================

        function getScoreColor(score) {
            const colors = {
                1: 'rgb(220, 38, 38)',
                2: 'rgb(249, 115, 22)',
                3: 'rgb(234, 179, 8)',
                4: 'rgb(132, 204, 22)',
                5: 'rgb(34, 197, 94)'
            };
            return colors[score] || 'rgb(156, 163, 175)';
        }

        function getCategoryLabel(min, max, isMissing) {
            if (isMissing) return 'Votes Missing';
            if (min === 4.5) return '4.5 - 5.0';
            return `${min.toFixed(1)} - ${max.toFixed(2)}`;
        }

        function getCategoryColor(min, isMissing) {
            // Special styling for missing votes - black text on dark gray background
            if (isMissing) return { color: 'text-black', bg: 'bg-gray-400', textColor: 'rgb(0, 0, 0)', bgColor: 'rgb(156, 163, 175)' };

            // Strong blue (4.5-5.0) - highest scores
            if (min >= 4.5) return { color: 'text-blue-700', bg: 'bg-blue-100', textColor: 'rgb(29, 78, 216)', bgColor: 'rgb(219, 234, 254)' };
            // Saturated cyan (4.0-4.49) - very good scores
            if (min >= 4.0) return { color: 'text-cyan-700', bg: 'bg-cyan-100', textColor: 'rgb(14, 116, 144)', bgColor: 'rgb(207, 250, 254)' };
            // Bright green (3.5-3.99) - good scores
            if (min >= 3.5) return { color: 'text-green-700', bg: 'bg-green-100', textColor: 'rgb(21, 128, 61)', bgColor: 'rgb(220, 252, 231)' };
            // Lime-green (3.0-3.49) - above average, MUST be green
            if (min >= 3.0) return { color: 'text-lime-700', bg: 'bg-lime-100', textColor: 'rgb(77, 124, 15)', bgColor: 'rgb(236, 252, 203)' };
            // Pale yellow (2.5-2.99) - average
            if (min >= 2.5) return { color: 'text-yellow-800', bg: 'bg-yellow-100', textColor: 'rgb(113, 63, 18)', bgColor: 'rgb(253, 224, 71)' };
            // Pale orange (2.0-2.49) - below average
            if (min >= 2.0) return { color: 'text-orange-800', bg: 'bg-orange-100', textColor: 'rgb(154, 52, 18)', bgColor: 'rgb(253, 186, 116)' };
            // Pale red (1.5-1.99) - low scores
            if (min >= 1.5) return { color: 'text-red-800', bg: 'bg-red-100', textColor: 'rgb(153, 27, 27)', bgColor: 'rgb(252, 165, 165)' };
            // Pale purple (1.0-1.49) - lowest scores
            if (min >= 1.0) return { color: 'text-purple-800', bg: 'bg-purple-200', textColor: 'rgb(107, 33, 168)', bgColor: 'rgb(216, 180, 254)' };
            // Fallback for any edge cases
            return { color: 'text-gray-600', bg: 'bg-gray-50', textColor: 'rgb(75, 85, 99)', bgColor: 'rgb(249, 250, 251)' };
        }


        async function loadResults() {
            setLoading('Loading results...');
            try {
                console.log('üîç DEBUG: Loading results for contest:', state.currentContest.id);
                console.log('üîç DEBUG: Current user:', state.user);

                let allVotes = [];
                const isExtract = state.currentContest.isExtract === true;

                if (isExtract) {
                    // For extracts, query votes from source contest(s) with pagination
                    const extractImageIds = state.currentContest.extractImageIds || [];

                    if (state.currentContest.extractSourceType === 'contest') {
                        // Query votes from source contest with pagination, filtering by extract image IDs
                        const contestId = state.currentContest.extractSourceContestId;
                        const votes = await fetchAllVotesPaginated(
                            `contest_id=eq.${contestId}`,
                            '*,voter:users!votes_user_id_fkey(username,avatar,is_banned)'
                        );
                        allVotes = Array.isArray(votes) ? votes.filter(v => extractImageIds.includes(v.image_id)) : [];
                    } else if (state.currentContest.extractSourceType === 'merger') {
                        // Query votes from all merged contests with pagination, filtering by extract image IDs
                        const mergerId = state.currentContest.extractSourceMergerId;
                        const merger = state.mergers.find(m => m.id === mergerId);
                        if (merger && merger.contestIds) {
                            const votesPromises = merger.contestIds.map(contestId =>
                                fetchAllVotesPaginated(
                                    `contest_id=eq.${contestId}`,
                                    '*,voter:users!votes_user_id_fkey(username,avatar,is_banned)'
                                )
                            );
                            const votesArrays = await Promise.all(votesPromises);
                            const combinedVotes = votesArrays.flat();
                            allVotes = combinedVotes.filter(v => extractImageIds.includes(v.image_id));
                        }
                    }
                } else {
                    // Regular contest - query votes with pagination
                    allVotes = await fetchAllVotesPaginated(
                        `contest_id=eq.${state.currentContest.id}`,
                        '*,voter:users!votes_user_id_fkey(username,avatar,is_banned)'
                    );
                }

                console.log('üîç DEBUG: Fetched votes:', allVotes);

                // Check if votes response is valid
                if (!Array.isArray(allVotes)) {
                    console.error('Invalid votes response:', allVotes);
                    showAlert('Error loading votes: ' + (allVotes.message || 'Invalid response'), '‚ùå');
                    return;
                }

                console.log('üîç DEBUG: Number of votes:', allVotes.length);

                // Warn if we hit the vote limit
                if (allVotes.length === 2000) {
                    console.warn('‚ö†Ô∏è Hit vote limit of 2000 - may be missing votes');
                }

                // Build list of unique voters for dropdown (exclude banned users)
                const votersMap = new Map();
                allVotes.forEach(vote => {
                    const voterIsBanned = vote.voter?.is_banned || false;
                    if (!votersMap.has(vote.user_id) && !voterIsBanned) {
                        votersMap.set(vote.user_id, {
                            userId: vote.user_id,
                            username: vote.voter.username,
                            avatar: vote.voter.avatar
                        });
                    }
                });
                state.contestVoters = Array.from(votersMap.values()).sort((a, b) =>
                    a.username.localeCompare(b.username)
                );

                const imageScores = {};
                allVotes.forEach(vote => {
                    console.log('üîç DEBUG: Processing vote:', vote);
                    if (!imageScores[vote.image_id]) {
                        imageScores[vote.image_id] = {
                            scores: [],
                            breakdown: []
                        };
                    }

                    const isBlocked = vote.is_blocked || false;
                    const voterIsBanned = vote.voter?.is_banned || false;

                    // Only include non-blocked AND non-banned votes in score calculations
                    if (!isBlocked && !voterIsBanned) {
                        imageScores[vote.image_id].scores.push(vote.score);
                    }

                    // Include ALL votes in breakdown (blocked, banned, and non-blocked)
                    imageScores[vote.image_id].breakdown.push({
                        userId: vote.user_id,
                        username: vote.voter.username,
                        avatar: vote.voter.avatar,
                        score: vote.score,
                        isCurrentUser: vote.user_id === state.user?.id,
                        isBlocked: isBlocked,
                        isBanned: voterIsBanned
                    });
                });

                console.log('üîç DEBUG: Image scores:', imageScores);
                console.log('üîç DEBUG: Contest images:', state.currentContest.images);

                // Map images with their scores
                state.results = state.currentContest.images.map(img => {
                    const scores = imageScores[img.id]?.scores || [];
                    const sum = scores.reduce((acc, s) => acc + s, 0);
                    const average = scores.length > 0 ? parseFloat((sum / scores.length).toFixed(2)) : 0;

                    console.log(`üîç DEBUG: Image ${img.id} - scores:`, scores, 'average:', average);

                    return {
                        ...img,
                        averageScore: average,
                        totalVotes: scores.length,
                        breakdown: imageScores[img.id]?.breakdown || []
                    };
                }).sort(compareWithTieBreaking);

                console.log('üîç DEBUG: Final results:', state.results);
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        async function loadMergedResults(contestIds) {
            setLoading('Loading merged results...');
            try {
                // Fetch contests with their images
                const contestsResponse = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=in.(${contestIds.join(',')})&select=*,images(*)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const contests = await contestsResponse.json();

                // Fetch ALL votes for these contests using pagination
                let allVotes = [];
                let offset = 0;
                const limit = 1000;
                let hasMore = true;

                while (hasMore) {
                    setLoading(`Loading votes... (${allVotes.length} loaded)`);

                    const votesResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?contest_id=in.(${contestIds.join(',')})&limit=${limit}&offset=${offset}&select=*,voter:users!votes_user_id_fkey(username,avatar,is_banned)`, {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    });
                    const votes = await votesResponse.json();

                    allVotes = allVotes.concat(votes);

                    // If we got fewer results than the limit, we've reached the end
                    if (votes.length < limit) {
                        hasMore = false;
                    } else {
                        offset += limit;
                    }
                }

                // Build image scores from votes
                const imageScores = {};
                allVotes.forEach(vote => {
                    if (!imageScores[vote.image_id]) {
                        imageScores[vote.image_id] = {
                            scores: [],
                            breakdown: []
                        };
                    }

                    const isBlocked = vote.is_blocked || false;
                    const voterIsBanned = vote.voter?.is_banned || false;

                    // Only include non-blocked AND non-banned votes in score calculations
                    if (!isBlocked && !voterIsBanned) {
                        imageScores[vote.image_id].scores.push(vote.score);
                    }

                    // Include ALL votes in breakdown
                    imageScores[vote.image_id].breakdown.push({
                        userId: vote.user_id,
                        username: vote.voter.username,
                        avatar: vote.voter.avatar,
                        score: vote.score,
                        isCurrentUser: vote.user_id === state.user?.id,
                        isBlocked: isBlocked,
                        isBanned: voterIsBanned
                    });
                });

                // Collect all images from all contests
                const allImages = [];
                const contestTitles = {};

                contests.forEach(contest => {
                    contestTitles[contest.id] = contest.title;
                    contest.images.forEach(img => {
                        const scores = imageScores[img.id]?.scores || [];
                        const sum = scores.reduce((acc, s) => acc + s, 0);
                        const average = scores.length > 0 ? parseFloat((sum / scores.length).toFixed(2)) : 0;

                        allImages.push({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            contestId: contest.id,
                            contestTitle: contest.title,
                            averageScore: average,
                            totalVotes: scores.length,
                            voteBreakdown: imageScores[img.id]?.breakdown || []
                        });
                    });
                });

                // Set merged results
                state.mergedResults = {
                    contestIds: contestIds,
                    contestTitles: contestTitles,
                    images: allImages.sort(compareWithTieBreaking)
                };

            } catch (error) {
                console.error('Error loading merged results:', error);
                showAlert('Error loading merged results: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        // Temporary stub for merge functionality - returns empty results
        // TODO: Implement proper async merge functionality with database queries
        // Tie-breaking logic: when scores are equal, count 5s, 4s, 3s, 2s, 1s
        function compareWithTieBreaking(a, b) {
            // First, compare by average score
            const scoreDiff = b.averageScore - a.averageScore;
            if (Math.abs(scoreDiff) > 0.001) return scoreDiff; // Not a tie

            // Tie detected - count votes by score level
            const getVoteCounts = (item) => {
                const counts = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
                if (item.breakdown && Array.isArray(item.breakdown)) {
                    item.breakdown.forEach(vote => {
                        if (!vote.isBlocked && counts[vote.score] !== undefined) {
                            counts[vote.score]++;
                        }
                    });
                }
                return counts;
            };

            const countsA = getVoteCounts(a);
            const countsB = getVoteCounts(b);

            // Compare 5s, then 4s, then 3s, etc.
            for (let score = 5; score >= 1; score--) {
                if (countsB[score] !== countsA[score]) {
                    return countsB[score] - countsA[score];
                }
            }

            // If still equal, use total vote count
            const totalA = a.breakdown?.filter(v => !v.isBlocked).length || 0;
            const totalB = b.breakdown?.filter(v => !v.isBlocked).length || 0;
            if (totalB !== totalA) return totalB - totalA;

            // If still equal, maintain original order
            return 0;
        }

        function groupByScoreRange(results) {
            const ranges = [
                { min: 4.5, max: 5.0 },
                { min: 4.0, max: 4.49 },
                { min: 3.5, max: 3.99 },
                { min: 3.0, max: 3.49 },
                { min: 2.5, max: 2.99 },
                { min: 2.0, max: 2.49 },
                { min: 1.5, max: 1.99 },
                { min: 1.0, max: 1.49 }
            ];

            const grouped = {};

            // Check for images with missing votes (averageScore === 0 or null)
            const missingVotes = results.filter(r => !r.averageScore || r.averageScore === 0);
            if (missingVotes.length > 0) {
                grouped['missing'] = {
                    items: missingVotes,
                    min: 0,
                    max: 0,
                    isMissing: true
                };
            }

            // Group images by score ranges (only those with actual votes)
            ranges.forEach(range => {
                const key = `${range.min}-${range.max}`;
                const items = results.filter(r => r.averageScore > 0 && r.averageScore >= range.min && r.averageScore <= range.max);
                if (items.length > 0) {
                    grouped[key] = {
                        items: items.sort(compareWithTieBreaking),
                        min: range.min,
                        max: range.max
                    };
                }
            });

            return grouped;
        }

        function groupMyVotesByScore(results) {
            const grouped = {};

            [5, 4, 3, 2, 1].forEach(score => {
                const items = results.filter(r => r.averageScore === score);
                if (items.length > 0) {
                    grouped[score] = {
                        items: items,
                        score: score
                    };
                }
            });

            return grouped;
        }

        /**
         * Generate voter statistics from loaded results
         * Calculates each voter's average score across all images they voted on
         * Uses only data from state.results (already loaded from database)
         *
         * @returns {Array} Array of voter objects with calculated averages, sorted by average score (highest first)
         */
        function generateVoterStats() {
            if (!state.results) return [];

            // Accumulator for voter data
            // Structure: { userId: { votes: [], totalScore: 0, totalImages: 0, username, avatar, etc. } }
            const voterVotes = {};

            // Collect votes from all images in loaded results
            state.results.forEach(imageResult => {
                if (!imageResult.breakdown) return;

                imageResult.breakdown.forEach(vote => {
                    // Skip blocked votes
                    if (vote.isBlocked) return;

                    if (!voterVotes[vote.userId]) {
                        voterVotes[vote.userId] = {
                            userId: vote.userId,
                            username: vote.username,
                            avatar: vote.avatar,
                            isCurrentUser: vote.isCurrentUser || false,
                            votes: [],
                            totalScore: 0,
                            totalImages: 0
                        };
                    }

                    voterVotes[vote.userId].votes.push(vote.score);
                    voterVotes[vote.userId].totalScore += vote.score;
                    voterVotes[vote.userId].totalImages++;
                });
            });

            // Calculate averages and sort based on state.voterSortBy
            const voters = Object.values(voterVotes)
                .map(voter => ({
                    ...voter,
                    averageScore: voter.totalImages > 0
                        ? parseFloat((voter.totalScore / voter.totalImages).toFixed(2))
                        : 0
                }));

            // Apply sorting based on state.voterSortBy
            switch (state.voterSortBy) {
                case 'scoreAsc':
                    return voters.sort((a, b) => a.averageScore - b.averageScore);
                case 'nameAsc':
                    return voters.sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
                case 'nameDesc':
                    return voters.sort((a, b) => b.username.toLowerCase().localeCompare(a.username.toLowerCase()));
                case 'scoreDesc':
                default:
                    return voters.sort((a, b) => b.averageScore - a.averageScore);
            }
        }

        function showModal(config) {
            if (state.modalProcessing) return;
            state.modal = config;
            document.body.classList.add('modal-open');
            render();
        }

        function closeModal() {
            if (state.modalProcessing) return;
            state.modal = null;
            state.modalProcessing = false;
            document.body.classList.remove('modal-open');
            render();
        }

        function showAlert(message, icon = 'üö®') {
            showModal({
                type: 'alert',
                icon,
                message,
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showContestCreationDisabledModal() {
            showModal({
                type: 'alert',
                icon: 'üîí',
                message: 'Contest creation is temporarily disabled. Contact admin for more information.',
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showRevotingDisabledModal() {
            showModal({
                type: 'alert',
                icon: 'üîí',
                message: 'Revoting is temporarily disabled. Contact admin for more information.',
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showConfirm(message, onConfirmName, icon = 'üö®') {
            showModal({
                type: 'confirm',
                icon,
                message,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Confirm', action: onConfirmName, primary: true }
                ]
            });
        }

        function showShortcakeWIPModal() {
            showModal({
                type: 'alert',
                icon: 'üöß',
                message: 'Shortcakes are a work in progress and will be redesigned in the future. This feature is currently unavailable.',
                buttons: [{ text: 'OK', action: 'closeModal', primary: true }]
            });
        }

        function showToast(message, icon = '‚úÖ') {
            state.toast = { message, icon };
            render();

            // Auto-dismiss after 5 seconds for better visibility
            setTimeout(() => {
                const toastEl = document.querySelector('.toast-notification');
                if (toastEl) {
                    toastEl.classList.add('fade-out');
                }
                setTimeout(() => {
                    state.toast = null;
                    render();
                }, 300);
            }, 5000);
        }

        function showInputModal(title, placeholder, onConfirmAction, allowEmpty = false) {
            showModal({
                type: 'input',
                icon: '‚úèÔ∏è',
                title,
                placeholder,
                allowEmpty,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Continue', action: onConfirmAction, primary: true }
                ]
            });
        }

        // Helper function to recalculate voter count ranges for an item (contest, merger, or extract)
        async function recalculateVoterCounts(itemType, itemId, imageIds, sourceContestIds) {
            try {
                // Fetch all votes for the specified images
                const votesResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/votes?contest_id=in.(${sourceContestIds.join(',')})&image_id=in.(${imageIds.join(',')})&is_blocked=eq.false&select=user_id,image_id`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                if (!votesResponse.ok) {
                    console.error('Failed to fetch votes for voter count calculation');
                    return;
                }

                const votes = await votesResponse.json();

                // Group votes by user
                const votesByUser = {};
                votes.forEach(vote => {
                    if (!votesByUser[vote.user_id]) {
                        votesByUser[vote.user_id] = new Set();
                    }
                    votesByUser[vote.user_id].add(vote.image_id);
                });

                // Count how many images each user has voted on
                const voterCounts = Object.keys(votesByUser).map(userId => {
                    const userVotedImages = votesByUser[userId];
                    // Count only images in the specified imageIds array
                    const votedInSet = imageIds.filter(imgId => userVotedImages.has(imgId)).length;
                    return votedInSet === imageIds.length ? userId : null;
                }).filter(userId => userId !== null);

                // Voter count calculation complete (no longer storing in database)
            } catch (error) {
                console.error(`Error recalculating voter counts for ${itemType} ${itemId}:`, error);
            }
        }

        async function confirmSubmitVotes() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            render(); // Close modal immediately before async work

            setLoading('Submitting votes...');

            // Timeout fallback: force clear loading and show error if submission takes >10 seconds
            const timeoutId = setTimeout(() => {
                if (state.isLoading) {
                    clearLoading();
                    showAlert('Vote submission timed out. Please try again.', '‚ùå');
                    state.modalProcessing = false;
                    render();
                }
            }, 10000);

            // Check if we're in merger voting mode
            const isMergerVoting = state.currentMergerId && state.mergerContestIds.length > 0;

            const votesToSubmit = [];
            state.shuffledImages.forEach(img => {
                if (state.votes[img.id]) {
                    // Find which contest this image belongs to
                    let contestId;
                    if (isMergerVoting) {
                        // In merger mode, find the original contest for each image
                        const contest = state.contests.find(c =>
                            state.mergerContestIds.includes(c.id) &&
                            c.images.some(i => i.id === img.id)
                        );
                        contestId = contest ? contest.id : state.mergerContestIds[0];
                    } else if (state.currentContest.isExtract) {
                        // For extract voting, find the source contest for each image
                        if (state.currentContest.extractSourceType === 'contest') {
                            contestId = state.currentContest.extractSourceContestId;
                        } else if (state.currentContest.extractSourceType === 'merger') {
                            // For merger-based extracts, find which contest the image belongs to
                            const merger = state.mergers.find(m => m.id === state.currentContest.extractSourceMergerId);
                            if (merger) {
                                const contest = state.contests.find(c =>
                                    merger.contestIds.includes(c.id) &&
                                    c.images.some(i => i.id === img.id)
                                );
                                contestId = contest ? contest.id : merger.contestIds[0];
                            }
                        }
                    } else {
                        contestId = state.currentContest.id;
                    }

                    votesToSubmit.push({
                        user_id: state.user.id,
                        image_id: img.id,
                        contest_id: contestId,
                        score: state.votes[img.id]
                    });
                }
            });

            try {
                // Group votes by contest for checking existing votes
                const votesByContest = {};
                votesToSubmit.forEach(vote => {
                    if (!votesByContest[vote.contest_id]) {
                        votesByContest[vote.contest_id] = [];
                    }
                    votesByContest[vote.contest_id].push(vote);
                });

                // Process votes for each contest
                for (const contestId of Object.keys(votesByContest)) {
                    const contestVotes = votesByContest[contestId];

                    // Check if votes already exist for this user and contest
                    const existingVotesResponse = await fetch(
                        `${SUPABASE_URL}/rest/v1/votes?user_id=eq.${state.user.id}&contest_id=eq.${contestId}&select=*`,
                        {
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Cache-Control': 'no-cache'
                            }
                        }
                    );

                    if (!existingVotesResponse.ok) {
                        throw new Error('Failed to check existing votes');
                    }

                    const existingVotes = await existingVotesResponse.json();

                    // Separate votes into updates and inserts
                    const votesToUpdate = [];
                    const votesToInsert = [];

                    contestVotes.forEach(vote => {
                        const existingVote = existingVotes.find(ev => ev.image_id === vote.image_id);
                        if (existingVote) {
                            votesToUpdate.push(vote);
                        } else {
                            votesToInsert.push(vote);
                        }
                    });

                    // Update existing votes
                    if (votesToUpdate.length > 0) {
                        const updatePromises = votesToUpdate.map(async (vote) => {
                            const response = await fetch(
                                `${SUPABASE_URL}/rest/v1/votes?user_id=eq.${vote.user_id}&contest_id=eq.${vote.contest_id}&image_id=eq.${vote.image_id}`,
                                {
                                    method: 'PATCH',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'apikey': SUPABASE_ANON_KEY,
                                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                        'Prefer': 'return=minimal',
                                        'Cache-Control': 'no-cache'
                                    },
                                    body: JSON.stringify({ score: vote.score })
                                }
                            );

                            if (!response.ok) {
                                throw new Error(`Failed to update vote for image ${vote.image_id}`);
                            }
                        });

                        await Promise.all(updatePromises);
                    }

                    // Insert new votes
                    if (votesToInsert.length > 0) {
                        const response = await fetch(`${SUPABASE_URL}/rest/v1/votes`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Prefer': 'return=minimal',
                                'Cache-Control': 'no-cache'
                            },
                            body: JSON.stringify(votesToInsert)
                        });

                        if (!response.ok) {
                            throw new Error('Failed to insert new votes');
                        }
                    }
                }

                // Reload user votes to reflect new submissions
                await loadUserVotes();
                state.hasSubmitted = true;

                // Update voter counts BEFORE loading results to ensure fresh data
                // Check if we're voting on an extract (only if not in merger mode)
                const isExtractVoting = !isMergerVoting && state.currentContest && state.currentContest.isExtract === true;

                if (isExtractVoting) {
                    // Extract voting - update both extract and source voter counts
                    const extractId = state.currentContest.id;
                    const extract = state.extracts.find(e => e.id === extractId);

                    if (extract) {
                        // Get source contest IDs
                        let sourceContestIds = [];
                        if (extract.sourceType === 'contest') {
                            sourceContestIds = [extract.sourceContestId];
                        } else if (extract.sourceType === 'merger') {
                            const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                            if (merger) {
                                sourceContestIds = merger.contestIds;
                            }
                        }

                        // Update extract voter counts based on its specific images
                        await recalculateVoterCounts('extract', extractId, extract.imageIds, sourceContestIds);

                        // Update source contest/merger voter counts based on ALL their images
                        if (extract.sourceType === 'contest') {
                            const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                            if (sourceContest) {
                                const allImageIds = sourceContest.images.map(img => img.id);
                                await recalculateVoterCounts('contest', extract.sourceContestId, allImageIds, [extract.sourceContestId]);
                            }
                        } else if (extract.sourceType === 'merger') {
                            const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                            if (merger) {
                                const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                                const allImageIds = mergedContests.flatMap(c => c.images.map(img => img.id));
                                await recalculateVoterCounts('merger', extract.sourceMergerId, allImageIds, merger.contestIds);
                            }
                        }

                        // Reload extracts to get updated voter counts
                        await loadExtracts();
                    }
                } else if (isMergerVoting) {
                    // Merger voting - update merger and source contest voter counts
                    const merger = state.mergers.find(m => m.id === state.currentMergerId);
                    if (merger) {
                        const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                        const allImageIds = mergedContests.flatMap(c => c.images.map(img => img.id));

                        // Update merger voter counts
                        await recalculateVoterCounts('merger', state.currentMergerId, allImageIds, merger.contestIds);

                        // Update each source contest
                        for (const contestId of merger.contestIds) {
                            const contest = state.contests.find(c => c.id === contestId);
                            if (contest) {
                                const contestImageIds = contest.images.map(img => img.id);
                                await recalculateVoterCounts('contest', contestId, contestImageIds, [contestId]);
                            }
                        }

                        // Reload mergers to get updated voter counts
                        await loadMergers();
                    }
                } else {
                    // Regular contest voting - update contest voter counts
                    const contest = state.contests.find(c => c.id === state.currentContest.id);
                    if (contest) {
                        const contestImageIds = contest.images.map(img => img.id);
                        await recalculateVoterCounts('contest', state.currentContest.id, contestImageIds, [state.currentContest.id]);
                    }
                }

                // Navigate to appropriate results view
                if (isMergerVoting) {
                    // Load merged results and display
                    const merger = state.mergers.find(m => m.id === state.currentMergerId);
                    if (merger) {
                        await loadMergedResults(merger.contestIds);
                        state.view = 'mergedResults';
                        state.resultsView = 'average';
                        state.showMyVotes = false;

                        // Update URL hash
                        window.location.hash = `merger=${state.currentMergerId}`;
                    } else {
                        // Merger not found - reload mergers and show menu
                        await loadMergers();
                        state.view = 'menu';
                        showToast('Merger results loaded successfully', 'success');
                    }
                } else {
                    // Refresh contest list to update voter counts FIRST
                    await loadContests();

                    // Switch to single contest results view
                    // If this was partial voting, load results for the original full contest
                    if (state.currentContest.isPartialVoting && state.currentContest.originalContestId) {
                        const originalContest = state.contests.find(c => c.id === state.currentContest.originalContestId);
                        if (originalContest) {
                            state.currentContest = originalContest;
                        }
                    }

                    // Load results BEFORE changing view (to match merger flow that works)
                    await loadResults();
                    state.view = 'results';

                    // Update URL hash
                    window.location.hash = `contest=${state.currentContest.id}`;
                }

                // Refresh contest list one more time if it was merger voting
                if (isMergerVoting) {
                    await loadContests();
                }

                // Clear processing state and clear loading before final render
                state.modalProcessing = false;
                clearTimeout(timeoutId);
                clearLoading();

                // Final render to show results view
                render();
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);

                // Ensure loading is cleared and modal processing is reset
                clearTimeout(timeoutId);
                clearLoading();
                state.modalProcessing = false;

                // Show error to user
                showAlert('Failed to submit votes: ' + error.message, '‚ùå');
                render();
            }
        }

        function confirmCancelVoting() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.view = 'home';
            state.currentContest = null;
            state.modalProcessing = false;
            render();
        }

        async function confirmSubmitShortcakeVotes() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            render(); // Close modal immediately before async work

            setLoading('Submitting shortcake votes...');

            // Timeout fallback: force clear loading and show error if submission takes >10 seconds
            const timeoutId = setTimeout(() => {
                if (state.isLoading) {
                    clearLoading();
                    showAlert('Vote submission timed out. Please try again.', '‚ùå');
                    state.modalProcessing = false;
                    render();
                }
            }, 10000);

            try {
                const shortcakeId = state.currentShortcake.id;
                const userId = state.user.id;
                const shortlistedImageIds = state.shortlistedImageIds;

                // Validate min/max selections
                const count = shortlistedImageIds.length;
                const min = state.currentShortcake.min;
                const max = state.currentShortcake.max;

                if (count < min || count > max) {
                    clearTimeout(timeoutId);
                    clearLoading();
                    state.modalProcessing = false;
                    showAlert(`Please select between ${min} and ${max} images!`, '‚ùå');
                    render();
                    return;
                }

                // Check if vote already exists for this user and shortcake
                const existingVotesResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/shortcake_votes?user_id=eq.${userId}&shortcake_id=eq.${shortcakeId}&select=*`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                if (!existingVotesResponse.ok) {
                    throw new Error('Failed to check existing votes');
                }

                const existingVotes = await existingVotesResponse.json();

                // UPSERT: Update if exists, insert if doesn't
                if (existingVotes && existingVotes.length > 0) {
                    // Update existing vote
                    const response = await fetch(
                        `${SUPABASE_URL}/rest/v1/shortcake_votes?user_id=eq.${userId}&shortcake_id=eq.${shortcakeId}`,
                        {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Prefer': 'return=minimal',
                                'Cache-Control': 'no-cache'
                            },
                            body: JSON.stringify({
                                shortlisted_image_ids: shortlistedImageIds
                            })
                        }
                    );

                    if (!response.ok) {
                        throw new Error('Failed to update shortcake vote');
                    }
                } else {
                    // Insert new vote
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/shortcake_votes`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Prefer': 'return=minimal',
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify({
                            shortcake_id: shortcakeId,
                            user_id: userId,
                            shortlisted_image_ids: shortlistedImageIds
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to insert shortcake vote');
                    }
                }

                state.hasSubmitted = true;

                // Refresh shortcakes to update voter counts
                await loadShortcakes();

                // Navigate to results view
                state.view = 'shortcakeResults';

                // Update URL hash
                window.location.hash = `shortcake=${shortcakeId}`;

                // Clear processing state and clear loading before final render
                state.modalProcessing = false;
                clearTimeout(timeoutId);
                clearLoading();

                // Show success message
                showToast('Shortcake votes submitted successfully!', '‚úÖ');

                // Final render to show results view
                render();
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);

                // Ensure loading is cleared and modal processing is reset
                clearTimeout(timeoutId);
                clearLoading();
                state.modalProcessing = false;

                // Show error to user
                showAlert('Failed to submit shortcake votes: ' + error.message, '‚ùå');
                render();
            }
        }

        function canDeleteContest(contest) {
            if (!state.user) return false;

            // Check if user is contest creator
            if (contest.createdBy === state.user.id) return true;

            // Admin check
            return state.user.id === ADMIN_DISCORD_ID;
        }

        function deleteContest(contestId) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) return;

            // Store contest info for validation
            state.contestToDelete = contest;

            showInputModal(
                `Type "${contest.title}" to confirm deletion`,
                'Enter contest title exactly...',
                'handleDeleteContestConfirmation',
                false
            );
        }

        function handleDeleteContestConfirmation() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const enteredTitle = input ? input.value.trim() : '';

            if (!state.contestToDelete) {
                showAlert('Contest information not found.', '‚ùå');
                return;
            }

            if (enteredTitle !== state.contestToDelete.title) {
                showAlert('Title does not match. Deletion cancelled.', '‚ùå');
                return;
            }

            // Title matches, proceed with deletion
            confirmDeleteContest(state.contestToDelete.id);
        }

        async function confirmDeleteContest(contestId) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            setLoading('Deleting contest...');

            try {
                // First, fetch contest images to clean up storage
                const contest = state.contests.find(c => c.id === contestId);
                if (contest && contest.images) {
                    const filesToDelete = [];

                    for (const image of contest.images) {
                        // Only delete images that were uploaded to storage (not external URLs)
                        if (image.isFileUpload && image.url) {
                            // Extract file path from Supabase storage URL
                            // URL format: https://{project}.supabase.co/storage/v1/object/public/contest-images/{fileName}
                            const urlParts = image.url.split('/contest-images/');
                            if (urlParts.length === 2) {
                                filesToDelete.push(urlParts[1]);
                            }
                        }
                    }

                    // Delete files from storage if there are any
                    if (filesToDelete.length > 0) {
                        console.log('Deleting files from storage:', filesToDelete);
                        const { data, error } = await supabase.storage
                            .from('contest-images')
                            .remove(filesToDelete);

                        if (error) {
                            console.warn('Storage cleanup error:', error);
                            // Don't fail the entire deletion if storage cleanup fails
                        } else {
                            console.log('Successfully deleted files from storage:', data);
                        }
                    }
                }

                // Now delete the contest from database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete contest');
                }

                await loadContests();
                delete state.userVotedContests[contestId];
                state.modalProcessing = false;
                showAlert('Contest deleted successfully!', '‚úÖ');
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Failed to delete contest: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            } finally {
                clearLoading();
            }
        }

        function deleteShortcake(shortcakeId) {
            const shortcake = state.shortcakes.find(s => s.id === shortcakeId);
            if (!shortcake) return;

            // Store shortcake info for validation
            state.shortcakeToDelete = shortcake;

            showInputModal(
                `Type "${shortcake.title}" to confirm deletion`,
                'Enter shortcake title exactly...',
                'handleDeleteShortcakeConfirmation',
                false
            );
        }

        function handleDeleteShortcakeConfirmation() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const enteredTitle = input ? input.value.trim() : '';

            if (!state.shortcakeToDelete) {
                showAlert('Shortcake information not found.', '‚ùå');
                return;
            }

            if (enteredTitle !== state.shortcakeToDelete.title) {
                showAlert('Title does not match. Deletion cancelled.', '‚ùå');
                return;
            }

            // Title matches, proceed with deletion
            confirmDeleteShortcake(state.shortcakeToDelete.id);
        }

        async function confirmDeleteShortcake(shortcakeId) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            setLoading('Deleting shortcake...');

            try {
                // Delete the shortcake from database (CASCADE will handle shortcake_votes)
                const response = await fetch(`${SUPABASE_URL}/rest/v1/shortcakes?id=eq.${shortcakeId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete shortcake');
                }

                await loadShortcakes();
                state.modalProcessing = false;
                showAlert('Shortcake deleted successfully!', '‚úÖ');
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Failed to delete shortcake: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            } finally {
                clearLoading();
            }
        }

        function startCreateContest() {
            showInputModal('Contest Title', 'Enter contest title...', 'handleContestTitle', false);
        }

        function handleContestTitle() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const title = input ? input.value.trim() : '';

            if (!title || title.length === 0) {
                showAlert('Contest title cannot be empty.', '‚ùå');
                return;
            }
            if (title.length > 50) {
                showAlert('Contest title is too long (max 50 characters).', '‚ùå');
                return;
            }

            // Check for duplicate title - BLOCK creation entirely
            const existingContest = state.contests.find(c => c.title.toLowerCase() === title.toLowerCase());
            if (existingContest) {
                showAlert('A contest with this title already exists. Please choose a different title.', '‚ùå');
                return;
            }

            state.modalProcessing = true;
            state.newContest.title = title;
            state.newContest.images = [];
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.view = 'createContest';
            state.modalProcessing = false;
            render();
        }

        function confirmCreateWithDuplicateTitle() {
            state.modalProcessing = true;
            const title = state.tempContestTitle;
            state.tempContestTitle = null;
            state.modal = null;
            document.body.classList.remove('modal-open');
            state.newContest.title = title;
            state.newContest.images = [];
            state.view = 'createContest';
            state.modalProcessing = false;
            render();
        }

        function cancelCreateContest() {
            showConfirm(
                'Your progress will be lost if you proceed. Are you sure?',
                'confirmCancelCreate',
                'üö®'
            );
        }

        function confirmCancelCreate() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URLs to free memory
            state.newContest.images.forEach(img => {
                if (img.isLocalFile && img.url.startsWith('blob:')) {
                    URL.revokeObjectURL(img.url);
                }
            });

            state.view = 'home';
            state.newContest = { title: '', images: [] };
            state.modalProcessing = false;
            render();
        }

        // ==================== SHORTCAKE CREATION ====================

        function startCreateShortcake() {
            // Initialize with defaults
            state.newShortcake = { title: '', images: [], min: 5, max: 20 };
            state.view = 'createShortcake';
            render();
        }

        function cancelCreateShortcake() {
            showConfirm(
                'Your progress will be lost if you proceed. Are you sure?',
                'confirmCancelCreateShortcake',
                'üö®'
            );
        }

        function confirmCancelCreateShortcake() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URLs to free memory
            state.newShortcake.images.forEach(img => {
                if (img.isLocalFile && img.url.startsWith('blob:')) {
                    URL.revokeObjectURL(img.url);
                }
            });

            state.view = 'home';
            state.newShortcake = { title: '', images: [], min: 5, max: 20 };
            state.modalProcessing = false;
            render();
        }

        async function submitShortcake() {
            if (state.modalProcessing) return;

            const { title, images, min, max } = state.newShortcake;

            // Validations
            if (!title || title.length === 0) {
                showAlert('Shortcake title cannot be empty.', '‚ùå');
                return;
            }
            if (title.length > 50) {
                showAlert('Shortcake title is too long (max 50 characters).', '‚ùå');
                return;
            }
            if (images.length === 0) {
                showAlert('Please add at least one image.', '‚ùå');
                return;
            }
            if (min < 1 || max < 1 || min > max) {
                showAlert('Invalid min/max values. Min must be ‚â• 1 and ‚â§ max.', '‚ùå');
                return;
            }
            if (max > images.length) {
                showAlert(`Max (${max}) cannot exceed total images (${images.length}).`, '‚ùå');
                return;
            }

            // Check for duplicate title
            const existingShortcake = state.shortcakes.find(s => s.title.toLowerCase() === title.toLowerCase());
            if (existingShortcake) {
                showAlert('A shortcake with this title already exists. Please choose a different title.', '‚ùå');
                return;
            }

            state.modalProcessing = true;
            setLoading('Creating shortcake...');

            try {
                // Process images to upload
                const imagesToProcess = images.filter(img => img.isFileUpload || img.isLocalFile);

                // Upload images if needed
                for (const img of imagesToProcess) {
                    if (img.isLocalFile && img.localFile) {
                        const imageUrl = await uploadImageFileWithRetry(img.localFile, 0);
                        img.url = imageUrl;
                        img.isFileUpload = true;
                        img.isLocalFile = false;
                    }
                }

                // Create shortcake in database
                const shortcakeResponse = await fetch(`${SUPABASE_URL}/rest/v1/shortcakes`, {
                    method: 'POST',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        title: title,
                        created_by: state.user.id,
                        min: min,
                        max: max,
                        image_ids: []  // Will be updated after images are created
                    })
                });

                if (!shortcakeResponse.ok) {
                    throw new Error('Failed to create shortcake');
                }

                const [newShortcake] = await shortcakeResponse.json();

                // Upload images to images table (without contest_id, for shortcakes)
                const imageInserts = images.map((img, index) => ({
                    url: img.url,
                    author: img.author || null,
                    image_order: index,
                    contest_id: null  // Not tied to contest
                }));

                const imagesResponse = await fetch(`${SUPABASE_URL}/rest/v1/images`, {
                    method: 'POST',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify(imageInserts)
                });

                if (!imagesResponse.ok) {
                    throw new Error('Failed to upload images');
                }

                const uploadedImages = await imagesResponse.json();
                const imageIds = uploadedImages.map(img => img.id);

                // Update shortcake with image IDs
                await fetch(`${SUPABASE_URL}/rest/v1/shortcakes?id=eq.${newShortcake.id}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image_ids: imageIds
                    })
                });

                // Revoke all Object URLs after successful creation
                state.newShortcake.images.forEach(img => {
                    if (img.url.startsWith('blob:')) {
                        URL.revokeObjectURL(img.url);
                    }
                });

                state.newShortcake = { title: '', images: [], min: 5, max: 20 };
                await loadShortcakes();
                state.view = 'home';
                state.modalProcessing = false;
                clearLoading();
                showAlert('Shortcake created successfully!', '‚ú®');
            } catch (error) {
                console.error('Error creating shortcake:', error);
                showAlert('Failed to create shortcake: ' + error.message, '‚ùå');
                state.modalProcessing = false;
                clearLoading();
            }
        }

        // ==================== END SHORTCAKE CREATION ====================

        function openEditContestModal(contestId) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) {
                showToast('Contest not found', 'error');
                return;
            }

            // Set up editing mode
            state.editingContestId = contestId;
            state.newContest.title = contest.title;
            state.newContest.images = [...contest.images.map(img => ({...img, isExisting: true}))]; // Copy existing images and mark them
            state.view = 'createContest'; // Reuse the create contest view
            render();
        }

        function cancelEditContest() {
            showConfirm(
                'Your changes will be lost if you proceed. Are you sure?',
                'confirmCancelEdit',
                'üö®'
            );
        }

        function confirmCancelEdit() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URLs for newly added images
            state.newContest.images.forEach(img => {
                if (!img.isExisting && img.isLocalFile && img.url.startsWith('blob:')) {
                    URL.revokeObjectURL(img.url);
                }
            });

            state.view = 'home';
            state.newContest = { title: '', images: [] };
            state.editingContestId = null;
            state.modalProcessing = false;
            render();
        }

        async function addImageFromUrl(urlInputId) {
            const input = document.getElementById(urlInputId);
            let url = input.value.trim();

            if (!url) {
                showAlert('Please enter an image URL!', '‚ùå');
                return;
            }

            // Convert Discord CDN URLs to media.discordapp.net for compatibility
            url = url.replace(/cdn\.discordapp\.com/g, 'media.discordapp.net');
            url = url.replace(/images-ext-\d+\.discordapp\.net/g, 'media.discordapp.net');

            // Check for duplicate URL
            const isDuplicate = state.newContest.images.some(img => img.url === url);

            if (isDuplicate) {
                console.log('‚ö†Ô∏è Duplicate image URL detected:', url);
                state.tempDuplicateUrl = url;
                state.tempDuplicateUrlInputId = urlInputId;
                showConfirm(
                    '‚ö†Ô∏è This image URL already exists in the contest. Do you want to add it anyway?',
                    'confirmAddDuplicateImage',
                    '‚ö†Ô∏è'
                );
                return;
            }

            // Admin can bypass 100-image limit
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (state.newContest.images.length >= 100 && !isAdmin) {
                showAlert('Maximum 100 images per contest!', '‚ùå');
                return;
            }

            try {
                const img = await loadImageFromUrl(url);
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random(),
                    url,
                    author: null,
                    isFileUpload: false,
                    label: `${imageCount}`
                });
                input.value = '';
                showToast('Image added successfully!', '‚úÖ');
                render();
            } catch (error) {
                showAlert(`Failed to load image: ${error.message}`, '‚ùå');
            }
        }

        async function confirmAddDuplicateImage() {
            const url = state.tempDuplicateUrl;
            const urlInputId = state.tempDuplicateUrlInputId;

            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            if (!url) {
                state.modalProcessing = false;
                return;
            }

            console.log('‚úÖ User confirmed adding duplicate URL:', url);

            // Admin can bypass 100-image limit
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (state.newContest.images.length >= 100 && !isAdmin) {
                showAlert('Maximum 100 images per contest!', '‚ùå');
                state.tempDuplicateUrl = null;
                state.tempDuplicateUrlInputId = null;
                state.modalProcessing = false;
                return;
            }

            try {
                const img = await loadImageFromUrl(url);
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random(),
                    url,
                    author: null,
                    isFileUpload: false,
                    label: `${imageCount}`
                });

                const input = document.getElementById(urlInputId);
                if (input) {
                    input.value = '';
                }

                showToast('Duplicate image added!', '‚úÖ');
            } catch (error) {
                showAlert(`Failed to load image: ${error.message}`, '‚ùå');
            }

            state.tempDuplicateUrl = null;
            state.tempDuplicateUrlInputId = null;
            state.modalProcessing = false;
            render();
        }

        function clearUrlInput() {
            const input = document.getElementById('contestUrlInput');
            if (input) {
                input.value = '';
            }
        }

        // Format file size in human-readable format
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Comprehensive image compression targeting 1000 KB
        async function compressImage(file, maxSizeKB = 1000, progressCallback = null, currentQuality = null, currentMaxDimension = null) {
            const maxSizeBytes = maxSizeKB * 1024; // 1000 KB = 1024000 bytes

            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = (e) => {
                    const img = new Image();

                    img.onload = async () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // Preserve original file type (important for PNG transparency)
                        const outputType = file.type || 'image/jpeg';
                        const supportsQuality = outputType === 'image/jpeg' || outputType === 'image/webp';

                        // Helper to resize and draw
                        const drawResized = (maxSize) => {
                            let w = img.width;
                            let h = img.height;

                            if (maxSize && (w > maxSize || h > maxSize)) {
                                if (w > h) {
                                    h = (h * maxSize) / w;
                                    w = maxSize;
                                } else {
                                    w = (w * maxSize) / h;
                                    h = maxSize;
                                }
                            }

                            canvas.width = w;
                            canvas.height = h;
                            ctx.drawImage(img, 0, 0, w, h);
                            return { w, h };
                        };

                        // Helper to try compression with specific quality and size
                        const tryCompress = (quality, maxDimension) => {
                            return new Promise((res) => {
                                drawResized(maxDimension);
                                // Only use quality parameter for formats that support it
                                const blobOptions = supportsQuality ? quality : undefined;
                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        res({ blob, quality, maxDimension });
                                    } else {
                                        res(null);
                                    }
                                }, outputType, blobOptions);
                            });
                        };

                        let result = null;
                        let finalQuality = currentQuality || 0.8;
                        let finalMaxDimension = currentMaxDimension || null;

                        // Check if original file is already under the limit
                        if (file.size <= maxSizeBytes && currentQuality === null && currentMaxDimension === null) {
                            // File already meets size requirements, no compression needed
                            resolve({
                                file: file,
                                originalSize: file.size,
                                compressedSize: file.size,
                                savingsPercent: 0,
                                currentQuality: null,
                                currentMaxDimension: null,
                                success: true
                            });
                            return;
                        }

                        // If specific parameters provided (for "Compress More"), use them
                        if (currentQuality !== null || currentMaxDimension !== null) {
                            result = await tryCompress(finalQuality, finalMaxDimension);
                            // Ensure compression actually made it smaller
                            if (result && result.blob.size >= file.size) {
                                // Compression made it larger or same size - reject
                                reject({
                                    message: `Compression would increase file size. Original: ${formatFileSize(file.size)}, Compressed: ${formatFileSize(result.blob.size)}`,
                                    file: file,
                                    originalSize: file.size,
                                    compressedSize: result.blob.size,
                                    success: false,
                                    currentQuality: finalQuality,
                                    currentMaxDimension: finalMaxDimension
                                });
                                return;
                            }
                        } else {
                            // Apply strongest reasonable compression by default (quality 0.4, 1000px max)
                            if (progressCallback) progressCallback(50);
                            result = await tryCompress(0.4, 1000);

                            if (result && result.blob.size <= maxSizeBytes) {
                                finalQuality = 0.4;
                                finalMaxDimension = 1000;
                            }
                        }

                        if (progressCallback) progressCallback(100);

                        // Check final result
                        if (result && result.blob.size <= maxSizeBytes) {
                            // Ensure compression actually made it smaller
                            if (result.blob.size >= file.size) {
                                // Compression made it larger - use original if it's under the limit
                                if (file.size <= maxSizeBytes) {
                                    resolve({
                                        file: file,
                                        originalSize: file.size,
                                        compressedSize: file.size,
                                        savingsPercent: 0,
                                        currentQuality: null,
                                        currentMaxDimension: null,
                                        success: true
                                    });
                                } else {
                                    reject({
                                        message: `Compression would increase file size. Original: ${formatFileSize(file.size)}, Compressed: ${formatFileSize(result.blob.size)}`,
                                        file: file,
                                        originalSize: file.size,
                                        compressedSize: result.blob.size,
                                        success: false,
                                        currentQuality: finalQuality,
                                        currentMaxDimension: finalMaxDimension
                                    });
                                }
                                return;
                            }

                            const compressedFile = new File([result.blob], file.name, {
                                type: outputType,
                                lastModified: Date.now()
                            });
                            const savingsPercent = Math.round((1 - result.blob.size / file.size) * 100);
                            resolve({
                                file: compressedFile,
                                originalSize: file.size,
                                compressedSize: result.blob.size,
                                savingsPercent,
                                currentQuality: finalQuality,
                                currentMaxDimension: finalMaxDimension,
                                success: true
                            });
                        } else {
                            // Failed to compress under limit
                            const finalSize = result ? result.blob.size : file.size;
                            reject({
                                message: `${file.name}: ${formatFileSize(finalSize)} - too large even after compression (max ${maxSizeKB} KB)`,
                                file: result ? new File([result.blob], file.name, { type: outputType, lastModified: Date.now() }) : file,
                                originalSize: file.size,
                                compressedSize: finalSize,
                                success: false,
                                currentQuality: finalQuality,
                                currentMaxDimension: finalMaxDimension
                            });
                        }
                    };

                    img.onerror = () => reject({ message: 'Failed to load image for compression', success: false });
                    img.src = e.target.result;
                };

                reader.onerror = () => reject({ message: 'Failed to read image file', success: false });
                reader.readAsDataURL(file);
            });
        }

        async function handleFileSelect(fileInput) {
            const files = Array.from(fileInput.files);
            if (files.length === 0) return;

            const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            const maxSizeBeforeCompression = 500 * 1024 * 1024; // 500MB - reject if too large even before compression

            // Validate file types
            const invalidTypeFiles = files.filter(file => !validTypes.includes(file.type));
            if (invalidTypeFiles.length > 0) {
                showAlert(`${invalidTypeFiles.length} file(s) are not valid image types (JPG, PNG, GIF, or WebP)`, '‚ùå');
                fileInput.value = '';
                return;
            }

            // Check for files that are too large even before compression
            const tooLargeFiles = files.filter(file => file.size > maxSizeBeforeCompression);
            if (tooLargeFiles.length > 0) {
                showAlert(`${tooLargeFiles.length} file(s) exceed 500MB. Please use smaller images.`, '‚ùå');
                fileInput.value = '';
                return;
            }

            // Check if adding all files would exceed the 100 image limit (admin can bypass)
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const totalImages = state.newContest.images.length + files.length;
            if (totalImages > 100) {
                if (!isAdmin) {
                    const availableSlots = 100 - state.newContest.images.length;
                    showAlert(`Cannot add ${files.length} images. Only ${availableSlots} slot(s) remaining (max 100 total)`, '‚ùå');
                    fileInput.value = '';
                    return;
                } else {
                    // Admin bypassing limit - show notification
                    showToast(`Admin: Bypassing 100 image limit (adding ${files.length} images, total: ${totalImages})`, 'info');
                }
            }

            fileInput.value = '';

            // Initialize compression progress state
            state.compressionProgress = {
                files: files.map(file => ({
                    name: file.name,
                    status: 'compressing', // 'compressing', 'complete', 'failed'
                    originalSize: file.size,
                    compressedSize: null,
                    progress: 0,
                    error: null,
                    canCompressMore: false,
                    file: null,
                    previewUrl: null,
                    savingsPercent: 0,
                    currentQuality: null,
                    currentMaxDimension: null,
                    originalFile: file
                })),
                allComplete: false
            };

            render();

            // Compress all files
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const fileState = state.compressionProgress.files[i];

                try {
                    const result = await compressImage(file, 1000, (progress) => {
                        fileState.progress = progress;
                        render();
                    });

                    // Success
                    fileState.status = 'complete';
                    fileState.compressedSize = result.compressedSize;
                    fileState.file = result.file;
                    fileState.previewUrl = URL.createObjectURL(result.file);
                    fileState.savingsPercent = result.savingsPercent;
                    fileState.currentQuality = result.currentQuality;
                    fileState.currentMaxDimension = result.currentMaxDimension;
                    fileState.canCompressMore = result.currentQuality > 0.3 || result.currentMaxDimension === null || result.currentMaxDimension > 1000;
                    fileState.progress = 100;
                } catch (error) {
                    // Failed
                    fileState.status = 'failed';
                    fileState.error = error.message || 'Compression failed';
                    fileState.compressedSize = error.compressedSize || file.size;
                    fileState.currentQuality = error.currentQuality;
                    fileState.currentMaxDimension = error.currentMaxDimension;
                    // Store the best attempt even if it failed
                    if (error.file) {
                        fileState.file = error.file;
                        fileState.previewUrl = URL.createObjectURL(error.file);
                    }
                    fileState.progress = 100;
                }

                render();
            }

            // All files processed
            state.compressionProgress.allComplete = true;
            render();
        }

        async function uploadImageFile(file, progressCallback) {
            // Always use .jpg extension for compressed images
            const fileExt = 'jpg';

            // Generate unique filename
            const fileName = `contest-${Date.now()}-${Math.random().toString(36).substring(2, 9)}.${fileExt}`;

            // Simulate progress updates (Supabase doesn't provide native progress)
            let progressInterval;
            if (progressCallback) {
                let simulatedProgress = 10;
                progressInterval = setInterval(() => {
                    if (simulatedProgress < 90) {
                        simulatedProgress += 10;
                        progressCallback(simulatedProgress);
                    }
                }, 200);
            }

            try {
                // Upload to Supabase Storage
                const { data, error } = await supabase.storage
                    .from('contest-images')
                    .upload(fileName, file, {
                        cacheControl: '3600',
                        upsert: false
                    });

                if (progressInterval) clearInterval(progressInterval);

                if (error) {
                    console.error('Supabase storage error:', error);
                    throw new Error(error.message || 'Failed to upload image to storage');
                }

                if (progressCallback) progressCallback(95);

                // Get public URL
                const { data: urlData } = supabase.storage
                    .from('contest-images')
                    .getPublicUrl(fileName);

                if (!urlData || !urlData.publicUrl) {
                    throw new Error('Failed to get public URL for uploaded image');
                }

                if (progressCallback) progressCallback(100);

                return urlData.publicUrl;
            } catch (error) {
                if (progressInterval) clearInterval(progressInterval);
                console.error('Upload error:', error);
                throw error;
            }
        }

        async function uploadImageFileWithRetry(file, fileIndex, maxRetries = 3) {
            const updateProgress = (progress) => {
                if (state.uploadProgress && state.uploadProgress.files[fileIndex]) {
                    state.uploadProgress.files[fileIndex].progress = progress;
                    render();
                }
            };

            let lastError;
            const retryCount = state.uploadProgress?.files[fileIndex]?.retryCount || 0;

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    // Exponential backoff: wait before retry (0ms, 1s, 2s, 4s)
                    if (attempt > 0) {
                        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 4000);
                        console.log(`Retrying upload for ${file.name} after ${delay}ms (attempt ${attempt + 1}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        updateProgress(5);
                    }

                    const imageUrl = await uploadImageFile(file, updateProgress);
                    return imageUrl;
                } catch (error) {
                    lastError = error;
                    console.error(`Upload attempt ${attempt + 1} failed for ${file.name}:`, error);

                    // Don't retry on certain errors
                    const errorMsg = error.message || String(error);
                    if (errorMsg.includes('413') || errorMsg.includes('Payload Too Large') ||
                        errorMsg.includes('401') || errorMsg.includes('403')) {
                        throw error; // Don't retry auth or size errors
                    }

                    // Continue to next retry if available
                    if (attempt < maxRetries - 1) {
                        updateProgress(0);
                    }
                }
            }

            // All retries failed
            throw lastError || new Error('Upload failed after multiple attempts');
        }

        // Upload progress modal helper functions
        function closeUploadProgress() {
            // Add successfully uploaded images to the contest
            const successfulUploads = state.uploadProgress.files.filter(f => f.status === 'success' && f.imageUrl);
            successfulUploads.forEach((file, index) => {
                const imageCount = state.newContest.images.length + 1;
                state.newContest.images.push({
                    id: Date.now() + Math.random() + index,
                    url: file.imageUrl,
                    author: null,
                    isFileUpload: true,
                    label: `${imageCount}`
                });
            });

            state.uploadProgress = null;
            render();

            if (successfulUploads.length > 0) {
                showToast(`${successfulUploads.length} image${successfulUploads.length > 1 ? 's' : ''} added to contest!`, '‚úÖ');
            }
        }

        async function retryUpload(fileIndex) {
            const fileData = state.uploadProgress.files[fileIndex];
            if (!fileData || !fileData.originalFile) return;

            // Reset file status
            fileData.status = 'pending';
            fileData.progress = 0;
            fileData.error = null;
            fileData.retryCount = (fileData.retryCount || 0) + 1;
            render();

            try {
                // Re-compress if needed (using original file)
                if (fileData.needsCompression) {
                    fileData.status = 'compressing';
                    fileData.progress = 5;
                    render();

                    const compressed = await compressImage(fileData.originalFile);
                    fileData.file = compressed.file;
                    fileData.compressedSize = compressed.compressedSize;
                    fileData.progress = 10;
                    render();
                } else {
                    fileData.file = fileData.originalFile;
                    fileData.compressedSize = fileData.originalFile.size;
                }

                // Upload the file
                fileData.status = 'uploading';
                fileData.progress = 15;
                render();

                const imageUrl = await uploadImageFileWithRetry(fileData.file, fileIndex);
                fileData.status = 'success';
                fileData.imageUrl = imageUrl;
                fileData.progress = 100;
            } catch (error) {
                fileData.status = 'failed';
                fileData.error = getFriendlyErrorMessage(error);
            }

            render();
        }

        function cancelAllUploads() {
            // Mark all pending/uploading files as cancelled
            state.uploadProgress.files.forEach(file => {
                if (file.status === 'pending' || file.status === 'uploading') {
                    file.status = 'failed';
                    file.error = 'Cancelled by user';
                }
            });
            render();
        }

        function getFriendlyErrorMessage(error) {
            const errorMsg = error.message || String(error);

            if (errorMsg.includes('Failed to fetch') || errorMsg.includes('ERR_HTTP2_PROTOCOL_ERROR')) {
                return 'Network error - please check your connection and try again';
            } else if (errorMsg.includes('timeout') || errorMsg.includes('timed out')) {
                return 'Upload timed out - file may be too large or connection too slow';
            } else if (errorMsg.includes('413') || errorMsg.includes('Payload Too Large')) {
                return 'File is too large for upload';
            } else if (errorMsg.includes('401') || errorMsg.includes('403')) {
                return 'Authentication error - please try logging in again';
            } else if (errorMsg.includes('storage')) {
                return 'Storage error: ' + errorMsg;
            }

            return errorMsg;
        }

        // Compression modal helper functions
        function closeCompressionModal() {
            if (!state.compressionProgress || !state.compressionProgress.allComplete) return;

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const maxSizeBytes = 1000 * 1024; // 1000 KB limit

            // Check if any non-admin files exceed the limit (e.g., after "Reset to Original")
            if (!isAdmin) {
                const oversizedFiles = state.compressionProgress.files.filter(f =>
                    (f.status === 'complete' && f.compressedSize > maxSizeBytes)
                );

                if (oversizedFiles.length > 0) {
                    const fileNames = oversizedFiles.map(f => `${f.name} (${formatFileSize(f.compressedSize)})`).join(', ');
                    showAlert(`Cannot add ${oversizedFiles.length} image(s) exceeding 1000 KB limit: ${fileNames}. Please compress further or remove these images.`, '‚ö†Ô∏è');
                    return;
                }
            }

            // Add successfully compressed images to contest or shortcake based on context
            const targetContext = state.compressionProgress.targetContext || 'contest';
            const targetImages = targetContext === 'shortcake' ? state.newShortcake.images : state.newContest.images;

            state.compressionProgress.files.forEach((fileState, index) => {
                if (fileState.status === 'complete' || (fileState.status === 'failed' && isAdmin && fileState.adminBypass)) {
                    const imageCount = targetImages.length + 1;
                    const newImage = {
                        id: Date.now() + Math.random() + index,
                        url: fileState.previewUrl,
                        localFile: fileState.file,
                        isLocalFile: true,
                        author: null,
                        isFileUpload: true,
                        label: `${imageCount}`,
                        compressedSize: fileState.compressedSize
                    };

                    if (targetContext === 'shortcake') {
                        state.newShortcake.images.push(newImage);
                    } else {
                        state.newContest.images.push(newImage);
                    }
                }
            });

            const successCount = state.compressionProgress.files.filter(f =>
                f.status === 'complete' || (f.status === 'failed' && f.adminBypass)
            ).length;

            state.compressionProgress = null;
            render();

            if (successCount > 0) {
                const itemType = targetContext === 'shortcake' ? 'shortcake' : 'contest';
                showToast(`${successCount} image${successCount > 1 ? 's' : ''} added to ${itemType}!`, '‚úÖ');
            }
        }

        async function compressMoreImage(fileIndex) {
            const fileState = state.compressionProgress.files[fileIndex];
            if (!fileState || !fileState.originalFile) return;

            // Determine next compression level
            let newQuality = fileState.currentQuality;
            let newMaxDimension = fileState.currentMaxDimension;

            if (newQuality > 0.3) {
                // Try lower quality
                newQuality = Math.max(0.3, newQuality - 0.1);
            } else if (newMaxDimension === null || newMaxDimension > 1000) {
                // Start resizing or go smaller
                if (newMaxDimension === null) {
                    newMaxDimension = 2000;
                } else if (newMaxDimension > 1500) {
                    newMaxDimension = 1500;
                } else if (newMaxDimension > 1200) {
                    newMaxDimension = 1200;
                } else {
                    newMaxDimension = 1000;
                }
                newQuality = 0.4;
            } else {
                // Already at minimum
                showToast('Already at minimum compression settings', 'info');
                return;
            }

            // Reset state for recompression
            fileState.status = 'compressing';
            fileState.progress = 0;
            render();

            try {
                const result = await compressImage(fileState.originalFile, 1000, (progress) => {
                    fileState.progress = progress;
                    render();
                }, newQuality, newMaxDimension);

                // Success
                fileState.status = 'complete';
                fileState.compressedSize = result.compressedSize;
                fileState.file = result.file;
                if (fileState.previewUrl) URL.revokeObjectURL(fileState.previewUrl);
                fileState.previewUrl = URL.createObjectURL(result.file);
                fileState.savingsPercent = result.savingsPercent;
                fileState.currentQuality = result.currentQuality;
                fileState.currentMaxDimension = result.currentMaxDimension;
                fileState.canCompressMore = result.currentQuality > 0.3 || result.currentMaxDimension === null || result.currentMaxDimension > 1000;
                fileState.progress = 100;
            } catch (error) {
                // Failed
                fileState.status = 'failed';
                fileState.error = error.message || 'Compression failed';
                fileState.compressedSize = error.compressedSize || fileState.originalFile.size;
                fileState.currentQuality = error.currentQuality;
                fileState.currentMaxDimension = error.currentMaxDimension;
                if (error.file) {
                    if (fileState.previewUrl) URL.revokeObjectURL(fileState.previewUrl);
                    fileState.file = error.file;
                    fileState.previewUrl = URL.createObjectURL(error.file);
                }
                fileState.progress = 100;
            }

            render();
        }

        function resetToOriginalImage(fileIndex) {
            const fileState = state.compressionProgress.files[fileIndex];
            if (!fileState || !fileState.originalFile) return;

            // Reset to original file
            fileState.file = fileState.originalFile;
            fileState.compressedSize = fileState.originalSize;
            fileState.savingsPercent = 0;
            fileState.currentQuality = null;
            fileState.currentMaxDimension = null;
            fileState.canCompressMore = true;

            // Update preview URL
            if (fileState.previewUrl) {
                URL.revokeObjectURL(fileState.previewUrl);
            }
            fileState.previewUrl = URL.createObjectURL(fileState.originalFile);

            render();
        }

        function cancelCompressionImage(fileIndex) {
            if (!state.compressionProgress) return;

            // Remove the file from compression progress
            state.compressionProgress.files.splice(fileIndex, 1);

            // Check if all remaining files are complete
            if (state.compressionProgress.files.length === 0) {
                state.compressionProgress = null;
            } else {
                state.compressionProgress.allComplete = state.compressionProgress.files.every(
                    f => f.status === 'complete' || f.status === 'failed'
                );
            }

            render();
        }

        function addOversizedImageAnyway(fileIndex) {
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin || !state.compressionProgress) return;

            const fileState = state.compressionProgress.files[fileIndex];
            if (!fileState || fileState.status !== 'failed') return;

            // Mark as admin bypass
            fileState.adminBypass = true;

            // Show notification to admin
            showToast(`Admin: Bypassing 1000 KB size limit for ${fileState.name}`, 'info');

            render();
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.add('border-blue-500', 'bg-blue-100');
                dropZone.classList.remove('border-gray-300', 'bg-gray-50');
            }
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-100');
                dropZone.classList.add('border-gray-300', 'bg-gray-50');
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();

            const dropZone = document.getElementById('dropZone');
            if (dropZone) {
                dropZone.classList.remove('border-blue-500', 'bg-blue-100');
                dropZone.classList.add('border-gray-300', 'bg-gray-50');
            }

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                // Create a mock file input object to reuse handleFileSelect logic
                const mockInput = {
                    files: files,
                    value: ''
                };
                handleFileSelect(mockInput);
            }
        }

        function removeContestImage(index) {
            showConfirm(
                'Delete this image from the contest?',
                `confirmRemoveImage_${index}`,
                'üö®'
            );
        }

        function confirmRemoveImage(index) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Revoke Object URL if it's a local file
            const img = state.newContest.images[index];
            if (img && img.isLocalFile && img.url.startsWith('blob:')) {
                URL.revokeObjectURL(img.url);
            }

            state.newContest.images.splice(index, 1);
            state.modalProcessing = false;
            render();

            // Show success message
            showAlert('Image successfully removed!', '‚úÖ');
        }
        function toggleUserDropdown() {
            state.showUserDropdown = !state.showUserDropdown;
            render();
        }

        async function toggleDarkTheme() {
            // Prevent spam clicking
            if (state.themeToggling) return;

            state.themeToggling = true;
            setLoading('Switching theme...');

            // Small delay to show loading modal and smooth transition
            await new Promise(resolve => setTimeout(resolve, 300));

            state.darkTheme = !state.darkTheme;

            // Apply dark theme class to body
            if (state.darkTheme) {
                document.body.classList.add('dark-theme');
            } else {
                document.body.classList.remove('dark-theme');
            }

            // Save to database
            if (state.user && state.user.id) {
                try {
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${state.user.id}`, {
                        method: 'PATCH',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Content-Type': 'application/json',
                            'Prefer': 'return=minimal'
                        },
                        body: JSON.stringify({
                            dark_theme: state.darkTheme
                        })
                    });

                    if (!response.ok) {
                        console.error('Failed to save dark theme preference');
                    }
                } catch (error) {
                    console.error('Error saving dark theme preference:', error);
                }
            }

            clearLoading();
            state.themeToggling = false;
            render();
        }

        function toggleMergedContestsDropdown() {
            state.showMergedContestsDropdown = !state.showMergedContestsDropdown;
            render();
        }

        async function shareContest(contestId) {
            try {
                const shareUrl = `${window.location.origin}${window.location.pathname}#contest=${contestId}`;

                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                showToast('üîó Contest link copied!', 'success');
            } catch (error) {
                console.error('Failed to copy link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        // Helper function to fetch all votes with pagination (works around 2000 row DB limit)
        async function fetchAllVotesPaginated(filterQuery, selectFields) {
            let allVotes = [];
            let offset = 0;
            const limit = 2000; // Database row limit per query
            let hasMore = true;

            while (hasMore) {
                const url = `${SUPABASE_URL}/rest/v1/votes?${filterQuery}&limit=${limit}&offset=${offset}&select=${selectFields}`;
                const response = await fetch(url, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch votes: ${response.statusText}`);
                }

                const batch = await response.json();
                if (!Array.isArray(batch)) {
                    break;
                }

                allVotes = allVotes.concat(batch);

                // If we got fewer than limit rows, we've reached the end
                if (batch.length < limit) {
                    hasMore = false;
                } else {
                    offset += limit;
                }
            }

            return allVotes;
        }

        async function showContestInfoModal(item, itemType) {
            setLoading('Loading information...');
            try {
                // Fetch voters for this contest/merger/extract
                let voters = [];
                let votesData = [];

                if (itemType === 'merger') {
                    // For mergers, we need to get all voters and calculate how many contests they voted on
                    const contestIds = item.contestIds || [];
                    if (contestIds.length === 0) {
                        voters = [];
                    } else {
                        // Get all votes from merged contests with pagination
                        votesData = await fetchAllVotesPaginated(
                            `contest_id=in.(${contestIds.join(',')})`,
                            'user_id,contest_id,users!inner(id,username,avatar,is_banned)'
                        );
                    }
                } else if (itemType === 'extract') {
                    // For extracts, query votes from source contest(s)
                    let sourceContestIds = [];
                    if (item.sourceType === 'contest') {
                        sourceContestIds = [item.sourceContestId];
                    } else if (item.sourceType === 'merger') {
                        const merger = state.mergers.find(m => m.id === item.sourceMergerId);
                        if (merger) {
                            sourceContestIds = merger.contestIds;
                        }
                    }

                    if (sourceContestIds.length === 0) {
                        voters = [];
                    } else {
                        votesData = await fetchAllVotesPaginated(
                            `contest_id=in.(${sourceContestIds.join(',')})`,
                            'user_id,users!inner(id,username,avatar,is_banned)'
                        );
                    }
                } else {
                    // For regular contests, query using the contest_id with pagination
                    const contestId = item.id;
                    votesData = await fetchAllVotesPaginated(
                        `contest_id=eq.${contestId}`,
                        'user_id,users!inner(id,username,avatar,is_banned)'
                    );
                }

                // Deduplicate voters and sort by username (exclude banned users)
                if (votesData && votesData.length > 0) {
                    if (Array.isArray(votesData)) {
                        if (itemType === 'merger') {
                            // For mergers, calculate how many contests each user voted on
                            const voterContestsMap = new Map();
                            votesData.forEach(vote => {
                                if (vote.users && !vote.users.is_banned) {
                                    if (!voterContestsMap.has(vote.user_id)) {
                                        voterContestsMap.set(vote.user_id, {
                                            user: vote.users,
                                            contestIds: new Set()
                                        });
                                    }
                                    voterContestsMap.get(vote.user_id).contestIds.add(vote.contest_id);
                                }
                            });
                            voters = Array.from(voterContestsMap.entries()).map(([userId, data]) => ({
                                ...data.user,
                                completedContests: data.contestIds.size,
                                totalContests: item.contestIds.length
                            })).sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
                        } else {
                            // For contests and extracts, calculate image completion per voter
                            // First, need to fetch full vote data with image_id
                            let fullVotesData = [];
                            if (itemType === 'extract') {
                                // For extracts, get source contests
                                let sourceContestIds = [];
                                if (item.sourceType === 'contest') {
                                    sourceContestIds = [item.sourceContestId];
                                } else if (item.sourceType === 'merger') {
                                    const merger = state.mergers.find(m => m.id === item.sourceMergerId);
                                    if (merger) {
                                        sourceContestIds = merger.contestIds;
                                    }
                                }
                                if (sourceContestIds.length > 0) {
                                    fullVotesData = await fetchAllVotesPaginated(
                                        `contest_id=in.(${sourceContestIds.join(',')})`,
                                        'user_id,image_id,users!inner(id,username,avatar,is_banned)'
                                    );
                                }
                            } else {
                                // For contests
                                const contestId = item.id;
                                fullVotesData = await fetchAllVotesPaginated(
                                    `contest_id=eq.${contestId}`,
                                    'user_id,image_id,users!inner(id,username,avatar,is_banned)'
                                );
                            }

                            // Calculate how many images each user has voted on
                            const voterImagesMap = new Map();
                            const relevantImageIds = itemType === 'extract'
                                ? (item.imageIds || [])
                                : item.images.map(img => img.id);

                            fullVotesData.forEach(vote => {
                                if (vote.users && !vote.users.is_banned && relevantImageIds.includes(vote.image_id)) {
                                    if (!voterImagesMap.has(vote.user_id)) {
                                        voterImagesMap.set(vote.user_id, {
                                            user: vote.users,
                                            imageIds: new Set()
                                        });
                                    }
                                    voterImagesMap.get(vote.user_id).imageIds.add(vote.image_id);
                                }
                            });

                            voters = Array.from(voterImagesMap.entries()).map(([userId, data]) => ({
                                ...data.user,
                                completedImages: data.imageIds.size,
                                totalImages: relevantImageIds.length
                            })).sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));
                        }
                    }
                }

                // Set state for modal
                state.contestInfoModal = {
                    item,
                    itemType,
                    voters
                };

                clearLoading();
                render();
            } catch (error) {
                console.error('Error loading contest info:', error);
                clearLoading();
                showAlert('Failed to load contest info: ' + error.message, '‚ùå');
            }
        }

        function closeContestInfoModal() {
            state.contestInfoModal = null;
            render();
        }

        async function shareContestFromModal() {
            if (!state.contestInfoModal) return;

            const { item, itemType } = state.contestInfoModal;
            let shareUrl;

            if (itemType === 'merger') {
                shareUrl = `${window.location.origin}${window.location.pathname}#merger=${item.id}`;
            } else if (itemType === 'extract') {
                shareUrl = `${window.location.origin}${window.location.pathname}#extract=${item.id}`;
            } else {
                shareUrl = `${window.location.origin}${window.location.pathname}#contest=${item.id}`;
            }

            try {
                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                const itemTypeName = itemType === 'merger' ? 'Merger' : itemType === 'extract' ? 'Extract' : 'Contest';
                showToast(`üîó ${itemTypeName} link copied!`, 'success');
            } catch (error) {
                console.error('Failed to copy link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        function showBreakdownMerged(imageId) {
            state.showBreakdownModal = imageId;
            render();
        }

        function renderBreakdownModalMerged() {
            if (!state.mergedResults || !state.mergedResults.images) return '';

            const item = state.mergedResults.images.find(img => img.id === state.showBreakdownModal);
            if (!item) return '';

            const votesByScore = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            (item.voteBreakdown || []).forEach(vote => {
                if (votesByScore[vote.score]) {
                    votesByScore[vote.score].push(vote);
                }
            });

            Object.keys(votesByScore).forEach(score => {
                votesByScore[score].sort((a, b) => a.username.localeCompare(b.username));
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[85vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Vote Breakdown</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="overflow-y-auto flex-1 p-4">

                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 400px;">
                                <img
                                    src="${item.url}"
                                    alt="Image"
                                    class="max-w-full max-h-[400px] object-contain"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                            </div>

                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-gray-800">${item.averageScore}</div>
                                    <div class="text-xs text-gray-600">Average Score</div>
                                    <div class="text-xs text-gray-500 mt-1">${item.totalVotes} total votes</div>
                                </div>
                            </div>

                            <div class="space-y-3">
                                ${[5, 4, 3, 2, 1].map(score => {
                                    const votes = votesByScore[score] || [];
                                    return `
                                    <div>
                                        <h4 class="text-sm font-bold mb-2 px-3 py-1 rounded-lg inline-block" style="color: ${getScoreColor(score)}; background-color: ${getScoreColor(score)}20;">
                                            Score ${score} (${votes.length} ${votes.length === 1 ? 'vote' : 'votes'})
                                        </h4>
                                        ${votes.length > 0 ? `
                                            <div class="grid grid-cols-1 gap-2 mt-2">
                                                ${votes.map(vote => `
                                                    <div class="flex items-center gap-2 p-2 rounded-lg ${
                                                        vote.isBlocked ? 'bg-gray-300' :
                                                        vote.isCurrentUser ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'
                                                    }">
                                                        <img src="${vote.avatar}" alt="${vote.username}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');" />
                                                        <span class="text-sm flex-1 truncate cursor-pointer ${
                                                            vote.isBlocked ? 'line-through text-gray-700' : 'text-gray-700 hover:text-mauve-600'
                                                        }" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');">
                                                            ${vote.username}${vote.isCurrentUser ? ' (You)' : ''}
                                                        </span>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        ` : `
                                            <div class="text-gray-400 italic text-sm mt-2 ml-3">No votes</div>
                                        `}
                                    </div>
                                `}).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        async function shareMerge() {
            if (state.selectedContestsForMerge.length < 2) {
                showAlert('Please select at least 2 contests to merge', '‚ùå');
                return;
            }

            try {
                // Convert contest IDs to contest numbers for shorter URLs
                const contestNumbers = state.selectedContestsForMerge.map(id => {
                    const contest = state.contests.find(c => c.id === id);
                    return contest ? contest.contestNumber : null;
                }).filter(n => n !== null);

                const shareUrl = `${window.location.origin}${window.location.pathname}#merge=${contestNumbers.join(',')}`;

                // Try to use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(shareUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }

                showToast('üîó Merge link copied!', 'success');
            } catch (error) {
                console.error('Failed to copy merge link:', error);
                showToast('Failed to copy link', 'error');
            }
        }

        async function loadSharedContest(contestId) {
            try {
                console.log('Loading shared contest:', contestId);

                // Fetch contest from database with aggressive cache-busting
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contestId}&select=*,images(*),creator:users!contests_created_by_fkey(username,avatar)`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const contests = await response.json();

                if (!contests || contests.length === 0) {
                    showAlert('Contest not found. It may have been deleted.', '‚ùå');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                const contestData = contests[0];
                const contest = {
                    id: contestData.id,
                    title: contestData.title,
                    isLocked: contestData.is_locked,
                    resultsPublic: contestData.results_public,
                    createdBy: contestData.created_by,
                    creatorName: contestData.creator.username,
                    creatorAvatar: contestData.creator.avatar,
                    createdAt: contestData.created_at,
                    images: contestData.images
                        .sort((a, b) => a.image_order - b.image_order)
                        .map(img => ({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            isFileUpload: img.is_file_upload
                        }))
                };

                // Check if user is banned
                if (state.bannedUsers.includes(state.user?.id)) {
                    showAlert('Your account has been restricted. You cannot access this contest.', 'üö´');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Add contest to state if not already present (for Complete Voting modal to work)
                const existingContest = state.contests.find(c => c.id === contest.id);
                if (!existingContest) {
                    state.contests.push(contest);
                }

                // Check voting status
                const userVotes = state.userVotedContests[contest.id] || {};
                const votedImageCount = Object.keys(userVotes).length;
                const totalImageCount = contest.images.length;
                const hasVotedAll = votedImageCount === totalImageCount && totalImageCount > 0;
                const hasVotedSome = votedImageCount > 0 && votedImageCount < totalImageCount;

                // Clear the hash to avoid issues on reload
                window.location.hash = '';

                if (contest.isLocked || hasVotedAll) {
                    // Show results
                    await viewResults(contest);
                } else if (hasVotedSome) {
                    // Show Complete Voting modal
                    showContestVoteModal(contest.id);
                } else {
                    // Start voting
                    startVoting(contest);
                }
            } catch (error) {
                console.error('Error loading shared contest:', error);
                showAlert('Failed to load contest: ' + error.message, '‚ùå');
                window.location.hash = '';
                state.view = 'home';
                render();
            }
        }


        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove '#'

            console.log('üîó [NAVIGATION] Hash changed:', hash);

            // Don't handle hash changes if we're currently in voting mode
            // (this prevents interrupting the voting flow during "Complete Voting")
            if (state.view === 'vote') {
                console.log('üîó [NAVIGATION] Skipping hash change handling - currently voting');
                return;
            }

            // Parse hash parameters
            const params = new URLSearchParams(hash);
            const contestId = params.get('contest');
            const mergerId = params.get('merger');
            const extractId = params.get('extract');

            // If user is not logged in but trying to access a shared link, store it and show login
            if ((contestId || mergerId || extractId) && !state.isLoggedIn) {
                console.log('üîó [NAVIGATION] Shared link detected but user not logged in, storing route');
                state.pendingRoute = hash;
                localStorage.setItem('peony_pending_route', hash);
                render(); // This will show the login screen with the pending route
                return;
            }

            // Check for contest share: #contest={uuid}
            if (contestId && state.isLoggedIn) {
                // Prevent infinite loop: don't reload if already viewing this contest's results
                if (state.view === 'results' && state.currentContest && state.currentContest.id === contestId) {
                    console.log('üîó [NAVIGATION] Already viewing results for this contest, skipping reload');
                    return;
                }
                console.log('üîó [NAVIGATION] Detected contest share link');
                loadSharedContest(contestId);
            }
            // Check for merger share: #merger={uuid}
            else if (mergerId && state.isLoggedIn) {
                console.log('üîó [NAVIGATION] Detected merger share link');
                loadSharedMerger(mergerId);
            }
            // Check for extract share: #extract={uuid}
            else if (extractId && state.isLoggedIn) {
                console.log('üîó [NAVIGATION] Detected extract share link');
                loadSharedExtract(extractId);
            }
        }

        async function loadSharedMerger(mergerId) {
            try {
                console.log('Loading shared merger:', mergerId);

                // Check if user is banned first
                if (state.bannedUsers.includes(state.user?.id)) {
                    showAlert('Your account has been restricted. You cannot access this merger.', 'üö´');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Reload data to get latest state
                await loadContests();
                await loadMergers();
                await loadExtracts();
                await loadVoterCounts();

                // Find the merger in state
                const merger = state.mergers.find(m => m.id === mergerId);

                if (!merger) {
                    showAlert('Merger not found. It may have been deleted.', '‚ùå');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Get all contests in the merger
                const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                const isCreator = state.user && state.user.id === merger.createdBy;

                // Check if user has voted on all contests
                const unlockedContests = mergedContests.filter(c => !c.isLocked);
                const votedContests = unlockedContests.filter(c => state.userVotedContests[c.id]);
                const hasVotedAll = votedContests.length === unlockedContests.length && unlockedContests.length > 0;
                const hasVotedSome = votedContests.length > 0 && votedContests.length < unlockedContests.length;
                const hasVotedNone = votedContests.length === 0;

                // Clear the hash to avoid issues on reload
                window.location.hash = '';

                // Route user based on their voting status
                if (hasVotedAll || isAdmin || isCreator) {
                    // User has voted on all contests or is admin/creator -> show results
                    await viewMergerResults(mergerId);
                } else if (hasVotedSome) {
                    // User has voted on some contests -> show "Complete Voting" modal
                    showMergerVoteModal(mergerId);
                } else {
                    // User hasn't voted on any -> start merger voting
                    startMergerVoting(mergerId, false);
                }
            } catch (error) {
                console.error('Error loading shared merger:', error);
                showAlert('Failed to load merger: ' + error.message, '‚ùå');
                window.location.hash = '';
                state.view = 'home';
                render();
            }
        }

        async function loadSharedExtract(extractId) {
            try {
                console.log('Loading shared extract:', extractId);

                // Check if user is banned first
                if (state.bannedUsers.includes(state.user?.id)) {
                    showAlert('Your account has been restricted. You cannot access this extract.', 'üö´');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Reload data to get latest state
                await loadContests();
                await loadMergers();
                await loadExtracts();
                await loadVoterCounts();

                // Find the extract in state
                const extract = state.extracts.find(e => e.id === extractId);

                if (!extract) {
                    showAlert('Extract not found. It may have been deleted.', '‚ùå');
                    window.location.hash = '';
                    state.view = 'home';
                    render();
                    return;
                }

                // Check if user has voted on the source
                let hasVotedOnSource = false;

                if (extract.sourceType === 'contest') {
                    // For contest source, check if user has voted on the contest
                    hasVotedOnSource = !!state.userVotedContests[extract.sourceContestId];
                } else if (extract.sourceType === 'merger') {
                    // For merger source, check if user has voted on all contests in the merger
                    const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (sourceMerger) {
                        const mergedContests = state.contests.filter(c => sourceMerger.contestIds.includes(c.id));
                        const votedContests = mergedContests.filter(c => state.userVotedContests[c.id]);
                        hasVotedOnSource = votedContests.length === mergedContests.length && mergedContests.length > 0;
                    }
                }

                // Clear the hash to avoid issues on reload
                window.location.hash = '';

                // Route user based on their voting status
                const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                const isCreator = state.user && state.user.id === extract.createdBy;

                if (hasVotedOnSource || isAdmin || isCreator) {
                    // User has voted on source or is admin/creator -> show extract results
                    await viewExtractResults(extractId);
                } else {
                    // User hasn't voted on source -> show redirect modal
                    showExtractVotingRedirectModal(extractId);
                }
            } catch (error) {
                console.error('Error loading shared extract:', error);
                showAlert('Failed to load extract: ' + error.message, '‚ùå');
                window.location.hash = '';
                state.view = 'home';
                render();
            }
        }

        function finishCreateContest() {
            const isEditMode = !!state.editingContestId;
            const newImages = isEditMode ? state.newContest.images.filter(img => !img.isExisting) : state.newContest.images;

            if (!isEditMode && state.newContest.images.length === 0) {
                showAlert('Add at least one image!', '‚ùå');
                return;
            }

            if (isEditMode && newImages.length === 0) {
                showAlert('Add at least one new image!', '‚ùå');
                return;
            }

            // Check for duplicate title (only in create mode)
            if (!isEditMode) {
                const duplicateTitle = state.contests.some(c =>
                    c.title.toLowerCase().trim() === state.newContest.title.toLowerCase().trim()
                );

                if (duplicateTitle) {
                    showAlert('A contest with this title already exists. Please choose a different title.', '‚ùå');
                    return;
                }
            }

            // Show confirmation popup
            const message = isEditMode
                ? `Add ${newImages.length} new image(s) to contest "${state.newContest.title}"?`
                : `Create contest "${state.newContest.title}" with ${state.newContest.images.length} images?`;

            showConfirm(
                message,
                'confirmFinishCreateContest',
                'üö®'
            );
        }

        async function confirmFinishCreateContest() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const isEditMode = !!state.editingContestId;
            const imagesToProcess = isEditMode
                ? state.newContest.images.filter(img => !img.isExisting)
                : state.newContest.images;
            const uploadedUrls = [];
            const localFilesToUpload = imagesToProcess.filter(img => img.isLocalFile);

            try {
                // Step 1: Upload all local files first
                if (localFilesToUpload.length > 0) {
                    setLoading(`Uploading images (0/${localFilesToUpload.length})...`);

                    for (let i = 0; i < localFilesToUpload.length; i++) {
                        const img = localFilesToUpload[i];
                        setLoading(`Uploading images (${i + 1}/${localFilesToUpload.length})...`);

                        // Images are already compressed during upload phase
                        // Upload to storage
                        const uploadedUrl = await uploadImageFile(img.localFile);
                        uploadedUrls.push(uploadedUrl);

                        // Update the image URL in state
                        img.url = uploadedUrl;
                        img.isLocalFile = false;
                        delete img.localFile;
                    }
                }

                let contestId;

                if (isEditMode) {
                    // Step 2a: Use existing contest ID
                    contestId = state.editingContestId;
                    setLoading('Adding images to contest...');

                    // Get the current max image_order for this contest
                    const existingImagesCount = state.newContest.images.filter(img => img.isExisting).length;

                    // Insert only new images
                    const imagesToInsert = imagesToProcess.map((img, i) => ({
                        contest_id: contestId,
                        url: img.url,
                        is_file_upload: img.isFileUpload,
                        author: img.author,
                        image_order: existingImagesCount + i
                    }));

                    const imagesResponse = await fetch(`${SUPABASE_URL}/rest/v1/images`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Prefer': 'return=minimal',
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify(imagesToInsert)
                    });

                    if (!imagesResponse.ok) {
                        const errorData = await imagesResponse.json();
                        console.error('Image insertion failed:', errorData);
                        throw new Error(errorData.message || 'Failed to add images');
                    }
                } else {
                    // Step 2b: Insert contest - database auto-generates UUID
                    setLoading('Creating contest...');
                    const contestResponse = await fetch(`${SUPABASE_URL}/rest/v1/contests`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Prefer': 'return=representation',
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify({
                            title: state.newContest.title,
                            created_by: state.user.id
                        })
                    });

                    if (!contestResponse.ok) {
                        const errorData = await contestResponse.json();
                        console.error('Contest creation failed:', errorData);
                        throw new Error(errorData.message || 'Failed to create contest');
                    }

                    const createdContests = await contestResponse.json();
                    contestId = createdContests[0].id;

                    // Step 3: Insert images
                    const imagesToInsert = state.newContest.images.map((img, i) => ({
                        contest_id: contestId,
                        url: img.url,
                        is_file_upload: img.isFileUpload,
                        author: img.author,
                        image_order: i
                    }));

                    const imagesResponse = await fetch(`${SUPABASE_URL}/rest/v1/images`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Prefer': 'return=minimal',
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify(imagesToInsert)
                    });

                    if (!imagesResponse.ok) {
                        const errorData = await imagesResponse.json();
                        console.error('Image insertion failed:', errorData);
                        throw new Error(errorData.message || 'Failed to add images');
                    }
                }

                // Revoke all Object URLs after successful creation/editing
                state.newContest.images.forEach(img => {
                    if (img.url.startsWith('blob:')) {
                        URL.revokeObjectURL(img.url);
                    }
                });

                state.newContest = { title: '', images: [] };
                state.editingContestId = null;
                await loadContests();
                state.view = 'home';
                state.modalProcessing = false;

                // Show success message
                const successMessage = isEditMode
                    ? `Images added successfully! ${imagesToProcess.length} new image(s) added to contest.`
                    : 'Contest created successfully!';
                showAlert(successMessage, '‚ú®');

            } catch (error) {
                console.error('Full contest creation/edit error:', error);

                // Clean up uploaded files if contest creation/edit failed
                if (uploadedUrls.length > 0) {
                    console.log('Cleaning up uploaded files due to error...');
                    for (const url of uploadedUrls) {
                        try {
                            const fileName = url.split('/').pop();
                            await supabase.storage
                                .from('contest-images')
                                .remove([fileName]);
                        } catch (cleanupError) {
                            console.error('Failed to cleanup file:', cleanupError);
                        }
                    }
                }

                state.modalProcessing = false;
                const errorMessage = isEditMode
                    ? 'Failed to add images: ' + error.message
                    : 'Failed to create contest: ' + error.message;
                showAlert(errorMessage, '‚ùå');
            } finally {
                clearLoading();
            }
        }

        async function loadImageFromUrl(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                let timedOut = false;

                // Network timeout with specific message
                const timeoutId = setTimeout(() => {
                    timedOut = true;
                    reject(new Error('‚è±Ô∏è Network timeout: Image took too long to load. Possible causes: slow connection, large file size, or server issues. Try a different image or check your internet connection.'));
                }, 10000);

                img.onload = () => {
                    if (!timedOut) {
                        clearTimeout(timeoutId);
                        resolve(img);
                    }
                };

                img.onerror = () => {
                    if (timedOut) return; // Already handled by timeout
                    clearTimeout(timeoutId);

                    // Provide specific error details
                    let errorMsg = '‚ùå Failed to load image.\n\n';

                    // Check URL validity
                    try {
                        new URL(url);
                    } catch {
                        reject(new Error(errorMsg + 'üîó Invalid URL format. Please enter a valid image URL.'));
                        return;
                    }

                    // Check file extension
                    const extension = url.split('?')[0].split('.').pop().toLowerCase();
                    const validExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'];

                    // Provide likely causes based on URL analysis
                    if (url.includes('discord')) {
                        errorMsg += 'üí¨ Discord CDN issue: The link may be expired, deleted, or have restricted access. Try re-uploading the image to Discord and getting a fresh link.';
                    } else if (url.startsWith('http://')) {
                        errorMsg += 'üîí CORS/Security issue: HTTP URLs often have cross-origin restrictions. Try using an HTTPS URL instead, or upload the image to a public image host.';
                    } else if (!validExtensions.includes(extension)) {
                        errorMsg += 'üìÅ Unsupported format: The URL doesn\'t end with a recognized image extension (.jpg, .png, .gif, .webp). Make sure you\'re linking directly to an image file.';
                    } else if (url.includes('imgur') && !url.includes('i.imgur')) {
                        errorMsg += 'üñºÔ∏è Imgur link issue: Use direct image links (i.imgur.com) instead of gallery links. Right-click the image and select "Copy image address".';
                    } else {
                        errorMsg += 'üåê Possible causes:\n‚Ä¢ CORS restrictions from the image host\n‚Ä¢ Broken or expired link\n‚Ä¢ Image was deleted or moved\n‚Ä¢ Server is down or blocking requests\n‚Ä¢ Private/restricted access image\n\nTry uploading to a public image host like Imgur or Discord.';
                    }

                    reject(new Error(errorMsg));
                };

                img.src = url;
            });
        }

        function login() {
            state.sessionExpired = false;  // Clear session expired flag
            const authUrl = `https://discord.com/oauth2/authorize?client_id=${DISCORD_CLIENT_ID}&redirect_uri=${encodeURIComponent(DISCORD_REDIRECT_URI)}&response_type=token&scope=identify`;
            window.location.href = authUrl;
        }

        function showLogoutConfirmation() {
            state.showLogoutConfirmModal = true;
            render();
        }

        function cancelLogout() {
            state.showLogoutConfirmModal = false;
            render();
        }

        function confirmLogout() {
            localStorage.removeItem('peony_user');
            state.isLoggedIn = false;
            state.user = null;
            state.view = 'home';
            state.showLogoutConfirmModal = false;
            render();
        }

        function logout() {
            showLogoutConfirmation();
        }

        async function loadVoterCounts() {
            // Only show loading modal if not in initialization phase
            if (!state.isInitializing) {
                setLoading('Loading voter counts...');
            }
            try {
                // Fetch all votes using pagination to avoid row limit
                const votes = await fetchAllVotesPaginated('', 'contest_id,user_id');

                if (Array.isArray(votes)) {
                    // Calculate voter counts for each contest
                    const contestVoterCounts = new Map();
                    votes.forEach(vote => {
                        if (!contestVoterCounts.has(vote.contest_id)) {
                            contestVoterCounts.set(vote.contest_id, new Set());
                        }
                        contestVoterCounts.get(vote.contest_id).add(vote.user_id);
                    });

                    // Update contest voter counts
                    state.contests.forEach(contest => {
                        const voters = contestVoterCounts.get(contest.id);
                        contest.voterCount = voters ? voters.size : 0;
                    });

                    // Update merger voter counts (count unique voters across all merged contests)
                    state.mergers.forEach(merger => {
                        const allVoters = new Set();
                        merger.contestIds.forEach(contestId => {
                            const voters = contestVoterCounts.get(contestId);
                            if (voters) {
                                voters.forEach(voterId => allVoters.add(voterId));
                            }
                        });
                        merger.voterCount = allVoters.size;
                    });

                    // Update extract voter counts (count unique voters from source)
                    // First fetch shortcake votes for extracts from shortcakes
                    const shortcakeVotesResponse = await fetch(`${SUPABASE_URL}/rest/v1/shortcake_votes?select=shortcake_id,user_id`, {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    });
                    const shortcakeVotesForExtracts = await shortcakeVotesResponse.json();

                    // Build shortcake voter counts map
                    const shortcakeVoterCounts = new Map();
                    if (Array.isArray(shortcakeVotesForExtracts)) {
                        shortcakeVotesForExtracts.forEach(vote => {
                            if (!shortcakeVoterCounts.has(vote.shortcake_id)) {
                                shortcakeVoterCounts.set(vote.shortcake_id, new Set());
                            }
                            shortcakeVoterCounts.get(vote.shortcake_id).add(vote.user_id);
                        });
                    }

                    state.extracts.forEach(extract => {
                        const allVoters = new Set();
                        if (extract.sourceType === 'shortcake') {
                            const voters = shortcakeVoterCounts.get(extract.sourceContestId);
                            if (voters) {
                                voters.forEach(voterId => allVoters.add(voterId));
                            }
                        } else if (extract.sourceType === 'contest') {
                            const voters = contestVoterCounts.get(extract.sourceContestId);
                            if (voters) {
                                voters.forEach(voterId => allVoters.add(voterId));
                            }
                        } else if (extract.sourceType === 'merger') {
                            const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                            if (merger) {
                                merger.contestIds.forEach(contestId => {
                                    const voters = contestVoterCounts.get(contestId);
                                    if (voters) {
                                        voters.forEach(voterId => allVoters.add(voterId));
                                    }
                                });
                            }
                        }
                        extract.voterCount = allVoters.size;
                    });
                }

                // Fetch shortcake votes for shortcake voter counts
                const shortcakeVotesResponse = await fetch(`${SUPABASE_URL}/rest/v1/shortcake_votes?select=shortcake_id,user_id`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const shortcakeVotes = await shortcakeVotesResponse.json();

                if (Array.isArray(shortcakeVotes)) {
                    // Calculate voter counts for each shortcake
                    const shortcakeVoterCounts = new Map();
                    shortcakeVotes.forEach(vote => {
                        if (!shortcakeVoterCounts.has(vote.shortcake_id)) {
                            shortcakeVoterCounts.set(vote.shortcake_id, new Set());
                        }
                        shortcakeVoterCounts.get(vote.shortcake_id).add(vote.user_id);
                    });

                    // Update shortcake voter counts
                    state.shortcakes.forEach(shortcake => {
                        const voters = shortcakeVoterCounts.get(shortcake.id);
                        shortcake.voterCount = voters ? voters.size : 0;
                    });
                }
            } catch (error) {
                console.error('Error loading voter counts:', error);
                // Don't throw - just log the error and continue with 0 voter counts
            } finally {
                // Only clear loading if not in initialization phase
                if (!state.isInitializing) {
                    clearLoading();
                }
            }
        }

        async function loadContests() {
            setLoading('Loading contests...');
            try {
                const response = await fetchFromSupabase('/rest/v1/contests?select=*,images(*),creator:users!contests_created_by_fkey(username,avatar)&order=created_at.desc');

                const contests = await response.json();

                // Check if contests response is valid
                if (!Array.isArray(contests)) {
                    console.error('Invalid contests response:', contests);
                    throw new Error(contests.message || 'Failed to load contests');
                }

                // Map contests with their voter counts from database fields
                state.contests = contests.map(contest => ({
                    id: contest.id,
                    contestNumber: contest.contest_number,
                    title: contest.title,
                    isLocked: contest.is_locked,
                    resultsPublic: contest.results_public,
                    createdBy: contest.created_by,
                    creatorName: contest.creator.username,
                    creatorAvatar: contest.creator.avatar,
                    createdAt: contest.created_at,
                    voterCount: 0, // Will be updated after fetching voter counts
                    images: contest.images
                        .sort((a, b) => a.image_order - b.image_order)
                        .map(img => ({
                            id: img.id,
                            url: img.url,
                            author: img.author,
                            isFileUpload: img.is_file_upload
                        }))
                }));

                // Load voter counts after loading contests (unless in initialization phase)
                if (!state.isInitializing) {
                    await loadVoterCounts();
                    render();
                }
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            } finally {
                // Only clear loading if not in initialization phase
                if (!state.isInitializing) {
                    clearLoading();
                }
            }
        }

        async function loadMergers() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?select=*,creator:users!mergers_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const mergers = await response.json();
                if (Array.isArray(mergers)) {
                    state.mergers = mergers.map(m => ({
                        id: m.id,
                        name: m.name,
                        createdBy: m.created_by,
                        creatorName: m.creator.username,
                        creatorAvatar: m.creator.avatar,
                        createdAt: m.created_at,
                        contestIds: m.contest_ids,
                        isLocked: m.is_locked || false,
                        resultsPublic: m.results_public !== false,
                        voterCount: 0, // Will be updated by loadVoterCounts
                        type: 'merger'
                    }));
                }
            } catch (error) {
                console.error('Error loading mergers:', error);
            }
        }

        async function loadExtracts() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?select=*,creator:users!extracts_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const extracts = await response.json();
                if (Array.isArray(extracts)) {
                    state.extracts = extracts.map(e => ({
                        id: e.id,
                        name: e.name,
                        createdBy: e.created_by,
                        creatorName: e.creator.username,
                        creatorAvatar: e.creator.avatar,
                        createdAt: e.created_at,
                        sourceContestId: e.source_type === 'contest' ? e.source_contest_id : (e.source_type === 'extract' ? e.source_contract_id : null),
                        sourceMergerId: e.source_type === 'merger' ? e.source_contest_id : null,
                        sourceType: e.source_type,
                        imageIds: e.image_ids,
                        isLocked: e.is_locked || false,
                        resultsPublic: e.results_public !== false,
                        voterCount: 0, // Will be updated by loadVoterCounts
                        type: 'extract'
                    }));
                }
            } catch (error) {
                console.error('Error loading extracts:', error);
            }
        }

        async function loadShortcakes() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/shortcakes?select=*,creator:users!shortcakes_created_by_fkey(username,avatar)&order=created_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const shortcakes = await response.json();
                if (Array.isArray(shortcakes)) {
                    // Fetch all images for shortcakes
                    const allImageIds = shortcakes.flatMap(s => s.image_ids || []);
                    let imagesMap = new Map();

                    if (allImageIds.length > 0) {
                        const imagesResponse = await fetch(`${SUPABASE_URL}/rest/v1/images?id=in.(${allImageIds.join(',')})`, {
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Cache-Control': 'no-cache'
                            }
                        });
                        const images = await imagesResponse.json();
                        if (Array.isArray(images)) {
                            images.forEach(img => imagesMap.set(img.id, img));
                        }
                    }

                    state.shortcakes = shortcakes.map(s => ({
                        id: s.id,
                        title: s.title,
                        createdBy: s.created_by,
                        creatorName: s.creator.username,
                        creatorAvatar: s.creator.avatar,
                        createdAt: s.created_at,
                        imageIds: s.image_ids || [],
                        images: (s.image_ids || [])
                            .map(id => imagesMap.get(id))
                            .filter(img => img)
                            .sort((a, b) => a.image_order - b.image_order)
                            .map(img => ({
                                id: img.id,
                                url: img.url,
                                author: img.author
                            })),
                        min: s.min,
                        max: s.max,
                        isLocked: s.is_locked || false,
                        resultsPublic: s.results_public !== false,
                        voterCount: 0, // Will be updated by loadVoterCounts
                        type: 'shortcake'
                    }));
                }
            } catch (error) {
                console.error('Error loading shortcakes:', error);
            }
        }

        async function loadPinnedItems() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/pinned_items?select=*&order=pinned_at.desc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const pinnedItems = await response.json();
                if (Array.isArray(pinnedItems)) {
                    state.pinnedItems = pinnedItems;
                }
            } catch (error) {
                console.error('Error loading pinned items:', error);
            }
        }

        async function pinItem(itemType, itemId) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showToast('Only admins can pin items', 'error');
                return;
            }

            // Check if item is already pinned
            const alreadyPinned = state.pinnedItems.some(
                item => item.item_type === itemType && item.item_id === itemId
            );

            if (alreadyPinned) {
                showToast('Item is already pinned', 'info');
                return;
            }

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/pinned_items`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=minimal'
                    },
                    body: JSON.stringify({
                        item_type: itemType,
                        item_id: itemId,
                        pinned_by: state.user.id
                    })
                });

                if (response.ok) {
                    showToast('Item pinned successfully', 'success');
                    await loadPinnedItems();
                    render();
                } else {
                    const error = await response.text();
                    console.error('Failed to pin item:', error);
                    showToast('Failed to pin item', 'error');
                }
            } catch (error) {
                console.error('Error pinning item:', error);
                showToast('Error pinning item', 'error');
            }
        }

        async function unpinItem(itemType, itemId) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showToast('Only admins can unpin items', 'error');
                return;
            }

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/pinned_items?item_type=eq.${itemType}&item_id=eq.${itemId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (response.ok) {
                    showToast('Item unpinned successfully', 'success');
                    await loadPinnedItems();
                    render();
                } else {
                    showToast('Failed to unpin item', 'error');
                }
            } catch (error) {
                console.error('Error unpinning item:', error);
                showToast('Error unpinning item', 'error');
            }
        }

        function togglePin(event, itemType, itemId, isPinned) {
            event.stopPropagation();
            if (isPinned) {
                unpinItem(itemType, itemId);
            } else {
                pinItem(itemType, itemId);
            }
        }

        async function loadAppSettings() {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const settings = await response.json();
                if (Array.isArray(settings)) {
                    settings.forEach(s => {
                        state.appSettings[s.setting_name] = s.value;
                    });
                }
            } catch (error) {
                console.error('Error loading app settings:', error);
            }
        }

        async function loadUserVotes() {
            if (!state.user) return;

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${state.user.id}&select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                const votes = await response.json();

                state.userVotedContests = {};
                votes.forEach(vote => {
                    if (!state.userVotedContests[vote.contest_id]) {
                        state.userVotedContests[vote.contest_id] = {};
                    }
                    state.userVotedContests[vote.contest_id][vote.image_id] = vote.score;
                });
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error message:', error.message);
                showAlert('Error: ' + error.message, '‚ùå');
            }
        }

        async function loadActivityLogs() {
            try {
                state.activityLogsLoading = true;
                render(); // Show loading state

                // Use state dates or default to last 7 days
                const now = new Date();
                let weekStart, weekEnd;

                if (state.activityDateStart && state.activityDateEnd) {
                    weekStart = new Date(state.activityDateStart);
                    weekEnd = new Date(state.activityDateEnd);
                    weekEnd.setHours(23, 59, 59, 999); // End of day
                } else {
                    weekStart = new Date(now);
                    weekStart.setDate(now.getDate() - 7);
                    weekStart.setHours(0, 0, 0, 0);
                    weekEnd = new Date(now);
                    weekEnd.setHours(23, 59, 59, 999);
                }

                const weekStartISO = weekStart.toISOString();
                const weekEndISO = weekEnd.toISOString();
                console.log('Recent Activity - Week Start:', weekStartISO, '| Week End:', weekEndISO);

                // Query votes from the date range with pagination (2000 row limit per query)
                let votes = [];
                let offset = 0;
                const limit = 2000;
                while (true) {
                    const votesResponse = await fetch(
                        `${SUPABASE_URL}/rest/v1/votes?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=${limit}&offset=${offset}&select=user_id,contest_id,created_at,voter:users!votes_user_id_fkey(username,avatar)&order=created_at.desc`,
                        {
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                'Cache-Control': 'no-cache'
                            }
                        }
                    );

                    if (!votesResponse.ok) {
                        console.error('Votes fetch failed:', votesResponse.status, votesResponse.statusText);
                        throw new Error('Failed to fetch vote activity logs');
                    }

                    const batch = await votesResponse.json();
                    votes.push(...batch);

                    // If we got less than the limit, we've fetched all data
                    if (batch.length < limit) break;

                    offset += limit;
                }

                // Query contest creations from the date range
                const contestsResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/contests?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=2000&select=id,title,created_at,created_by,creator:users!contests_created_by_fkey(username,avatar)&order=created_at.desc`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                // Query merger creations from the date range
                const mergersResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/mergers?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=2000&select=id,name,created_at,created_by,creator:users!mergers_created_by_fkey(username,avatar)&order=created_at.desc`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                // Query extract creations from the date range
                const extractsResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/extracts?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=2000&select=id,name,created_at,created_by,creator:users!extracts_created_by_fkey(username,avatar)&order=created_at.desc`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                // Query user signups from the date range
                const usersResponse = await fetch(
                    `${SUPABASE_URL}/rest/v1/users?created_at=gte.${weekStartISO}&created_at=lte.${weekEndISO}&limit=2000&select=id,username,avatar,created_at&order=created_at.desc`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                const contests = contestsResponse.ok ? await contestsResponse.json() : [];
                const mergers = mergersResponse.ok ? await mergersResponse.json() : [];
                const extracts = extractsResponse.ok ? await extractsResponse.json() : [];
                const users = usersResponse.ok ? await usersResponse.json() : [];

                console.log('Recent Activity Data:', {
                    votes: votes.length,
                    contests: contests.length,
                    mergers: mergers.length,
                    extracts: extracts.length,
                    users: users.length,
                    voteSample: votes[0],
                    contestSample: contests[0],
                    userSample: users[0]
                });

                // Group votes by user-contest combination and check if voting is complete
                const activityMap = new Map();
                const voteCountMap = new Map(); // Track vote counts per user-contest

                // First, count votes per user-contest
                votes.forEach(vote => {
                    const countKey = `${vote.user_id}-${vote.contest_id}`;
                    voteCountMap.set(countKey, (voteCountMap.get(countKey) || 0) + 1);
                });

                votes.forEach(vote => {
                    const key = `vote-${vote.user_id}-${vote.contest_id}`;
                    if (!activityMap.has(key) || new Date(vote.created_at) > new Date(activityMap.get(key).timestamp)) {
                        // Get contest title and image count from state.contests
                        const contest = state.contests.find(c => c.id === vote.contest_id);
                        const totalImages = contest?.images?.length || 0;
                        const countKey = `${vote.user_id}-${vote.contest_id}`;
                        const userVoteCount = voteCountMap.get(countKey) || 0;
                        const isCompleted = totalImages > 0 && userVoteCount === totalImages;

                        activityMap.set(key, {
                            type: isCompleted ? 'vote_completed' : 'vote',
                            userId: vote.user_id,
                            username: vote.voter?.username || 'Unknown User',
                            avatar: vote.voter?.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${vote.user_id}`,
                            contestId: vote.contest_id,
                            contestTitle: contest?.title || 'Unknown Contest',
                            timestamp: vote.created_at,
                            voteCount: userVoteCount,
                            totalImages: totalImages
                        });
                    }
                });

                // Add contest creations
                contests.forEach(contest => {
                    activityMap.set(`contest-${contest.id}`, {
                        type: 'contest',
                        userId: contest.created_by,
                        username: contest.creator?.username || 'Unknown User',
                        avatar: contest.creator?.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${contest.created_by}`,
                        itemId: contest.id,
                        itemName: contest.title,
                        timestamp: contest.created_at
                    });
                });

                // Add merger creations
                mergers.forEach(merger => {
                    activityMap.set(`merger-${merger.id}`, {
                        type: 'merger',
                        userId: merger.created_by,
                        username: merger.creator?.username || 'Unknown User',
                        avatar: merger.creator?.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${merger.created_by}`,
                        itemId: merger.id,
                        itemName: merger.name,
                        timestamp: merger.created_at
                    });
                });

                // Add extract creations
                extracts.forEach(extract => {
                    activityMap.set(`extract-${extract.id}`, {
                        type: 'extract',
                        userId: extract.created_by,
                        username: extract.creator?.username || 'Unknown User',
                        avatar: extract.creator?.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${extract.created_by}`,
                        itemId: extract.id,
                        itemName: extract.name,
                        timestamp: extract.created_at
                    });
                });

                // Add user signups
                users.forEach(user => {
                    activityMap.set(`user-${user.id}`, {
                        type: 'signup',
                        userId: user.id,
                        username: user.username || 'Unknown User',
                        avatar: user.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${user.id}`,
                        timestamp: user.created_at
                    });
                });

                // Convert to array and sort by timestamp (most recent first)
                state.activityLogs = Array.from(activityMap.values()).sort((a, b) =>
                    new Date(b.timestamp) - new Date(a.timestamp)
                );

                console.log('Recent Activity - Final count:', state.activityLogs.length, 'activities');
                if (state.activityLogs.length > 0) {
                    console.log('Sample activities:', state.activityLogs.slice(0, 3));
                }

                state.activityLogsLoading = false;
                render();
            } catch (error) {
                console.error('Error loading activity logs:', error);
                state.activityLogsLoading = false;
                showToast('Failed to load activity logs', 'error');
                render();
            }
        }

        function showActivityLogs() {
            state.showActivityLogsModal = true;
            loadActivityLogs();
        }

        function closeActivityLogs() {
            state.showActivityLogsModal = false;
            render();
        }

        function setActivityStartDate(value) {
            state.activityDateStart = value;
        }

        function setActivityEndDate(value) {
            state.activityDateEnd = value;
        }

        function setActivityFilterUser(userId) {
            state.activityFilterUser = userId || null;
            render();
        }

        function setActivityFilterContest(contestId) {
            state.activityFilterContest = contestId || null;
            render();
        }

        // --- ADD: ensureLocalUser (insert this near other helper functions) ---
        function ensureLocalUser(user) {
            // returns a Promise that resolves when the user exists (or after insertion)
            console.log('üë§ Ensuring user exists in database:', user.id, user.username);
            return fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${user.id}`, {
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'Cache-Control': 'no-cache'
                }
            })
            .then(r => r.json())
            .then(rows => {
                if (rows.length === 0) {
                    console.log('üë§ User not found in database, creating new user');
                    // create the user row in public.users
                    return fetch(`${SUPABASE_URL}/rest/v1/users`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify({
                            id: user.id,
                            username: user.username,
                            avatar: user.avatar
                        })
                    }).then(resp => {
                        // If the insert fails, still let caller continue but log error
                        if (!resp.ok) {
                            return resp.text().then(t => {
                                console.error('‚ùå Failed to insert local user:', t);
                                console.error('‚ùå Response status:', resp.status);
                                console.error('‚ùå User data:', { id: user.id, username: user.username, avatar: user.avatar });
                                // swallow error to avoid locking login flow; caller can handle later
                                return;
                            });
                        } else {
                            console.log('‚úÖ User successfully created in database');
                        }
                    });
                } else {
                    console.log('‚úÖ User already exists in database');
                }
                // user already exists: resolve immediately
                return;
            })
            .catch(err => {
                console.error('‚ùå ensureLocalUser error:', err);
                // resolve anyway so login flow continues; caller may show an error later
                return;
            });
        }
        // --- END ADD ---

        // Helper function to load images with proper tracking
        function loadImagesWithTracking(images) {
            return new Promise((resolve) => {
                const MAX_TIMEOUT = 10000; // 10 seconds max timeout
                let loadedCount = 0;
                let hasCompleted = false;

                // Timeout fallback
                const timeoutId = setTimeout(() => {
                    if (!hasCompleted) {
                        hasCompleted = true;
                        state.isLoadingMultiModeImages = false;
                        render();
                        resolve();
                    }
                }, MAX_TIMEOUT);

                // If no images, resolve immediately
                if (!images || images.length === 0) {
                    clearTimeout(timeoutId);
                    state.isLoadingMultiModeImages = false;
                    render();
                    resolve();
                    return;
                }

                // Create image load promises
                const imagePromises = images.map((img, index) => {
                    return new Promise((resolveImg) => {
                        const imageObj = new Image();

                        const onLoadOrError = () => {
                            if (!hasCompleted) {
                                loadedCount++;
                                state.multiModeLoadedImages = loadedCount;
                                render();
                                resolveImg();
                            }
                        };

                        imageObj.onload = onLoadOrError;
                        imageObj.onerror = onLoadOrError; // Count errors as loaded to prevent hanging
                        imageObj.src = img.url;
                    });
                });

                // Wait for all images to load
                Promise.all(imagePromises).then(() => {
                    if (!hasCompleted) {
                        hasCompleted = true;
                        clearTimeout(timeoutId);
                        state.isLoadingMultiModeImages = false;
                        render();
                        resolve();
                    }
                });
            });
        }

        function startVoting(contest) {
            state.currentContest = contest;
            state.shuffledImages = shuffleArray(contest.images);
            state.votes = {};
            state.currentImageIndex = 0;
            state.hasSubmitted = false;
            state.results = null;
            state.view = 'vote';

            // Load voting mode preference from localStorage, default to 'multi'
            const savedVotingMode = localStorage.getItem('peony_voting_mode');
            state.votingMode = savedVotingMode || 'multi';

            // Clear merger context (we're voting on a single contest)
            state.currentMergerId = null;
            state.mergerContestIds = [];

            // Update URL hash for shareable link
            window.location.hash = `contest=${contest.id}`;

            // Show loading modal if starting in multi mode
            if (state.votingMode === 'multi') {
                state.isLoadingMultiModeImages = true;
                state.multiModeLoadedImages = 0;
                state.multiModeTotalImages = state.shuffledImages.length;
                render();

                // Load images with tracking, hide modal when done or after 10s timeout
                loadImagesWithTracking(state.shuffledImages);
            } else {
                render();
            }
        }

        async function startShortcakeVoting(shortcake) {
            // Check if user has already voted
            setLoading('Loading shortcake voting...');
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/shortcake_votes?shortcake_id=eq.${shortcake.id}&user_id=eq.${state.user.id}`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const existingVotes = await response.json();

                state.currentShortcake = shortcake;
                state.shuffledImages = shuffleArray(shortcake.images);
                state.shortlistedImageIds = existingVotes.length > 0 ? existingVotes[0].shortlisted_image_ids || [] : [];
                state.currentImageIndex = 0;
                state.hasSubmitted = false;
                state.view = 'voteShortcake';
                state.votingMode = 'multi';  // Shortcakes default to multi mode

                // Update URL hash
                window.location.hash = `shortcake=${shortcake.id}`;

                clearLoading();
                render();
            } catch (error) {
                console.error('Error loading shortcake voting:', error);
                clearLoading();
                showAlert('Failed to load shortcake voting: ' + error.message, '‚ùå');
            }
        }

        async function viewResults(contest) {
            // Skip database check for extracts
            const isExtract = contest.isExtract === true;

            if (!isExtract) {
                // Check if contest still exists in the database
                try {
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/contests?id=eq.${contest.id}&select=*`, {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    });

                    const contests = await response.json();

                    // If contest doesn't exist (deleted), refresh the page
                    if (!contests || contests.length === 0) {
                        console.log('Contest no longer exists, refreshing...');
                        showAlert('Contest was deleted. Refreshing...', 'üîÑ');
                        setTimeout(() => location.reload(), 1500);
                        return;
                    }

                    // Check if results are public
                    const contestData = contests[0];
                    const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                    const isCreator = state.user && state.user.id === contestData.created_by;
                    const resultsPublic = contestData.results_public !== false;
                    const hasVoted = !!state.userVotedContests[contest.id];

                    // For hidden results, allow viewing with restrictions if user has voted
                    if (!resultsPublic && !isAdmin && !isCreator && !hasVoted) {
                        showAlert('Results are private. Only voters, the creator, or admin can view them.', 'üîí');
                        return;
                    }
                } catch (error) {
                    console.error('Error checking contest existence:', error);
                    showAlert('Error loading results: ' + error.message, '‚ùå');
                    return;
                }
            }

            state.currentContest = contest;
            const userVotes = state.userVotedContests[contest.id] || {};
            state.votes = userVotes;
            await loadResults();
            state.showMyVotes = false;

            // For hidden results, default to userVotes tab (showing own votes only)
            const isPrivate = contest.resultsPublic === false;
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === contest.createdBy;
            if (isPrivate && !isAdmin && !isCreator) {
                state.resultsView = 'userVotes';
                state.selectedVoterUserId = state.user.id;
            } else {
                state.resultsView = 'average'; // Default to average for public results
            }

            state.view = 'results';

            // Update URL hash for shareable link (only for real contests, not extracts)
            if (!isExtract) {
                window.location.hash = `contest=${contest.id}`;
            }

            render();
        }

        async function viewShortcakeResults(shortcake) {
            setLoading('Loading shortcake results...');
            try {
                // Fetch all shortcake votes with voter details
                const response = await fetch(
                    `${SUPABASE_URL}/rest/v1/shortcake_votes?shortcake_id=eq.${shortcake.id}&select=*,voter:users!shortcake_votes_user_id_fkey(username,avatar,is_banned)`,
                    {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to fetch shortcake votes');
                }

                const votes = await response.json();

                // Store votes in state for rendering
                state.shortcakeResults = votes;
                state.currentShortcake = shortcake;
                state.view = 'shortcakeResults';
                state.shortcakeResultsView = 'average'; // Reset to average view

                // Update URL hash
                window.location.hash = `shortcake=${shortcake.id}`;

                clearLoading();
                render();
            } catch (error) {
                console.error('Error loading shortcake results:', error);
                clearLoading();
                showAlert('Failed to load shortcake results: ' + error.message, '‚ùå');
            }
        }

        async function viewLockedResults(contest) {
            // Check if results are public
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === contest.createdBy;
            const resultsPublic = contest.resultsPublic !== false;

            if (!resultsPublic && !isAdmin && !isCreator) {
                showAlert('Results are private. Only the creator or admin can view them.', 'üîí');
                return;
            }

            state.currentContest = contest;
            state.votes = {};
            await loadResults();
            state.showMyVotes = false;
            state.view = 'results';
            render();
        }

        // Admin bypass functions - allow viewing results without voting requirement
        async function adminViewResults(contestOrId) {
            setLoading('Loading results...');
            try {
                // Handle both contest object and contest ID
                let contest;
                if (typeof contestOrId === 'string') {
                    // It's an ID, look up the contest
                    contest = state.contests.find(c => c.id === contestOrId);
                    if (!contest) {
                        throw new Error('Contest not found');
                    }
                } else {
                    // It's already a contest object
                    contest = contestOrId;
                }

                state.currentContest = contest;
                state.votes = {};
                await loadResults();
                state.showMyVotes = false;
                state.view = 'results';
                window.location.hash = `contest=${contest.id}`;
                clearLoading();
                render();
            } catch (error) {
                console.error('Error loading results:', error);
                clearLoading();
                showAlert('Error loading results: ' + error.message, '‚ùå');
            }
        }

        async function adminViewMergerResults(mergerId) {
            setLoading('Loading merger results...');
            try {
                const merger = state.mergers.find(m => m.id === mergerId);
                if (!merger) {
                    showAlert('Merger not found', '‚ùå');
                    clearLoading();
                    return;
                }

                state.currentMergerId = mergerId;
                state.mergerContestIds = merger.contestIds;
                state.votes = {};
                await loadMergedResults(mergerId);
                state.view = 'mergedResults';
                window.location.hash = `merger=${mergerId}`;
                clearLoading();
                render();
            } catch (error) {
                console.error('Error loading merger results:', error);
                clearLoading();
                showAlert('Error loading merger results: ' + error.message, '‚ùå');
            }
        }

        async function adminViewExtractResults(extractId) {
            setLoading('Loading extract results...');
            try {
                const extract = state.extracts.find(e => e.id === extractId);
                if (!extract) {
                    showAlert('Extract not found', '‚ùå');
                    clearLoading();
                    return;
                }

                // Navigate to the extract's results view
                await viewExtractResults(extractId);
                clearLoading();
            } catch (error) {
                console.error('Error loading extract results:', error);
                clearLoading();
                showAlert('Error loading extract results: ' + error.message, '‚ùå');
            }
        }

        function startRevoteFromHome(contest) {
            // Set the current contest first
            state.currentContest = contest;
            // Then call the standard revote flow
            startRevote();
        }

        function startRevote() {
            // Show confirmation modal with options to start fresh or preload existing votes
            state.modal = {
                type: 'confirm',
                icon: 'üîÑ',
                message: 'How would you like to revote?',
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Start Fresh', action: 'confirmRevote', primary: false, color: 'pink' },
                    { text: 'Preload Previous Votes', action: 'confirmRevoteWithPrefill', primary: true, color: 'blue' }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function confirmRevote() {
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Reset voting state with clean slate
            state.votes = {};
            state.hasSubmitted = false;
            state.shuffledImages = shuffleArray(state.currentContest.images);
            state.currentImageIndex = 0;
            state.view = 'vote';

            render();
        }

        async function confirmRevoteWithPrefill() {
            state.modal = null;
            document.body.classList.remove('modal-open');

            setLoading('Loading your previous votes...');

            try {
                // Fetch user's previous votes for this contest
                const userVotes = await fetchAllVotesPaginated(
                    `contest_id=eq.${state.currentContest.id}&user_id=eq.${state.user.id}`,
                    'image_id,score'
                );

                // Prefill votes from previous submission
                state.votes = {};
                userVotes.forEach(vote => {
                    state.votes[vote.image_id] = vote.score;
                });

                // Set up voting state
                state.hasSubmitted = false;
                state.shuffledImages = shuffleArray(state.currentContest.images);
                state.currentImageIndex = 0;
                state.view = 'vote';

                clearLoading();
                render();

                // Show toast to confirm prefill
                showToast('Previous votes loaded!', 'success');
            } catch (error) {
                console.error('Error loading previous votes:', error);
                clearLoading();
                showAlert('Failed to load previous votes. Starting fresh instead.', '‚ùå');

                // Fall back to fresh start
                confirmRevote();
            }
        }

        async function toggleContestLock(itemId) {
            // Find item across all types
            let item = state.contests.find(c => c.id === itemId);
            let itemType = 'contest';
            let tableName = 'contests';

            if (!item) {
                item = state.mergers.find(m => m.id === itemId);
                itemType = 'merger';
                tableName = 'mergers';
            }
            if (!item) {
                item = state.extracts.find(e => e.id === itemId);
                itemType = 'extract';
                tableName = 'extracts';
            }
            if (!item) {
                item = state.shortcakes.find(s => s.id === itemId);
                itemType = 'shortcake';
                tableName = 'shortcakes';
            }
            if (!item) return;

            // Only the creator or admin can lock/unlock
            if (item.createdBy !== state.user.id && state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Only the creator or admin can lock/unlock this item.', 'üîí');
                return;
            }

            const newLockStatus = !item.isLocked;

            try {
                // Update database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/${tableName}?id=eq.${itemId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_locked: newLockStatus
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Lock status update failed:', errorData);
                    throw new Error(errorData.message || 'Failed to update lock status');
                }

                // Update local state only if database update succeeded
                item.isLocked = newLockStatus;
                const itemLabel = itemType.charAt(0).toUpperCase() + itemType.slice(1);
                showAlert(item.isLocked ? `üîí ${itemLabel} locked - Users cannot vote` : `üîì ${itemLabel} unlocked - Users can now vote`, item.isLocked ? 'üö®' : '‚úÖ');
                render();
            } catch (error) {
                console.error('Full lock toggle error:', error);
                showAlert('Failed to update lock status: ' + error.message, '‚ùå');
            }
        }

        async function toggleResultsPublic(itemId) {
            try {
                // Find item across all types
                let item = state.contests.find(c => c.id === itemId);
                let tableName = 'contests';

                if (!item) {
                    item = state.mergers.find(m => m.id === itemId);
                    tableName = 'mergers';
                }
                if (!item) {
                    item = state.extracts.find(e => e.id === itemId);
                    tableName = 'extracts';
                }
                if (!item) {
                    item = state.shortcakes.find(s => s.id === itemId);
                    tableName = 'shortcakes';
                }

                if (!item) {
                    throw new Error('Item not found');
                }

                // Check if user is creator or admin
                const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                const isCreator = state.user && state.user.id === item.createdBy;

                if (!isAdmin && !isCreator) {
                    showAlert('Only the creator or admin can toggle results visibility', '‚ùå');
                    return;
                }

                const newPublicStatus = !item.resultsPublic;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/${tableName}?id=eq.${itemId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        results_public: newPublicStatus
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Results public update failed:', errorData);
                    throw new Error(errorData.message || 'Failed to update results visibility');
                }

                // Update local state only if database update succeeded
                item.resultsPublic = newPublicStatus;
                showAlert(item.resultsPublic ? 'üëÅÔ∏è Results public - Everyone can view' : 'üîí Results hidden - Only you can view', item.resultsPublic ? 'üëÅÔ∏è' : 'üîí');
                render();
            } catch (error) {
                console.error('Results public toggle error:', error);
                showAlert('Failed to update results visibility: ' + error.message, '‚ùå');
            }
        }

        // ==================== MERGER SYSTEM FUNCTIONS ====================

        function openCreateMergerModal() {
            state.showCreateMergerModal = true;
            state.selectedContestsForMerge = [];
            state.newMergerName = '';
            document.body.classList.add('modal-open');
            render();
        }

        function closeCreateMergerModal() {
            state.showCreateMergerModal = false;
            state.selectedContestsForMerge = [];
            state.newMergerName = '';
            document.body.classList.remove('modal-open');
            render();
        }

        function openUnifiedCreateModal() {
            state.showUnifiedCreateModal = true;
            document.body.classList.add('modal-open');
            render();
        }

        function closeUnifiedCreateModal() {
            state.showUnifiedCreateModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        function toggleContestForMerger(contestId) {
            if (!state.selectedContestsForMerge) {
                state.selectedContestsForMerge = [];
            }

            const index = state.selectedContestsForMerge.indexOf(contestId);
            if (index > -1) {
                state.selectedContestsForMerge.splice(index, 1);
            } else {
                state.selectedContestsForMerge.push(contestId);
            }

            // Preserve scroll position
            const modalContent = document.querySelector('.modal-content .overflow-y-auto');
            const scrollTop = modalContent ? modalContent.scrollTop : 0;

            render();

            // Restore scroll position after render
            setTimeout(() => {
                const newModalContent = document.querySelector('.modal-content .overflow-y-auto');
                if (newModalContent && scrollTop > 0) {
                    newModalContent.scrollTop = scrollTop;
                }
            }, 0);
        }

        function setMergerName(name) {
            state.newMergerName = name;
            // Don't render to avoid input blur - button state will be updated on blur
        }

        function updateMergerNameOnBlur() {
            const input = document.getElementById('merger-name-input');
            if (input) {
                state.newMergerName = input.value;
                render();
            }
        }

        async function saveMerger() {
            if (state.selectedContestsForMerge.length < 2) {
                showToast('Please select at least 2 contests', 'error');
                return;
            }

            if (!state.newMergerName || state.newMergerName.trim() === '') {
                showToast('Please enter a name for the merger', 'error');
                return;
            }

            setLoading('Creating merger...');

            try {
                // Save to mergers table
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify({
                        name: state.newMergerName.trim(),
                        created_by: state.user.id,
                        contest_ids: state.selectedContestsForMerge
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Merger creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create merger');
                }

                // Reload mergers
                await loadMergers();

                showToast('Merger created successfully!', 'success');
                closeCreateMergerModal();
            } catch (error) {
                console.error('Error creating merger:', error);
                showToast('Failed to create merger: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        function openEditMergerModal(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Store the merger being edited
            state.editingMergerId = mergerId;
            state.editMergerSelectedContests = [...merger.contestIds]; // Copy current contest IDs
            state.showEditMergerModal = true;
            document.body.classList.add('modal-open');
            render();
        }

        function closeEditMergerModal() {
            state.showEditMergerModal = false;
            state.editingMergerId = null;
            state.editMergerSelectedContests = [];
            document.body.classList.remove('modal-open');
            render();
        }

        function toggleContestForEditMerger(contestId) {
            if (!state.editMergerSelectedContests) {
                state.editMergerSelectedContests = [];
            }

            const index = state.editMergerSelectedContests.indexOf(contestId);
            if (index > -1) {
                // Remove contest
                state.editMergerSelectedContests.splice(index, 1);
            } else {
                // Add contest
                state.editMergerSelectedContests.push(contestId);
            }

            // Preserve scroll position
            const modalContent = document.querySelector('.modal-content .overflow-y-auto');
            const scrollTop = modalContent ? modalContent.scrollTop : 0;

            render();

            // Restore scroll position after render
            setTimeout(() => {
                const newModalContent = document.querySelector('.modal-content .overflow-y-auto');
                if (newModalContent && scrollTop > 0) {
                    newModalContent.scrollTop = scrollTop;
                }
            }, 0);
        }

        async function saveEditedMerger() {
            const mergerId = state.editingMergerId;
            const merger = state.mergers.find(m => m.id === mergerId);

            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            if (state.editMergerSelectedContests.length < 2) {
                showAlert('Please select at least 2 contests', '‚ùå');
                return;
            }

            try {
                setLoading('Saving merger...');

                // Validate that contest_ids is an array
                if (!Array.isArray(state.editMergerSelectedContests)) {
                    throw new Error('Invalid contest selection');
                }

                // Verify user is logged in
                if (!state.user || !state.user.id) {
                    throw new Error('You must be logged in to update mergers');
                }

                // Verify user owns this merger
                if (merger.createdBy !== state.user.id) {
                    throw new Error('You can only update mergers you created');
                }

                console.log('üîÑ Updating merger:', {
                    mergerId,
                    userId: state.user.id,
                    currentContestIds: merger.contestIds,
                    newContestIds: state.editMergerSelectedContests
                });

                // Update merger in database with user context
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?id=eq.${mergerId}&created_by=eq.${state.user.id}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation',
                        'Cache-Control': 'no-cache',
                        'X-Client-Info': JSON.stringify({ user_id: state.user.id })
                    },
                    body: JSON.stringify({
                        contest_ids: state.editMergerSelectedContests
                    })
                });

                console.log('üì° Response status:', response.status, response.statusText);

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('‚ùå Merger update failed:', {
                        status: response.status,
                        error: errorData,
                        mergerId,
                        userId: state.user.id
                    });

                    // Provide specific error messages
                    if (response.status === 403) {
                        throw new Error('Permission denied: RLS policy may be blocking this update. Check that you own this merger.');
                    } else if (response.status === 404) {
                        throw new Error('Merger not found or you do not have permission to update it.');
                    }

                    throw new Error(errorData.message || errorData.hint || `Failed to update merger (${response.status})`);
                }

                // Verify the update by checking the response
                const updatedData = await response.json();
                console.log('‚úÖ Merger updated successfully:', updatedData);

                if (Array.isArray(updatedData) && updatedData.length === 0) {
                    console.warn('‚ö†Ô∏è No rows updated - possible causes:');
                    console.warn('  1. Merger does not exist');
                    console.warn('  2. RLS policy is blocking the update');
                    console.warn('  3. User does not own this merger');
                    console.warn('  Current user ID:', state.user.id);
                    console.warn('  Merger created_by:', merger.createdBy);
                    throw new Error('Update failed: No rows were updated. You may not have permission to edit this merger.');
                }

                // Reload mergers to get updated data
                await loadMergers();

                // If currently viewing this merger's results, reload them
                if (state.view === 'mergedResults' && state.currentMergerId === mergerId) {
                    const updatedMerger = state.mergers.find(m => m.id === mergerId);
                    if (updatedMerger) {
                        await loadMergedResults(updatedMerger.contestIds);
                    }
                }

                closeEditMergerModal();
                showToast('Merger updated successfully', 'success');
            } catch (error) {
                console.error('Error updating merger:', error);
                showToast('Failed to update merger: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        function deleteMerger(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) return;

            // Store merger info for validation
            state.mergerToDelete = merger;

            showInputModal(
                `Type "${merger.name}" to confirm deletion`,
                'Enter merger name exactly...',
                'handleDeleteMergerConfirmation',
                false
            );
        }

        function handleDeleteMergerConfirmation() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const enteredName = input ? input.value.trim() : '';

            if (!state.mergerToDelete) {
                showAlert('Merger information not found.', '‚ùå');
                return;
            }

            if (enteredName !== state.mergerToDelete.name) {
                showAlert('Name does not match. Deletion cancelled.', '‚ùå');
                return;
            }

            // Name matches, proceed with deletion
            confirmDeleteMerger(state.mergerToDelete.id);
        }

        async function confirmDeleteMerger(mergerId) {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            setLoading('Deleting merger...');

            try {
                // Delete only the merger record, leave contests intact
                const response = await fetch(`${SUPABASE_URL}/rest/v1/mergers?id=eq.${mergerId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete merger');
                }

                await loadMergers();
                state.modalProcessing = false;
                showAlert('Merger deleted successfully!', '‚úÖ');
            } catch (error) {
                console.error('Error deleting merger:', error);
                showAlert('Failed to delete merger: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            } finally {
                clearLoading();
            }
        }

        async function viewMergerResults(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Check if user has voted on ALL contests (unless admin/creator)
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === merger.createdBy;

            if (!isAdmin && !isCreator) {
                // Check if user has voted on all contests
                const votedContests = mergedContests.filter(c => state.userVotedContests[c.id]);
                const unvotedContests = mergedContests.filter(c => !state.userVotedContests[c.id]);

                if (unvotedContests.length > 0) {
                    const contestTitles = unvotedContests.map(c => `‚Ä¢ ${c.title}`).join('\n');
                    showAlert(
                        `You must vote on all ${mergedContests.length} contests before viewing merge results.\n\nRemaining contests:\n${contestTitles}`,
                        'üó≥Ô∏è'
                    );
                    return;
                }

                // Check if all source contests have public results
                const hasPrivateContest = mergedContests.some(c => c.resultsPublic === false && c.createdBy !== state.user.id);
                if (hasPrivateContest) {
                    showAlert('Some contests in this merger have private results. Only the creator or admin can view them.', 'üîí');
                    return;
                }
            }

            // Store current merger for revote functionality
            state.currentMergerId = mergerId;

            // Load merged results and display
            await loadMergedResults(merger.contestIds);
            state.view = 'mergedResults';
            state.resultsView = 'average';
            state.showMyVotes = false;
            render();
        }

        async function startMergerVoting(mergerId, revoteAll = false) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Filter out locked contests (unless revoting all)
            const unlockedContests = mergedContests.filter(c => !c.isLocked);

            if (unlockedContests.length === 0) {
                showToast('All contests in this merger are locked', 'error');
                return;
            }

            // Determine which images to vote on based on user's vote status
            let allImages = [];

            if (revoteAll) {
                // Revote all images in all unlocked contests
                allImages = unlockedContests.flatMap(c => c.images);
                state.mergerContestIds = unlockedContests.map(c => c.id);
            } else {
                // Collect only unvoted images from each contest
                const contestsWithMissingVotes = [];

                unlockedContests.forEach(c => {
                    const userVotes = state.userVotedContests[c.id] || {};
                    const votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
                    const unvotedImages = c.images.filter(img => !votedImageIds.includes(img.id));

                    if (unvotedImages.length > 0) {
                        allImages.push(...unvotedImages);
                        contestsWithMissingVotes.push(c.id);
                    }
                });

                state.mergerContestIds = contestsWithMissingVotes;

                // If no missing votes, include all images (fallback)
                if (allImages.length === 0) {
                    allImages = unlockedContests.flatMap(c => c.images);
                    state.mergerContestIds = unlockedContests.map(c => c.id);
                }
            }

            if (allImages.length === 0) {
                showToast('No images available to vote on', 'error');
                return;
            }

            // Store merger context
            state.currentMergerId = mergerId;
            // mergerContestIds is already set in the if/else block above

            // Shuffle all images together
            state.shuffledImages = shuffleArray(allImages);
            state.votes = {};
            state.currentImageIndex = 0;
            state.hasSubmitted = false;
            state.results = null;
            state.view = 'vote';

            // Load voting mode preference from localStorage, default to 'multi'
            const savedVotingMode = localStorage.getItem('peony_voting_mode');
            state.votingMode = savedVotingMode || 'multi';

            // Set currentContest to null to indicate merger voting mode
            state.currentContest = null;

            // Update URL hash for shareable link
            window.location.hash = `merger=${mergerId}`;

            // Show loading modal if starting in multi mode
            if (state.votingMode === 'multi') {
                state.isLoadingMultiModeImages = true;
                state.multiModeLoadedImages = 0;
                state.multiModeTotalImages = state.shuffledImages.length;
                render();

                // Load images with tracking, hide modal when done or after 10s timeout
                loadImagesWithTracking(state.shuffledImages);
            } else {
                render();
            }
        }

        function revoteMerge() {
            if (!state.currentMergerId) {
                showToast('No merger context found', 'error');
                return;
            }

            // Restart merger voting with revote all flag
            startMergerVoting(state.currentMergerId, true);
        }

        function showMergerVoteModal(mergerId) {
            const merger = state.mergers.find(m => m.id === mergerId);
            if (!merger) {
                showToast('Merger not found', 'error');
                return;
            }

            // Get all contests in the merger
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));

            // Find which contests user hasn't voted in (excluding locked ones)
            const unlockedContests = mergedContests.filter(c => !c.isLocked);

            // Check for contests with incomplete voting
            const contestsWithStatus = unlockedContests.map(c => {
                const userVotes = state.userVotedContests[c.id] || {};
                const votedImageCount = Object.keys(userVotes).length;
                const totalImageCount = c.images.length;
                const hasVotedAll = votedImageCount === totalImageCount && totalImageCount > 0;
                const hasVotedSome = votedImageCount > 0 && votedImageCount < totalImageCount;
                const missingVotes = totalImageCount - votedImageCount;

                return {
                    contest: c,
                    hasVotedAll,
                    hasVotedSome,
                    hasVotedNone: votedImageCount === 0,
                    votedImageCount,
                    totalImageCount,
                    missingVotes
                };
            });

            const fullyVoted = contestsWithStatus.filter(cs => cs.hasVotedAll);
            const partiallyVoted = contestsWithStatus.filter(cs => cs.hasVotedSome);
            const unvoted = contestsWithStatus.filter(cs => cs.hasVotedNone);

            // Build detailed message
            let messageLines = [];
            messageLines.push(`You've fully voted in ${fullyVoted.length} out of ${unlockedContests.length} unlocked contests.`);

            if (partiallyVoted.length > 0) {
                messageLines.push(`\nContests with incomplete voting (${partiallyVoted.length}):`);
                partiallyVoted.forEach(cs => {
                    messageLines.push(`‚Ä¢ ${cs.contest.title}: ${cs.missingVotes} new image(s) added`);
                });
            }

            if (unvoted.length > 0) {
                messageLines.push(`\nUnvoted contests (${unvoted.length}):`);
                unvoted.forEach(cs => {
                    messageLines.push(`‚Ä¢ ${cs.contest.title}`);
                });
            }

            messageLines.push('\nWhat would you like to do?');
            const message = messageLines.join('\n');

            // Store the mergerId for the action functions
            state.pendingMergerId = mergerId;

            state.modal = {
                icon: 'üîÑ',
                title: 'Complete Voting - ' + merger.name,
                message: message,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Vote Missing Only', action: 'confirmVoteMissingOnly', primary: true },
                    { text: 'Revote All', action: 'confirmRevoteAll', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function confirmVoteMissingOnly() {
            const mergerId = state.pendingMergerId;
            state.modal = null;
            state.pendingMergerId = null;
            document.body.classList.remove('modal-open');
            startMergerVoting(mergerId, false);
        }

        function confirmRevoteAll() {
            const mergerId = state.pendingMergerId;
            state.modal = null;
            state.pendingMergerId = null;
            document.body.classList.remove('modal-open');
            startMergerVoting(mergerId, true);
        }

        async function shareMerger(mergerId) {
            try {
                const shareUrl = `${window.location.origin}${window.location.pathname}#merger=${mergerId}`;

                if (navigator.share) {
                    await navigator.share({
                        title: 'Peony - Merger',
                        text: 'Check out this merged contest!',
                        url: shareUrl
                    });
                    showToast('Share successful!', 'success');
                } else {
                    await navigator.clipboard.writeText(shareUrl);
                    showToast('Link copied to clipboard!', 'success');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Share error:', error);
                    showToast('Failed to share', 'error');
                }
            }
        }

        // Contest "Complete Voting" modal (similar to merger)
        function showContestVoteModal(contestId) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) {
                showToast('Contest not found', 'error');
                return;
            }

            // Get user's voted images for this contest
            const userVotes = state.userVotedContests[contest.id] || {};
            const votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
            const unvotedImages = contest.images.filter(img => !votedImageIds.includes(img.id));

            // Show modal with options
            const message = `You've voted on ${votedImageIds.length} out of ${contest.images.length} images.\n\nUnvoted images: ${unvotedImages.length}\n\nWhat would you like to do?`;

            // Store the contestId for the action functions
            state.pendingContestId = contestId;

            state.modal = {
                icon: 'üîÑ',
                title: 'Complete Voting - ' + contest.title,
                message: message,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Vote Missing Only', action: 'confirmContestVoteMissingOnly', primary: true },
                    { text: 'Revote All', action: 'confirmContestRevoteAll', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function confirmContestVoteMissingOnly() {
            const contestId = state.pendingContestId;
            state.modal = null;
            state.pendingContestId = null;
            document.body.classList.remove('modal-open');
            startContestVoting(contestId, false);
        }

        function confirmContestRevoteAll() {
            const contestId = state.pendingContestId;
            state.modal = null;
            state.pendingContestId = null;
            document.body.classList.remove('modal-open');
            startContestVoting(contestId, true);
        }

        function startContestVoting(contestId, revoteAll = false) {
            const contest = state.contests.find(c => c.id === contestId);
            if (!contest) {
                showToast('Contest not found', 'error');
                return;
            }

            // If revoteAll is false, only include unvoted images
            let imagesToVote;
            if (revoteAll) {
                imagesToVote = contest.images;
            } else {
                const userVotes = state.userVotedContests[contest.id] || {};
                const votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
                imagesToVote = contest.images.filter(img => !votedImageIds.includes(img.id));
            }

            if (imagesToVote.length === 0) {
                showToast('No images to vote on', 'info');
                return;
            }

            // Create a temporary contest object with only the images to vote on
            // But keep reference to original contest for results display
            const votingContest = {
                ...contest,
                images: imagesToVote,
                isPartialVoting: !revoteAll,
                originalContestId: contest.id
            };

            startVoting(votingContest);
        }

        // Extract voting redirect modal
        function showExtractVotingRedirectModal(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Determine the source
            let sourceName = '';
            let sourceType = '';
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                sourceName = sourceContest ? sourceContest.title : 'Unknown Contest';
                sourceType = 'contest';
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                sourceName = sourceMerger ? sourceMerger.name : 'Unknown Merger';
                sourceType = 'merger';
            }

            const message = `In order to be able to see this extract's results, you will be prompted to vote in the original ${sourceType}: ${sourceName}`;

            // Store the extractId for the action function
            state.pendingExtractId = extractId;

            state.modal = {
                icon: 'üìã',
                title: 'Vote on Extract',
                message: message,
                buttons: [
                    { text: 'OK', action: 'redirectToExtractSource', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function redirectToExtractSource() {
            const extractId = state.pendingExtractId;
            const extract = state.extracts.find(e => e.id === extractId);

            state.modal = null;
            state.pendingExtractId = null;
            document.body.classList.remove('modal-open');

            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Redirect to source contest or merger voting
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                if (sourceContest) {
                    // Check if user has partially voted
                    const userVotes = state.userVotedContests[sourceContest.id] || {};
                    const votedImageCount = Object.keys(userVotes).length;
                    const hasVotedSome = votedImageCount > 0 && votedImageCount < sourceContest.images.length;

                    // Start voting on the contest
                    startVoting(sourceContest);
                }
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (sourceMerger) {
                    // Check if user has partially voted on the merger
                    const mergedContests = state.contests.filter(c => sourceMerger.contestIds.includes(c.id));
                    const votedContests = mergedContests.filter(c => state.userVotedContests[c.id]);
                    const hasVotedSome = votedContests.length > 0 && votedContests.length < mergedContests.length;

                    if (hasVotedSome) {
                        // Show merger "Complete Voting" modal
                        showMergerVoteModal(sourceMerger.id);
                    } else {
                        // Start voting on the merger
                        startMergerVoting(sourceMerger.id, false);
                    }
                }
            }
        }

        // ==================== END MERGER SYSTEM FUNCTIONS ====================

        // ==================== EXTRACT SYSTEM FUNCTIONS ====================

        function openCreateExtractModal() {
            state.view = 'createExtract';
            state.extractSourceType = null;
            state.extractSourceId = null;
            state.extractSelectedImages = [];
            state.newExtractName = '';
            state.extractContestFilter = 'all'; // For filtering merger contests
            state.extractImageScale = 100;
            render();
        }

        function closeCreateExtractModal() {
            state.view = 'home';
            state.extractSourceType = null;
            state.extractSourceId = null;
            state.extractSelectedImages = [];
            state.newExtractName = '';
            state.extractContestFilter = 'all';
            render();
        }

        function selectExtractSource(sourceType, sourceId) {
            state.extractSourceType = sourceType;
            state.extractSourceId = sourceId;
            state.extractSelectedImages = [];
            state.extractContestFilter = 'all';
            render();
        }

        function setExtractContestFilter(contestId) {
            state.extractContestFilter = contestId;
            render();
        }

        function toggleExtractImage(imageId) {
            if (!state.extractSelectedImages) {
                state.extractSelectedImages = [];
            }

            const index = state.extractSelectedImages.indexOf(imageId);
            if (index > -1) {
                state.extractSelectedImages.splice(index, 1);
            } else {
                state.extractSelectedImages.push(imageId);
            }

            // Update the count display and button state without full re-render to prevent blink
            const countDisplay = document.querySelector('[data-extract-count]');
            if (countDisplay) {
                let sourceName = '';
                if (state.extractSourceType === 'shortcake') {
                    sourceName = state.shortcakes.find(s => s.id === state.extractSourceId)?.title;
                } else if (state.extractSourceType === 'contest') {
                    sourceName = state.contests.find(c => c.id === state.extractSourceId)?.title;
                } else if (state.extractSourceType === 'merger') {
                    sourceName = state.mergers.find(m => m.id === state.extractSourceId)?.name;
                }
                countDisplay.textContent = `From: ${sourceName} (${state.extractSelectedImages.length} selected)`;
            }

            // Update save button state
            const saveButton = document.querySelector('[data-extract-save]');
            if (saveButton) {
                const canSave = state.extractSelectedImages.length > 0 && state.newExtractName;
                saveButton.disabled = !canSave;
                if (canSave) {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700';
                } else {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-300 text-gray-500 cursor-not-allowed';
                }
            }

            // Update the specific checkbox visual
            const imageElement = event?.target?.closest('[data-image-id]');
            if (imageElement) {
                const isSelected = state.extractSelectedImages.includes(imageId);
                const borderDiv = imageElement.querySelector('.relative.cursor-pointer');
                const checkboxDiv = imageElement.querySelector('.absolute.top-2');

                if (borderDiv) {
                    if (isSelected) {
                        borderDiv.className = 'relative cursor-pointer rounded-lg overflow-hidden border-4 border-blue-500 bg-blue-50';
                    } else {
                        borderDiv.className = 'relative cursor-pointer rounded-lg overflow-hidden border-4 border-transparent hover:border-blue-300';
                    }
                }

                if (checkboxDiv) {
                    if (isSelected) {
                        checkboxDiv.innerHTML = `
                            <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                            </svg>
                        `;
                        checkboxDiv.className = 'absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 border-blue-500';
                    } else {
                        checkboxDiv.innerHTML = '<div class="w-4 h-4 border-2 border-gray-400 rounded"></div>';
                        checkboxDiv.className = 'absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 border-gray-300';
                    }
                }
            }
        }

        function setExtractName(name) {
            state.newExtractName = name;
            // Update button state without full render
            updateExtractSaveButtonState();
        }

        function updateExtractImageScale(value) {
            state.extractImageScale = parseInt(value);
            render();
        }

        function updateExtractNameOnBlur() {
            const input = document.getElementById('extract-name-input');
            if (input) {
                state.newExtractName = input.value;
                // Update save button state without full re-render to preserve selection visual state
                updateExtractSaveButtonState();
            }
        }

        function updateExtractSaveButtonState() {
            // Update save button state without full re-render
            const saveButton = document.querySelector('[data-extract-save]');
            if (saveButton) {
                const canSave = state.extractSelectedImages.length > 0 && state.newExtractName && state.newExtractName.trim() !== '';
                saveButton.disabled = !canSave;
                if (canSave) {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700';
                } else {
                    saveButton.className = 'flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-300 text-gray-500 cursor-not-allowed';
                }
            }
        }

        async function saveExtract() {
            if (!state.extractSelectedImages || state.extractSelectedImages.length === 0) {
                showToast('Please select at least one image', 'error');
                return;
            }

            if (!state.newExtractName || state.newExtractName.trim() === '') {
                showToast('Please enter a name for the extract', 'error');
                return;
            }

            setLoading('Creating extract...');

            try {
                // Ensure image IDs are integers (convert from any type)
                const imageIds = state.extractSelectedImages.map(id => parseInt(id));

                setLoading('Creating extract...');

                // Get source contest ID
                let sourceContestId = null;
                if (state.extractSourceType === 'shortcake') {
                    const shortcake = state.shortcakes.find(s => s.id === state.extractSourceId);
                    if (shortcake) {
                        sourceContestId = shortcake.imageIds;
                    }
                } else if (state.extractSourceType === 'contest') {
                    let contest = state.contests.find(c => c.id === state.extractSourceId);
                    if (!contest) {
                        const sourceIdAsNumber = parseInt(state.extractSourceId);
                        if (!isNaN(sourceIdAsNumber)) {
                            contest = state.contests.find(c => c.contestNumber === sourceIdAsNumber);
                        }
                    }
                    if (contest) {
                        sourceContestId = contest.id;
                    }
                } else if (state.extractSourceType === 'merger') {
                    const merger = state.mergers.find(m => m.id === state.extractSourceId);
                    if (merger) {
                        sourceContestId = merger.contestIds;
                    }
                }

                // Image IDs are integers in the database
                const extractData = {
                    name: state.newExtractName.trim(),
                    created_by: state.user.id,
                    source_type: state.extractSourceType,
                    image_ids: imageIds
                };

                // Set source_contest_id based on source type
                // For contests, mergers, and shortcakes, store their IDs in source_contest_id
                // The column name says "contest" but it's used for all based on source_type
                if (state.extractSourceType === 'shortcake') {
                    // For shortcakes, store the shortcake's id in source_contest_id
                    const shortcake = state.shortcakes.find(s => s.id === state.extractSourceId);
                    if (shortcake) {
                        extractData.source_contest_id = shortcake.id;
                    } else {
                        throw new Error('Shortcake not found');
                    }
                } else if (state.extractSourceType === 'contest') {
                    if (sourceContestId) {
                        extractData.source_contest_id = sourceContestId;
                    } else {
                        throw new Error('Contest not found');
                    }
                } else if (state.extractSourceType === 'merger') {
                    // For mergers, store the merger's id in source_contest_id
                    const merger = state.mergers.find(m => m.id === state.extractSourceId);
                    if (merger) {
                        extractData.source_contest_id = merger.id;
                    } else {
                        throw new Error('Merger not found');
                    }
                } else {
                    throw new Error('Invalid extract source type. Must be contest, merger, or shortcake.');
                }

                // Save to extracts table
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify(extractData)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract creation failed:', errorData);
                    throw new Error(errorData.message || 'Failed to create extract');
                }

                // Reload extracts
                await loadExtracts();

                showToast('Extract created successfully!', 'success');
                closeCreateExtractModal();
            } catch (error) {
                console.error('Error creating extract:', error);
                showToast('Failed to create extract: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        function confirmDeleteExtract(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) return;

            // Store extract info for validation
            state.extractToDelete = extract;

            showInputModal(
                `Type "${extract.name}" to confirm deletion`,
                'Enter extract name exactly...',
                'handleDeleteExtractConfirmation',
                false
            );
        }

        function handleDeleteExtractConfirmation() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const enteredName = input ? input.value.trim() : '';

            if (!state.extractToDelete) {
                showAlert('Extract information not found.', '‚ùå');
                return;
            }

            if (enteredName !== state.extractToDelete.name) {
                showAlert('Name does not match. Deletion cancelled.', '‚ùå');
                return;
            }

            // Name matches, proceed with deletion
            executeDeleteExtract(state.extractToDelete.id);
        }

        async function executeDeleteExtract(extractId) {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            state.extractToDelete = null;

            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?id=eq.${extractId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract deletion failed:', errorData);
                    throw new Error(errorData.message || 'Failed to delete extract');
                }

                // Reload extracts
                await loadExtracts();

                showToast('Extract deleted successfully', 'success');
            } catch (error) {
                console.error('Error deleting extract:', error);
                showToast('Failed to delete extract: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                render();
            }
        }

        // Legacy function name for backwards compatibility
        async function deleteExtract(extractId) {
            confirmDeleteExtract(extractId);
        }

        function openEditExtractModal(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Store the extract being edited
            state.editingExtractId = extractId;
            state.editExtractSelectedImages = [...extract.imageIds]; // Copy current image IDs
            state.view = 'editExtract';
            state.extractImageScale = 100;
            render();
        }

        function closeEditExtractModal() {
            state.view = 'home';
            state.editingExtractId = null;
            state.editExtractSelectedImages = [];
            render();
        }

        function toggleEditExtractImage(imageId) {
            if (!state.editExtractSelectedImages) {
                state.editExtractSelectedImages = [];
            }

            const index = state.editExtractSelectedImages.indexOf(imageId);
            if (index > -1) {
                // Remove image
                state.editExtractSelectedImages.splice(index, 1);
            } else {
                // Add image
                state.editExtractSelectedImages.push(imageId);
            }

            // Preserve scroll position of the modal
            const modalContent = document.querySelector('.fixed.inset-0.modal-overlay[style*="z-index: 60"], .fixed.inset-0.modal-overlay.z-\\[60\\]');
            let scrollContainer = null;
            let scrollTop = 0;

            if (modalContent) {
                scrollContainer = modalContent.querySelector('.overflow-y-auto');
                if (scrollContainer) {
                    scrollTop = scrollContainer.scrollTop;
                }
            }

            render();

            // Restore scroll position after render
            requestAnimationFrame(() => {
                const newModalContent = document.querySelector('.fixed.inset-0.modal-overlay[style*="z-index: 60"], .fixed.inset-0.modal-overlay.z-\\[60\\]');
                if (newModalContent) {
                    const newScrollContainer = newModalContent.querySelector('.overflow-y-auto');
                    if (newScrollContainer && scrollTop > 0) {
                        newScrollContainer.scrollTop = scrollTop;
                    }
                }
            });
        }

        async function saveEditedExtract() {
            const extractId = state.editingExtractId;
            const extract = state.extracts.find(e => e.id === extractId);

            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            if (state.editExtractSelectedImages.length === 0) {
                showAlert('Please select at least one image', '‚ùå');
                return;
            }

            try {
                setLoading('Saving extract...');

                // Update extract in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/extracts?id=eq.${extractId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        image_ids: state.editExtractSelectedImages
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Extract update failed:', errorData);
                    throw new Error(errorData.message || 'Failed to update extract');
                }

                // Reload extracts to get updated data
                await loadExtracts();

                closeEditExtractModal();
                showToast('Extract updated successfully', 'success');
            } catch (error) {
                console.error('Error updating extract:', error);
                showToast('Failed to update extract: ' + error.message, 'error');
            } finally {
                clearLoading();
            }
        }

        async function startExtractVoting(extractId, revoteAll = true) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Get source contest to find the images
            let sourceContest = null;
            let sourceImages = [];

            if (extract.sourceType === 'contest') {
                sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                if (sourceContest) {
                    sourceImages = sourceContest.images;
                }
            } else if (extract.sourceType === 'merger') {
                // For mergers, we need to get all images from all merged contests
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceImages = mergedContests.flatMap(c => c.images);
                    // Create a pseudo source contest for ID purposes
                    sourceContest = {
                        id: merger.contestIds[0], // Use first contest ID for vote storage
                        title: extract.name,
                        createdBy: extract.createdBy,
                        creatorName: extract.creatorName,
                        creatorAvatar: extract.creatorAvatar
                    };
                }
            } else if (extract.sourceType === 'extract') {
                // Get images from source extract
                const sourceExtract = state.extracts.find(e => e.id === extract.sourceContestId);
                if (sourceExtract && sourceExtract.sourceType === 'contest') {
                    const originalContest = state.contests.find(c => c.id === sourceExtract.sourceContestId);
                    if (originalContest) {
                        sourceImages = originalContest.images;
                        sourceContest = originalContest;
                    }
                }
            }

            if (!sourceContest || sourceImages.length === 0) {
                showToast('Source not found', 'error');
                return;
            }

            // Filter images to only those in the extract
            const extractImages = sourceImages.filter(img => extract.imageIds.includes(img.id));

            // If revoteAll is false, filter to only unvoted images
            let imagesToVote = extractImages;
            if (!revoteAll) {
                // Get user's voted images from source contest(s)
                let votedImageIds = [];
                if (extract.sourceType === 'contest' && extract.sourceContestId) {
                    const userVotes = state.userVotedContests[extract.sourceContestId] || {};
                    votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
                } else if (extract.sourceType === 'merger' && extract.sourceMergerId) {
                    const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (merger) {
                        let allVotedImageIds = [];
                        merger.contestIds.forEach(contestId => {
                            const userVotes = state.userVotedContests[contestId] || {};
                            allVotedImageIds.push(...Object.keys(userVotes).map(id => parseInt(id)));
                        });
                        votedImageIds = allVotedImageIds;
                    }
                }
                imagesToVote = extractImages.filter(img => !votedImageIds.includes(img.id));
            }

            if (imagesToVote.length === 0) {
                showToast('No images to vote on', 'info');
                return;
            }

            // Create a temporary contest object for voting
            const extractContest = {
                id: extractId,
                title: extract.name,
                images: imagesToVote,
                createdBy: extract.createdBy,
                creatorName: extract.creatorName,
                creatorAvatar: extract.creatorAvatar,
                isExtract: true,
                extractSourceType: extract.sourceType,
                extractSourceContestId: extract.sourceContestId,
                extractSourceMergerId: extract.sourceMergerId,
                extractImageIds: extract.imageIds,
                isPartialVoting: !revoteAll,
                originalContestId: extractId
            };

            startVoting(extractContest);
        }

        async function viewExtractResults(extractId) {
            const extract = state.extracts.find(e => e.id === extractId);
            if (!extract) {
                showToast('Extract not found', 'error');
                return;
            }

            // Check if user can view results (admin, creator, or source has public results)
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === extract.createdBy;

            if (!isAdmin && !isCreator) {
                // Check source contest/merger results_public
                if (extract.sourceType === 'contest') {
                    const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                    if (sourceContest && sourceContest.resultsPublic === false && sourceContest.createdBy !== state.user.id) {
                        showAlert('The source contest has private results. Only the creator or admin can view them.', 'üîí');
                        return;
                    }
                } else if (extract.sourceType === 'merger') {
                    const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (merger) {
                        const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                        const hasPrivateContest = mergedContests.some(c => c.resultsPublic === false && c.createdBy !== state.user.id);
                        if (hasPrivateContest) {
                            showAlert('Some contests in the source merger have private results. Only the creator or admin can view them.', 'üîí');
                            return;
                        }
                    }
                }
            }

            // Get source contest or merger
            let sourceImages = [];
            let resultsPublic = true; // Default to public
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                if (sourceContest) {
                    sourceImages = sourceContest.images;
                    resultsPublic = sourceContest.resultsPublic !== false;
                }
            } else if (extract.sourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceImages = mergedContests.flatMap(c => c.images);
                    // If any merged contest has private results, the extract is also private
                    resultsPublic = !mergedContests.some(c => c.resultsPublic === false);
                }
            }

            if (sourceImages.length === 0) {
                showToast('Source not found', 'error');
                return;
            }

            // Filter images to only those in the extract
            const extractImages = sourceImages.filter(img => extract.imageIds.includes(img.id));

            // Create a temporary contest object for results with extract information
            const extractContest = {
                id: extractId,
                title: extract.name,
                images: extractImages,
                createdBy: extract.createdBy,
                creatorName: extract.creatorName,
                creatorAvatar: extract.creatorAvatar,
                resultsPublic: resultsPublic,
                isExtract: true,
                extractSourceType: extract.sourceType,
                extractSourceContestId: extract.sourceContestId,
                extractSourceMergerId: extract.sourceMergerId,
                extractImageIds: extract.imageIds
            };

            viewResults(extractContest);
        }

        // ==================== END EXTRACT SYSTEM FUNCTIONS ====================

        function handleVote(score) {
            if (state.isAnimating) return;

            state.isAnimating = true;
            const currentImage = state.shuffledImages[state.currentImageIndex];
            state.votes[currentImage.id] = score;
            state.lastClickedImageId = currentImage.id;
            state.showTickAnimation = true;

            render();

            setTimeout(() => {
                state.showTickAnimation = false;
                state.isAnimating = false;
                if (state.currentImageIndex < state.shuffledImages.length - 1) {
                    state.currentImageIndex++;
                }
                render();
            }, 500);
        }

        function navigateImage(direction) {
            if (direction === 'next') {
                if (state.currentImageIndex < state.shuffledImages.length - 1) {
                    state.currentImageIndex++;
                }
            } else if (direction === 'prev' && state.currentImageIndex > 0) {
                state.currentImageIndex--;
            }
            render();
        }

        function jumpToImage(index) {
            if (state.isAnimating) return;
            state.currentImageIndex = index;
            render();
        }

        function toggleScoreSelection(score) {
            // Toggle score selection: if already selected, unselect it
            if (state.selectedScore === score) {
                state.selectedScore = null;
            } else {
                state.selectedScore = score;
            }
            render();
        }

        function voteImageMulti(imageId) {
            // If no score is selected, do nothing
            if (state.selectedScore === null) {
                return;
            }

            // Track the last clicked image
            state.lastClickedImageId = imageId;

            // Assign the selected score to this image
            state.votes[imageId] = state.selectedScore;
            render();
        }

        function updateMultiVotingImageScale(value) {
            state.multiVotingImageScale = parseInt(value, 10);
            render();
        }

        function adjustMultiVotingImageScale(delta) {
            const newScale = Math.max(20, Math.min(200, state.multiVotingImageScale + delta));
            state.multiVotingImageScale = newScale;
            render();
        }

        function setMultiModeFilter(filter) {
            // Toggle filter: if same filter is selected, clear it
            if (state.multiModeFilter === filter) {
                state.multiModeFilter = null;
            } else {
                state.multiModeFilter = filter;
            }
            render();
        }

        function setMultiModeSort(sort) {
            state.multiModeSort = sort;
            render();
        }

        function cancelVoting() {
            showConfirm(
                'Your progress will be lost if you proceed. Are you sure?',
                'confirmCancelVoting',
                'üö®'
            );
        }

        function submitVotes() {
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);
            if (!allVoted) {
                showAlert('Please vote on all images before submitting!', '‚ùå');
                return;
            }
            showConfirm(
                'Confirm to submit your votes. After submission, you can only revote completely.',
                'confirmSubmitVotes',
                'üó≥Ô∏è'
            );
        }

        function showBreakdown(imageId) {
            state.showBreakdownModal = imageId;
            document.body.classList.add('modal-open');
            render();
        }

        function showVoterVotes(username) {
            // Set viewing specific user
            state.viewingSpecificUser = username;
            state.showMyVotes = false;
            state.showVoterBreakdown = false;

            // Filter mockResults to show only images with this user's votes
            // and update the results to show this user's score as the primary score
            state.results = state.results.map(img => {
                const vote = img.breakdown.find(v => v.username === username);
                if (vote) {
                    return {
                        ...img,
                        averageScore: vote.score,
                        userSpecificScore: vote.score
                    };
                }
                return null;
            }).filter(img => img !== null)
            .sort(compareWithTieBreaking);

            render();
        }

        function viewUserVotes(username) {
            // Alias for showVoterVotes for clarity
            showVoterVotes(username);
        }

        async function clearUserVotesView() {
            state.viewingSpecificUser = null;
            state.showVoterBreakdown = true;
            // Regenerate full results
            if (state.currentContest) {
                await loadResults();
            }
            render();
        }

        function closeBreakdown() {
            state.showBreakdownModal = null;
            document.body.classList.remove('modal-open');
            render();
        }

        // Admin vote editing
        async function adminEditVote(userId, imageId, currentScore) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Admin access required', 'üîí');
                return;
            }

            // Show modal with score buttons
            const voteData = state.results.find(r => r.id === imageId)?.breakdown.find(v => v.userId === userId);
            if (!voteData) return;

            showModal({
                type: 'custom',
                title: `Edit ${voteData.username}'s Vote`,
                icon: '‚úèÔ∏è',
                message: `Current score: ${currentScore}\nSelect new score:`,
                buttons: [1, 2, 3, 4, 5].map(score => ({
                    text: score.toString(),
                    primary: false,
                    action: `confirmEditVote_${userId}_${imageId}_${currentScore}_${score}`
                })).concat([{
                    text: 'Cancel',
                    primary: false,
                    action: 'closeModal'
                }])
            });
        }

        async function confirmEditVote(userId, imageId, oldScore, newScore) {
            try {
                // Close modal FIRST before setting modalProcessing
                state.modal = null;
                document.body.classList.remove('modal-open');
                render();

                state.modalProcessing = true;
                setLoading('Updating vote...');

                // Find the contest ID for this image
                // For extracts, need to find the actual source contest ID where the vote is stored
                let contestId = state.currentContest.id;
                if (state.currentContest.isExtract) {
                    // Find which source contest this image belongs to
                    const image = state.currentContest.images.find(img => img.id === imageId);
                    if (image && image.contestId) {
                        contestId = image.contestId;
                    } else if (state.currentContest.extractSourceType === 'contest') {
                        contestId = state.currentContest.extractSourceContestId;
                    }
                }

                // Update vote in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&image_id=eq.${imageId}&contest_id=eq.${contestId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({ score: parseInt(newScore) })
                });

                if (!response.ok) {
                    throw new Error('Failed to update vote');
                }

                showToast(`Vote updated from ${oldScore} to ${newScore}`, 'success');

                // Reload results to get fresh data
                await loadResults();
                clearLoading();

            } catch (error) {
                console.error('Error updating vote:', error);
                clearLoading();
                showAlert('Failed to update vote: ' + error.message, '‚ùå');
                state.modalProcessing = false;
            }
        }

        // Admin vote blocking
        async function adminToggleBlockVote(userId, imageId, currentlyBlocked) {
            if (!state.user || state.user.id !== ADMIN_DISCORD_ID) {
                showAlert('Admin access required', 'üîí');
                return;
            }

            const voteData = state.results.find(r => r.id === imageId)?.breakdown.find(v => v.userId === userId);
            if (!voteData) return;

            const action = currentlyBlocked ? 'unblock' : 'block';
            showConfirm(
                `Are you sure you want to ${action} ${voteData.username}'s vote?`,
                `executeToggleBlockVote_${userId}_${imageId}_${!currentlyBlocked}`,
                'üö´'
            );
        }

        async function executeToggleBlockVote(userId, imageId, shouldBlock) {
            try {
                // Close modal FIRST before setting modalProcessing
                state.modal = null;
                document.body.classList.remove('modal-open');
                render();

                state.modalProcessing = true;
                setLoading(shouldBlock ? 'Blocking vote...' : 'Unblocking vote...');

                // Find the contest ID for this image
                // For extracts, need to find the actual source contest ID where the vote is stored
                let contestId = state.currentContest.id;
                if (state.currentContest.isExtract) {
                    // Find which source contest this image belongs to
                    const image = state.currentContest.images.find(img => img.id === imageId);
                    if (image && image.contestId) {
                        contestId = image.contestId;
                    } else if (state.currentContest.extractSourceType === 'contest') {
                        contestId = state.currentContest.extractSourceContestId;
                    }
                }

                // Update vote in database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&image_id=eq.${imageId}&contest_id=eq.${contestId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({ is_blocked: shouldBlock })
                });

                if (!response.ok) {
                    throw new Error('Failed to update vote block status');
                }

                showToast(`Vote ${shouldBlock ? 'blocked' : 'unblocked'}`, 'success');

                // Reload results to get fresh data with updated ban status
                await loadResults();

                // Re-render to refresh the breakdown modal
                render();

            } catch (error) {
                console.error('Error toggling vote block:', error);
                showAlert('Failed to toggle vote block: ' + error.message, '‚ùå');
            } finally {
                clearLoading();
                state.modalProcessing = false;
            }
        }


        async function backToHome() {
            console.log('üè† [NAVIGATION] Returning to home from view:', state.view);

            // Check for both contest and merge voting in progress
            const isContestVoting = state.view === 'vote' && !state.hasSubmitted && state.currentContest && state.currentContest.images;
            const isMergeVoting = state.view === 'vote' && !state.hasSubmitted && state.currentMergerId && state.mergerContestIds && state.mergerContestIds.length > 0;

            if (isContestVoting || isMergeVoting) {
                showConfirm(
                    'Your progress will be lost if you proceed. Are you sure?',
                    'confirmBackToHome',
                    'üö®'
                );
                return;
            }

            // Refresh contest list (this now includes fresh voter counts)
            console.log('üîÑ [CLEANUP] Refreshing contest list');
            await loadContests();

            // Reset all contest-related state
            state.view = 'home';
            window.location.hash = ''; // Clear hash to avoid confusion on reload
            state.currentContest = null;
            state.showBreakdownModal = null;
            state.results = null;
            state.mergedResults = null;
            state.showMyVotes = false;
            state.resultsView = 'average';
            state.selectedVoterUserId = null;
            state.contestVoters = [];

            // Clear URL hash
            window.location.hash = '';

            console.log('‚úÖ [NAVIGATION] Successfully returned to home');

            render();
        }

        function confirmBackToHome() {
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            // Reset all contest-related state with null checks
            state.view = 'home';
            state.currentContest = null;
            state.showBreakdownModal = null;
            state.results = null;
            state.showMyVotes = false;
            state.resultsView = 'average';
            state.selectedVoterUserId = null;
            state.contestVoters = [];

            // Clear URL hash
            window.location.hash = '';

            state.modalProcessing = false;
            render();
        }

        function toggleVoteView() {
            state.showMyVotes = !state.showMyVotes;
            render();
        }

        function toggleVotingMode() {
            const newMode = state.votingMode === 'single' ? 'multi' : 'single';

            // Save voting mode preference to localStorage
            localStorage.setItem('peony_voting_mode', newMode);

            // Show loading modal when switching to multi mode
            if (newMode === 'multi') {
                state.isLoadingMultiModeImages = true;
                state.multiModeLoadedImages = 0;
                state.multiModeTotalImages = state.shuffledImages.length;
                state.votingMode = newMode;
                render();

                // Load images with tracking, hide modal when done or after 10s timeout
                loadImagesWithTracking(state.shuffledImages);
            } else {
                // Switching from multi to single mode
                state.votingMode = newMode;
                state.selectedScore = null;

                // If there was a last clicked image, navigate to it
                if (state.lastClickedImageId) {
                    const imageIndex = state.shuffledImages.findIndex(img => img.id === state.lastClickedImageId);
                    if (imageIndex !== -1) {
                        state.currentImageIndex = imageIndex;
                    }
                }

                render();
            }
        }

        function toggleFilters() {
            state.showFilters = !state.showFilters;
            render();
        }

        function togglePinnedSection() {
            state.isPinnedSectionExpanded = !state.isPinnedSectionExpanded;
            render();
        }

        function toggleCompleteVotingSection() {
            state.isCompleteVotingExpanded = !state.isCompleteVotingExpanded;
            render();
        }

        function toggleAllContestsSection() {
            state.isAllContestsSectionExpanded = !state.isAllContestsSectionExpanded;
            render();
        }

        // Make toggle functions globally accessible
        window.togglePinnedSection = togglePinnedSection;
        window.toggleCompleteVotingSection = toggleCompleteVotingSection;
        window.toggleAllContestsSection = toggleAllContestsSection;

        function setResultsView(view, userId = null) {
            state.resultsView = view;
            state.showMyVotes = view === 'userVotes';  // Backwards compatibility

            // Reset selected voter when changing views
            if (view !== 'userVotes') {
                state.selectedVoterUserId = null;
            } else if (userId !== null) {
                // If userId provided, select that user
                state.selectedVoterUserId = userId;
            } else if (state.selectedVoterUserId === null) {
                // Default to current user if not already selected
                state.selectedVoterUserId = state.user?.id || null;
            }

            render();
        }

        function setVoterSortBy(sortBy) {
            state.voterSortBy = sortBy;
            render();
        }

        function updateScale(value) {
            clearTimeout(state.scaleUpdateTimeout);
            state.scaleUpdateTimeout = setTimeout(() => {
                state.imageScale = parseInt(value);
                render();
            }, 200);
        }

        function adjustScale(delta) {
            const newScale = Math.max(40, Math.min(200, state.imageScale + delta));
            state.imageScale = newScale;
            render();
        }

        async function showAdminDashboard() {
            try {
                state.showAdminDashboard = true;
                state.adminDashboardLoading = true;
                render(); // Show loading state

                // Load all users from database
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?select=*&order=username.asc`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Failed to load users:', errorData);
                    throw new Error(errorData.message || 'Failed to load users');
                }

                const users = await response.json();
                console.log('üìä Loaded users from database:', users);

                // Update state with all users (including current user, banned users, etc.)
                state.allUsers = users.map(user => ({
                    id: user.id,
                    username: user.username,
                    avatar: user.avatar,
                    isBanned: user.is_banned || false
                }));

                console.log('üìä All users in state:', state.allUsers);

                // Fetch admin statistics from database with aggressive cache-busting
                const voterResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?select=user_id`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const votes = await voterResponse.json();

                // Check if votes response is valid
                if (!Array.isArray(votes)) {
                    console.error('Invalid votes response:', votes);
                    throw new Error(votes.message || 'Failed to load voter statistics');
                }

                // Count unique voters from users table
                const totalUniqueVoters = users.length;

                // Count total votes using COUNT(*)
                const votesCountResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?select=*`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'count=exact',
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });

                // Parse count from Content-Range header (e.g., "0-99/150" means 150 total)
                const contentRange = votesCountResponse.headers.get('Content-Range');
                const totalVotes = contentRange ? parseInt(contentRange.split('/')[1]) : 0;

                // Count total images shortlisted from shortcake_votes
                const shortcakeVotesResponse = await fetch(`${SUPABASE_URL}/rest/v1/shortcake_votes?select=shortlisted_image_ids`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const shortcakeVotes = await shortcakeVotesResponse.json();
                const totalImagesShortlisted = Array.isArray(shortcakeVotes)
                    ? shortcakeVotes.reduce((sum, vote) => sum + (vote.shortlisted_image_ids?.length || 0), 0)
                    : 0;

                state.adminStats = { totalVotes, totalUniqueVoters, totalImagesShortlisted };

                state.adminDashboardLoading = false;
                document.body.classList.add('modal-open');
                render();
            } catch (error) {
                console.error('Error loading admin dashboard:', error);
                state.adminDashboardLoading = false;
                state.showAdminDashboard = false;
                showAlert('Failed to load admin dashboard: ' + error.message, '‚ùå');
            }
        }

        function closeAdminDashboard() {
            state.showAdminDashboard = false;
            document.body.classList.remove('modal-open');
            render();
        }

        async function showAppSettings() {
            state.showAppSettingsModal = true;
            state.showUserDropdown = false;
            document.body.classList.add('modal-open');
            render();
        }

        function closeAppSettings() {
            state.showAppSettingsModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        async function toggleAppSetting(settingName) {
            try {
                // Get current value (default to true if not set)
                const currentValue = state.appSettings[settingName] !== false;
                const newValue = !currentValue;

                // Update in database
                // First, check if setting exists
                const checkResponse = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                const existingSettings = await checkResponse.json();

                if (existingSettings.length > 0) {
                    // Update existing setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update setting');
                    }
                } else {
                    // Insert new setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            setting_name: settingName,
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create setting');
                    }
                }

                // Update local state
                state.appSettings[settingName] = newValue;

                // Format setting name properly
                const formattedName = settingName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                showToast(
                    `‚úÖ ${formattedName} ${newValue ? 'enabled' : 'disabled'}`
                );
                render();
            } catch (error) {
                console.error('Error toggling app setting:', error);
                showToast('Failed to update setting: ' + error.message, 'error');
            }
        }

        async function updateAppSetting(settingName, newValue) {
            try {
                // Update in database
                // First, check if setting exists
                const checkResponse = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                const existingSettings = await checkResponse.json();

                if (existingSettings.length > 0) {
                    // Update existing setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings?setting_name=eq.${settingName}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update setting');
                    }
                } else {
                    // Insert new setting
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/app_settings`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            setting_name: settingName,
                            value: newValue
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create setting');
                    }
                }

                // Update local state
                state.appSettings[settingName] = newValue;
            } catch (error) {
                console.error('Error updating app setting:', error);
                throw error;
            }
        }

        // ==================== FOLDER MANAGEMENT ====================

        function initializeFolderSortable() {
            const foldersList = document.getElementById('folders-list');
            if (!foldersList || typeof Sortable === 'undefined') return;

            // Initialize folder reordering
            new Sortable(foldersList, {
                animation: 150,
                handle: '.cursor-move',
                ghostClass: 'bg-blue-100',
                onEnd: async (evt) => {
                    // Skip if dropped at the same position
                    if (evt.oldIndex === evt.newIndex) {
                        return;
                    }

                    // Save scroll position before re-render
                    const modalContent = document.querySelector('.overflow-y-auto');
                    const scrollPos = modalContent ? modalContent.scrollTop : 0;

                    try {
                        // Get all children to determine what was moved
                        const children = Array.from(foldersList.children);
                        const movedElement = evt.item;
                        const isUnfolderedMoved = movedElement.hasAttribute('data-unfoldered');

                        // Get current unfoldered position
                        const currentUnfolderedPos = state.appSettings.unfoldered_items_position !== undefined
                            ? parseInt(state.appSettings.unfoldered_items_position)
                            : state.groups.length;

                        if (isUnfolderedMoved) {
                            // Unfoldered items meta-item was moved
                            // The new index IS the new position (since it's in the combined list)
                            const newUnfolderedPos = evt.newIndex;
                            await updateAppSetting('unfoldered_items_position', newUnfolderedPos);
                        } else {
                            // A folder was moved
                            // Need to adjust folder positions and possibly unfoldered position

                            // Count folders before and after unfoldered in the NEW layout
                            let newUnfolderedPos = currentUnfolderedPos;
                            const unfolderedElement = children.find(c => c.hasAttribute('data-unfoldered'));
                            if (unfolderedElement) {
                                newUnfolderedPos = Array.from(foldersList.children).indexOf(unfolderedElement);
                            }

                            // Build mapping of folder IDs to new positions (excluding unfoldered item)
                            const folderPositions = [];
                            children.forEach((child, visualIndex) => {
                                if (!child.hasAttribute('data-unfoldered')) {
                                    const folderId = child.getAttribute('data-folder-id');
                                    if (folderId) {
                                        // Calculate actual folder position (excluding unfoldered item)
                                        const actualPosition = visualIndex < newUnfolderedPos ? visualIndex : visualIndex - 1;
                                        folderPositions.push({ folderId, position: actualPosition });
                                    }
                                }
                            });

                            // Reorder state.groups to match new positions
                            const reorderedGroups = folderPositions
                                .sort((a, b) => a.position - b.position)
                                .map(fp => state.groups.find(g => g.id === fp.folderId))
                                .filter(Boolean);

                            state.groups = reorderedGroups;

                            // Save all folder positions
                            const updatePromises = state.groups.map((group, index) =>
                                saveFolderOrder(group.id, index)
                            );

                            await Promise.all(updatePromises);

                            // Update unfoldered position if it changed
                            if (newUnfolderedPos !== currentUnfolderedPos) {
                                await updateAppSetting('unfoldered_items_position', newUnfolderedPos);
                            }
                        }

                        // Only reload and re-render after successful save
                        render();

                        // Restore scroll position after render
                        setTimeout(() => {
                            const newModalContent = document.querySelector('.overflow-y-auto');
                            if (newModalContent) newModalContent.scrollTop = scrollPos;
                            initializeFolderSortable();
                        }, 100);
                    } catch (error) {
                        console.error('Failed to save folder order:', error);
                        showToast('Failed to save folder order', 'error');
                        // Reload to revert visual state
                        render();

                        // Restore scroll position after render
                        setTimeout(() => {
                            const newModalContent = document.querySelector('.overflow-y-auto');
                            if (newModalContent) newModalContent.scrollTop = scrollPos;
                            initializeFolderSortable();
                        }, 100);
                    }
                }
            });

            // Initialize item reordering within each folder
            state.groups.forEach(group => {
                const itemsList = document.getElementById(`folder-items-${group.id}`);
                if (itemsList) {
                    new Sortable(itemsList, {
                        animation: 150,
                        handle: '.cursor-move',
                        ghostClass: 'bg-blue-100',
                        onEnd: async (evt) => {
                            // Skip if dropped at the same position
                            if (evt.oldIndex === evt.newIndex) {
                                return;
                            }

                            // Save scroll position before re-render
                            const modalContent = document.querySelector('.overflow-y-auto');
                            const scrollPos = modalContent ? modalContent.scrollTop : 0;

                            try {
                                const folderId = itemsList.dataset.folderId;
                                const folder = state.groups.find(g => g.id === folderId);
                                if (!folder) return;

                                // Reorder the items array
                                const movedItem = folder.items.splice(evt.oldIndex, 1)[0];
                                folder.items.splice(evt.newIndex, 0, movedItem);

                                // Collect all update promises and execute in parallel
                                const updatePromises = folder.items.map((item, index) =>
                                    saveItemOrder(folderId, item.item_id, item.item_type, index)
                                );

                                // Wait for all saves to complete before proceeding
                                await Promise.all(updatePromises);

                                // Only reload and re-render after successful save
                                        render();

                                // Restore scroll position after render
                                setTimeout(() => {
                                    const newModalContent = document.querySelector('.overflow-y-auto');
                                    if (newModalContent) newModalContent.scrollTop = scrollPos;
                                    initializeFolderSortable();
                                }, 100);
                            } catch (error) {
                                console.error('Failed to save item order:', error);
                                showToast('Failed to save item order', 'error');
                                // Reload to revert visual state
                                        render();

                                // Restore scroll position after render
                                setTimeout(() => {
                                    const newModalContent = document.querySelector('.overflow-y-auto');
                                    if (newModalContent) newModalContent.scrollTop = scrollPos;
                                    initializeFolderSortable();
                                }, 100);
                            }
                        }
                    });
                }
            });
        }

        async function openManageFoldersModal() {
            state.showManageFoldersModal = true;
            state.showUserDropdown = false;
            document.body.classList.add('modal-open');
            render();
            // Initialize SortableJS after render
            setTimeout(initializeFolderSortable, 100);
        }

        function closeManageFoldersModal() {
            state.showManageFoldersModal = false;
            document.body.classList.remove('modal-open');
            render();
        }

        function showCreateFolderModal() {
            state.modal = {
                icon: 'üìÅ',
                title: 'Create New Folder',
                type: 'input',
                placeholder: 'Enter folder name...',
                inputValue: '',
                buttons: [
                    {
                        text: 'Cancel',
                        primary: false,
                        action: 'cancelCreateFolder'
                    },
                    {
                        text: 'Create',
                        primary: true,
                        action: 'confirmCreateFolder'
                    }
                ]
            };
            document.body.classList.add('modal-open');
            render();
            // Focus the input after render
            setTimeout(() => {
                const input = document.getElementById('modal-input');
                if (input) input.focus();
            }, 100);
        }

        function cancelCreateFolder() {
            state.modal = null;
            document.body.classList.remove('modal-open');
            render();
        }

        async function confirmCreateFolder() {
            const folderName = document.getElementById('modal-input')?.value;
            if (!folderName || !folderName.trim()) {
                showToast('‚ùå Please enter a folder name');
                return;
            }
            state.modal = null;
            document.body.classList.remove('modal-open');
            await createFolder(folderName.trim());
        }

        async function createFolder(folderName) {
            try {
                setLoading('Creating folder...');
                const maxOrder = state.groups.length > 0 ? Math.max(...state.groups.map(g => g.display_order || 0)) : 0;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        name: folderName,
                        display_order: maxOrder + 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to create folder');
                }

                    showToast('‚úÖ Folder created successfully');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error creating folder:', error);
                showToast('‚ùå Failed to create folder: ' + error.message);
                clearLoading();
            }
        }

        function confirmDeleteFolder(folderId) {
            state.folderToDelete = folderId;
            showConfirm(
                'Delete this folder? Items will not be deleted, only ungrouped.',
                'executeDeleteFolder',
                'üóëÔ∏è'
            );
        }

        async function executeDeleteFolder() {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const folderId = state.folderToDelete;
            state.folderToDelete = null;

            try {
                setLoading('Deleting folder...');

                // First delete all contest_groups entries for this folder
                await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${folderId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                // Then delete the group itself
                const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?id=eq.${folderId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete folder');
                }

                    showToast('Folder deleted successfully', 'success');
            } catch (error) {
                console.error('Error deleting folder:', error);
                showToast('Failed to delete folder: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                clearLoading();
                render();
            }
        }

        // Legacy function name for backwards compatibility
        async function deleteFolder(folderId) {
            confirmDeleteFolder(folderId);
        }

        async function addItemToFolder(folderId) {
            // Get all available items
            const allItems = [
                ...state.contests.map(c => ({ id: c.id, type: 'contest', title: c.title })),
                ...state.mergers.map(m => ({ id: m.id, type: 'merger', title: m.name })),
                ...state.extracts.map(e => ({ id: e.id, type: 'extract', title: e.name }))
            ];

            // Filter out items already in this folder
            const folder = state.groups.find(g => g.id === folderId);
            const folderItemIds = folder?.items?.map(i => `${i.item_type}:${i.item_id}`) || [];
            const availableItems = allItems.filter(item => !folderItemIds.includes(`${item.type}:${item.id}`));

            if (availableItems.length === 0) {
                showToast('No items available to add', 'info');
                return;
            }

            // Store data in state for the modal
            state.folderItemsToAdd = availableItems;
            state.targetFolderId = folderId;
            state.selectedFolderItems = []; // Reset selections

            // Show custom selection modal
            state.modal = {
                type: 'selectItem',
                icon: 'üìÅ',
                title: 'Add Items to Folder',
                message: 'Select one or more items to add to this folder:',
                items: availableItems,
                buttons: [
                    { text: 'Cancel', action: 'closeModal', primary: false },
                    { text: 'Add Selected Items', action: 'confirmAddMultipleItemsToFolder', primary: true }
                ]
            };
            document.body.classList.add('modal-open');
            render();
        }

        function toggleFolderItemSelection(itemIndex) {
            const index = state.selectedFolderItems.indexOf(itemIndex);
            if (index > -1) {
                state.selectedFolderItems.splice(index, 1);
            } else {
                state.selectedFolderItems.push(itemIndex);
            }

            // Update the visual state of checkboxes without full re-render
            const checkbox = document.querySelector(`[data-folder-item-index="${itemIndex}"]`);
            if (checkbox) {
                const isSelected = state.selectedFolderItems.includes(itemIndex);
                const checkboxIcon = checkbox.querySelector('.checkbox-icon');
                if (checkboxIcon) {
                    if (isSelected) {
                        checkboxIcon.innerHTML = `
                            <svg class="w-5 h-5 text-mauve-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                            </svg>
                        `;
                        checkbox.classList.add('border-mauve-400', 'bg-mauve-50');
                        checkbox.classList.remove('border-gray-200');
                    } else {
                        checkboxIcon.innerHTML = '<div class="w-4 h-4 border-2 border-gray-400 rounded"></div>';
                        checkbox.classList.remove('border-mauve-400', 'bg-mauve-50');
                        checkbox.classList.add('border-gray-200');
                    }
                }
            }

            // Update button state
            const addButton = document.querySelector('[data-add-items-button]');
            if (addButton) {
                if (state.selectedFolderItems.length > 0) {
                    addButton.disabled = false;
                    addButton.className = 'px-5 py-2 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700';
                    addButton.textContent = `Add Selected Items (${state.selectedFolderItems.length})`;
                } else {
                    addButton.disabled = true;
                    addButton.className = 'px-5 py-2 rounded-lg font-semibold transition text-sm bg-gray-300 text-gray-500 cursor-not-allowed';
                    addButton.textContent = 'Add Selected Items';
                }
            }
        }

        async function confirmAddMultipleItemsToFolder() {
            if (state.modalProcessing) return;
            if (state.selectedFolderItems.length === 0) {
                showToast('Please select at least one item', 'error');
                return;
            }

            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const folderId = state.targetFolderId;

            try {
                setLoading(`Adding ${state.selectedFolderItems.length} item(s) to folder...`);
                const folder = state.groups.find(g => g.id === folderId);
                const maxOrder = folder?.items?.length > 0 ? Math.max(...folder.items.map(i => i.display_order || 0)) : -1;

                // Prepare batch of items to insert
                const itemsToInsert = state.selectedFolderItems.map((itemIndex, idx) => {
                    const selectedItem = state.folderItemsToAdd[itemIndex];
                    return {
                        group_id: folderId,
                        item_id: selectedItem.id,
                        item_type: selectedItem.type,
                        display_order: maxOrder + idx + 1
                    };
                });

                // Batch insert all items
                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify(itemsToInsert)
                });

                if (!response.ok) {
                    throw new Error('Failed to add items to folder');
                }

                    showToast(`Added ${state.selectedFolderItems.length} item(s) successfully`, 'success');
                state.selectedFolderItems = [];
                render();
                setTimeout(initializeFolderSortable, 100);
            } catch (error) {
                console.error('Error adding items to folder:', error);
                showToast('Failed to add items: ' + error.message, 'error');
                render();
            } finally {
                state.modalProcessing = false;
                clearLoading();
            }
        }

        async function selectFolderItem(itemIndex) {
            if (state.modalProcessing) return;
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');

            const selectedItem = state.folderItemsToAdd[itemIndex];
            const folderId = state.targetFolderId;

            try {
                setLoading('Adding item to folder...');
                const folder = state.groups.find(g => g.id === folderId);
                const maxOrder = folder?.items?.length > 0 ? Math.max(...folder.items.map(i => i.display_order || 0)) : 0;

                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify({
                        group_id: folderId,
                        item_id: selectedItem.id,
                        item_type: selectedItem.type,
                        display_order: maxOrder + 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to add item to folder');
                }

                    showToast('Item added to folder successfully', 'success');
            } catch (error) {
                console.error('Error adding item to folder:', error);
                showToast('Failed to add item to folder: ' + error.message, 'error');
            } finally {
                state.modalProcessing = false;
                clearLoading();
                render();
            }
        }

        async function removeItemFromFolder(groupId, itemId, itemType) {
            try {
                setLoading('Removing item from folder...');

                const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${groupId}&item_id=eq.${itemId}&item_type=eq.${itemType}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to remove item from folder');
                }

                    showToast('Item removed from folder', 'success');
                clearLoading();
                render();
            } catch (error) {
                console.error('Error removing item from folder:', error);
                showToast('Failed to remove item: ' + error.message, 'error');
                clearLoading();
            }
        }

        async function saveFolderOrder(folderId, newOrder) {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/groups?id=eq.${folderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                },
                body: JSON.stringify({
                    display_order: newOrder
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(`Failed to update folder order: ${error.message || response.statusText}`);
            }
        }

        async function saveItemOrder(groupId, itemId, itemType, newOrder) {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/contest_groups?group_id=eq.${groupId}&item_id=eq.${itemId}&item_type=eq.${itemType}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                },
                body: JSON.stringify({
                    display_order: newOrder
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(`Failed to update item order: ${error.message || response.statusText}`);
            }
        }

        function toggleFolderExpanded(folderId) {
            const index = state.expandedFolderIds.indexOf(folderId);
            if (index > -1) {
                state.expandedFolderIds.splice(index, 1);
            } else {
                state.expandedFolderIds.push(folderId);
            }
            render();
        }


        function viewAllByCreator(userId) {
            state.filters.createdBy = userId;
            state.view = 'home';
            render();
        }

        async function viewUserProfile(userId) {
            // Close other modals first to prevent stacking
            state.contestInfoModal = null;
            state.modal = null;

            state.viewingUserId = userId;
            state.showUserProfileModal = true;
            document.body.classList.add('modal-open');

            // Ensure allUsers is loaded
            if (!state.allUsers || state.allUsers.length === 0) {
                try {
                    const usersResponse = await fetch(`${SUPABASE_URL}/rest/v1/users?select=*`, {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Cache-Control': 'no-cache'
                        }
                    });

                    if (usersResponse.ok) {
                        const users = await usersResponse.json();
                        state.allUsers = users.map(user => ({
                            id: user.id,
                            username: user.username,
                            avatar: user.avatar,
                            isBanned: user.is_banned || false
                        }));
                    }
                } catch (error) {
                    console.error('Error loading users:', error);
                    state.allUsers = [];
                }
            }

            // Fetch user's voting history
            try {
                const votesResponse = await fetch(`${SUPABASE_URL}/rest/v1/votes?user_id=eq.${userId}&select=contest_id`, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Cache-Control': 'no-cache'
                    }
                });
                const userVotes = await votesResponse.json();

                // Store unique contest IDs this user has voted on
                state.userProfileVotedContests = [...new Set(userVotes.map(v => v.contest_id))];
            } catch (error) {
                console.error('Error loading user voting history:', error);
                state.userProfileVotedContests = [];
            }

            render();
        }

        function closeUserProfileModal() {
            state.showUserProfileModal = false;
            state.viewingUserId = null;
            state.userProfileVotedContests = [];
            document.body.classList.remove('modal-open');
            render();
        }

        async function banUser(userId, banReason) {
            try {
                // Update database with ban status and reason
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${userId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_banned: true,
                        ban_reason: banReason
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to ban user in database');
                }

                // Update local state
                if (!state.bannedUsers.includes(userId)) {
                    state.bannedUsers.push(userId);
                }

                // Update allUsers state
                const userIndex = state.allUsers.findIndex(u => u.id === userId);
                if (userIndex !== -1) {
                    state.allUsers[userIndex].isBanned = true;
                    state.allUsers[userIndex].banReason = banReason;
                }

                // Reload results to refresh vote data with updated ban status
                if (state.view === 'results' && state.currentContest) {
                    await loadResults();
                }

                showAlert('User has been banned.', '‚úÖ');
                render();
            } catch (error) {
                console.error('Error banning user:', error);
                showAlert('Failed to ban user: ' + error.message, '‚ùå');
            }
        }

        async function unbanUser(userId) {
            try {
                // Update database - clear ban status and reason
                const response = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${userId}`, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        is_banned: false,
                        ban_reason: null
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to unban user in database');
                }

                // Update local state
                state.bannedUsers = state.bannedUsers.filter(id => id !== userId);

                // Update allUsers state
                const userIndex = state.allUsers.findIndex(u => u.id === userId);
                if (userIndex !== -1) {
                    state.allUsers[userIndex].isBanned = false;
                    state.allUsers[userIndex].banReason = null;
                }

                // Reload results to refresh vote data with updated ban status
                if (state.view === 'results' && state.currentContest) {
                    await loadResults();
                }

                showAlert('User has been unbanned. Their votes will now be included in results.', '‚úÖ');
                render();
            } catch (error) {
                console.error('Error unbanning user:', error);
                showAlert('Failed to unban user: ' + error.message, '‚ùå');
            }
        }

        function confirmBanUser(userId) {
            // Store userId for later use
            state.userToBan = userId;
            showInputModal(
                'Ban User - Enter Reason',
                'e.g., spam, inappropriate content, etc.',
                'handleBanUserReason',
                false
            );
        }

        function handleBanUserReason() {
            if (state.modalProcessing) return;
            const input = document.querySelector('.modal-input');
            const banReason = input ? input.value.trim() : '';

            if (!banReason || banReason.length === 0) {
                showAlert('Ban reason cannot be empty.', '‚ùå');
                return;
            }
            if (banReason.length > 500) {
                showAlert('Ban reason is too long (max 500 characters).', '‚ùå');
                return;
            }

            // Proceed with ban
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            banUser(state.userToBan, banReason);
            state.userToBan = null;
            state.modalProcessing = false;
        }

        function executeBanUser(userId) {
            // This function is no longer used, but kept for backwards compatibility
            state.modalProcessing = true;
            state.modal = null;
            document.body.classList.remove('modal-open');
            banUser(userId, 'No reason provided');
            state.modalProcessing = false;
        }


        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (state.showBreakdownModal) {
                    closeBreakdown();
                } else if (state.modal) {
                    closeModal();
                }
            }
        });

        function renderToast() {
            if (!state.toast) return '';

            return `
                <div class="fixed top-4 left-1/2 transform -translate-x-1/2 z-[70] toast-notification">
                    <div class="bg-white rounded-lg shadow-2xl px-6 py-3 flex items-center gap-3 border-2 border-green-500">
                        <span class="text-2xl">${state.toast.icon}</span>
                        <span class="text-sm font-semibold text-gray-800">${state.toast.message}</span>
                    </div>
                </div>
            `;
        }

        function renderUnifiedCreateModal() {
            if (!state.showUnifiedCreateModal) return '';

            const isBanned = state.user && state.bannedUsers.includes(state.user.id);
            const contestCreationEnabled = state.appSettings.contest_creation_enabled !== false;
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const canCreate = !isBanned && (contestCreationEnabled || isAdmin);

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeUnifiedCreateModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full p-6 modal-content" onclick="event.stopPropagation()">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-2xl font-bold text-gray-800">Create New Item</h3>
                            <button onclick="closeUnifiedCreateModal()" class="text-gray-500 hover:text-gray-700">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                            </button>
                        </div>

                        <p class="text-sm text-gray-600 mb-6">Choose what type of item you'd like to create:</p>

                        ${canCreate ? `
                            <div class="space-y-3">
                                <!-- Contest Option -->
                                <button
                                    onclick="closeUnifiedCreateModal(); startCreateContest();"
                                    class="w-full text-left p-4 bg-gradient-to-r from-green-50 to-green-100 hover:from-green-100 hover:to-green-200 rounded-lg border-2 border-green-300 transition group"
                                >
                                    <div class="flex items-start gap-4">
                                        <div class="text-3xl">üèÜ</div>
                                        <div class="flex-1">
                                            <h4 class="text-lg font-bold text-gray-800 group-hover:text-green-700">Contest</h4>
                                            <p class="text-sm text-gray-600 mt-1">Create a new voting contest with images. Users can vote on each image with scores from 1-5.</p>
                                        </div>
                                        <svg class="w-6 h-6 text-green-600 flex-shrink-0 mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                        </svg>
                                    </div>
                                </button>

                                <!-- Shortcake Option -->
                                <button
                                    onclick="closeUnifiedCreateModal(); showShortcakeWIPModal();"
                                    class="w-full text-left p-4 bg-gradient-to-r from-amber-50 to-amber-100 hover:from-amber-100 hover:to-amber-200 rounded-lg border-2 border-amber-700 transition group"
                                >
                                    <div class="flex items-start gap-4">
                                        <div class="text-3xl">üç∞</div>
                                        <div class="flex-1">
                                            <h4 class="text-lg font-bold text-gray-800 group-hover:text-amber-900">Shortcake</h4>
                                            <p class="text-sm text-gray-600 mt-1">Create a shortlist voting contest where users select their favorite images within a min-max range.</p>
                                        </div>
                                        <svg class="w-6 h-6 text-amber-700 flex-shrink-0 mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                        </svg>
                                    </div>
                                </button>

                                <!-- Merger Option -->
                                <button
                                    onclick="closeUnifiedCreateModal(); openCreateMergerModal();"
                                    class="w-full text-left p-4 bg-gradient-to-r from-blue-50 to-blue-100 hover:from-blue-100 hover:to-blue-200 rounded-lg border-2 border-blue-300 transition group"
                                >
                                    <div class="flex items-start gap-4">
                                        <div class="text-3xl">üîÄ</div>
                                        <div class="flex-1">
                                            <h4 class="text-lg font-bold text-gray-800 group-hover:text-blue-700">Merger</h4>
                                            <p class="text-sm text-gray-600 mt-1">Combine multiple existing contests into one merged voting session. View aggregated results across all selected contests.</p>
                                        </div>
                                        <svg class="w-6 h-6 text-blue-600 flex-shrink-0 mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                        </svg>
                                    </div>
                                </button>

                                <!-- Extract Option -->
                                <button
                                    onclick="closeUnifiedCreateModal(); openCreateExtractModal();"
                                    class="w-full text-left p-4 bg-gradient-to-r from-yellow-50 to-yellow-100 hover:from-yellow-100 hover:to-yellow-200 rounded-lg border-2 border-yellow-300 transition group"
                                >
                                    <div class="flex items-start gap-4">
                                        <div class="text-3xl">‚úÇÔ∏è</div>
                                        <div class="flex-1">
                                            <h4 class="text-lg font-bold text-gray-800 group-hover:text-yellow-700">Extract</h4>
                                            <p class="text-sm text-gray-600 mt-1">Create a subset by selecting specific images from an existing contest or merger. Perfect for narrowing down favourites.</p>
                                        </div>
                                        <svg class="w-6 h-6 text-yellow-600 flex-shrink-0 mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                        </svg>
                                    </div>
                                </button>
                            </div>
                        ` : `
                            <div class="text-center py-8">
                                <div class="text-6xl mb-4">üö´</div>
                                <h4 class="text-lg font-bold text-gray-800 mb-2">Creation Disabled</h4>
                                <p class="text-gray-600">Contest creation is currently disabled. Please contact an administrator.</p>
                            </div>
                        `}
                    </div>
                </div>
            `;
        }

        function renderModal() {
            if (!state.modal) return '';

            const isInput = state.modal.type === 'input';
            const isSelectItem = state.modal.type === 'selectItem';

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-${isSelectItem ? '2xl' : 'md'} w-full ${isSelectItem ? 'max-h-[80vh]' : ''} p-6 modal-content ${isSelectItem ? 'flex flex-col' : ''}" onclick="event.stopPropagation()">
                        <div class="text-center mb-2 ${isSelectItem ? 'flex-shrink-0' : ''}">
                            <div class="text-5xl mb-2">${state.modal.icon}</div>
                            ${isInput ? `
                                <h3 class="text-xl font-bold text-gray-800 mb-2">${state.modal.title}</h3>
                                <input id="modal-input" type="text" value="${state.modal.inputValue || ''}" class="modal-input w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-mauve-400 focus:outline-none" placeholder="${state.modal.placeholder}" />
                            ` : isSelectItem ? `
                                <h3 class="text-xl font-bold text-gray-800 mb-2">${state.modal.title}</h3>
                                <p class="text-sm text-gray-600 mb-2">${state.modal.message}</p>
                            ` : `
                                <p class="text-base font-bold text-gray-800 whitespace-pre-line">${state.modal.message}</p>
                            `}
                        </div>
                        ${isSelectItem ? `
                            <div class="flex-1 overflow-y-auto mb-4">
                                <div class="space-y-2">
                                    ${state.modal.items.map((item, idx) => {
                                        const typeColor = item.type === 'contest' ? 'mauve' : item.type === 'merger' ? 'blue' : 'yellow';
                                        const isSelected = state.selectedFolderItems.includes(idx);
                                        return `
                                            <div data-folder-item-index="${idx}" class="border-2 ${isSelected ? 'border-mauve-400 bg-mauve-50' : 'border-gray-200'} rounded-lg p-3 cursor-pointer hover:border-${typeColor}-400 hover:bg-${typeColor}-50 transition"
                                                 onclick="toggleFolderItemSelection(${idx})">
                                                <div class="flex items-center gap-3">
                                                    <div class="checkbox-icon flex-shrink-0 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-md border-2 ${isSelected ? 'border-mauve-500' : 'border-gray-300'}">
                                                        ${isSelected ? `
                                                            <svg class="w-5 h-5 text-mauve-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                            </svg>
                                                        ` : `
                                                            <div class="w-4 h-4 border-2 border-gray-400 rounded"></div>
                                                        `}
                                                    </div>
                                                    <div class="flex-1">
                                                        <div class="font-semibold text-gray-800">${item.title}</div>
                                                        <div class="text-xs text-gray-500 uppercase">${item.type}</div>
                                                    </div>
                                                    <div class="text-2xl flex-shrink-0">
                                                        ${item.type === 'contest' ? 'üé®' : item.type === 'merger' ? 'üîÄ' : '‚≠ê'}
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        ` : ''}
                        <div class="flex gap-2 justify-center ${isSelectItem ? 'flex-shrink-0' : ''}">
                            ${(state.modal.buttons || []).map(btn => {
                                const deleteContestMatch = btn.action.match(/confirmDeleteContest_(.+)/);
                                const banUserMatch = btn.action.match(/executeBanUser_(.+)/);
                                const removeImageMatch = btn.action.match(/confirmRemoveImage_(.+)/);
                                const editVoteMatch = btn.action.match(/confirmEditVote_(.+)_(.+)_(.+)_(.+)/);
                                const toggleBlockMatch = btn.action.match(/executeToggleBlockVote_(.+)_(.+)_(true|false)/);
                                let onclick;
                                if (deleteContestMatch) {
                                    onclick = `confirmDeleteContest('${deleteContestMatch[1]}')`;
                                } else if (banUserMatch) {
                                    onclick = `executeBanUser('${banUserMatch[1]}')`;
                                } else if (removeImageMatch) {
                                    onclick = `confirmRemoveImage(${removeImageMatch[1]})`;
                                } else if (editVoteMatch) {
                                    onclick = `confirmEditVote('${editVoteMatch[1]}', ${editVoteMatch[2]}, ${editVoteMatch[3]}, ${editVoteMatch[4]})`;
                                } else if (toggleBlockMatch) {
                                    onclick = `executeToggleBlockVote('${toggleBlockMatch[1]}', ${toggleBlockMatch[2]}, ${toggleBlockMatch[3]})`;
                                } else {
                                    onclick = `${btn.action}()`;
                                }

                                const isAddButton = btn.action === 'confirmAddMultipleItemsToFolder';
                                const isDisabled = isAddButton && state.selectedFolderItems.length === 0;

                                // Determine button color based on custom color property
                                let buttonClass = '';
                                if (isDisabled) {
                                    buttonClass = 'bg-gray-300 text-gray-500 cursor-not-allowed';
                                } else if (btn.color === 'pink') {
                                    buttonClass = 'bg-gradient-to-r from-pink-400 to-pink-600 text-white hover:from-pink-500 hover:to-pink-700';
                                } else if (btn.color === 'blue') {
                                    buttonClass = 'bg-gradient-to-r from-blue-400 to-blue-600 text-white hover:from-blue-500 hover:to-blue-700';
                                } else if (btn.primary) {
                                    buttonClass = 'bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700';
                                } else {
                                    buttonClass = 'bg-gray-200 text-gray-700 hover:bg-gray-300';
                                }

                                return `
                                    <button
                                        ${isAddButton ? 'data-add-items-button' : ''}
                                        ${isDisabled ? 'disabled' : ''}
                                        onclick="${onclick}"
                                        class="px-5 py-2 rounded-lg font-semibold transition text-sm ${buttonClass}"
                                    >
                                        ${btn.text}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCreateExtract() {
            // Full page view for creating extract

            // Step 1: Select source (contest or merger)
            if (!state.extractSourceType) {
                return `
                    <div class="max-w-4xl mx-auto px-3 py-4">
                        <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                            <!-- Header -->
                            <div class="p-6 border-b border-gray-200">
                                <h3 class="text-2xl font-bold text-gray-800">Create Extract - Select Source</h3>
                                <p class="text-sm text-gray-600 mt-1">
                                    Choose a contest or merger to extract images from
                                </p>
                            </div>

                            <!-- Source Selection -->
                            <div class="p-6">

                                ${state.mergers.length > 0 ? `
                                    <div class="mb-4">
                                        <h4 class="font-semibold text-gray-700 mb-2">Mergers</h4>
                                        <div class="space-y-2">
                                            ${state.mergers.map(merger => {
                                                const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                                                const totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);
                                                return `
                                                    <div class="border border-gray-200 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-yellow-400 hover:bg-yellow-50"
                                                         onclick="selectExtractSource('merger', '${merger.id}')">
                                                        <img src="${merger.creatorAvatar}" alt="${merger.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                        <div class="flex-1 min-w-0">
                                                            <h5 class="font-semibold text-gray-800 truncate">${merger.name}</h5>
                                                            <p class="text-xs text-gray-500">
                                                                ${merger.creatorName} ‚Ä¢ ${totalImages} images from ${mergedContests.length} contests
                                                            </p>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}

                                <div>
                                    <h4 class="font-semibold text-gray-700 mb-2">Contests</h4>
                                    <div class="space-y-2">
                                        ${state.contests.map(contest => `
                                            <div class="border border-gray-200 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-yellow-400 hover:bg-yellow-50"
                                                 onclick="selectExtractSource('contest', '${contest.id}')">
                                                <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                <div class="flex-1 min-w-0">
                                                    <h5 class="font-semibold text-gray-800 truncate">${contest.title}</h5>
                                                    <p class="text-xs text-gray-500">
                                                        ${contest.creatorName} ‚Ä¢ ${contest.images.length} images
                                                    </p>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Step 2: Visual image picker with scale slider
            let sourceImages = [];
            let sourceName = '';
            let mergedContests = [];
            let showContestFilter = false;

            if (state.extractSourceType === 'shortcake') {
                const shortcake = state.shortcakes.find(s => s.id === state.extractSourceId);
                if (shortcake) {
                    sourceImages = shortcake.images;
                    sourceName = shortcake.title;
                }
            } else if (state.extractSourceType === 'contest') {
                const contest = state.contests.find(c => c.id === state.extractSourceId);
                if (contest) {
                    sourceImages = contest.images;
                    sourceName = contest.title;
                }
            } else if (state.extractSourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === state.extractSourceId);
                if (merger) {
                    mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceName = merger.name;
                    showContestFilter = true;

                    // Apply contest filter
                    if (state.extractContestFilter === 'all') {
                        sourceImages = mergedContests.flatMap(c => c.images);
                    } else {
                        const filteredContest = mergedContests.find(c => c.id === state.extractContestFilter);
                        sourceImages = filteredContest ? filteredContest.images : [];
                    }
                }
            }

            const selectedCount = (state.extractSelectedImages || []).length;
            const imageScale = state.extractImageScale || 100;

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <!-- Header -->
                        <div class="p-4 border-b border-gray-200">
                            <div class="flex items-center justify-between mb-3">
                                <div>
                                    <h3 class="text-2xl font-bold text-gray-800">Create Extract - Select Images</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        From: ${sourceName} (${selectedCount} selected)
                                    </p>
                                </div>
                            </div>
                            ${showContestFilter ? `
                                <div class="mt-4">
                                    <label class="text-sm font-medium text-gray-700 mb-2 block">Filter by Contest:</label>
                                    <select
                                        onchange="setExtractContestFilter(this.value)"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-yellow-400 focus:outline-none"
                                    >
                                        <option value="all" ${state.extractContestFilter === 'all' ? 'selected' : ''}>
                                            Show All Contests (${mergedContests.reduce((sum, c) => sum + c.images.length, 0)} images)
                                        </option>
                                        ${mergedContests.map(contest => `
                                            <option value="${contest.id}" ${state.extractContestFilter === contest.id ? 'selected' : ''}>
                                                ${contest.title} (${contest.images.length} images)
                                            </option>
                                        `).join('')}
                                    </select>
                                </div>
                            ` : ''}

                            <!-- Image Scale Slider -->
                            <div class="mt-3">
                                <label class="text-sm font-medium text-gray-700 mb-2 block">Image Size: ${imageScale}%</label>
                                <input
                                    type="range"
                                    min="40"
                                    max="200"
                                    value="${imageScale}"
                                    oninput="updateExtractImageScale(this.value)"
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                                />
                            </div>
                        </div>

                        <!-- Image Grid -->
                        <div class="p-4">
                            <div class="flex flex-wrap gap-1">
                                ${sourceImages.map(image => {
                                    const isSelected = (state.extractSelectedImages || []).includes(image.id);
                                    const baseSize = 150;
                                    const imageHeight = Math.max(30, Math.min(500, Math.floor(baseSize * (imageScale / 100))));
                                    return `
                                        <div data-image-id="${image.id}">
                                            <div
                                                class="relative cursor-pointer rounded-lg overflow-hidden border-4 bg-gray-100 ${isSelected ? 'border-blue-500 bg-blue-50' : 'border-transparent hover:border-blue-300'}"
                                                onclick="toggleExtractImage(${image.id})"
                                                style="height: ${imageHeight}px;"
                                            >
                                                <img src="${image.url}" alt="" class="h-full w-auto object-cover" />
                                                <div class="absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 ${isSelected ? 'border-blue-500' : 'border-gray-300'}">
                                                ${isSelected ? `
                                                    <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                    </svg>
                                                ` : `
                                                    <div class="w-4 h-4 border-2 border-gray-400 rounded"></div>
                                                `}
                                            </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Name Input and Footer -->
                        <div class="p-4 border-t border-gray-200">
                            <div class="mb-4">
                                <label class="text-sm font-medium text-gray-700 mb-1 block">Extract Name</label>
                                <input
                                    id="extract-name-input"
                                    type="text"
                                    value="${state.newExtractName || ''}"
                                    oninput="setExtractName(this.value)"
                                    onblur="updateExtractNameOnBlur()"
                                    placeholder="Enter name for this extract..."
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-yellow-400 focus:outline-none"
                                />
                            </div>
                            <div class="flex gap-3">
                                <button
                                    data-extract-save
                                    onclick="saveExtract()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedCount > 0 && state.newExtractName ? 'bg-gradient-to-r from-yellow-500 to-yellow-600 text-white hover:from-yellow-600 hover:to-yellow-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedCount === 0 || !state.newExtractName ? 'disabled' : ''}
                                >
                                    Create Extract (${selectedCount} selected)
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderEditExtractModal() {
            // Full page view for editing extract
            const extract = state.extracts.find(e => e.id === state.editingExtractId);
            if (!extract) return '';

            // Get source images
            let sourceImages = [];
            let sourceName = '';

            if (extract.sourceType === 'contest') {
                const contest = state.contests.find(c => c.id === extract.sourceContestId);
                if (contest) {
                    sourceImages = contest.images;
                    sourceName = contest.title;
                }
            } else if (extract.sourceType === 'merger') {
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    sourceImages = mergedContests.flatMap(c => c.images);
                    sourceName = merger.name;
                }
            }

            const selectedCount = (state.editExtractSelectedImages || []).length;
            const imageScale = state.extractImageScale || 100;

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <!-- Header -->
                        <div class="p-4 border-b border-gray-200">
                            <div class="mb-3">
                                <h3 class="text-2xl font-bold text-gray-800">Edit Extract - ${extract.name}</h3>
                                <p class="text-sm text-gray-600 mt-1">
                                    From: ${sourceName} (${selectedCount} selected)
                                </p>
                            </div>

                            <!-- Image Scale Slider -->
                            <div class="mt-3">
                                <label class="text-sm font-medium text-gray-700 mb-2 block">Image Size: ${imageScale}%</label>
                                <input
                                    type="range"
                                    min="40"
                                    max="200"
                                    value="${imageScale}"
                                    oninput="updateExtractImageScale(this.value)"
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                                />
                            </div>
                        </div>

                        <!-- Image Grid -->
                        <div class="p-4">
                            <div class="flex flex-wrap gap-1">
                                ${sourceImages.map(image => {
                                    const isSelected = (state.editExtractSelectedImages || []).includes(image.id);
                                    const baseSize = 150;
                                    const imageHeight = Math.max(30, Math.min(500, Math.floor(baseSize * (imageScale / 100))));
                                    return `
                                        <div data-image-id="${image.id}">
                                            <div
                                                class="relative cursor-pointer rounded-lg overflow-hidden border-4 bg-gray-100 ${isSelected ? 'border-blue-500 bg-blue-50' : 'border-transparent hover:border-blue-300'}"
                                                onclick="toggleEditExtractImage(${image.id})"
                                                style="height: ${imageHeight}px;"
                                            >
                                                <img src="${image.url}" alt="" class="h-full w-auto object-cover" />
                                                <div class="absolute top-2 left-2 bg-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 ${isSelected ? 'border-blue-500' : 'border-gray-300'}">
                                                ${isSelected ? `
                                                    <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                    </svg>
                                                ` : `
                                                    <div class="w-4 h-4 border-2 border-gray-400 rounded"></div>
                                                `}
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Footer -->
                        <div class="p-4 border-t border-gray-200">
                            <button
                                onclick="saveEditedExtract()"
                                class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedCount > 0 ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                ${selectedCount === 0 ? 'disabled' : ''}
                            >
                                Save Changes (${selectedCount} selected)
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCreateMergerModal() {
            if (!state.showCreateMergerModal) return '';

            // State for selected contests for merging
            const selectedContests = state.selectedContestsForMerge || [];

            // Check if any selected contest has an extract that includes it
            // This prevents duplicate images (extract + source contest)
            const hasExtractConflict = selectedContests.some(contestId => {
                const contest = state.contests.find(c => c.id === contestId);
                if (!contest) return false;

                // Check if any extract uses this contest as a source
                return state.extracts.some(extract => {
                    if (extract.sourceType === 'contest' && extract.sourceContestId === contestId) {
                        // Check if any selected contest is in the extract's images
                        return selectedContests.some(otherContestId => {
                            if (otherContestId === contestId) return false;
                            const otherContest = state.contests.find(c => c.id === otherContestId);
                            if (!otherContest) return false;
                            // Check if any image from other contest is in the extract
                            return otherContest.images.some(img => extract.imageIds.includes(img.id));
                        });
                    }
                    return false;
                });
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeCreateMergerModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">Create Merge</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        Select contests to merge together (${selectedContests.length} selected, min 2 required)
                                    </p>
                                </div>
                                <button onclick="closeCreateMergerModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Contest List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-2">
                            ${state.shortcakes.length > 0 ? `
                                <div class="mb-4 bg-amber-50 border border-amber-300 text-amber-700 p-3 rounded-lg text-sm">
                                    Note: Shortcakes cannot be merged. Only contests can be selected for mergers.
                                </div>
                            ` : ''}
                            ${state.contests.map(contest => {
                                const isSelected = selectedContests.includes(contest.id);

                                return `
                                    <div class="border ${isSelected ? 'border-blue-400 bg-blue-50' : 'border-gray-200'} rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-blue-300"
                                         onclick="toggleContestForMerger('${contest.id}')">
                                        <input
                                            type="checkbox"
                                            ${isSelected ? 'checked' : ''}
                                            class="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
                                            onclick="event.stopPropagation()"
                                            onchange="toggleContestForMerger('${contest.id}')"
                                        />
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h4 class="font-semibold text-gray-800 truncate">${contest.title}</h4>
                                            </div>
                                            <p class="text-xs text-gray-500">
                                                ${contest.creatorName} ‚Ä¢ ${contest.images.length} images ‚Ä¢ ${contest.voterCount || 0} voters
                                            </p>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <!-- Name Input and Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${hasExtractConflict ? `
                                <div class="mb-4 bg-red-50 border border-red-300 text-red-700 p-3 rounded-lg text-sm">
                                    ‚ö†Ô∏è Warning: You've selected a contest and an extract that includes images from that contest. This will create duplicates.
                                </div>
                            ` : ''}
                            <div class="mb-4">
                                <label class="text-sm font-medium text-gray-700 mb-1 block">Merger Name</label>
                                <input
                                    id="merger-name-input"
                                    type="text"
                                    value="${state.newMergerName || ''}"
                                    oninput="setMergerName(this.value)"
                                    onblur="updateMergerNameOnBlur()"
                                    placeholder="Enter name for this merger..."
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-blue-400 focus:outline-none"
                                />
                            </div>
                            <div class="flex gap-3">
                                <button
                                    onclick="closeCreateMergerModal()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                                >
                                    Cancel
                                </button>
                                <button
                                    onclick="saveMerger()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedContests.length >= 2 && state.newMergerName && !hasExtractConflict ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedContests.length < 2 || !state.newMergerName || hasExtractConflict ? 'disabled' : ''}
                                >
                                    Create Merger
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderEditMergerModal() {
            if (!state.showEditMergerModal) return '';

            const merger = state.mergers.find(m => m.id === state.editingMergerId);
            if (!merger) return '';

            // State for selected contests for editing
            const selectedContests = state.editMergerSelectedContests || [];

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeEditMergerModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">Edit Merger - ${merger.name}</h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        Select contests to include in this merger (${selectedContests.length} selected, min 2 required)
                                    </p>
                                </div>
                                <button onclick="closeEditMergerModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Contest List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-2">
                            ${state.contests.map(contest => {
                                const isSelected = selectedContests.includes(contest.id);

                                return `
                                    <div class="border ${isSelected ? 'border-purple-400 bg-purple-50' : 'border-gray-200'} rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:border-purple-300"
                                         onclick="toggleContestForEditMerger('${contest.id}')">
                                        <input
                                            type="checkbox"
                                            ${isSelected ? 'checked' : ''}
                                            class="w-5 h-5 rounded border-gray-300 text-purple-600 focus:ring-purple-500 cursor-pointer"
                                            onclick="event.stopPropagation()"
                                            onchange="toggleContestForEditMerger('${contest.id}')"
                                        />
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h4 class="font-semibold text-gray-800 truncate">${contest.title}</h4>
                                            </div>
                                            <p class="text-xs text-gray-500">
                                                ${contest.creatorName} ‚Ä¢ ${contest.images.length} images
                                            </p>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <!-- Footer -->
                        <div class="p-6 border-t border-gray-200">
                            <div class="flex gap-3">
                                <button
                                    onclick="closeEditMergerModal()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                                >
                                    Cancel
                                </button>
                                <button
                                    onclick="saveEditedMerger()"
                                    class="flex-1 px-5 py-3 rounded-lg font-semibold transition text-sm ${selectedContests.length >= 2 ? 'bg-gradient-to-r from-purple-500 to-purple-600 text-white hover:from-purple-600 hover:to-purple-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}"
                                    ${selectedContests.length < 2 ? 'disabled' : ''}
                                >
                                    Save Changes
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderUploadProgressModal() {
            if (!state.uploadProgress) return '';

            const allCompleted = state.uploadProgress.files.every(f => f.status === 'success' || f.status === 'failed');
            const successCount = state.uploadProgress.files.filter(f => f.status === 'success').length;
            const failedCount = state.uploadProgress.files.filter(f => f.status === 'failed').length;
            const uploadingCount = state.uploadProgress.files.filter(f => f.status === 'uploading' || f.status === 'compressing').length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">
                                        ${allCompleted ? 'Upload Complete' : 'Uploading Images...'}
                                    </h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        ${successCount} succeeded, ${failedCount} failed, ${uploadingCount} in progress
                                    </p>
                                </div>
                                <div class="text-3xl">
                                    ${allCompleted ? (failedCount > 0 ? '‚ö†Ô∏è' : '‚úÖ') : '‚è≥'}
                                </div>
                            </div>
                        </div>

                        <!-- File List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-3">
                            ${state.uploadProgress.files.map((file, index) => `
                                <div class="border border-gray-200 rounded-lg p-4 ${
                                    file.status === 'success' ? 'bg-green-50 border-green-200' :
                                    file.status === 'failed' ? 'bg-red-50 border-red-200' :
                                    'bg-blue-50 border-blue-200'
                                }">
                                    <div class="flex items-start justify-between mb-2">
                                        <div class="flex-1 min-w-0">
                                            <p class="font-medium text-gray-800 truncate" title="${file.name}">
                                                ${file.name}
                                            </p>
                                            ${file.needsCompression ? `
                                                <p class="text-xs text-gray-600 mt-1">
                                                    ${file.compressedSize && file.compressedSize < file.originalSize ? `Original: ${(file.originalSize / 1024).toFixed(0)}KB ‚Üí Compressed: ${(file.compressedSize / 1024).toFixed(0)}KB (${Math.round((1 - file.compressedSize / file.originalSize) * 100)}% smaller)` :
                                                      file.compressedSize ? `${(file.originalSize / 1024).toFixed(0)}KB (no compression needed)` :
                                                      `Original: ${(file.originalSize / 1024).toFixed(0)}KB ‚Üí Compressing...`}
                                                </p>
                                            ` : file.originalSize ? `
                                                <p class="text-xs text-gray-600 mt-1">${(file.originalSize / 1024).toFixed(0)}KB</p>
                                            ` : ''}
                                            ${file.status === 'compressing' ? `
                                                <p class="text-xs text-blue-600 mt-1">üîÑ Compressing...</p>
                                            ` : ''}
                                            ${file.error ? `
                                                <p class="text-xs text-red-600 mt-1">${file.error}</p>
                                            ` : ''}
                                        </div>
                                        <div class="ml-3 text-2xl flex-shrink-0">
                                            ${file.status === 'success' ? '‚úÖ' :
                                              file.status === 'failed' ? '‚ùå' :
                                              file.status === 'compressing' ? 'üîÑ' :
                                              file.status === 'uploading' ? '‚è≥' : '‚è±Ô∏è'}
                                        </div>
                                    </div>

                                    <!-- Progress Bar -->
                                    ${file.status === 'uploading' || file.status === 'compressing' || file.status === 'pending' ? `
                                        <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                                            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300"
                                                 style="width: ${file.progress || 0}%"></div>
                                        </div>
                                        <p class="text-xs text-gray-600">
                                            ${file.status === 'compressing' ? 'Compressing...' : `${file.progress || 0}%`}
                                        </p>
                                    ` : ''}

                                    <!-- Retry Button -->
                                    ${file.status === 'failed' ? `
                                        <button onclick="retryUpload(${index})"
                                                class="mt-2 px-3 py-1 text-xs bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">
                                            üîÑ Retry Upload
                                        </button>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>

                        <!-- Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${allCompleted ? `
                                <button onclick="closeUploadProgress()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-mauve-400 to-mauve-600 text-white hover:from-mauve-500 hover:to-mauve-700">
                                    Done
                                </button>
                            ` : `
                                <button onclick="cancelAllUploads()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300">
                                    Cancel Remaining Uploads
                                </button>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderCompressionModal() {
            if (!state.compressionProgress) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const allCompleted = state.compressionProgress.allComplete;
            const completeCount = state.compressionProgress.files.filter(f => f.status === 'complete').length;
            const failedCount = state.compressionProgress.files.filter(f => f.status === 'failed' && !f.adminBypass).length;
            const compressingCount = state.compressionProgress.files.filter(f => f.status === 'compressing').length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-3xl w-full max-h-[85vh] flex flex-col modal-content" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-800">
                                        ${allCompleted ? 'Compression Complete' : 'Compressing Images...'}
                                    </h3>
                                    <p class="text-sm text-gray-600 mt-1">
                                        ${completeCount} completed, ${failedCount} failed, ${compressingCount} in progress
                                    </p>
                                </div>
                                <div class="text-3xl">
                                    ${allCompleted ? (failedCount > 0 ? '‚ö†Ô∏è' : '‚úÖ') : 'üîÑ'}
                                </div>
                            </div>
                        </div>

                        <!-- File List -->
                        <div class="flex-1 overflow-y-auto p-6 space-y-4">
                            ${state.compressionProgress.files.map((fileState, index) => {
                                const isOversized = fileState.status === 'failed' && fileState.compressedSize > 1000 * 1024;
                                const bgColor = fileState.status === 'complete' || fileState.adminBypass ? 'bg-green-50 border-green-200' :
                                                fileState.status === 'failed' ? 'bg-red-50 border-red-200' :
                                                'bg-blue-50 border-blue-200';

                                return `
                                    <div class="border border-gray-200 rounded-lg p-4 ${bgColor}">
                                        <div class="flex items-start justify-between mb-2">
                                            <div class="flex-1 min-w-0">
                                                <p class="font-medium text-gray-800 truncate" title="${fileState.name}">
                                                    ${fileState.name}
                                                </p>
                                                <div class="flex flex-wrap gap-3 mt-2 text-xs text-gray-600">
                                                    ${fileState.savingsPercent > 0 ? `
                                                        <span><strong>Original:</strong> ${formatFileSize(fileState.originalSize)}</span>
                                                        <span><strong>Compressed:</strong> ${formatFileSize(fileState.compressedSize)}</span>
                                                        <span class="text-green-600 font-semibold">Saved ${fileState.savingsPercent}%</span>
                                                    ` : `
                                                        <span><strong>Original:</strong> ${formatFileSize(fileState.originalSize)}</span>
                                                    `}
                                                </div>
                                                ${fileState.status === 'compressing' ? `
                                                    <p class="text-xs text-blue-600 mt-1">üîÑ Compressing...</p>
                                                ` : ''}
                                                ${fileState.status === 'complete' ? `
                                                    <p class="text-xs text-green-600 mt-1">‚úÖ Complete</p>
                                                ` : ''}
                                                ${fileState.status === 'failed' && !fileState.adminBypass ? `
                                                    <p class="text-xs text-red-600 mt-1">‚ùå ${fileState.error}</p>
                                                ` : ''}
                                                ${fileState.adminBypass ? `
                                                    <p class="text-xs text-orange-600 mt-1 font-semibold">‚ö†Ô∏è Admin override: Adding image exceeding 1000 KB limit</p>
                                                ` : ''}
                                            </div>
                                            <div class="ml-3 text-2xl flex-shrink-0">
                                                ${fileState.status === 'complete' || fileState.adminBypass ? '‚úÖ' :
                                                  fileState.status === 'failed' ? '‚ùå' :
                                                  'üîÑ'}
                                            </div>
                                        </div>

                                        <!-- Progress Bar -->
                                        ${fileState.status === 'compressing' ? `
                                            <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                                                <div class="bg-blue-500 h-2 rounded-full transition-all duration-300"
                                                     style="width: ${fileState.progress || 0}%"></div>
                                            </div>
                                            <p class="text-xs text-gray-600">${fileState.progress || 0}%</p>
                                        ` : ''}

                                        <!-- Action Buttons -->
                                        <div class="flex gap-2 mt-3">
                                            ${fileState.status === 'complete' && fileState.savingsPercent > 0 && isAdmin ? `
                                                <button onclick="resetToOriginalImage(${index})"
                                                        class="px-3 py-1.5 text-xs bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition font-medium">
                                                    ‚Ü∫ Reset to Original
                                                </button>
                                            ` : ''}
                                            ${fileState.status === 'failed' && isAdmin && isOversized && !fileState.adminBypass ? `
                                                <button onclick="addOversizedImageAnyway(${index})"
                                                        class="px-3 py-1.5 text-xs bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition font-medium">
                                                    ‚ö†Ô∏è Add Anyway
                                                </button>
                                            ` : ''}
                                            ${(fileState.status === 'complete' || fileState.status === 'failed') && !fileState.adminBypass ? `
                                                <button onclick="cancelCompressionImage(${index})"
                                                        class="px-3 py-1.5 text-xs bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition font-medium">
                                                    ‚úñ Cancel Image
                                                </button>
                                            ` : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <!-- Footer -->
                        <div class="p-6 border-t border-gray-200">
                            ${allCompleted ? `
                                <button onclick="closeCompressionModal()"
                                        class="w-full px-5 py-3 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-green-500 to-green-700 text-white hover:from-green-600 hover:to-green-800">
                                    Done (${completeCount + (isAdmin ? state.compressionProgress.files.filter(f => f.adminBypass).length : 0)} images will be added)
                                </button>
                            ` : `
                                <p class="text-sm text-gray-600 text-center">
                                    Please wait for compression to complete...
                                </p>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderLoadingOverlay() {
            if (!state.isLoading) return '';
            return `<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100]">
                <div class="bg-white rounded-lg p-6 flex flex-col items-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-mauve-500 mb-3"></div>
                    <p class="text-gray-700 font-semibold">${state.loadingMessage}</p>
                </div>
            </div>`;
        }

        function renderMultiModeLoadingModal() {
            if (!state.isLoadingMultiModeImages) return '';
            const loadedCount = state.multiModeLoadedImages;
            const totalCount = state.multiModeTotalImages;
            const progress = totalCount > 0 ? (loadedCount / totalCount * 100) : 0;

            return `<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100]">
                <div class="bg-white rounded-lg p-8 flex flex-col items-center max-w-md w-full mx-4">
                    <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-green-600 mb-4"></div>
                    <h3 class="text-xl font-bold text-gray-800 mb-2">Loading Multi-Mode View</h3>
                    <p class="text-gray-600 text-center mb-4">Loading ${loadedCount} of ${totalCount} images...</p>
                    <div class="w-full bg-gray-200 rounded-full h-3 overflow-hidden">
                        <div class="bg-gradient-to-r from-green-500 to-green-600 h-full rounded-full transition-all duration-300" style="width: ${progress.toFixed(1)}%"></div>
                    </div>
                    <p class="text-sm text-gray-500 mt-2">${progress.toFixed(0)}% complete</p>
                </div>
            </div>`;
        }

        function renderHeader() {
            const showBackButton = state.view === 'results' || state.view === 'vote' || state.view === 'mergedResults' || state.view === 'createExtract' || state.view === 'editExtract';
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isVoting = state.view === 'vote';

            return `
                <header class="safe-header bg-gradient-to-r from-mauve-600 via-mauve-300 to-green-700 text-white shadow-lg">
                    <div class="max-w-7xl mx-auto px-3 py-2 sm:py-3 flex justify-between items-center gap-2">
                        <div class="flex items-center gap-2">
                            <div onclick="backToHome()" class="w-8 h-8 rounded-full flex items-center justify-center bg-gradient-to-br from-mauve-300 to-mauve-500 cursor-pointer hover:opacity-80 transition">
                                <span class="text-xl">üå∫</span>
                            </div>
                            <h1 onclick="backToHome()" class="text-xl font-bold cursor-pointer hover:opacity-80 transition">Peony</h1>
                            ${showBackButton ? `
                                <button onclick="backToHome()" class="ml-2 bg-white/20 hover:bg-white/30 text-white px-3 py-1.5 sm:py-1 rounded-lg font-semibold transition text-sm flex items-center gap-1 min-h-[36px] sm:min-h-0">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                                    </svg>
                                    Back
                                </button>
                            ` : ''}
                        </div>

                        ${isVoting ? `
                            <!-- Voting Mode Toggle Switch (centered on desktop, right-aligned on mobile) -->
                            <div class="sm:absolute sm:left-1/2 sm:transform sm:-translate-x-1/2 ml-auto flex items-center gap-2 bg-white/20 backdrop-blur-sm rounded-lg px-3 py-1.5">
                                <button
                                    onclick="toggleVotingMode()"
                                    class="flex items-center gap-2 focus:outline-none"
                                >
                                    <svg class="w-4 h-4 ${state.votingMode === 'single' ? 'text-white' : 'text-white/50'}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                    </svg>
                                    <div class="relative inline-block w-10 h-5 sm:w-12 sm:h-6">
                                        <div class="absolute inset-0 bg-white/30 rounded-full transition"></div>
                                        <div class="absolute top-0.5 left-0.5 bg-white rounded-full w-4 h-4 sm:w-5 sm:h-5 transition-transform ${state.votingMode === 'multi' ? 'transform translate-x-5 sm:translate-x-6' : ''}"></div>
                                    </div>
                                    <svg class="w-5 h-5 ${state.votingMode === 'multi' ? 'text-white' : 'text-white/50'}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"/>
                                    </svg>
                                </button>
                            </div>
                        ` : ''}

                        ${!state.isLoggedIn ? `
                            <button onclick="login()" class="bg-white text-mauve-500 px-4 py-2 rounded-lg font-semibold hover:bg-pink-50 transition text-sm min-h-[36px]">
                                Login with Discord
                            </button>
                        ` : `
                            <div class="flex items-center gap-2">
                                <div class="relative">
                                    <button onclick="toggleUserDropdown()" class="flex items-center gap-2 cursor-pointer hover:opacity-80 focus:outline-none">
                                        <img src="${state.user.avatar}" alt="Avatar" class="w-7 h-7 rounded-full" />
                                        <span class="font-medium text-sm hidden sm:inline">${state.user.username}</span>
                                        <svg class="w-4 h-4 transition-transform ${state.showUserDropdown ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                                        </svg>
                                    </button>
                                    ${state.showUserDropdown ? `
                                        <div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg py-1 z-50">
                                            ${isAdmin ? `
                                                <button onclick="showAdminDashboard()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    ‚öôÔ∏è Admin Dashboard
                                                </button>
                                                <button onclick="showAppSettings()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                                                    üîß App Settings
                                                </button>
                                            ` : ''}
                                            <button onclick="toggleDarkTheme()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center justify-between ${isAdmin ? 'border-t border-gray-200' : ''}">
                                                <span>üåô Dark Theme</span>
                                                <div class="relative inline-block w-10 h-5 transition duration-200 ease-in-out rounded-full ${state.darkTheme ? 'bg-purple-500' : 'bg-gray-300'}">
                                                    <span class="absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full transition-transform duration-200 ease-in-out ${state.darkTheme ? 'translate-x-5' : 'translate-x-0'}"></span>
                                                </div>
                                            </button>
                                            <button onclick="logout()" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 border-t border-gray-200">
                                                Logout
                                            </button>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `}
                    </div>
                </header>
            `;
        }

        function renderLoginScreen() {
            return `
                <div class="max-w-md mx-auto mt-20 p-6 bg-white rounded-2xl shadow-xl fade-in">
                    ${state.sessionExpired ? `
                        <div class="bg-amber-50 border border-amber-300 rounded-lg p-3 mb-4">
                            <p class="text-sm text-amber-800 flex items-center gap-2">
                                <span class="text-lg">‚è∞</span>
                                <span><strong>Session Expired:</strong> Your session has expired. Please login again to continue.</span>
                            </p>
                        </div>
                    ` : ''}
                    ${state.pendingRoute ? `
                        <div class="bg-blue-50 border border-blue-300 rounded-lg p-3 mb-4">
                            <p class="text-sm text-blue-800 flex items-center gap-2">
                                <span class="text-lg">üîó</span>
                                <span><strong>Shared Link Detected!</strong> Please login to view this content. You'll be redirected automatically after logging in.</span>
                            </p>
                        </div>
                    ` : ''}
                    <div class="text-center mb-6">
                        <div class="w-16 h-16 bg-gradient-to-br from-mauve-300 to-mauve-500 rounded-full flex items-center justify-center mx-auto mb-4">
                            <span class="text-3xl">üå∫</span>
                        </div>
                        <h2 class="text-2xl font-bold text-gray-800 mb-2">Welcome to Peony</h2>
                        <p class="text-gray-600 text-sm">Create and vote on image contests</p>
                    </div>

                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
                        <p class="text-xs text-blue-800">
                            <strong>Privacy Notice:</strong> This app only accesses your Discord username and avatar. Contact me if you have any questions.
                        </p>
                    </div>

                    <button onclick="login()" class="w-full bg-gradient-to-r from-indigo-600 to-indigo-700 text-white py-3 rounded-lg font-semibold hover:from-indigo-700 hover:to-indigo-800 transition flex items-center justify-center gap-2 text-sm">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                        Login with Discord
                    </button>
                </div>
            `;
        }

        function setSortBy(sortBy) {
            state.filters.sortBy = sortBy;
            render();
        }

        function setFilterCreator(creatorId) {
            state.filters.createdBy = creatorId === 'all' ? null : creatorId;
            render();
        }

        function setSearchQuery(query) {
            state.filters.searchQuery = query;
            // Update URL parameter
            const url = new URL(window.location);
            if (query) {
                url.searchParams.set('search', query);
            } else {
                url.searchParams.delete('search');
            }
            window.history.replaceState({}, '', url);
            render();
        }

        function applySearch() {
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                setSearchQuery(searchInput.value);
            }
        }

        function clearAllFilters() {
            state.filters.createdBy = null;
            state.filters.sortBy = 'newest';
            state.filters.searchQuery = '';
            // Clear URL parameter
            const url = new URL(window.location);
            url.searchParams.delete('search');
            window.history.replaceState({}, '', url);
            render();
        }

        function renderHome() {
            // Get unique creators
            const creators = [...new Set(state.contests.map(c => ({ id: c.createdBy, name: c.creatorName })))];
            const uniqueCreators = Array.from(new Map(creators.map(c => [c.id, c])).values());

            // Filter contests
            let filteredContests = state.contests;
            let filteredMergers = state.mergers;
            let filteredExtracts = state.extracts;
            let filteredShortcakes = state.shortcakes;

            // Filter by creator
            if (state.filters.createdBy) {
                filteredContests = filteredContests.filter(c => c.createdBy === state.filters.createdBy);
                filteredMergers = filteredMergers.filter(m => m.createdBy === state.filters.createdBy);
                filteredExtracts = filteredExtracts.filter(e => e.createdBy === state.filters.createdBy);
                filteredShortcakes = filteredShortcakes.filter(s => s.createdBy === state.filters.createdBy);
            }

            // Filter by search query
            if (state.filters.searchQuery) {
                const searchLower = state.filters.searchQuery.toLowerCase();
                filteredContests = filteredContests.filter(c =>
                    c.title.toLowerCase().includes(searchLower) ||
                    (c.creatorName && c.creatorName.toLowerCase().includes(searchLower))
                );
                filteredMergers = filteredMergers.filter(m =>
                    m.name.toLowerCase().includes(searchLower) ||
                    (m.creatorName && m.creatorName.toLowerCase().includes(searchLower))
                );
                filteredExtracts = filteredExtracts.filter(e =>
                    e.name.toLowerCase().includes(searchLower) ||
                    (e.creatorName && e.creatorName.toLowerCase().includes(searchLower))
                );
                filteredShortcakes = filteredShortcakes.filter(s =>
                    s.title.toLowerCase().includes(searchLower) ||
                    (s.creatorName && s.creatorName.toLowerCase().includes(searchLower))
                );
            }

            // Sort contests
            filteredContests = [...filteredContests].sort((a, b) => {
                // Apply selected sort
                const voterCountA = a.voterCount || 0;
                const voterCountB = b.voterCount || 0;

                switch (state.filters.sortBy) {
                    case 'newest':
                    case 'dateDesc':
                        return (b.createdAt || 0) - (a.createdAt || 0);
                    case 'oldest':
                    case 'dateAsc':
                        return (a.createdAt || 0) - (b.createdAt || 0);
                    case 'titleAsc':
                        return a.title.toLowerCase().localeCompare(b.title.toLowerCase());
                    case 'titleDesc':
                        return b.title.toLowerCase().localeCompare(a.title.toLowerCase());
                    case 'mostVoted':
                    case 'votersDesc':
                        return voterCountB - voterCountA;
                    case 'leastVoted':
                    case 'votersAsc':
                        return voterCountA - voterCountB;
                    case 'imagesDesc':
                        return b.images.length - a.images.length;
                    case 'imagesAsc':
                        return a.images.length - b.images.length;
                    default:
                        return 0;
                }
            });

            const isBanned = state.bannedUsers.includes(state.user.id);

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    ${(() => {
                        // COMPLETE VOTING SECTION
                        // Identify contests and mergers where user has partial votes
                        const itemsToComplete = [];

                        // Check contests for partial votes
                        filteredContests.forEach(contest => {
                            const userVotes = state.userVotedContests[contest.id];
                            if (userVotes && Object.keys(userVotes).length > 0) {
                                const totalImages = contest.images.length;
                                const votedImages = Object.keys(userVotes).length;
                                if (votedImages < totalImages) {
                                    // User has partial votes
                                    itemsToComplete.push({ item: contest, type: 'contest', votedImages, totalImages });
                                }
                            }
                        });

                        // Check mergers for partial votes
                        filteredMergers.forEach(merger => {
                            const mergerContestIds = merger.contestIds || [];
                            let totalImages = 0;
                            let votedImages = 0;

                            mergerContestIds.forEach(contestId => {
                                const contest = state.contests.find(c => c.id === contestId);
                                if (contest) {
                                    totalImages += contest.images.length;
                                    const userVotes = state.userVotedContests[contestId];
                                    if (userVotes) {
                                        votedImages += Object.keys(userVotes).length;
                                    }
                                }
                            });

                            if (votedImages > 0 && votedImages < totalImages) {
                                // User has partial votes in this merger
                                itemsToComplete.push({ item: merger, type: 'merger', votedImages, totalImages });
                            }
                        });

                        // Check extracts for partial votes
                        filteredExtracts.forEach(extract => {
                            const extractImageIds = extract.imageIds || [];
                            const totalImages = extractImageIds.length;

                            // Get the source contest ID for this extract
                            let sourceContestId = null;
                            if (extract.sourceType === 'contest') {
                                sourceContestId = extract.sourceId;
                            } else if (extract.sourceType === 'merger') {
                                // For mergers, we need to check all merged contests
                                const merger = state.mergers.find(m => m.id === extract.sourceId);
                                if (merger && merger.contestIds && merger.contestIds.length > 0) {
                                    sourceContestId = merger.contestIds[0]; // Use first contest for simplicity
                                }
                            }

                            if (sourceContestId) {
                                const userVotes = state.userVotedContests[sourceContestId];
                                if (userVotes) {
                                    // Count how many extract images have been voted on
                                    const votedImages = extractImageIds.filter(imgId => userVotes[imgId]).length;
                                    if (votedImages > 0 && votedImages < totalImages) {
                                        itemsToComplete.push({ item: extract, type: 'extract', votedImages, totalImages });
                                    }
                                }
                            }
                        });

                        // Sort items by created_at (newest first)
                        itemsToComplete.sort((a, b) => {
                            const dateA = new Date(a.item.createdAt || a.item.created_at || 0);
                            const dateB = new Date(b.item.createdAt || b.item.created_at || 0);
                            return dateB - dateA;
                        });

                        if (itemsToComplete.length > 0) {
                            const displayItems = state.isCompleteVotingExpanded ? itemsToComplete : itemsToComplete.slice(0, 1);

                            return `
                                <div class="mb-4">
                                    <div class="bg-gradient-to-r from-yellow-500 to-yellow-600 px-4 py-3 rounded-lg shadow-lg mb-3">
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-3 flex-1">
                                                <button
                                                    onclick="toggleCompleteVotingSection()"
                                                    class="text-white hover:bg-white/20 rounded-lg p-1 transition"
                                                >
                                                    <svg class="w-5 h-5 transition-transform ${state.isCompleteVotingExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                    </svg>
                                                </button>
                                                <div class="flex-1">
                                                    <h3 class="text-lg font-bold text-white">üå† Complete Voting</h3>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2 mb-2">
                                        ${displayItems.map(({ item, type, votedImages, totalImages }) => {
                                            const unvotedCount = totalImages - votedImages;
                                            const unvotedLabel = unvotedCount === 1
                                                ? 'Just 1 more vote needed!'
                                                : `Just ${unvotedCount} more votes needed!`;

                                            if (type === 'contest') return renderContestCard(item, false, unvotedLabel);
                                            if (type === 'merger') return renderMergerCard(item, false, unvotedLabel);
                                            if (type === 'extract') return renderExtractCard(item, false, unvotedLabel);
                                            return '';
                                        }).join('')}
                                    </div>
                                    ${itemsToComplete.length > 1 && !state.isCompleteVotingExpanded ? `
                                        <button
                                            onclick="toggleCompleteVotingSection()"
                                            class="w-full text-center text-sm text-yellow-600 hover:text-yellow-700 font-medium py-2 bg-yellow-50 hover:bg-yellow-100 rounded-lg transition"
                                        >
                                            Show ${itemsToComplete.length - 1} more item${itemsToComplete.length - 1 > 1 ? 's' : ''} to complete
                                        </button>
                                    ` : ''}
                                </div>
                            `;
                        }
                        return '';
                    })()}

                    ${(() => {
                        // PINNED ITEMS SECTION
                        const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

                        // Create array of pinned items with their data and timestamp, sorted by timestamp
                        const allPinnedItems = state.pinnedItems
                            .map(p => {
                                let item = null;
                                if (p.item_type === 'contest') {
                                    item = state.contests.find(c => c.id === p.item_id);
                                } else if (p.item_type === 'merger') {
                                    item = state.mergers.find(m => m.id === p.item_id);
                                } else if (p.item_type === 'extract') {
                                    item = state.extracts.find(e => e.id === p.item_id);
                                } else if (p.item_type === 'shortcake') {
                                    item = state.shortcakes.find(s => s.id === p.item_id);
                                }
                                return item ? { item, type: p.item_type, pinnedAt: p.pinned_at } : null;
                            })
                            .filter(Boolean)
                            // Sort by pinned timestamp (most recent first)
                            .sort((a, b) => new Date(b.pinnedAt) - new Date(a.pinnedAt));

                        if (allPinnedItems.length > 0) {
                            const displayItems = state.isPinnedSectionExpanded ? allPinnedItems : allPinnedItems.slice(0, 3);

                            return `
                                <div class="mb-4">
                                    <div class="bg-gradient-to-r from-red-500 to-red-600 px-4 py-3 rounded-lg shadow-lg mb-3">
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-3 flex-1">
                                                <button
                                                    onclick="togglePinnedSection()"
                                                    class="text-white hover:bg-white/20 rounded-lg p-1 transition"
                                                >
                                                    <svg class="w-5 h-5 transition-transform ${state.isPinnedSectionExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                    </svg>
                                                </button>
                                                <div class="flex-1">
                                                    <h3 class="text-lg font-bold text-white">üìå Pinned</h3>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2 mb-2">
                                        ${displayItems.map(({ item, type }) => {
                                            if (type === 'contest') return renderContestCard(item, true);
                                            if (type === 'merger') return renderMergerCard(item, true);
                                            if (type === 'extract') return renderExtractCard(item, true);
                                            if (type === 'shortcake') return renderShortcakeCard(item, true);
                                            return '';
                                        }).join('')}
                                    </div>
                                    ${allPinnedItems.length > 3 && !state.isPinnedSectionExpanded ? `
                                        <button
                                            onclick="togglePinnedSection()"
                                            class="w-full text-center text-sm text-red-600 hover:text-red-700 font-medium py-2 bg-red-50 hover:bg-red-100 rounded-lg transition"
                                        >
                                            Show ${allPinnedItems.length - 3} more pinned items
                                        </button>
                                    ` : ''}
                                </div>
                            `;
                        }
                        return '';
                    })()}

                    <div class="bg-gradient-to-r from-green-500 to-green-600 px-3 md:px-4 py-2 md:py-2.5 rounded-lg shadow-lg mb-2">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-3 flex-1">
                                <button
                                    onclick="toggleAllContestsSection()"
                                    class="text-white hover:bg-white/20 rounded-lg p-1 transition"
                                >
                                    <svg class="w-5 h-5 transition-transform ${state.isAllContestsSectionExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                    </svg>
                                </button>
                                <div class="flex-1">
                                    <h2 class="text-xl font-bold text-white">All Votings</h2>
                                </div>
                            </div>
                            ${!isBanned ? `
                                <div class="flex items-center gap-2">
                                    <button onclick="toggleFilters()" class="bg-white text-green-700 p-2 rounded-lg font-semibold hover:bg-green-50 transition shadow-lg" title="Search & Filter">
                                        üîç
                                    </button>
                                    <button onclick="openUnifiedCreateModal()" class="bg-white text-green-700 px-4 py-2 rounded-lg font-semibold hover:bg-green-50 transition shadow-lg text-sm whitespace-nowrap">
                                        + Create
                                    </button>
                                </div>
                            ` : `
                                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded-lg text-sm">
                                    üö´ Your account has been restricted. Contact admin.
                                </div>
                            `}
                        </div>
                    </div>

                    ${state.isAllContestsSectionExpanded && state.showFilters ? `
                        <div class="bg-white rounded-lg shadow-md mb-4 overflow-hidden">
                                <div class="p-3">
                                    <div class="mb-3">
                                        <label class="text-xs font-medium text-gray-700 mb-1 block">Search Contests</label>
                                        <div class="flex gap-2">
                                            <input
                                                id="search-input"
                                                type="text"
                                                value="${state.filters.searchQuery || ''}"
                                                onkeypress="if(event.key==='Enter') applySearch()"
                                                placeholder="Search by contest title or creator name..."
                                                class="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none"
                                            />
                                            <button
                                                onclick="applySearch()"
                                                class="px-4 py-2 bg-mauve-500 text-white rounded-lg text-sm font-semibold hover:bg-mauve-600 transition"
                                            >
                                                Search
                                            </button>
                                        </div>
                                    </div>
                                    <div class="flex gap-3 flex-wrap">
                                    <div class="flex-1 min-w-[200px]">
                                        <label class="text-xs font-medium text-gray-700 mb-1 block">Sort By</label>
                                        <select onchange="setSortBy(this.value)" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none">
                                            <option value="newest" ${state.filters.sortBy === 'newest' || state.filters.sortBy === 'dateDesc' ? 'selected' : ''}>Newest First</option>
                                            <option value="oldest" ${state.filters.sortBy === 'oldest' || state.filters.sortBy === 'dateAsc' ? 'selected' : ''}>Oldest First</option>
                                            <option value="titleAsc" ${state.filters.sortBy === 'titleAsc' ? 'selected' : ''}>A-Z</option>
                                            <option value="titleDesc" ${state.filters.sortBy === 'titleDesc' ? 'selected' : ''}>Z-A</option>
                                            <option value="imagesDesc" ${state.filters.sortBy === 'imagesDesc' ? 'selected' : ''}>Most Images</option>
                                            <option value="imagesAsc" ${state.filters.sortBy === 'imagesAsc' ? 'selected' : ''}>Fewest Images</option>
                                        </select>
                                    </div>
                                    <div class="flex-1 min-w-[200px]">
                                        <label class="text-xs font-medium text-gray-700 mb-1 block">Filter by Creator</label>
                                        <select onchange="setFilterCreator(this.value)" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-mauve-400 focus:outline-none">
                                            <option value="all" ${state.filters.createdBy === null ? 'selected' : ''}>All Creators</option>
                                            ${uniqueCreators.map(creator => `
                                                <option value="${creator.id}" ${state.filters.createdBy === creator.id ? 'selected' : ''}>${creator.name}</option>
                                            `).join('')}
                                        </select>
                                    </div>
                                    ${state.filters.createdBy || state.filters.sortBy !== 'newest' || state.filters.searchQuery ? `
                                        <div class="flex items-end">
                                            <button onclick="clearAllFilters()" class="bg-red-500 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-600 transition text-sm">
                                                Clear All Filters
                                            </button>
                                        </div>
                                    ` : ''}
                                    </div>
                                </div>
                        </div>
                    ` : ''}

                    ${state.isAllContestsSectionExpanded ? `
                        ${state.filters.createdBy || state.filters.searchQuery ? `
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 flex gap-2 items-center flex-wrap">
                                <span class="text-sm font-medium text-blue-800">Active Filters:</span>
                                ${state.filters.createdBy ? `
                                    <span class="bg-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs font-semibold flex items-center gap-1">
                                        Creator: ${uniqueCreators.find(c => c.id === state.filters.createdBy)?.name || 'Unknown'}
                                        <button onclick="setFilterCreator('all')" class="hover:text-blue-900">‚úï</button>
                                    </span>
                                ` : ''}
                                ${state.filters.searchQuery ? `
                                    <span class="bg-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs font-semibold flex items-center gap-1">
                                        Search: "${state.filters.searchQuery}"
                                        <button onclick="setSearchQuery('')" class="hover:text-blue-900">‚úï</button>
                                    </span>
                                ` : ''}
                            </div>
                        ` : ''}
                    ` : ''}

                    ${(() => {
                        // Combine filtered contests, mergers, extracts, and shortcakes into a unified list
                        // Mix them without any type priority
                        const allItems = [
                            ...filteredContests.map(c => ({ ...c, itemType: 'contest' })),
                            ...filteredMergers.map(m => ({ ...m, itemType: 'merger' })),
                            ...filteredExtracts.map(e => ({ ...e, itemType: 'extract' })),
                            ...filteredShortcakes.map(s => ({ ...s, itemType: 'shortcake' }))
                        ];

                        // Apply sorting based on selected sort option
                        allItems.sort((a, b) => {

                            // Get image/item counts
                            const getItemCount = (item) => {
                                if (item.images) return item.images.length;
                                if (item.imageIds) return item.imageIds.length;
                                // For mergers, calculate total images from all merged contests
                                if (item.itemType === 'merger' && item.contestIds) {
                                    const mergedContests = state.contests.filter(c => item.contestIds.includes(c.id));
                                    return mergedContests.reduce((sum, c) => sum + c.images.length, 0);
                                }
                                return 0;
                            };
                            const itemCountA = getItemCount(a);
                            const itemCountB = getItemCount(b);

                            // Get titles/names for sorting
                            const titleA = (a.title || a.name || '').toLowerCase();
                            const titleB = (b.title || b.name || '').toLowerCase();

                            // Get timestamps for date sorting
                            const getTimestamp = (item) => {
                                if (!item.createdAt) return 0;
                                return new Date(item.createdAt).getTime();
                            };

                            switch (state.filters.sortBy) {
                                case 'newest':
                                case 'dateDesc':
                                case 'withFolders':
                                    return getTimestamp(b) - getTimestamp(a);
                                case 'oldest':
                                case 'dateAsc':
                                    return getTimestamp(a) - getTimestamp(b);
                                case 'titleAsc':
                                    return titleA.localeCompare(titleB);
                                case 'titleDesc':
                                    return titleB.localeCompare(titleA);
                                case 'imagesDesc':
                                    return itemCountB - itemCountA;
                                case 'imagesAsc':
                                    return itemCountA - itemCountB;
                                default:
                                    return getTimestamp(b) - getTimestamp(a);
                            }
                        });

                        // Check if we should show folders (only when sort is withFolders and no filters)
                        const showFolders = state.filters.sortBy === 'withFolders' && !state.filters.createdBy && !state.filters.searchQuery;

                        if (showFolders && state.groups.length > 0 && state.isAllContestsSectionExpanded) {
                            // Get items that are in folders
                            const itemsInFolders = new Set();
                            state.groups.forEach(group => {
                                (group.items || []).forEach(item => {
                                    itemsInFolders.add(`${item.item_type}:${item.item_id}`);
                                });
                            });

                            // Get ungrouped items
                            const ungroupedItems = allItems.filter(item =>
                                !itemsInFolders.has(`${item.itemType}:${item.id}`)
                            );

                            // Sort folders
                            const sortedGroups = [...state.groups];

                            // Get unfoldered items position from app settings (default to bottom if not set)
                            const unfolderedPosition = state.appSettings.unfoldered_items_position !== undefined
                                ? parseInt(state.appSettings.unfoldered_items_position)
                                : sortedGroups.length;

                            // Helper function to render a folder
                            const renderFolder = (group) => {
                                const isExpanded = state.expandedFolderIds.includes(group.id);
                                // Get actual items for this folder
                                const folderItems = (group.items || []).map(item => {
                                    if (item.item_type === 'contest') {
                                        const contest = state.contests.find(c => c.id === item.item_id);
                                        return contest ? { ...contest, itemType: 'contest' } : null;
                                    } else if (item.item_type === 'merger') {
                                        const merger = state.mergers.find(m => m.id === item.item_id);
                                        return merger ? { ...merger, itemType: 'merger' } : null;
                                    } else if (item.item_type === 'extract') {
                                        const extract = state.extracts.find(e => e.id === item.item_id);
                                        return extract ? { ...extract, itemType: 'extract' } : null;
                                    } else if (item.item_type === 'shortcake') {
                                        const shortcake = state.shortcakes.find(s => s.id === item.item_id);
                                        return shortcake ? { ...shortcake, itemType: 'shortcake' } : null;
                                    }
                                    return null;
                                }).filter(Boolean);

                                const headerGradient = 'bg-gradient-to-r from-mauve-400 to-mauve-600 hover:from-mauve-500 hover:to-mauve-700';
                                const contentGradient = 'bg-gradient-to-b from-pink-50 to-pink-100';

                                return `
                                    <div class="bg-white rounded-xl shadow-lg overflow-hidden mb-2 md:mb-3 fade-in">
                                        <div class="${headerGradient} p-2.5 md:p-3 cursor-pointer transition" onclick="toggleFolderExpanded('${group.id}')">
                                            <div class="flex items-center gap-2 text-white">
                                                <svg class="w-5 h-5 transition-transform ${isExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                </svg>
                                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
                                                </svg>
                                                <div class="flex-1">
                                                    <h3 class="text-lg font-bold">${group.name}</h3>
                                                </div>
                                                <span class="text-sm opacity-90">${folderItems.length} items</span>
                                            </div>
                                        </div>
                                        ${isExpanded ? `
                                            <div class="p-2.5 md:p-3 ${contentGradient}">
                                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2">
                                                    ${folderItems.map(item => {
                                                        if (item.itemType === 'merger') {
                                                            return renderMergerCard(item);
                                                        } else if (item.itemType === 'extract') {
                                                            return renderExtractCard(item);
                                                        } else if (item.itemType === 'shortcake') {
                                                            return renderShortcakeCard(item);
                                                        } else {
                                                            return renderContestCard(item);
                                                        }
                                                    }).join('')}
                                                </div>
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            };

                            // Helper function to render unfoldered items
                            const renderUnfolderedItems = () => {
                                if (ungroupedItems.length === 0) return '';
                                return `
                                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2 mb-2 md:mb-3">
                                        ${ungroupedItems.map(item => {
                                            if (item.itemType === 'merger') {
                                                return renderMergerCard(item);
                                            } else if (item.itemType === 'extract') {
                                                return renderExtractCard(item);
                                            } else if (item.itemType === 'shortcake') {
                                                return renderShortcakeCard(item);
                                            } else {
                                                return renderContestCard(item);
                                            }
                                        }).join('')}
                                    </div>
                                `;
                            };

                            // Build the output with unfoldered items at the correct position
                            return `
                                ${(() => {
                                    let output = '';
                                    sortedGroups.forEach((group, index) => {
                                        // Insert unfoldered items before this folder if needed
                                        if (index === unfolderedPosition) {
                                            output += renderUnfolderedItems();
                                        }
                                        output += renderFolder(group);
                                    });
                                    // Insert unfoldered items at the end if position >= folder count
                                    if (unfolderedPosition >= sortedGroups.length) {
                                        output += renderUnfolderedItems();
                                    }
                                    return output;
                                })()}
                            `;
                        } else {
                            // Show flat list when not using default sort or when no folders exist
                            const displayItems = state.isAllContestsSectionExpanded ? allItems : allItems.slice(0, 6);

                            return `
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-1.5 md:gap-2 mb-2">
                                    ${displayItems.map(item => {
                                        if (item.itemType === 'merger') {
                                            return renderMergerCard(item);
                                        } else if (item.itemType === 'extract') {
                                            return renderExtractCard(item);
                                        } else if (item.itemType === 'shortcake') {
                                            return renderShortcakeCard(item);
                                        } else {
                                            return renderContestCard(item);
                                        }
                                    }).join('')}
                                </div>
                                ${allItems.length > 6 && !state.isAllContestsSectionExpanded ? `
                                    <button
                                        onclick="toggleAllContestsSection()"
                                        class="w-full text-center text-sm text-green-600 hover:text-green-700 font-medium py-2 bg-green-50 hover:bg-green-100 rounded-lg transition"
                                    >
                                        Show ${allItems.length - 6} more items
                                    </button>
                                ` : ''}
                            `;
                        }
                    })()}
                </div>
            `;
        }

        function renderContestInfoModal() {
            if (!state.contestInfoModal) return '';

            const { item, itemType, voters } = state.contestInfoModal;
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === item.createdBy;
            const canManageSettings = isAdmin || isCreator;

            // Format date
            const createdDate = formatDate(item.createdAt);

            // Get voter count display from actual voters
            const voterCount = voters ? voters.length : 0;

            // Get merged contests info (for mergers) and calculate image count
            let mergedContestsHTML = '';
            let imageCount = item.images?.length || item.imageIds?.length || 0;

            if (itemType === 'merger' && item.contestIds && item.contestIds.length > 0) {
                const mergedContests = state.contests.filter(c => item.contestIds.includes(c.id));
                // Calculate total images from all merged contests
                imageCount = mergedContests.reduce((sum, c) => sum + (c.images?.length || 0), 0);
                mergedContestsHTML = `
                    <details class="mt-2">
                        <summary class="cursor-pointer font-semibold text-gray-700 hover:text-mauve-600 transition">
                            Merged Contests (${mergedContests.length})
                        </summary>
                        <ul class="mt-2 ml-4 space-y-1">
                            ${mergedContests.map(c => `
                                <li class="text-sm text-gray-600">‚Ä¢ ${c.title}</li>
                            `).join('')}
                        </ul>
                    </details>
                `;
            }

            // Get source info (for extracts)
            let sourceHTML = '';
            if (itemType === 'extract' && item.sourceType) {
                let sourceItem = null;
                let sourceName = 'Unknown';

                if (item.sourceType === 'contest') {
                    sourceItem = state.contests.find(c => c.id === item.sourceContestId);
                    sourceName = sourceItem ? sourceItem.title : 'Unknown Contest';
                } else if (item.sourceType === 'merger') {
                    sourceItem = state.mergers.find(m => m.id === item.sourceMergerId);
                    sourceName = sourceItem ? sourceItem.name : 'Unknown Merger';
                } else if (item.sourceType === 'extract') {
                    sourceItem = state.extracts.find(e => e.id === item.sourceContestId);
                    sourceName = sourceItem ? sourceItem.name : 'Unknown Extract';
                }

                const sourceTypeLabel = item.sourceType === 'contest' ? 'contest' : item.sourceType === 'merger' ? 'merger' : 'extract';
                sourceHTML = `
                    <div class="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                        <span class="text-sm text-yellow-800">This is an extract from ${sourceTypeLabel === 'contest' ? 'another contest' : sourceTypeLabel}: <strong>${sourceName}</strong></span>
                    </div>
                `;
            }

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeContestInfoModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200 flex-shrink-0">
                            <div class="flex items-start justify-between gap-4">
                                <h2 class="text-2xl font-bold text-gray-800 flex-1">${item.title || item.name}</h2>
                                <button onclick="closeContestInfoModal()" class="p-2 hover:bg-gray-100 rounded-lg transition flex-shrink-0">
                                    <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Scrollable Content -->
                        <div class="flex-1 overflow-y-auto p-6">
                            <!-- Main Info Section -->
                            <div class="mb-6">
                                <div class="flex items-center gap-3 mb-3">
                                    <img src="${item.creatorAvatar}" alt="${item.creatorName}" class="w-12 h-12 rounded-full cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="viewUserProfile('${item.createdBy}')" />
                                    <div>
                                        <div class="font-semibold text-gray-800 cursor-pointer hover:text-mauve-600 transition" onclick="viewUserProfile('${item.createdBy}')">${item.creatorName}</div>
                                        <div class="text-sm text-gray-500">${createdDate || 'Date unknown'}</div>
                                    </div>
                                </div>
                                <div class="text-sm">
                                    <div class="flex items-center justify-between gap-4">
                                        <div class="flex items-center gap-1 whitespace-nowrap">
                                            <span class="font-semibold text-gray-700">Voters:</span>
                                            <span class="text-gray-600">${voterCount}üë•</span>
                                        </div>
                                        <div class="flex items-center gap-1 whitespace-nowrap">
                                            <span class="font-semibold text-gray-700">Images:</span>
                                            <span class="text-gray-600">${imageCount}üñºÔ∏è</span>
                                        </div>
                                    </div>
                                </div>
                                ${mergedContestsHTML}
                                ${sourceHTML}
                            </div>

                            <!-- User Completion Status (for contests and extracts) -->
                            ${itemType === 'contest' || itemType === 'extract' ? (() => {
                                const userVotes = state.userVotedContests[item.id] || {};
                                const votedImageCount = Object.keys(userVotes).length;
                                const totalImageCount = imageCount;
                                const completionRate = totalImageCount > 0 ? Math.round((votedImageCount / totalImageCount) * 100) : 0;
                                const isComplete = votedImageCount === totalImageCount && totalImageCount > 0;
                                const badgeColor = isComplete ? 'bg-green-200 text-green-800' : 'bg-yellow-200 text-yellow-800';

                                return `
                                    <div class="mb-6 p-4 bg-gray-50 rounded-lg">
                                        <h3 class="font-semibold text-gray-800 mb-2">Your Voting Progress</h3>
                                        <div class="flex items-center justify-between">
                                            <div class="text-sm text-gray-700">
                                                <span class="font-medium">Images completed voting on:</span>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <span class="text-sm font-semibold px-2 py-1 ${badgeColor} rounded">${votedImageCount}/${totalImageCount}</span>
                                                <span class="text-sm text-gray-600">(${completionRate}%)</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            })() : ''}

                            <!-- Actions Section (visible to all) -->
                            <div class="mb-6 p-4 bg-gray-50 rounded-lg">
                                <h3 class="font-semibold text-gray-800 mb-3">Actions</h3>
                                <button
                                    onclick="shareContestFromModal()"
                                    class="w-full px-4 py-2 bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg font-semibold hover:from-purple-600 hover:to-purple-700 transition shadow-md flex items-center justify-center gap-2"
                                >
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/>
                                    </svg>
                                    Share
                                </button>
                            </div>

                            <!-- Admin/Creator Settings Section -->
                            ${canManageSettings ? `
                                <div class="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                                    <h3 class="font-semibold text-gray-800 mb-3">Settings (Creator/Admin Only)</h3>
                                    <div class="space-y-3">
                                        <!-- Lock Toggle -->
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-2">
                                                <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                                                </svg>
                                                <span class="font-medium text-gray-700">Lock Contest</span>
                                            </div>
                                            <button
                                                onclick="toggleContestLock('${item.id}'); closeContestInfoModal();"
                                                class="px-3 py-1 rounded-lg font-semibold transition text-sm ${item.isLocked ? 'bg-black text-white hover:bg-gray-900' : 'bg-green-500 text-white hover:bg-green-600'}"
                                            >
                                                ${item.isLocked ? 'üîí Locked' : 'üîì Unlocked'}
                                            </button>
                                        </div>
                                        <!-- Results Visibility Toggle -->
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center gap-2">
                                                <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                                                </svg>
                                                <span class="font-medium text-gray-700">Results Visibility</span>
                                            </div>
                                            <button
                                                onclick="toggleResultsPublic('${item.id}'); closeContestInfoModal();"
                                                class="px-3 py-1 rounded-lg font-semibold transition text-sm ${item.resultsPublic !== false ? 'bg-green-500 text-white hover:bg-green-600' : 'bg-black text-white hover:bg-gray-900'}"
                                            >
                                                ${item.resultsPublic !== false ? 'üëÅÔ∏è Public' : 'üîí Private'}
                                            </button>
                                        </div>
                                        <!-- View Results Button (Bypass Voting) -->
                                        <button
                                            onclick="${itemType === 'merger' ? `adminViewMergerResults('${item.id}')` : itemType === 'extract' ? `adminViewExtractResults('${item.id}')` : `adminViewResults('${item.id}')`}; closeContestInfoModal();"
                                            class="w-full px-4 py-2 bg-gradient-to-r from-mauve-500 to-mauve-600 text-white rounded-lg font-semibold hover:from-mauve-600 hover:to-mauve-700 transition text-sm flex items-center justify-center gap-2"
                                        >
                                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                                            </svg>
                                            View Results (Bypass Voting)
                                        </button>
                                        <!-- Edit Extract Button (Extract Only) -->
                                        ${itemType === 'extract' ? `
                                            <button
                                                onclick="openEditExtractModal('${item.id}'); closeContestInfoModal();"
                                                class="w-full px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition text-sm"
                                            >
                                                ‚úèÔ∏è Edit Extract
                                            </button>
                                        ` : ''}
                                        <!-- Edit Merger Button (Merger Only) -->
                                        ${itemType === 'merger' ? `
                                            <button
                                                onclick="openEditMergerModal('${item.id}'); closeContestInfoModal();"
                                                class="w-full px-4 py-2 bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg font-semibold hover:from-purple-600 hover:to-purple-700 transition text-sm"
                                            >
                                                ‚úèÔ∏è Edit Merger
                                            </button>
                                        ` : ''}
                                        <!-- Edit Contest Button (Contest Only) -->
                                        ${itemType === 'contest' ? `
                                            <button
                                                onclick="openEditContestModal('${item.id}'); closeContestInfoModal();"
                                                class="w-full px-4 py-2 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-lg font-semibold hover:from-green-600 hover:to-green-700 transition text-sm"
                                            >
                                                ‚úèÔ∏è Add More Images
                                            </button>
                                        ` : ''}
                                        <!-- Delete Button -->
                                        <button
                                            onclick="${itemType === 'contest' ? `deleteContest('${item.id}')` : itemType === 'merger' ? `deleteMerger('${item.id}')` : `deleteExtract('${item.id}')`}; closeContestInfoModal();"
                                            class="w-full px-4 py-2 bg-red-500 text-white rounded-lg font-semibold hover:bg-red-600 transition text-sm"
                                        >
                                            üóëÔ∏è Delete ${itemType === 'contest' ? 'Contest' : itemType === 'merger' ? 'Merger' : 'Extract'}
                                        </button>
                                    </div>
                                </div>
            ` : ''}

                            <!-- Voters Section -->
                            <div class="p-4 bg-blue-50 rounded-lg">
                                <h3 class="font-semibold text-gray-800 mb-3">Users that have voted (${voters.length})</h3>
                                ${voters.length > 0 ? `
                                    ${itemType === 'merger' ? `
                                        ${(() => {
                                            const fullyCompletedCount = voters.filter(v => v.completedContests === v.totalContests).length;
                                            const completionRate = voters.length > 0 ? Math.round((fullyCompletedCount / voters.length) * 100) : 0;
                                            return `
                                                <div class="mb-3 p-2 bg-white rounded-lg border border-blue-200">
                                                    <div class="text-sm font-semibold text-gray-700">
                                                        Completion rate: <span class="text-blue-600">${completionRate}%</span>
                                                        <span class="text-xs text-gray-500 ml-2">(${fullyCompletedCount}/${voters.length} users)</span>
                                                    </div>
                                                </div>
                                            `;
                                        })()}
                                        <div class="mb-2 flex items-center justify-between px-2">
                                            <span class="text-xs font-medium text-gray-600">User</span>
                                            <span class="text-xs font-medium text-gray-600">Contests completed voting on</span>
                                        </div>
                                        <div class="space-y-2 max-h-64 overflow-y-auto">
                                            ${voters.map(voter => {
                                                const isComplete = voter.completedContests === voter.totalContests;
                                                const badgeColor = isComplete ? 'bg-green-200 text-green-800' : 'bg-yellow-200 text-yellow-800';
                                                return `
                                                    <div class="flex items-center gap-3 p-2 hover:bg-blue-100 rounded-lg transition cursor-pointer" onclick="viewUserProfile('${voter.id}')">
                                                        <img src="${voter.avatar}" alt="${voter.username}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                        <span class="text-sm font-medium text-gray-700 flex-1">${voter.username}</span>
                                                        <span class="text-xs font-semibold px-2 py-1 ${badgeColor} rounded">${voter.completedContests}/${voter.totalContests}</span>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : `
                                        ${(() => {
                                            // Calculate overall completion rate for contests/extracts
                                            const fullyCompletedCount = voters.filter(v => v.completedImages === v.totalImages).length;
                                            const completionRate = voters.length > 0 ? Math.round((fullyCompletedCount / voters.length) * 100) : 0;
                                            return `
                                                <div class="mb-3 p-2 bg-white rounded-lg border border-blue-200">
                                                    <div class="text-sm font-semibold text-gray-700">
                                                        Completion rate: <span class="text-blue-600">${completionRate}%</span>
                                                        <span class="text-xs text-gray-500 ml-2">(${fullyCompletedCount}/${voters.length} users)</span>
                                                    </div>
                                                </div>
                                            `;
                                        })()}
                                        <div class="mb-2 flex items-center justify-between px-2">
                                            <span class="text-xs font-medium text-gray-600">User</span>
                                            <span class="text-xs font-medium text-gray-600">Images completed voting on</span>
                                        </div>
                                        <div class="space-y-2 max-h-64 overflow-y-auto">
                                            ${voters.map(voter => {
                                                const isComplete = voter.completedImages === voter.totalImages;
                                                const badgeColor = isComplete ? 'bg-green-200 text-green-800' : 'bg-yellow-200 text-yellow-800';
                                                return `
                                                    <div class="flex items-center gap-3 p-2 hover:bg-blue-100 rounded-lg transition cursor-pointer" onclick="viewUserProfile('${voter.id}')">
                                                        <img src="${voter.avatar}" alt="${voter.username}" class="w-8 h-8 rounded-full flex-shrink-0" />
                                                        <span class="text-sm font-medium text-gray-700 flex-1">${voter.username}</span>
                                                        <span class="text-xs font-semibold px-2 py-1 ${badgeColor} rounded">${voter.completedImages}/${voter.totalImages}</span>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    `}
                                ` : `
                                    <p class="text-sm text-gray-600 text-center py-4">No votes yet</p>
                                `}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderUserProfileModal() {
            if (!state.showUserProfileModal) return '';

            const userId = state.viewingUserId;
            if (!userId) {
                return '';
            }

            // Find user info from allUsers or from contest data
            let userInfo = state.allUsers.find(u => u.id === userId);

            // If not in allUsers, try to find from contest votes
            if (!userInfo) {
                // Look through all contests to find this user's votes
                for (const contest of state.contests) {
                    const votes = contest.votes || [];
                    const vote = votes.find(v => v.userId === userId);
                    if (vote) {
                        userInfo = { id: userId, username: vote.username, avatar: vote.avatar };
                        break;
                    }
                }
            }

            if (!userInfo) {
                return `
                    <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeUserProfileModal()">
                        <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 modal-content flex flex-col" onclick="event.stopPropagation()">
                            <div class="text-center">
                                <p class="text-xl font-bold text-gray-800 mb-4">User Not Found</p>
                                <p class="text-gray-600 mb-6">The requested user profile could not be loaded.</p>
                                <button onclick="closeUserProfileModal()" class="bg-mauve-500 text-white px-6 py-2 rounded-lg hover:bg-mauve-600 transition">
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Find items created by this user
            const createdContests = state.contests.filter(c => c.createdBy === userId);
            const createdMergers = state.mergers.filter(m => m.createdBy === userId);
            const createdExtracts = state.extracts.filter(e => e.createdBy === userId);

            // Find items voted on by this user (using fetched vote data)
            const userVotedContestIds = state.userProfileVotedContests || [];

            // Get contests this user has voted on (INCLUDING ones they created)
            const votedContests = state.contests.filter(contest =>
                userVotedContestIds.includes(contest.id)
            );

            // Get mergers where user voted on source contests (INCLUDING ones they created)
            const votedMergers = state.mergers.filter(merger => {
                const sourceContestIds = merger.contestIds || [];
                return sourceContestIds.some(contestId => userVotedContestIds.includes(contestId));
            });

            // Get extracts where user voted on source (INCLUDING ones they created)
            const votedExtracts = state.extracts.filter(extract => {
                if (extract.sourceType === 'contest') {
                    return userVotedContestIds.includes(extract.sourceContestId);
                } else if (extract.sourceType === 'merger') {
                    const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                    if (!merger) return false;
                    const sourceContestIds = merger.contestIds || [];
                    return sourceContestIds.some(contestId => userVotedContestIds.includes(contestId));
                }
                return false;
            });

            const allCreatedItems = [
                ...createdContests.map(c => ({ ...c, itemType: 'contest' })),
                ...createdMergers.map(m => ({ ...m, itemType: 'merger' })),
                ...createdExtracts.map(e => ({ ...e, itemType: 'extract' }))
            ];

            const allVotedItems = [
                ...votedContests.map(c => ({ ...c, itemType: 'contest' })),
                ...votedMergers.map(m => ({ ...m, itemType: 'merger' })),
                ...votedExtracts.map(e => ({ ...e, itemType: 'extract' }))
            ];

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isBanned = state.bannedUsers.includes(userId);
            const isCurrentUser = state.user && state.user.id === userId;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && closeUserProfileModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden modal-content flex flex-col" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="p-6 border-b border-gray-200 flex-shrink-0">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-2xl font-bold text-gray-800">User Profile</h3>
                                <button onclick="closeUserProfileModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="flex items-center gap-4">
                                <img src="${userInfo.avatar}" alt="${userInfo.username}" class="w-20 h-20 rounded-full" />
                                <div class="flex-1">
                                    <h2 class="text-2xl font-bold text-gray-800">${userInfo.username}</h2>
                                    <p class="text-gray-600">${isCurrentUser ? '(You)' : ''} ${isBanned ? 'üö´ BANNED' : ''}</p>
                                    <p class="text-sm text-gray-500 mt-1">
                                        Created ${allCreatedItems.length} ${allCreatedItems.length === 1 ? 'item' : 'items'} ‚Ä¢
                                        Voted in ${allVotedItems.length} ${allVotedItems.length === 1 ? 'item' : 'items'}
                                    </p>
                                </div>
                            </div>
                        </div>

                        <!-- Scrollable content -->
                        <div class="flex-1 overflow-y-auto p-6">
                            <!-- Created Items Section -->
                            ${allCreatedItems.length > 0 ? `
                                <div class="mb-6">
                                    <h3 class="text-lg font-bold text-gray-800 mb-3">Items Created (${allCreatedItems.length})</h3>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                        ${allCreatedItems.map(item => {
                                            const title = item.title || item.name;
                                            const colorClass = item.itemType === 'merger' ? 'text-blue-700' :
                                                              item.itemType === 'extract' ? 'text-yellow-700' :
                                                              'text-gray-700';
                                            const hoverClass = item.itemType === 'merger' ? 'hover:text-blue-900 hover:bg-blue-50' :
                                                              item.itemType === 'extract' ? 'hover:text-yellow-900 hover:bg-yellow-50' :
                                                              'hover:text-mauve-600 hover:bg-gray-50';
                                            return `
                                                <div class="text-sm ${colorClass} ${hoverClass} transition p-2 rounded font-medium">
                                                    ‚Ä¢ ${title}
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                            ` : ''}

                            <!-- Voting History Section -->
                            <div class="mb-4">
                                <h3 class="text-lg font-bold text-gray-800 mb-3">Items Voted On (${allVotedItems.length})</h3>
                            </div>

                            ${allVotedItems.length === 0 ? `
                                <div class="bg-gray-50 rounded-lg p-8 text-center">
                                    <p class="text-gray-500">No voting history yet</p>
                                </div>
                            ` : `
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                    ${allVotedItems.map(item => {
                                        const title = item.title || item.name;
                                        const colorClass = item.itemType === 'merger' ? 'text-blue-700' :
                                                          item.itemType === 'extract' ? 'text-yellow-700' :
                                                          'text-gray-700';
                                        const hoverClass = item.itemType === 'merger' ? 'hover:text-blue-900 hover:bg-blue-50' :
                                                          item.itemType === 'extract' ? 'hover:text-yellow-900 hover:bg-yellow-50' :
                                                          'hover:text-mauve-600 hover:bg-gray-50';
                                        return `
                                            <div class="text-sm ${colorClass} ${hoverClass} transition p-2 rounded font-medium">
                                                ‚Ä¢ ${title}
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            `}
                        </div>

                        <!-- Footer with ban button -->
                        ${isAdmin && !isCurrentUser && !isBanned ? `
                            <div class="p-4 border-t border-gray-200 flex-shrink-0">
                                <button onclick="confirmBanUser('${userId}', '${userInfo.username}')" class="w-full bg-red-500 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-600 transition">
                                    üö´ Ban User
                                </button>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function renderContestCard(contest, isPinned = false, unvotedLabel = null) {
                        try {
                                const userVotes = state.userVotedContests[contest.id] || {};
                                const votedImageCount = Object.keys(userVotes).length;
                                const totalImageCount = contest.images.length;
                                const hasVotedAll = votedImageCount === totalImageCount && totalImageCount > 0;
                                const hasVotedSome = votedImageCount > 0 && votedImageCount < totalImageCount;
                                const hasVotedNone = votedImageCount === 0;
                            const canDelete = canDeleteContest(contest);
                            const isBanned = state.bannedUsers.includes(state.user.id);
                            const createdDate = formatDate(contest.createdAt);
                            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

                            return `
                                <div class="bg-white rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative border-2 border-gray-300">
                                    ${unvotedLabel ? `
                                        <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-yellow-500 text-white text-xs font-bold px-3 py-1 rounded-full shadow-lg whitespace-nowrap z-10">
                                            ${unvotedLabel}
                                        </div>
                                    ` : ''}
                                    ${isAdmin && state.appSettings.show_pin_icons ? `
                                        <button
                                            onclick="togglePin(event, 'contest', '${contest.id}', ${isPinned})"
                                            class="absolute top-3 right-3 ${isPinned ? 'bg-red-800 hover:bg-red-900' : 'bg-red-50 hover:bg-red-100'} ${isPinned ? 'text-white' : 'text-red-800'} p-1 rounded-full shadow-lg transition z-10"
                                            title="${isPinned ? 'Unpin contest' : 'Pin contest'}"
                                        >
                                            üìå
                                        </button>
                                    ` : ''}
                                    ${contest.isLocked ? `
                                        <div class="absolute top-3 ${isAdmin ? (contest.resultsPublic === false ? 'right-20' : 'right-11') : (contest.resultsPublic === false ? 'right-12' : 'right-3')} bg-black text-white p-1.5 rounded-full shadow-lg" title="Contest is locked">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                                            </svg>
                                        </div>
                                    ` : ''}
                                    ${contest.resultsPublic === false ? `
                                        <div class="absolute top-3 ${isAdmin ? 'right-11' : 'right-3'} bg-gray-800 text-white p-1.5 rounded-full shadow-lg" title="Results are hidden">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L6.5 6.5m12.975 12.975L16.121 16.12m0 0l-4.243-4.243m0 0L9.5 9.5M3.5 3.5l5.378 5.378m0 0a3 3 0 014.243 4.243L9.878 9.878z"/>
                                            </svg>
                                        </div>
                                    ` : ''}
                                    <div class="flex items-start gap-2 mb-2">
                                        <img src="${contest.creatorAvatar}" alt="${contest.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${contest.createdBy}');" />
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2">
                                                <h3 class="text-base font-bold text-gray-800 truncate">${contest.title}</h3>
                                            </div>
                                            <div class="text-xs text-gray-500 flex items-center gap-2 flex-wrap">
                                                <span class="truncate">by <span class="cursor-pointer hover:text-mauve-600 transition" onclick="event.stopPropagation(); viewUserProfile('${contest.createdBy}');">${contest.creatorName}</span></span>
                                                <span class="ml-auto whitespace-nowrap">${contest.voterCount || 0}üë• ${contest.images.length}üñºÔ∏è</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="flex gap-2">
                                        ${isBanned ? `
                                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                                üö´ Account restricted
                                            </div>
                                        ` : contest.isLocked ? `
                                            <button
                                                onclick='viewLockedResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : hasVotedAll ? `
                                            <button
                                                onclick='startRevoteFromHome(${safeStringify(contest)})'
                                                class="flex-[0.5] bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                                            >
                                                Revote
                                            </button>
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-[1.5] bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : hasVotedSome ? `
                                            <button
                                                onclick='showContestVoteModal("${contest.id}")'
                                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                                            >
                                                Complete Voting
                                            </button>
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : hasVotedNone ? `
                                            <button
                                                onclick='startVoting(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                                            >
                                                Start Voting
                                            </button>
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        ` : `
                                            <button
                                                onclick='startVoting(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                                            >
                                                Start Voting
                                            </button>
                                            <button
                                                onclick='viewResults(${safeStringify(contest)})'
                                                class="flex-1 bg-gradient-to-r ${contest.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${contest.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                                            >
                                                View Results
                                            </button>
                                        `}
                                        <button
                                            onclick='showContestInfoModal(${safeStringify(contest)}, "contest")'
                                            class="bg-gradient-to-r from-blue-500 to-blue-600 text-white px-3 py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm flex items-center gap-1"
                                            title="Contest Info"
                                        >
                                            ‚ÑπÔ∏è
                                        </button>
                                    </div>
                                </div>
                            `;
                            } catch (error) {
                                console.error('Error rendering contest:', contest?.id, error);
                                return ''; // Skip this contest and continue
                            }
        }

        function renderMergerCard(merger, isPinned = false, unvotedLabel = null) {
            // Get contest details for the merged contests
            const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
            const totalImages = mergedContests.reduce((sum, c) => sum + c.images.length, 0);

            // Check if user has voted on ALL images in ALL contests
            const contestVotingStatus = mergedContests.map(c => {
                const userVotes = state.userVotedContests[c.id] || {};
                const votedImageCount = Object.keys(userVotes).length;
                const totalImageCount = c.images.length;
                return {
                    contest: c,
                    hasVotedAll: votedImageCount === totalImageCount && totalImageCount > 0,
                    hasVotedSome: votedImageCount > 0 && votedImageCount < totalImageCount
                };
            });

            const fullyVotedContests = contestVotingStatus.filter(cs => cs.hasVotedAll);
            const partiallyVotedContests = contestVotingStatus.filter(cs => cs.hasVotedSome);

            const hasVotedAll = fullyVotedContests.length === mergedContests.length && mergedContests.length > 0;
            const hasVotedSome = (fullyVotedContests.length > 0 || partiallyVotedContests.length > 0) && !hasVotedAll;
            const hasVotedNone = fullyVotedContests.length === 0 && partiallyVotedContests.length === 0;

            const isBanned = state.bannedUsers.includes(state.user.id);
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

            return `
                <div class="bg-blue-50 border-2 border-blue-300 rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative">
                    ${unvotedLabel ? `
                        <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-yellow-500 text-white text-xs font-bold px-3 py-1 rounded-full shadow-lg whitespace-nowrap z-10">
                            ${unvotedLabel}
                        </div>
                    ` : ''}
                    ${isAdmin && state.appSettings.show_pin_icons ? `
                        <button
                            onclick="togglePin(event, 'merger', '${merger.id}', ${isPinned})"
                            class="absolute top-3 right-3 ${isPinned ? 'bg-red-800 hover:bg-red-900' : 'bg-red-50 hover:bg-red-100'} ${isPinned ? 'text-white' : 'text-red-800'} p-1 rounded-full shadow-lg transition z-10"
                            title="${isPinned ? 'Unpin merger' : 'Pin merger'}"
                        >
                            üìå
                        </button>
                    ` : ''}
                    ${merger.isLocked ? `
                        <div class="absolute top-3 ${isAdmin ? (merger.resultsPublic === false ? 'right-20' : 'right-11') : (merger.resultsPublic === false ? 'right-12' : 'right-3')} bg-black text-white p-1.5 rounded-full shadow-lg" title="Merger is locked">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                            </svg>
                        </div>
                    ` : ''}
                    ${merger.resultsPublic === false ? `
                        <div class="absolute top-3 ${isAdmin ? 'right-11' : 'right-3'} bg-gray-800 text-white p-1.5 rounded-full shadow-lg" title="Results are hidden">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L6.5 6.5m12.975 12.975L16.121 16.12m0 0l-4.243-4.243m0 0L9.5 9.5M3.5 3.5l5.378 5.378m0 0a3 3 0 014.243 4.243L9.878 9.878z"/>
                            </svg>
                        </div>
                    ` : ''}
                    <div class="flex items-start gap-2 mb-2">
                        <img src="${merger.creatorAvatar}" alt="${merger.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-blue-400 transition" onclick="event.stopPropagation(); viewUserProfile('${merger.createdBy}');" />
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h3 class="text-base font-bold text-blue-900 truncate">${merger.name}</h3>
                            </div>
                            <div class="text-xs text-blue-700 flex items-center gap-2 flex-wrap">
                                <span class="truncate">by <span class="cursor-pointer hover:text-blue-900 transition" onclick="event.stopPropagation(); viewUserProfile('${merger.createdBy}');">${merger.creatorName}</span></span>
                                <span class="ml-auto whitespace-nowrap">${merger.voterCount || 0}üë• ${totalImages}üñºÔ∏è</span>
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-2">
                        ${isBanned ? `
                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                üö´ Account restricted
                            </div>
                        ` : hasVotedAll ? `
                            <button
                                onclick='startMergerVoting("${merger.id}", true)'
                                class="flex-[0.5] bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                            >
                                Revote
                            </button>
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-[1.5] bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedSome ? `
                            <button
                                onclick='showMergerVoteModal("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                            >
                                Complete Voting
                            </button>
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedNone ? `
                            <button
                                onclick='startMergerVoting("${merger.id}")'
                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                            >
                                Start Voting
                            </button>
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : `
                            <button
                                onclick='viewMergerResults("${merger.id}")'
                                class="flex-1 bg-gradient-to-r ${merger.resultsPublic === false ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${merger.resultsPublic === false ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        `}
                        <button
                            onclick='showContestInfoModal(${safeStringify(merger)}, "merger")'
                            class="bg-gradient-to-r from-blue-300 to-blue-500 text-white px-3 py-2 rounded-lg font-semibold hover:from-blue-400 hover:to-blue-600 transition shadow-md text-sm flex items-center gap-1"
                            title="Merger Info"
                        >
                            ‚ÑπÔ∏è
                        </button>
                    </div>
                </div>
            `;
        }

        function renderExtractCard(extract, isPinned = false, unvotedLabel = null) {
            // Get source reference
            let sourceRef = 'Unknown';
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                sourceRef = sourceContest ? sourceContest.title : 'Unknown Contest';
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                sourceRef = sourceMerger ? sourceMerger.name : 'Unknown Merger';
            } else if (extract.sourceType === 'extract') {
                const sourceExtract = state.extracts.find(e => e.id === extract.sourceContestId);
                sourceRef = sourceExtract ? sourceExtract.name : 'Unknown Extract';
            }

            // Check if user has voted on this extract
            // For extracts, we need to check if user has voted on ALL images in the extract
            let hasVotedAll = false;
            let hasVotedSome = false;
            let hasVotedNone = true;
            let sourceFullyVoted = false; // Track if origin contest/merger was already fully voted
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;

            if (extract.sourceType === 'contest' && extract.sourceContestId) {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                const userVotes = state.userVotedContests[extract.sourceContestId] || {};
                const votedImageIds = Object.keys(userVotes).map(id => parseInt(id));
                const votedCount = extract.imageIds.filter(imageId => votedImageIds.includes(imageId)).length;

                // Check if the source contest itself has been fully voted
                if (sourceContest) {
                    const totalVotedInContest = Object.keys(userVotes).length;
                    sourceFullyVoted = totalVotedInContest === sourceContest.images.length && sourceContest.images.length > 0;
                }

                hasVotedAll = votedCount === extract.imageIds.length && extract.imageIds.length > 0;
                hasVotedSome = votedCount > 0 && votedCount < extract.imageIds.length;
                hasVotedNone = votedCount === 0;
            } else if (extract.sourceType === 'merger' && extract.sourceMergerId) {
                // For mergers, check if user has voted on all images from any of the merged contests
                const merger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (merger) {
                    // Check if the source merger itself has been fully voted
                    const mergedContests = state.contests.filter(c => merger.contestIds.includes(c.id));
                    const contestVotingStatus = mergedContests.map(c => {
                        const userVotes = state.userVotedContests[c.id] || {};
                        const votedImageCount = Object.keys(userVotes).length;
                        const totalImageCount = c.images.length;
                        return votedImageCount === totalImageCount && totalImageCount > 0;
                    });
                    sourceFullyVoted = contestVotingStatus.every(voted => voted) && mergedContests.length > 0;

                    // Check if user has voted on all extract images across all merged contests
                    let allVotedImageIds = [];
                    merger.contestIds.forEach(contestId => {
                        const userVotes = state.userVotedContests[contestId] || {};
                        allVotedImageIds.push(...Object.keys(userVotes).map(id => parseInt(id)));
                    });
                    const votedCount = extract.imageIds.filter(imageId => allVotedImageIds.includes(imageId)).length;

                    hasVotedAll = votedCount === extract.imageIds.length && extract.imageIds.length > 0;
                    hasVotedSome = votedCount > 0 && votedCount < extract.imageIds.length;
                    hasVotedNone = votedCount === 0;
                }
            }

            const imageCount = extract.imageIds.length;
            const isBanned = state.bannedUsers.includes(state.user.id);
            const createdDate = formatDate(extract.createdAt);

            // Check if source has private results
            let hasPrivateResults = false;
            if (extract.sourceType === 'contest') {
                const sourceContest = state.contests.find(c => c.id === extract.sourceContestId);
                if (sourceContest && sourceContest.resultsPublic === false) {
                    hasPrivateResults = true;
                }
            } else if (extract.sourceType === 'merger') {
                const sourceMerger = state.mergers.find(m => m.id === extract.sourceMergerId);
                if (sourceMerger && sourceMerger.resultsPublic === false) {
                    hasPrivateResults = true;
                }
            }

            return `
                <div class="bg-yellow-50 border-2 border-yellow-400 rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative">
                    ${unvotedLabel ? `
                        <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-yellow-500 text-white text-xs font-bold px-3 py-1 rounded-full shadow-lg whitespace-nowrap z-10">
                            ${unvotedLabel}
                        </div>
                    ` : ''}
                    ${isAdmin && state.appSettings.show_pin_icons ? `
                        <button
                            onclick="togglePin(event, 'extract', '${extract.id}', ${isPinned})"
                            class="absolute top-3 right-3 ${isPinned ? 'bg-red-800 hover:bg-red-900' : 'bg-red-50 hover:bg-red-100'} ${isPinned ? 'text-white' : 'text-red-800'} p-1 rounded-full shadow-lg transition z-10"
                            title="${isPinned ? 'Unpin extract' : 'Pin extract'}"
                        >
                            üìå
                        </button>
                    ` : ''}
                    ${extract.isLocked ? `
                        <div class="absolute top-3 ${isAdmin ? (extract.resultsPublic === false ? 'right-20' : 'right-11') : (extract.resultsPublic === false ? 'right-12' : 'right-3')} bg-black text-white p-1.5 rounded-full shadow-lg" title="Extract is locked">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                            </svg>
                        </div>
                    ` : ''}
                    ${extract.resultsPublic === false ? `
                        <div class="absolute top-3 ${isAdmin ? 'right-11' : 'right-3'} bg-gray-800 text-white p-1.5 rounded-full shadow-lg" title="Results are hidden">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L6.5 6.5m12.975 12.975L16.121 16.12m0 0l-4.243-4.243m0 0L9.5 9.5M3.5 3.5l5.378 5.378m0 0a3 3 0 014.243 4.243L9.878 9.878z"/>
                            </svg>
                        </div>
                    ` : ''}
                    <div class="flex items-start gap-2 mb-2">
                        <img src="${extract.creatorAvatar}" alt="${extract.creatorName}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-yellow-400 transition" onclick="event.stopPropagation(); viewUserProfile('${extract.createdBy}');" />
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h3 class="text-base font-bold text-yellow-900 truncate">${extract.name}</h3>
                            </div>
                            <div class="text-xs text-yellow-700 flex items-center gap-2 flex-wrap">
                                <span class="truncate">by <span class="cursor-pointer hover:text-yellow-900 transition" onclick="event.stopPropagation(); viewUserProfile('${extract.createdBy}');">${extract.creatorName}</span></span>
                                <span class="ml-auto whitespace-nowrap">${extract.voterCount || 0}üë• ${imageCount}üñºÔ∏è</span>
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-2">
                        ${isBanned ? `
                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                üö´ Account restricted
                            </div>
                        ` : sourceFullyVoted ? `
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedAll ? `
                            <button
                                onclick='startExtractVoting("${extract.id}", true)'
                                class="flex-[0.5] bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 transition shadow-md text-sm"
                            >
                                Revote
                            </button>
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-[1.5] bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedSome ? `
                            <button
                                onclick='startExtractVoting("${extract.id}", false)'
                                class="flex-1 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white py-2 rounded-lg font-semibold hover:from-yellow-600 hover:to-yellow-700 transition shadow-md text-sm"
                            >
                                Complete Voting
                            </button>
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : hasVotedNone ? `
                            <button
                                onclick='showExtractVotingRedirectModal("${extract.id}")'
                                class="flex-1 bg-gradient-to-r from-mauve-400 to-mauve-600 text-white py-2 rounded-lg font-semibold hover:from-mauve-500 hover:to-mauve-700 transition shadow-md text-sm"
                            >
                                Start Voting
                            </button>
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        ` : `
                            <button
                                onclick='viewExtractResults("${extract.id}")'
                                class="flex-1 bg-gradient-to-r ${hasPrivateResults ? 'from-gray-800 to-black' : 'from-blue-500 to-blue-600'} text-white py-2 rounded-lg font-semibold hover:${hasPrivateResults ? 'from-gray-900 to-gray-800' : 'from-blue-600 to-blue-700'} transition shadow-md text-sm"
                            >
                                View Results
                            </button>
                        `}
                        <button
                            onclick='showContestInfoModal(${safeStringify(extract)}, "extract")'
                            class="bg-gradient-to-r from-blue-400 to-blue-600 text-white px-3 py-2 rounded-lg font-semibold hover:from-blue-500 hover:to-blue-700 transition shadow-md text-sm flex items-center gap-1"
                            title="Extract Info"
                        >
                            ‚ÑπÔ∏è
                        </button>
                    </div>
                </div>
            `;
        }

        function renderShortcakeCard(shortcake, isPinned = false) {
            const isBanned = state.bannedUsers.includes(state.user.id);
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const imageCount = shortcake.images.length;

            return `
                <div class="bg-gradient-to-r from-amber-50 to-amber-100 border-2 border-amber-700 rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition fade-in p-4 relative">
                    ${isAdmin && state.appSettings.show_pin_icons ? `
                        <button
                            onclick="togglePin(event, 'shortcake', '${shortcake.id}', ${isPinned})"
                            class="absolute top-3 right-3 ${isPinned ? 'bg-red-800 hover:bg-red-900' : 'bg-red-50 hover:bg-red-100'} ${isPinned ? 'text-white' : 'text-red-800'} p-1 rounded-full shadow-lg transition z-10"
                            title="${isPinned ? 'Unpin shortcake' : 'Pin shortcake'}"
                        >
                            üìå
                        </button>
                    ` : ''}
                    ${shortcake.isLocked ? `
                        <div class="absolute top-3 ${isAdmin ? (shortcake.resultsPublic === false ? 'right-20' : 'right-11') : (shortcake.resultsPublic === false ? 'right-12' : 'right-3')} bg-black text-white p-1.5 rounded-full shadow-lg" title="Shortcake is locked">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                            </svg>
                        </div>
                    ` : ''}
                    ${shortcake.resultsPublic === false ? `
                        <div class="absolute top-3 ${isAdmin ? 'right-11' : 'right-3'} bg-gray-800 text-white p-1.5 rounded-full shadow-lg" title="Results are hidden">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L6.5 6.5m12.975 12.975L16.121 16.12m0 0l-4.243-4.243m0 0L9.5 9.5M3.5 3.5l5.378 5.378m0 0a3 3 0 014.243 4.243L9.878 9.878z"/>
                            </svg>
                        </div>
                    ` : ''}
                    <div class="flex items-start gap-2 mb-2">
                        <div class="text-2xl flex-shrink-0">üç∞</div>
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <h3 class="text-base font-bold text-amber-900 truncate">${shortcake.title}</h3>
                            </div>
                            <div class="flex items-center gap-2 mb-1">
                                <img src="${shortcake.creatorAvatar}" alt="${shortcake.creatorName}" class="w-6 h-6 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-amber-400 transition" onclick="event.stopPropagation(); viewUserProfile('${shortcake.createdBy}');" />
                                <span class="text-xs text-amber-700 truncate cursor-pointer hover:text-amber-900 transition" onclick="event.stopPropagation(); viewUserProfile('${shortcake.createdBy}');">${shortcake.creatorName}</span>
                            </div>
                            <div class="text-xs text-amber-700 flex items-center gap-2 flex-wrap">
                                <span class="whitespace-nowrap">${shortcake.voterCount || 0}üë•</span>
                                <span class="whitespace-nowrap">${imageCount} images</span>
                            </div>
                            <div class="text-xs text-amber-600 mt-1">
                                <span>Shortlist ${shortcake.min}-${shortcake.max} images</span>
                            </div>
                        </div>
                    </div>

                    <div class="flex gap-2">
                        ${isBanned ? `
                            <div class="flex-1 bg-red-100 border border-red-400 text-red-700 py-2 rounded-lg text-center text-xs">
                                üö´ Account restricted
                            </div>
                        ` : `
                            <button
                                onclick='alert("Shortcake voting coming soon!")'
                                class="flex-1 bg-gradient-to-r from-amber-500 to-amber-600 text-white py-2 rounded-lg font-semibold hover:from-amber-600 hover:to-amber-700 transition shadow-md text-sm"
                            >
                                Vote
                            </button>
                        `}
                        <button
                            onclick='alert("Shortcake info modal coming soon!")'
                            class="bg-gradient-to-r from-amber-600 to-amber-700 text-white px-3 py-2 rounded-lg font-semibold hover:from-amber-700 hover:to-amber-800 transition shadow-md text-sm flex items-center gap-1"
                            title="Shortcake Info"
                        >
                            ‚ÑπÔ∏è
                        </button>
                    </div>
                </div>
            `;
        }

        function renderCreateContest() {
            const isEditMode = !!state.editingContestId;
            const newImagesCount = isEditMode
                ? state.newContest.images.filter(img => !img.isExisting).length
                : state.newContest.images.length;

            return `
                <div class="max-w-5xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="flex justify-between items-center mb-4">
                            <div>
                                <h2 class="text-2xl font-bold text-gray-800">${isEditMode ? 'Edit Contest: ' : ''}${state.newContest.title}</h2>
                                ${isEditMode ? `<p class="text-sm text-gray-600 mt-1">Adding images to existing contest (${newImagesCount} new image(s))</p>` : ''}
                            </div>
                            <button onclick="${isEditMode ? 'cancelEditContest()' : 'cancelCreateContest()'}" class="text-gray-600 hover:text-gray-800 flex items-center gap-1 text-sm">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                                Cancel
                            </button>
                        </div>

                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                            <h3 class="font-bold text-blue-900 mb-2 flex items-center gap-2 text-sm">
                                <span class="text-xl">üì∏</span>
                                How to Add Images
                            </h3>
                            <p class="text-xs text-blue-800 mb-1">
                                üíª <strong>Desktop:</strong> Click image ‚Üí Right-click ‚Üí Copy image link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üì± <strong>Mobile:</strong> Open image ‚Üí Share ‚Üí Copy link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üìÅ <strong>Or:</strong> Click "Upload Image Files" or drag & drop files (max 10MB each, multiple files supported)
                            </p>
                            <p class="text-xs text-green-800 font-semibold">
                                ‚ö° Uploaded files are automatically compressed to 1000 KB max to optimize loading speed
                            </p>
                        </div>

                        <div class="bg-yellow-50 border border-yellow-300 rounded-lg p-3 mb-4">
                            <p class="text-xs text-yellow-800">
                                ‚ö†Ô∏è <strong>Warning:</strong> Discord image URLs expire after 24 hours. Use permanent image hosting (Imgur, etc.) or upload files directly.
                            </p>
                        </div>

                        <div class="mb-4">
                            <input type="url" id="contestUrlInput" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg text-sm mb-2" placeholder="Paste Discord image URL or any image URL...">
                            <div class="flex gap-2 mb-2">
                                <button onclick="clearUrlInput()" class="flex-1 bg-gray-500 text-white py-2 rounded-lg font-semibold hover:bg-gray-600 transition text-sm">
                                    Clear Text Field
                                </button>
                                <button onclick="addImageFromUrl('contestUrlInput')" class="flex-1 bg-gradient-to-r from-pink-500 to-rose-600 text-white py-2 rounded-lg font-semibold hover:from-pink-600 hover:to-rose-700 transition text-sm">
                                    Add URL
                                </button>
                            </div>
                            <div class="flex items-center gap-2 mb-3">
                                <span class="text-sm text-gray-600 font-medium">or</span>
                                <input type="file" id="contestFileInput" accept="image/jpeg,image/png,image/gif,image/webp" multiple class="hidden" onchange="handleFileSelect(this)">
                                <button onclick="document.getElementById('contestFileInput').click()" class="flex-1 bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-indigo-700 transition text-sm flex items-center justify-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                    </svg>
                                    Upload Image Files
                                </button>
                            </div>
                            <div
                                id="dropZone"
                                class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center bg-gray-50 hover:border-blue-400 hover:bg-blue-50 transition cursor-pointer"
                                ondragover="handleDragOver(event)"
                                ondragleave="handleDragLeave(event)"
                                ondrop="handleDrop(event)"
                                onclick="document.getElementById('contestFileInput').click()"
                            >
                                <svg class="w-12 h-12 mx-auto mb-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <p class="text-sm text-gray-600 font-medium mb-1">Drag & drop images here</p>
                                <p class="text-xs text-gray-500">or click to browse files</p>
                            </div>
                        </div>

                        <div class="flex items-center justify-between mb-3 p-3 bg-gray-50 rounded-lg">
                            <div class="text-sm font-semibold text-gray-800">
                                ${state.newContest.images.length} / 100 images added
                            </div>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 min-h-[100px]">
                            ${state.newContest.images.length === 0 ? `
                                <div class="col-span-full text-center text-gray-400 py-8 text-sm italic">
                                    No images added yet
                                </div>
                            ` : state.newContest.images.map((img, index) => `
                                <div class="relative group">
                                    <img src="${img.url}" class="w-full h-48 object-contain rounded-lg bg-gray-100" />
                                    ${img.isExisting ? `
                                        <div class="absolute top-1 right-1 bg-blue-500 text-white px-2 py-1 rounded text-xs shadow-lg">
                                            Existing
                                        </div>
                                    ` : `
                                        <button onclick="removeContestImage(${index})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition shadow-lg">
                                            √ó
                                        </button>
                                    `}
                                    ${img.compressedSize ? `
                                        <div class="text-xs text-center text-gray-600 mt-1 font-medium">
                                            ${formatFileSize(img.compressedSize)}
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>

                        <button
                            onclick="finishCreateContest()"
                            ${(isEditMode ? newImagesCount : state.newContest.images.length) === 0 ? 'disabled' : ''}
                            class="w-full bg-gradient-to-r from-green-500 to-green-700 text-white py-3 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                        >
                            ${isEditMode ? `Add Images (${newImagesCount} new)` : `Create Contest (${state.newContest.images.length} images)`}
                        </button>
                    </div>
                </div>
            `;
        }

        function renderCreateShortcake() {
            return `
                <div class="max-w-5xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="flex justify-between items-center mb-4">
                            <div>
                                <h2 class="text-2xl font-bold text-amber-900">üç∞ ${state.newShortcake.title || 'Create Shortcake'}</h2>
                                <p class="text-sm text-gray-600 mt-1">Shortlist voting: users select their favorites within a range</p>
                            </div>
                            <button onclick="cancelCreateShortcake()" class="text-gray-600 hover:text-gray-800 flex items-center gap-1 text-sm">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                                Cancel
                            </button>
                        </div>

                        <!-- Title and Range Inputs -->
                        <div class="bg-amber-50 border-2 border-amber-700 rounded-lg p-4 mb-4">
                            <label class="block text-sm font-bold text-amber-900 mb-2">Shortcake Title</label>
                            <input
                                type="text"
                                class="w-full px-3 py-2 border-2 border-amber-300 rounded-lg text-sm mb-3"
                                placeholder="Enter shortcake title..."
                                value="${state.newShortcake.title || ''}"
                                oninput="setShortcakeTitle(this.value);"
                                maxlength="50"
                            >

                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="block text-sm font-bold text-amber-900 mb-2">Minimum Selections</label>
                                    <input
                                        type="number"
                                        class="w-full px-3 py-2 border-2 border-amber-300 rounded-lg text-sm"
                                        placeholder="Min"
                                        value="${state.newShortcake.min}"
                                        min="1"
                                        oninput="setShortcakeMin(this.value);"
                                    >
                                </div>
                                <div>
                                    <label class="block text-sm font-bold text-amber-900 mb-2">Maximum Selections</label>
                                    <input
                                        type="number"
                                        class="w-full px-3 py-2 border-2 border-amber-300 rounded-lg text-sm"
                                        placeholder="Max"
                                        value="${state.newShortcake.max}"
                                        min="1"
                                        oninput="setShortcakeMax(this.value);"
                                    >
                                </div>
                            </div>
                            <p class="text-xs text-amber-800 mt-2">
                                Users must shortlist between ${state.newShortcake.min} and ${state.newShortcake.max} images
                            </p>
                        </div>

                        <!-- Image Upload Section -->
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                            <h3 class="font-bold text-blue-900 mb-2 flex items-center gap-2 text-sm">
                                <span class="text-xl">üì∏</span>
                                How to Add Images
                            </h3>
                            <p class="text-xs text-blue-800 mb-1">
                                üíª <strong>Desktop:</strong> Click image ‚Üí Right-click ‚Üí Copy image link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üì± <strong>Mobile:</strong> Open image ‚Üí Share ‚Üí Copy link ‚Üí Paste below
                            </p>
                            <p class="text-xs text-blue-800 mb-1">
                                üìÅ <strong>Or:</strong> Click "Upload Image Files" or drag & drop files (max 10MB each, multiple files supported)
                            </p>
                            <p class="text-xs text-green-800 font-semibold">
                                ‚ö° Uploaded files are automatically compressed to 1000 KB max to optimize loading speed
                            </p>
                        </div>

                        <div class="bg-yellow-50 border border-yellow-300 rounded-lg p-3 mb-4">
                            <p class="text-xs text-yellow-800">
                                ‚ö†Ô∏è <strong>Warning:</strong> Discord image URLs expire after 24 hours. Use permanent image hosting (Imgur, etc.) or upload files directly.
                            </p>
                        </div>

                        <div class="mb-4">
                            <input type="url" id="shortcakeUrlInput" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg text-sm mb-2" placeholder="Paste Discord image URL or any image URL...">
                            <div class="flex gap-2 mb-2">
                                <button onclick="clearUrlInputShortcake()" class="flex-1 bg-gray-500 text-white py-2 rounded-lg font-semibold hover:bg-gray-600 transition text-sm">
                                    Clear Text Field
                                </button>
                                <button onclick="addImageFromUrlShortcake('shortcakeUrlInput')" class="flex-1 bg-gradient-to-r from-pink-500 to-rose-600 text-white py-2 rounded-lg font-semibold hover:from-pink-600 hover:to-rose-700 transition text-sm">
                                    Add URL
                                </button>
                            </div>
                            <div class="flex items-center gap-2 mb-3">
                                <span class="text-sm text-gray-600 font-medium">or</span>
                                <input type="file" id="shortcakeFileInput" accept="image/jpeg,image/png,image/gif,image/webp" multiple class="hidden" onchange="handleFileSelectShortcake(this)">
                                <button onclick="document.getElementById('shortcakeFileInput').click()" class="flex-1 bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-2 rounded-lg font-semibold hover:from-blue-600 hover:to-indigo-700 transition text-sm flex items-center justify-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                    </svg>
                                    Upload Image Files
                                </button>
                            </div>
                            <div
                                id="dropZoneShortcake"
                                class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center bg-gray-50 hover:border-amber-400 hover:bg-amber-50 transition cursor-pointer"
                                ondragover="handleDragOverShortcake(event)"
                                ondragleave="handleDragLeaveShortcake(event)"
                                ondrop="handleDropShortcake(event)"
                                onclick="document.getElementById('shortcakeFileInput').click()"
                            >
                                <svg class="w-12 h-12 mx-auto mb-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <p class="text-sm text-gray-600 font-medium mb-1">Drag & drop images here</p>
                                <p class="text-xs text-gray-500">or click to browse files</p>
                            </div>
                        </div>

                        <div class="flex items-center justify-between mb-3 p-3 bg-gray-50 rounded-lg">
                            <div class="text-sm font-semibold text-gray-800">
                                ${state.newShortcake.images.length} / 100 images added
                            </div>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 min-h-[100px]">
                            ${state.newShortcake.images.length === 0 ? `
                                <div class="col-span-full text-center text-gray-400 py-8 text-sm italic">
                                    No images added yet
                                </div>
                            ` : state.newShortcake.images.map((img, index) => `
                                <div class="relative group">
                                    <img src="${img.url}" class="w-full h-48 object-contain rounded-lg bg-gray-100" />
                                    <button onclick="removeShortcakeImage(${index})" class="absolute top-2 right-2 bg-red-500 hover:bg-red-600 text-white rounded-full p-1.5 opacity-0 group-hover:opacity-100 transition shadow-lg">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                        </svg>
                                    </button>
                                    <div class="absolute bottom-2 left-2 bg-black bg-opacity-60 text-white px-2 py-1 rounded text-xs">
                                        #${index + 1}
                                    </div>
                                </div>
                            `).join('')}
                        </div>

                        <button
                            onclick="submitShortcake()"
                            class="w-full bg-gradient-to-r from-amber-600 to-amber-800 text-white py-3 rounded-lg font-bold text-lg hover:from-amber-700 hover:to-amber-900 transition shadow-xl mb-2 ${state.newShortcake.images.length === 0 || !state.newShortcake.title.trim() ? 'opacity-50 cursor-not-allowed' : ''}"
                            ${state.newShortcake.images.length === 0 || !state.newShortcake.title.trim() ? 'disabled' : ''}
                        >
                            Create Shortcake (${state.newShortcake.images.length} images)
                        </button>
                    </div>
                </div>
            `;
        }

        // Helper functions for shortcake creation
        function clearUrlInputShortcake() {
            const input = document.getElementById('shortcakeUrlInput');
            if (input) input.value = '';
        }

        function setShortcakeTitle(value) {
            state.newShortcake.title = value;
            render();
        }

        function setShortcakeMin(value) {
            state.newShortcake.min = parseInt(value) || 1;
            render();
        }

        function setShortcakeMax(value) {
            state.newShortcake.max = parseInt(value) || 1;
            render();
        }

        function addImageFromUrlShortcake(inputId) {
            const input = document.getElementById(inputId);
            const url = input.value.trim();
            if (!url) return;

            state.newShortcake.images.push({
                id: Date.now() + Math.random(),
                url: url,
                author: null,
                isFileUpload: false,
                label: `${state.newShortcake.images.length + 1}`
            });

            input.value = '';
            render();
        }

        function handleFileSelectShortcake(inputElement) {
            const files = Array.from(inputElement.files);
            if (files.length === 0) return;

            // Check if any file is larger than 1000 KB and needs compression
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const largeFiles = files.filter(f => f.size > 1000 * 1024);

            if (largeFiles.length > 0 && !isAdmin) {
                // Show compression modal
                showCompressionModalForShortcake(files);
            } else {
                // Add files directly (admin bypass or all files small enough)
                files.forEach(file => {
                    const url = URL.createObjectURL(file);
                    state.newShortcake.images.push({
                        id: Date.now() + Math.random(),
                        url: url,
                        localFile: file,
                        isLocalFile: true,
                        author: null,
                        isFileUpload: true,
                        label: `${state.newShortcake.images.length + 1}`,
                        compressedSize: file.size
                    });
                });
                render();
            }

            inputElement.value = '';
        }

        function showCompressionModalForShortcake(files) {
            // Use the same compression modal as contests
            state.compressionProgress = {
                files: files.map(f => ({
                    name: f.name,
                    status: 'pending',
                    originalSize: f.size,
                    compressedSize: f.size,
                    progress: 0,
                    error: null,
                    canCompressMore: false,
                    originalFile: f,
                    file: f,
                    previewUrl: URL.createObjectURL(f),
                    currentQuality: 0.7,
                    currentMaxDimension: null,
                    adminBypass: false
                })),
                allComplete: false,
                targetContext: 'shortcake'  // Add context to know where to add images after compression
            };
            render();

            // Start compression for all files
            state.compressionProgress.files.forEach((fileState, index) => {
                compressImageAsync(fileState, index);
            });
        }

        function handleDragOverShortcake(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.add('border-amber-400', 'bg-amber-50');
        }

        function handleDragLeaveShortcake(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('border-amber-400', 'bg-amber-50');
        }

        function handleDropShortcake(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('border-amber-400', 'bg-amber-50');

            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                const input = document.getElementById('shortcakeFileInput');
                const dt = new DataTransfer();
                files.forEach(file => dt.items.add(file));
                input.files = dt.files;
                handleFileSelectShortcake(input);
            }
        }

        function removeShortcakeImage(index) {
            const img = state.newShortcake.images[index];
            if (img.isLocalFile && img.url.startsWith('blob:')) {
                URL.revokeObjectURL(img.url);
            }
            state.newShortcake.images.splice(index, 1);
            render();
        }

        function renderMultiViewVoting() {
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);
            const isMergerVoting = state.currentMergerId && !state.currentContest;
            const votingTitle = isMergerVoting
                ? (state.mergers.find(m => m.id === state.currentMergerId)?.name || 'Merger Voting')
                : (state.currentContest?.title || 'Voting');

            // Calculate voting progress
            const votedCount = state.shuffledImages.filter(img => state.votes[img.id]).length;
            const totalCount = state.shuffledImages.length;

            // Get image scale (use state.imageScale if available, default to 100)
            const imageScale = state.multiVotingImageScale || 100;
            const baseSize = 150;
            const imageHeight = Math.max(30, Math.min(500, Math.floor(baseSize * (imageScale / 100))));

            // Calculate score circle size based on image scale
            const baseCircleSize = 28; // Base size in pixels (smaller than before)
            const circleSize = Math.max(16, Math.min(56, Math.floor(baseCircleSize * (imageScale / 100))));
            const baseFontSize = 14;
            const fontSize = Math.max(10, Math.min(20, Math.floor(baseFontSize * (imageScale / 100))));

            return `
                <div class="max-w-7xl mx-auto px-3 py-4 pb-32">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <!-- Header with progress -->
                        <div class="bg-gray-50 px-4 py-3 border-b border-gray-200">
                            <div class="flex justify-between items-center mb-2">
                                <h2 class="text-lg font-bold text-gray-800">${votingTitle}</h2>
                                <span class="text-gray-600 font-medium text-sm">${votedCount}/${totalCount} voted</span>
                            </div>
                            <!-- Progress bar -->
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div class="bg-gradient-to-r from-green-500 to-green-600 h-2 rounded-full transition-all duration-300" style="width: ${(votedCount / totalCount * 100).toFixed(1)}%"></div>
                            </div>

                            <!-- Image Scale Slider -->
                            <div class="mt-3">
                                <label class="text-sm font-medium text-gray-700 mb-2 block">Image Scale</label>
                                <div class="flex items-center gap-2">
                                    <button
                                        onclick="adjustMultiVotingImageScale(-1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Decrease scale by 1%"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        min="20"
                                        max="200"
                                        value="${imageScale}"
                                        oninput="updateMultiVotingImageScale(this.value)"
                                        class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                                    />
                                    <button
                                        onclick="adjustMultiVotingImageScale(1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Increase scale by 1%"
                                    >+</button>
                                    <span class="text-sm font-medium text-gray-700 w-12">${imageScale}%</span>
                                </div>
                            </div>

                            <!-- Filter and Sort Controls -->
                            <div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
                                <!-- Filter by Score -->
                                <div>
                                    <label class="text-sm font-medium text-gray-700 mb-2 block">Filter by Score</label>
                                    <div class="flex gap-1.5 flex-wrap">
                                        ${['non-voted', 1, 2, 3, 4, 5].map(filter => {
                                            const isSelected = state.multiModeFilter === filter;
                                            const label = filter === 'non-voted' ? '?' : filter;
                                            const bgColor = filter === 'non-voted' ? '#9ca3af' : getScoreColor(filter);
                                            return `
                                                <button
                                                    onclick="setMultiModeFilter(${typeof filter === 'string' ? `'${filter}'` : filter})"
                                                    class="px-3 py-1.5 rounded-lg text-white text-sm font-semibold transition ${isSelected ? 'ring-2 ring-offset-1 ring-gray-800 scale-105' : 'opacity-60 hover:opacity-100'}"
                                                    style="background-color: ${bgColor};"
                                                    title="Show ${filter === 'non-voted' ? 'non-voted' : 'score ' + filter} images"
                                                >
                                                    ${label}
                                                </button>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>

                                <!-- Sort -->
                                <div>
                                    <label class="text-sm font-medium text-gray-700 mb-2 block">Sort</label>
                                    <select
                                        onchange="setMultiModeSort(this.value)"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-blue-400 focus:outline-none"
                                    >
                                        <option value="default" ${state.multiModeSort === 'default' ? 'selected' : ''}>Default Order</option>
                                        <option value="highest" ${state.multiModeSort === 'highest' ? 'selected' : ''}>Highest to Lowest</option>
                                        <option value="lowest" ${state.multiModeSort === 'lowest' ? 'selected' : ''}>Lowest to Highest</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- Image grid with flex-wrap layout -->
                        <div class="p-4">
                            <div class="flex flex-wrap gap-1">
                                ${(() => {
                                    // Apply filtering
                                    let filteredImages = state.shuffledImages;
                                    if (state.multiModeFilter !== null) {
                                        if (state.multiModeFilter === 'non-voted') {
                                            filteredImages = filteredImages.filter(img => !state.votes[img.id]);
                                        } else {
                                            filteredImages = filteredImages.filter(img => state.votes[img.id] === state.multiModeFilter);
                                        }
                                    }

                                    // Apply sorting
                                    if (state.multiModeSort === 'highest') {
                                        filteredImages = [...filteredImages].sort((a, b) => {
                                            const voteA = state.votes[a.id] || 0;
                                            const voteB = state.votes[b.id] || 0;
                                            return voteB - voteA;
                                        });
                                    } else if (state.multiModeSort === 'lowest') {
                                        filteredImages = [...filteredImages].sort((a, b) => {
                                            const voteA = state.votes[a.id] || 0;
                                            const voteB = state.votes[b.id] || 0;
                                            return voteA - voteB;
                                        });
                                    }
                                    // 'default' keeps the original order

                                    return filteredImages.map((image, idx) => {
                                        const currentVote = state.votes[image.id];
                                        const isHoverable = state.selectedScore !== null;
                                        const borderColor = currentVote ? getScoreColor(currentVote) : 'transparent';
                                        return `
                                        <div class="relative" style="height: ${imageHeight}px;">
                                            <div
                                                class="relative cursor-pointer rounded-lg overflow-hidden border-4 bg-gray-100 h-full ${isHoverable ? 'hover:border-blue-400' : ''}"
                                                onclick="voteImageMulti('${image.id}')"
                                                style="height: ${imageHeight}px; border-color: ${borderColor};"
                                            >
                                                <img src="${image.url}" alt="Image ${idx + 1}" class="h-full w-auto object-cover" />

                                                <!-- Score indicator circle (top-left) -->
                                                <div class="absolute top-2 left-2">
                                                    <div class="rounded-full flex items-center justify-center font-bold shadow-lg ${currentVote ? '' : 'bg-white text-gray-400'}"
                                                         style="width: ${circleSize}px; height: ${circleSize}px; font-size: ${fontSize}px; ${currentVote ? `background-color: ${getScoreColor(currentVote)}; color: white;` : ''}">
                                                        ${currentVote || '?'}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                    }).join('');
                                })()}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Fixed bottom voting panel -->
                <div class="fixed bottom-0 left-0 right-0 bg-white border-t-2 border-gray-300 shadow-2xl z-50">
                    <div class="max-w-4xl mx-auto px-4 py-4">
                        <!-- Mobile layout: stacked -->
                        <div class="flex flex-col sm:hidden items-center justify-center gap-4">
                            <!-- Info label -->
                            ${state.selectedScore !== null ? `
                                <span class="text-sm text-gray-600 font-medium">
                                    Click images to vote <span class="font-bold" style="color: ${getScoreColor(state.selectedScore)}">${state.selectedScore}</span>
                                </span>
                            ` : `
                                <span class="text-sm text-gray-500">
                                    Select a score below
                                </span>
                            `}

                            <!-- Score buttons -->
                            <div class="flex gap-2">
                                ${[1, 2, 3, 4, 5].map(score => {
                                    const isSelected = state.selectedScore === score;
                                    return `
                                        <button
                                            onclick="toggleScoreSelection(${score})"
                                            class="w-14 h-14 rounded-full font-bold text-white text-lg shadow-lg hover:scale-110 transition-transform relative ${isSelected ? 'ring-4 ring-offset-2 scale-110' : ''}"
                                            style="background-color: ${getScoreColor(score)}; ring-color: ${getScoreColor(score)};"
                                            title="Score ${score}${isSelected ? ' (selected - click images to vote)' : ''}"
                                        >
                                            ${score}
                                            ${isSelected ? `
                                                <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-blue-600 rounded-full p-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                </svg>
                                            ` : ''}
                                        </button>
                                    `;
                                }).join('')}
                            </div>

                            <!-- Submit button -->
                            ${allVoted ? `
                                <button onclick="submitVotes()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-6 py-3 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition flex items-center gap-2 shadow-lg whitespace-nowrap">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    Submit Votes
                                </button>
                            ` : ''}
                        </div>

                        <!-- Desktop layout: label left, buttons center, submit right -->
                        <div class="hidden sm:flex items-center justify-between gap-4">
                            <!-- Info label (left) -->
                            <div class="flex-shrink-0">
                                ${state.selectedScore !== null ? `
                                    <span class="text-sm text-gray-600 font-medium">
                                        Click images to vote <span class="font-bold" style="color: ${getScoreColor(state.selectedScore)}">${state.selectedScore}</span>
                                    </span>
                                ` : `
                                    <span class="text-sm text-gray-500">
                                        Select a score
                                    </span>
                                `}
                            </div>

                            <!-- Score buttons (center) -->
                            <div class="flex gap-2 flex-shrink-0">
                                ${[1, 2, 3, 4, 5].map(score => {
                                    const isSelected = state.selectedScore === score;
                                    return `
                                        <button
                                            onclick="toggleScoreSelection(${score})"
                                            class="w-14 h-14 rounded-full font-bold text-white text-lg shadow-lg hover:scale-110 transition-transform relative ${isSelected ? 'ring-4 ring-offset-2 scale-110' : ''}"
                                            style="background-color: ${getScoreColor(score)}; ring-color: ${getScoreColor(score)};"
                                            title="Score ${score}${isSelected ? ' (selected - click images to vote)' : ''}"
                                        >
                                            ${score}
                                            ${isSelected ? `
                                                <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-blue-600 rounded-full p-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                                </svg>
                                            ` : ''}
                                        </button>
                                    `;
                                }).join('')}
                            </div>

                            <!-- Submit button (right) -->
                            <div class="flex-shrink-0">
                                ${allVoted ? `
                                    <button onclick="submitVotes()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-6 py-3 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition flex items-center gap-2 shadow-lg whitespace-nowrap">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        Submit Votes
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderVoting() {
            // Switch between single and multi view based on state.votingMode
            if (state.votingMode === 'multi') {
                return renderMultiViewVoting();
            }

            const currentImage = state.shuffledImages[state.currentImageIndex];
            const currentVote = state.votes[currentImage.id];
            const allVoted = state.shuffledImages.every(img => state.votes[img.id]);

            // Determine voting context (contest or merger)
            const isMergerVoting = state.currentMergerId && !state.currentContest;
            const votingTitle = isMergerVoting
                ? (state.mergers.find(m => m.id === state.currentMergerId)?.name || 'Merger Voting')
                : (state.currentContest?.title || 'Voting');

            // Adaptive progress bar logic - ensure EXACTLY segmentCount dashes
            const imageCount = state.shuffledImages.length;
            const segmentCount = Math.min(imageCount, 20);
            const imagesPerSegment = Math.ceil(imageCount / segmentCount);

            return `
                <div class="max-w-4xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <div class="bg-gray-200 h-3 flex gap-1 p-1">
                            ${Array.from({ length: segmentCount }, (_, segmentIdx) => {
                                const startIdx = segmentIdx * imagesPerSegment;
                                const endIdx = Math.min(startIdx + imagesPerSegment, imageCount);

                                // Skip segments that would start beyond our image count
                                if (startIdx >= imageCount) return '';

                                const segmentImages = state.shuffledImages.slice(startIdx, endIdx);

                                const votedCount = segmentImages.filter(img => state.votes[img.id]).length;
                                const totalCount = segmentImages.length;
                                const hasCurrentImage = state.currentImageIndex >= startIdx && state.currentImageIndex < endIdx;

                                // Determine color based on priority
                                let bgColor;
                                if (hasCurrentImage) {
                                    bgColor = 'bg-mauve-400';
                                } else if (votedCount === totalCount) {
                                    bgColor = 'bg-green-500';
                                } else if (votedCount > 0) {
                                    bgColor = 'bg-yellow-500';
                                } else {
                                    bgColor = 'bg-gray-300';
                                }

                                const imageRange = startIdx + 1 === endIdx ? `Image ${startIdx + 1}` : `Images ${startIdx + 1}-${endIdx}`;
                                const tooltip = `${imageRange} (${votedCount}/${totalCount} voted)`;

                                return `
                                    <div
                                        onclick="jumpToImage(${startIdx})"
                                        class="progress-segment flex-1 ${bgColor}"
                                        title="${tooltip}"
                                    ></div>
                                `;
                            }).join('')}
                        </div>

                        <div class="p-3">
                            <div class="flex justify-between items-center mb-3 gap-2">
                                <h2 class="text-lg font-bold text-gray-800">${votingTitle}</h2>
                                <span class="text-gray-600 font-medium text-sm">${state.currentImageIndex + 1}/${state.shuffledImages.length}</span>
                            </div>

                            <div class="relative mb-3 bg-gray-100 overflow-hidden flex items-center justify-center" style="height: 55vh;">
                                <img
                                    src="${currentImage.url}"
                                    alt="Image ${state.currentImageIndex + 1}"
                                    class="max-h-full max-w-full object-contain"
                                    style="max-height: 100%; max-width: 100%;"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                                ${currentVote ? `
                                    <div class="absolute top-2 right-2 bg-white rounded-full px-3 py-1 shadow-lg flex items-center gap-1 text-sm">
                                        <svg class="w-4 h-4 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                                        </svg>
                                        <span class="font-semibold">Voted: ${currentVote}</span>
                                    </div>
                                ` : ''}
                            </div>

                            <div class="flex justify-center gap-2 mb-3">
                                ${[1, 2, 3, 4, 5].map(score => `
                                    <button 
                                        data-score="${score}"
                                        onclick="handleVote(${score})" 
                                        ${state.isAnimating ? 'disabled' : ''}
                                        class="w-12 h-12 sm:w-14 sm:h-14 rounded-full font-bold text-white text-base shadow-lg hover:scale-110 transition-transform relative ${currentVote === score ? 'ring-4 ring-offset-2' : ''} ${state.isAnimating ? 'opacity-70 cursor-not-allowed' : ''}"
                                        style="background-color: ${getScoreColor(score)}; transform: ${currentVote === score ? 'scale(1.15)' : 'scale(1)'}; ring-color: ${getScoreColor(score)};"
                                    >
                                        ${score}
                                        ${currentVote === score && state.showTickAnimation ? `
                                            <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-green-600 rounded-full p-1 tick-animation" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                            </svg>
                                        ` : currentVote === score ? `
                                            <svg class="absolute -top-1 -right-1 w-6 h-6 text-white bg-green-600 rounded-full p-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>
                                            </svg>
                                        ` : ''}
                                    </button>
                                `).join('')}
                            </div>

                            <div class="flex justify-between items-center gap-2">
                                <button 
                                    onclick="navigateImage('prev')" 
                                    ${state.currentImageIndex === 0 ? 'disabled' : ''}
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                                >
                                    ‚Üê Prev
                                </button>

                                ${allVoted ? `
                                    <button onclick="submitVotes()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition flex items-center gap-1 shadow-lg text-sm">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        Submit
                                    </button>
                                ` : '<div></div>'}

                                <button 
                                    onclick="navigateImage('next')" 
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition text-sm"
                                >
                                    Next ‚Üí
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderShortcakeVoting() {
            // Check if single or multi mode
            const isSingleMode = state.votingMode === 'single';

            if (isSingleMode) {
                // Single mode with upvote/downvote
                return renderShortcakeVotingSingle();
            } else {
                // Multi mode with checkboxes (default)
                return renderShortcakeVotingMulti();
            }
        }

        function renderShortcakeVotingMulti() {
            const shortcake = state.currentShortcake;
            const count = state.shortlistedImageIds.length;
            const min = shortcake.min;
            const max = shortcake.max;
            const isValidCount = count >= min && count <= max;

            // Get image scale
            const imageScale = state.multiVotingImageScale || 100;
            const baseSize = 150;
            const imageHeight = Math.max(30, Math.min(500, Math.floor(baseSize * (imageScale / 100))));

            return `
                <div class="max-w-7xl mx-auto px-3 py-4 pb-32">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <!-- Header -->
                        <div class="bg-amber-50 border-b-2 border-amber-700 px-4 py-3">
                            <div class="flex justify-between items-center mb-2">
                                <h2 class="text-lg font-bold text-amber-900">üç∞ ${shortcake.title}</h2>
                                <span class="text-amber-800 font-bold text-sm">
                                    ${count}/${min}-${max} images shortlisted
                                </span>
                            </div>
                            <!-- Progress bar -->
                            <div class="w-full bg-amber-200 rounded-full h-2 mb-3">
                                <div class="bg-gradient-to-r from-amber-600 to-amber-800 h-2 rounded-full transition-all duration-300" style="width: ${Math.min(100, (count / max * 100)).toFixed(1)}%"></div>
                            </div>

                            <!-- Image Scale Slider -->
                            <div class="mt-3">
                                <label class="text-sm font-medium text-amber-900 mb-2 block">Image Scale</label>
                                <div class="flex items-center gap-2">
                                    <button
                                        onclick="adjustMultiVotingImageScale(-1)"
                                        class="w-6 h-6 rounded bg-amber-200 hover:bg-amber-300 flex items-center justify-center font-bold text-amber-900 transition"
                                        title="Decrease scale by 1%"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        min="20"
                                        max="200"
                                        value="${imageScale}"
                                        oninput="updateMultiVotingImageScale(this.value)"
                                        class="flex-1 h-2 bg-amber-200 rounded-lg appearance-none cursor-pointer slider"
                                    />
                                    <button
                                        onclick="adjustMultiVotingImageScale(1)"
                                        class="w-6 h-6 rounded bg-amber-200 hover:bg-amber-300 flex items-center justify-center font-bold text-amber-900 transition"
                                        title="Increase scale by 1%"
                                    >+</button>
                                    <span class="text-sm font-medium text-amber-900 w-12">${imageScale}%</span>
                                </div>
                            </div>
                        </div>

                        <!-- Image grid -->
                        <div class="p-4">
                            <div class="flex flex-wrap gap-1">
                                ${state.shuffledImages.map((image, idx) => {
                                    const isShortlisted = state.shortlistedImageIds.includes(image.id);
                                    const borderColor = isShortlisted ? '#d97706' : 'transparent'; // amber-600
                                    return `
                                        <div class="relative" style="height: ${imageHeight}px;">
                                            <div
                                                class="relative cursor-pointer rounded-lg overflow-hidden border-4 bg-gray-100 h-full hover:border-amber-400 transition"
                                                onclick="toggleShortlist('${image.id}')"
                                                style="height: ${imageHeight}px; border-color: ${borderColor};"
                                            >
                                                <img src="${image.url}" alt="Image ${idx + 1}" class="h-full w-auto object-cover" />

                                                <!-- Checkbox indicator (top-left) -->
                                                <div class="absolute top-2 left-2">
                                                    <div class="rounded-full flex items-center justify-center font-bold shadow-lg w-8 h-8"
                                                         style="background-color: ${isShortlisted ? '#d97706' : '#ffffff'}; color: ${isShortlisted ? '#ffffff' : '#9ca3af'};">
                                                        ${isShortlisted ? '‚úì' : '‚òê'}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Fixed bottom panel -->
                <div class="fixed bottom-0 left-0 right-0 bg-gradient-to-r from-amber-50 to-amber-100 border-t-2 border-amber-700 shadow-2xl z-50">
                    <div class="max-w-4xl mx-auto px-4 py-4">
                        <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
                            <!-- Info label -->
                            <div class="flex-shrink-0 text-center sm:text-left">
                                <span class="text-sm text-amber-900 font-bold">
                                    Click images to shortlist (${count}/${min}-${max})
                                </span>
                            </div>

                            <!-- Submit button -->
                            <div class="flex-shrink-0">
                                ${isValidCount ? `
                                    <button onclick="submitShortcakeVotes()" class="bg-gradient-to-r from-amber-600 to-amber-800 text-white px-6 py-3 rounded-lg font-semibold hover:from-amber-700 hover:to-amber-900 transition flex items-center gap-2 shadow-lg whitespace-nowrap">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        Submit Votes
                                    </button>
                                ` : `
                                    <button disabled class="bg-gray-300 text-gray-500 px-6 py-3 rounded-lg font-semibold cursor-not-allowed flex items-center gap-2 shadow-lg whitespace-nowrap">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                                        </svg>
                                        Select ${min}-${max} Images
                                    </button>
                                `}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderShortcakeVotingSingle() {
            const shortcake = state.currentShortcake;
            const currentImage = state.shuffledImages[state.currentImageIndex];
            const isShortlisted = state.shortlistedImageIds.includes(currentImage.id);
            const count = state.shortlistedImageIds.length;
            const min = shortcake.min;
            const max = shortcake.max;
            const isValidCount = count >= min && count <= max;

            return `
                <div class="max-w-4xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl overflow-hidden fade-in">
                        <!-- Header -->
                        <div class="bg-amber-50 border-b-2 border-amber-700 p-3">
                            <div class="flex justify-between items-center mb-3">
                                <h2 class="text-lg font-bold text-amber-900">üç∞ ${shortcake.title}</h2>
                                <span class="text-amber-800 font-medium text-sm">${state.currentImageIndex + 1}/${state.shuffledImages.length}</span>
                            </div>
                            <div class="text-center text-amber-900 font-bold text-sm">
                                ${count}/${min}-${max} images shortlisted
                            </div>
                        </div>

                        <div class="p-3">
                            <!-- Image -->
                            <div class="relative mb-3 bg-gray-100 overflow-hidden flex items-center justify-center" style="height: 55vh;">
                                <img
                                    src="${currentImage.url}"
                                    alt="Image ${state.currentImageIndex + 1}"
                                    class="max-h-full max-w-full object-contain"
                                    style="max-height: 100%; max-width: 100%;"
                                />
                                ${isShortlisted ? `
                                    <div class="absolute top-2 right-2 bg-amber-600 text-white rounded-full px-3 py-1 shadow-lg flex items-center gap-1 text-sm font-bold">
                                        ‚úì Shortlisted
                                    </div>
                                ` : ''}
                            </div>

                            <!-- Vote buttons -->
                            <div class="flex justify-center gap-4 mb-3">
                                <button
                                    onclick="voteShortcakeImage('${currentImage.id}', false)"
                                    class="w-16 h-16 rounded-full font-bold text-white text-lg shadow-lg hover:scale-110 transition-transform bg-red-500 hover:bg-red-600 flex items-center justify-center"
                                >
                                    ‚úó
                                </button>
                                <button
                                    onclick="voteShortcakeImage('${currentImage.id}', true)"
                                    class="w-16 h-16 rounded-full font-bold text-white text-lg shadow-lg hover:scale-110 transition-transform bg-blue-500 hover:bg-blue-600 flex items-center justify-center"
                                >
                                    ‚úì
                                </button>
                            </div>

                            <!-- Navigation -->
                            <div class="flex justify-between items-center gap-2">
                                <button
                                    onclick="navigateImage('prev')"
                                    ${state.currentImageIndex === 0 ? 'disabled' : ''}
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                                >
                                    ‚Üê Prev
                                </button>

                                ${isValidCount ? `
                                    <button onclick="submitShortcakeVotes()" class="bg-gradient-to-r from-amber-600 to-amber-800 text-white px-4 py-2 rounded-lg font-semibold hover:from-amber-700 hover:to-amber-900 transition flex items-center gap-1 shadow-lg text-sm">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        Submit
                                    </button>
                                ` : '<div></div>'}

                                <button
                                    onclick="navigateImage('next')"
                                    class="flex items-center gap-1 bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition text-sm"
                                >
                                    Next ‚Üí
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleShortlist(imageId) {
            const index = state.shortlistedImageIds.indexOf(imageId);
            if (index > -1) {
                // Remove from shortlist
                state.shortlistedImageIds.splice(index, 1);
            } else {
                // Add to shortlist
                state.shortlistedImageIds.push(imageId);
            }
            render();
        }

        function voteShortcakeImage(imageId, shouldShortlist) {
            const index = state.shortlistedImageIds.indexOf(imageId);

            if (shouldShortlist && index === -1) {
                // Add to shortlist if not already there
                state.shortlistedImageIds.push(imageId);
            } else if (!shouldShortlist && index > -1) {
                // Remove from shortlist if it's there
                state.shortlistedImageIds.splice(index, 1);
            }

            // Auto-advance to next image
            if (state.currentImageIndex < state.shuffledImages.length - 1) {
                state.currentImageIndex++;
            }

            render();
        }

        function submitShortcakeVotes() {
            const count = state.shortlistedImageIds.length;
            const min = state.currentShortcake.min;
            const max = state.currentShortcake.max;

            if (count < min || count > max) {
                showAlert(`Please select between ${min} and ${max} images!`, '‚ùå');
                return;
            }

            showConfirm(
                `Confirm to submit your shortcake votes (${count} images selected).`,
                'confirmSubmitShortcakeVotes',
                'üç∞'
            );
        }

        function renderResults() {
            // Check privacy settings
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === state.currentContest.createdBy;
            const isPrivate = state.currentContest.resultsPublic === false;
            const canViewPrivateResults = isAdmin || isCreator;

            // Block unauthorized users from viewing private results
            if (isPrivate && !canViewPrivateResults) {
                return `
                    <div class="max-w-7xl mx-auto px-3 py-4">
                        <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                            <div class="text-center mb-4">
                                <div class="flex items-center justify-center gap-2 mb-2">
                                    <span class="text-4xl">üéÜ</span>
                                    <h2 class="text-2xl font-bold text-gray-800">Final Ranking</h2>
                                </div>
                            </div>

                            <div class="mt-3 flex flex-col items-center justify-center gap-2 mb-4">
                                <!-- Disabled tabs -->
                                <div class="flex items-center justify-center gap-3 opacity-50">
                                    <button class="px-3 py-1 rounded-lg bg-gray-200 cursor-not-allowed" disabled>
                                        Total
                                    </button>
                                    <button class="px-3 py-1 rounded-lg bg-gray-200 cursor-not-allowed" disabled>
                                        By User
                                    </button>
                                    <button class="px-3 py-1 rounded-lg bg-gray-200 cursor-not-allowed" disabled>
                                        Average
                                    </button>
                                </div>
                            </div>

                            <!-- Privacy message -->
                            <div class="text-center py-16">
                                <div class="text-8xl mb-6">üîí</div>
                                <h3 class="text-2xl font-bold text-gray-800 mb-3">Results are Private</h3>
                                <p class="text-gray-600 max-w-md mx-auto">
                                    Only the contest creator can view results. Contact the creator if you believe you should have access.
                                </p>
                            </div>
                        </div>
                    </div>
                `;
            }

            let displayResults, grouped, sortedKeys, voterStats;

            // === BY VOTER VIEW ===
            // Shows statistics for each voter, including their average score across all images
            if (state.resultsView === 'byVoter') {
                voterStats = generateVoterStats();
            }
            // === USER VOTES VIEW ===
            // Shows images grouped by a selected user's vote scores
            else if (state.resultsView === 'userVotes') {
                // If no voter is explicitly selected, default to the first voter in the list (not necessarily the current user)
                let selectedUserId = state.selectedVoterUserId;
                if (!selectedUserId && state.contestVoters.length > 0) {
                    selectedUserId = state.contestVoters[0].userId;
                }
                if (!selectedUserId) {
                    selectedUserId = state.user?.id;
                }

                // Find all votes by the selected user from the loaded results (including blocked ones)
                const userVotesMap = {};
                const blockedVotesSet = new Set();
                state.results.forEach(imageResult => {
                    const userVote = imageResult.breakdown.find(v => v.userId === selectedUserId);
                    if (userVote) {
                        userVotesMap[imageResult.id] = userVote.score;
                        if (userVote.isBlocked) {
                            blockedVotesSet.add(imageResult.id);
                        }
                    }
                });

                const hasVotes = Object.keys(userVotesMap).length > 0;

                // Map the selected user's votes onto the images
                displayResults = state.results.map(img => ({
                    ...img,
                    averageScore: userVotesMap[img.id] || 0,
                    userVoteScore: userVotesMap[img.id],
                    isBlocked: blockedVotesSet.has(img.id)
                })).filter(img => img.userVoteScore); // Only show images the user voted on

                grouped = groupMyVotesByScore(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => parseInt(b) - parseInt(a));
            }
            // === AVERAGE VIEW ===
            // Shows images grouped by average score ranges (e.g., 4.5-5.0, 4.0-4.49, etc.)
            else {
                displayResults = state.results;
                grouped = groupByScoreRange(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => {
                    const aMin = grouped[a].min;
                    const bMin = grouped[b].min;
                    return bMin - aMin;
                });
            }
            
            const baseSize = 150;
            const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
            const baseFontSize = 12;
            const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="text-center mb-4">
                            <div class="flex items-center justify-center gap-2 mb-2">
                                <span class="text-4xl">üéÜ</span>
                                <h2 class="text-2xl font-bold text-gray-800">Final Ranking</h2>
                            </div>
                            <p class="text-gray-600 text-sm mb-1">${
                                state.resultsView === 'byVoter' ? 'Average scores per voter' :
                                state.resultsView === 'userVotes' ? 'Individual user votes' :
                                'Total votes from all participants'
                            }</p>
                            <p class="text-xs text-gray-500">Click on any image to see the vote breakdown</p>

                            ${(() => {
                                if (isPrivate) {
                                    const message = isCreator
                                        ? "These results are private. Only you can view them."
                                        : "These results are private. Only you and the creator can view them.";
                                    return `
                                        <div class="mt-3 mb-2 max-w-2xl mx-auto">
                                            <div class="bg-yellow-50 border border-yellow-400 text-yellow-800 px-4 py-3 rounded-lg text-sm flex items-start gap-2">
                                                <span class="text-lg flex-shrink-0">‚ö†Ô∏è</span>
                                                <p class="flex-1">${message}</p>
                                            </div>
                                        </div>
                                    `;
                                }
                                return '';
                            })()}

                            <div class="mt-3 flex flex-col items-center justify-center gap-2">
                                <!-- First row: View tabs -->
                                ${(() => {
                                    // For hidden results (non-admin/creator), disable tab switching
                                    const canSwitchTabs = !isPrivate || isAdmin || isCreator;
                                    const disabledClass = canSwitchTabs ? '' : 'opacity-50 cursor-not-allowed';
                                    const onclick = canSwitchTabs ? 'onclick' : 'data-disabled';

                                    return `
                                        <div class="flex items-center justify-center gap-3">
                                            <button
                                                ${onclick}="setResultsView('average')"
                                                class="px-3 py-1 rounded-lg ${state.resultsView === 'average' ? 'bg-mauve-400 text-white' : 'bg-gray-200'} ${disabledClass}"
                                                ${!canSwitchTabs ? 'disabled title="Results are hidden - viewing your votes only"' : ''}
                                            >
                                                Total
                                            </button>
                                            <button
                                                ${onclick}="setResultsView('userVotes')"
                                                class="px-3 py-1 rounded-lg ${state.resultsView === 'userVotes' ? 'bg-mauve-400 text-white' : 'bg-gray-200'} ${disabledClass}"
                                                ${!canSwitchTabs ? 'disabled title="Results are hidden - viewing your votes only"' : ''}
                                            >
                                                By User
                                            </button>
                                            <button
                                                ${onclick}="setResultsView('byVoter')"
                                                class="px-3 py-1 rounded-lg ${state.resultsView === 'byVoter' ? 'bg-mauve-400 text-white' : 'bg-gray-200'} ${disabledClass}"
                                                ${!canSwitchTabs ? 'disabled title="Results are hidden - viewing your votes only"' : ''}
                                            >
                                                Average
                                            </button>
                                        </div>
                                    `;
                                })()}
                                <!-- Second row: Action buttons (only show if user has voted and contest is not locked) -->
                                ${state.userVotedContests[state.currentContest.id] && !state.currentContest.isLocked ? `
                                    <div class="flex items-center justify-center gap-3">
                                        ${(() => {
                                            const revotingEnabled = state.appSettings.revoting_enabled !== false;
                                            if (!revotingEnabled) {
                                                return `
                                                    <button
                                                        onclick="showRevotingDisabledModal()"
                                                        class="px-3 py-1 rounded-lg bg-gray-400 text-gray-200 opacity-50 cursor-not-allowed transition text-sm"
                                                        title="Revoting is temporarily disabled"
                                                    >
                                                        Revote
                                                    </button>
                                                `;
                                            }
                                            return `
                                                <button
                                                    onclick="startRevote()"
                                                    class="px-3 py-1 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition text-sm"
                                                    title="Re-vote from scratch"
                                                >
                                                    Revote
                                                </button>
                                            `;
                                        })()}
                                    </div>
                                ` : ''}
                            </div>
                                <!-- User selector dropdown for User Votes view -->
                                ${state.resultsView === 'userVotes' && state.contestVoters.length > 0 ? (() => {
                                    // For hidden results (non-admin/creator), disable user selection
                                    const canSelectUser = !isPrivate || isAdmin || isCreator;
                                    if (!canSelectUser) {
                                        return `
                                            <div class="flex justify-center items-center gap-2">
                                                <label class="text-xs font-medium text-gray-700">Viewing: Your Votes Only</label>
                                                <span class="text-xs text-gray-500">(Results are hidden)</span>
                                            </div>
                                        `;
                                    }
                                    return `
                                        <div class="flex justify-center items-center gap-2">
                                            <label class="text-xs font-medium text-gray-700">Select User:</label>
                                            <select
                                                onchange="setResultsView('userVotes', this.value)"
                                                class="px-2 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                            >
                                                ${state.contestVoters.map((voter, index) => {
                                                    // Default to first voter if no explicit selection
                                                    const defaultUserId = state.contestVoters.length > 0 ? state.contestVoters[0].userId : state.user?.id;
                                                    const isSelected = (state.selectedVoterUserId || defaultUserId) === voter.userId;
                                                    const isCurrent = voter.userId === state.user?.id;
                                                    return `
                                                        <option value="${voter.userId}" ${isSelected ? 'selected' : ''}>
                                                            ${voter.username}${isCurrent ? ' (You)' : ''}
                                                        </option>
                                                    `;
                                                }).join('')}
                                            </select>
                                        </div>
                                    `;
                                })() : ''}
                            </div>

                        ${state.resultsView !== 'byVoter' ? `
                            <div class="mb-4 max-w-md mx-auto">
                                <div class="flex items-center gap-2">
                                    <label class="text-xs font-medium text-gray-700 whitespace-nowrap">Image Scale:</label>
                                    <button
                                        onclick="adjustScale(-1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Decrease scale"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        id="scaleSlider"
                                        min="40"
                                        max="200"
                                        value="${state.imageScale}"
                                        oninput="updateScale(this.value)"
                                        class="flex-1 h-2 bg-gray-200 rounded-lg cursor-pointer"
                                    />
                                    <button
                                        onclick="adjustScale(1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Increase scale"
                                    >+</button>
                                    <span class="text-xs font-medium text-gray-700 w-10">${state.imageScale}%</span>
                                </div>
                            </div>
                        ` : ''}

                        ${state.resultsView === 'byVoter' ? `
                            ${voterStats && voterStats.length > 0 ? `
                                <div class="mb-4 flex justify-center">
                                    <div class="flex items-center gap-2">
                                        <label class="text-xs font-medium text-gray-700">Sort by:</label>
                                        <select
                                            onchange="setVoterSortBy(this.value)"
                                            class="px-3 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                        >
                                            <option value="scoreDesc" ${state.voterSortBy === 'scoreDesc' ? 'selected' : ''}>Score: High to Low</option>
                                            <option value="scoreAsc" ${state.voterSortBy === 'scoreAsc' ? 'selected' : ''}>Score: Low to High</option>
                                            <option value="nameAsc" ${state.voterSortBy === 'nameAsc' ? 'selected' : ''}>Name: A-Z</option>
                                            <option value="nameDesc" ${state.voterSortBy === 'nameDesc' ? 'selected' : ''}>Name: Z-A</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-2">
                                    ${(() => {
                                        // Calculate contest average from all non-blocked votes
                                        let totalVotes = 0;
                                        let totalScore = 0;
                                        state.results.forEach(img => {
                                            img.breakdown.forEach(vote => {
                                                if (!vote.isBlocked) {
                                                    totalVotes++;
                                                    totalScore += vote.score;
                                                }
                                            });
                                        });
                                        const contestAverage = totalVotes > 0 ? (totalScore / totalVotes).toFixed(2) : 0;

                                        return `
                                            <div class="bg-gradient-to-br from-yellow-50 to-yellow-100 rounded-lg shadow-md p-3 flex flex-col items-center border-2 border-yellow-500">
                                                <div class="text-2xl mb-2">üèÜ</div>
                                                <div class="text-xs font-semibold text-gray-800 text-center mb-1">
                                                    Contest Average
                                                </div>
                                                <div class="text-xl font-bold text-white score-text">
                                                    ${contestAverage}
                                                </div>
                                                <div class="text-xs text-gray-500">
                                                    ${totalVotes} vote${totalVotes !== 1 ? 's' : ''}
                                                </div>
                                            </div>
                                        `;
                                    })()}
                                    ${voterStats.map(voter => `
                                        <div class="bg-white rounded-lg shadow-md p-3 flex flex-col items-center hover:shadow-lg transition-shadow border-2 ${voter.isCurrentUser ? 'border-mauve-400' : 'border-transparent'}">
                                            <img src="${voter.avatar}" alt="${voter.username}" class="w-12 h-12 rounded-full mb-2 cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');" />
                                            <div class="text-xs font-semibold text-gray-800 truncate w-full text-center mb-1 cursor-pointer hover:text-mauve-600 transition" title="${voter.username}" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');">
                                                ${voter.username}
                                            </div>
                                            <div class="text-xl font-bold text-white score-text">
                                                ${voter.averageScore}
                                            </div>
                                            <div class="text-xs text-gray-500">
                                                ${voter.totalImages} vote${voter.totalImages !== 1 ? 's' : ''}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">üë•</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Voters Yet</h3>
                                    <p class="text-gray-600">No voting data available for this contest.</p>
                                </div>
                            `}
                        ` : state.resultsView === 'userVotes' && (!displayResults || displayResults.length === 0) ? `
                            <div class="text-center py-12">
                                <div class="text-6xl mb-4">üì≠</div>
                                <h3 class="text-xl font-bold text-gray-800 mb-2">No Votes Yet</h3>
                                <p class="text-gray-600">This user hasn't voted on this contest yet.</p>
                            </div>
                        ` : sortedKeys.map(key => {
                            const group = grouped[key];

                            if (state.resultsView === 'userVotes') {
                                const score = group.score;
                                const colorStyle = getScoreColor(score);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg inline-block" style="color: white; background-color: ${colorStyle};">
                                            Score ${score}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdown(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    ${item.isBlocked ? `
                                                        <div class="absolute inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-10">
                                                            <span class="text-4xl">üö´</span>
                                                        </div>
                                                    ` : ''}
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover ${item.isBlocked ? 'opacity-60' : ''}"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            } else {
                                const colorStyle = getCategoryColor(group.min, group.isMissing);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg ${colorStyle.color} ${colorStyle.bg} w-full block">
                                            ${getCategoryLabel(group.min, group.max, group.isMissing)}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdown(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                    <div class="absolute bottom-0 left-0 right-0 text-white text-center py-1 font-bold score-text" style="font-size: ${fontSize}px;">
                                                        ${item.averageScore}
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>
                    ${state.showBreakdownModal ? renderBreakdownModal() : ''}
                </div>
            `;
        }

        function renderBreakdownModal() {
            // Check if this is a shortcake breakdown modal
            if (state.showBreakdownModal && typeof state.showBreakdownModal === 'object' && state.showBreakdownModal.type === 'shortcake') {
                return renderShortcakeBreakdownModal();
            }

            const item = state.results.find(r => r.id === state.showBreakdownModal);
            if (!item) return '';

            const votesByScore = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            item.breakdown.forEach(vote => {
                votesByScore[vote.score].push(vote);
            });

            Object.keys(votesByScore).forEach(score => {
                votesByScore[score].sort((a, b) => a.username.localeCompare(b.username));
            });

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] sm:max-h-[85vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-gray-800">Vote Breakdown</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="overflow-y-auto flex-1 p-4">

                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 400px;">
                                <img
                                    src="${item.url}"
                                    alt="Image"
                                    class="max-w-full max-h-[400px] object-contain"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                            </div>

                            <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-gray-800">${item.averageScore}</div>
                                    <div class="text-xs text-gray-600">Average Score</div>
                                    <div class="text-xs text-gray-500 mt-1">${item.totalVotes} total votes</div>
                                </div>
                            </div>

                            <div class="space-y-3">
                                ${[5, 4, 3, 2, 1].map(score => `
                                    <div>
                                        <h4 class="text-sm font-bold mb-2 px-3 py-1 rounded-lg inline-block" style="color: ${getScoreColor(score)}; background-color: ${getScoreColor(score)}20;">
                                            Score ${score} (${votesByScore[score].length} ${votesByScore[score].length === 1 ? 'vote' : 'votes'})
                                        </h4>
                                        ${votesByScore[score].length > 0 ? `
                                            <div class="grid grid-cols-1 gap-2 mt-2">
                                                ${votesByScore[score].map(vote => {
                                                    const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
                                                    return `
                                                    <div class="flex items-center gap-2 p-2 rounded-lg ${
                                                        vote.isBanned ? 'bg-red-100 opacity-60' :
                                                        vote.isBlocked ? 'bg-gray-300' :
                                                        vote.isCurrentUser ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'
                                                    }">
                                                        <img src="${vote.avatar}" alt="${vote.username}" class="w-8 h-8 rounded-full flex-shrink-0 ${vote.isBanned ? 'opacity-50' : ''} cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');" />
                                                        <span class="text-sm flex-1 truncate cursor-pointer ${
                                                            vote.isBanned ? 'line-through text-red-600' :
                                                            vote.isBlocked ? 'line-through text-gray-700' :
                                                            'text-gray-700 hover:text-mauve-600'
                                                        }" onclick="event.stopPropagation(); viewUserProfile('${vote.userId}');">
                                                            ${vote.username}${vote.isCurrentUser ? ' (You)' : ''}${vote.isBanned ? ' (BANNED)' : ''}
                                                        </span>
                                                        ${isAdmin ? `
                                                            <button
                                                                onclick="adminEditVote('${vote.userId}', ${item.id}, ${score})"
                                                                class="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-xs"
                                                                title="Edit vote"
                                                            >
                                                                ‚úèÔ∏è
                                                            </button>
                                                            <button
                                                                onclick="adminToggleBlockVote('${vote.userId}', ${item.id}, ${vote.isBlocked || false})"
                                                                class="px-2 py-1 ${vote.isBlocked ? 'bg-green-500 hover:bg-green-600' : 'bg-red-500 hover:bg-red-600'} text-white rounded text-xs"
                                                                title="${vote.isBlocked ? 'Unblock vote' : 'Block vote'}"
                                                            >
                                                                ${vote.isBlocked ? '‚úì' : 'üö´'}
                                                            </button>
                                                        ` : ''}
                                                    </div>
                                                `}).join('')}
                                            </div>
                                        ` : `
                                            <div class="text-gray-400 italic text-sm mt-2 ml-3">No votes</div>
                                        `}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Shortcake breakdown modal with two-column layout
        function renderShortcakeBreakdownModal() {
            const modalData = state.showBreakdownModal;
            if (!modalData) return '';

            const { imageUrl, shortlisted, notShortlisted } = modalData;

            // Sort voters alphabetically
            shortlisted.sort((a, b) => a.username.localeCompare(b.username));
            notShortlisted.sort((a, b) => a.username.localeCompare(b.username));

            return `
                <div class="fixed inset-0 modal-overlay flex items-start sm:items-center justify-center z-50 p-4 overflow-y-auto" onclick="event.target === this && closeBreakdown()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-5xl w-full max-h-[90vh] sm:max-h-[85vh] flex flex-col modal-content my-4 sm:my-0" onclick="event.stopPropagation()">
                        <div class="p-4 flex-shrink-0 bg-white z-10 border-b border-gray-200 rounded-t-2xl">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-amber-900">Shortlist Breakdown</h3>
                                <button onclick="closeBreakdown()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="overflow-y-auto flex-1 p-4">
                            <div class="mb-3 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100" style="max-height: 400px;">
                                <img
                                    src="${imageUrl}"
                                    alt="Image"
                                    class="max-w-full max-h-[400px] object-contain"
                                    onload="this.parentElement.classList.remove('image-loading')"
                                />
                            </div>

                            <div class="bg-amber-50 rounded-lg p-3 mb-3">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-amber-900">${shortlisted.length} shortlisted</div>
                                    <div class="text-xs text-amber-700">out of ${shortlisted.length + notShortlisted.length} total voters</div>
                                </div>
                            </div>

                            <!-- Two-column layout: Shortlisted vs Not Shortlisted -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <!-- Shortlisted Column -->
                                <div>
                                    <h4 class="text-sm font-bold mb-2 px-3 py-2 rounded-lg bg-blue-500 text-white text-center">
                                        ‚úì Shortlisted (${shortlisted.length})
                                    </h4>
                                    ${shortlisted.length > 0 ? `
                                        <div class="space-y-2 mt-2 max-h-96 overflow-y-auto">
                                            ${shortlisted.map(voter => `
                                                <div class="flex items-center gap-2 p-2 rounded-lg bg-blue-50 border border-blue-200">
                                                    ${voter.avatar ? `
                                                        <img src="${voter.avatar}" alt="${voter.username}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-blue-400 transition" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');" />
                                                    ` : `
                                                        <div class="w-8 h-8 rounded-full bg-blue-300 flex items-center justify-center text-blue-700 font-bold text-sm flex-shrink-0">
                                                            ${voter.username.charAt(0).toUpperCase()}
                                                        </div>
                                                    `}
                                                    <span class="text-sm flex-1 truncate cursor-pointer text-gray-700 hover:text-blue-600" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');">
                                                        ${voter.username}${voter.userId === state.user?.id ? ' (You)' : ''}
                                                    </span>
                                                </div>
                                            `).join('')}
                                        </div>
                                    ` : `
                                        <div class="text-gray-400 italic text-sm mt-2 text-center py-4">No voters shortlisted this image</div>
                                    `}
                                </div>

                                <!-- Not Shortlisted Column -->
                                <div>
                                    <h4 class="text-sm font-bold mb-2 px-3 py-2 rounded-lg bg-red-500 text-white text-center">
                                        ‚úó Not Shortlisted (${notShortlisted.length})
                                    </h4>
                                    ${notShortlisted.length > 0 ? `
                                        <div class="space-y-2 mt-2 max-h-96 overflow-y-auto">
                                            ${notShortlisted.map(voter => `
                                                <div class="flex items-center gap-2 p-2 rounded-lg bg-red-50 border border-red-200">
                                                    ${voter.avatar ? `
                                                        <img src="${voter.avatar}" alt="${voter.username}" class="w-8 h-8 rounded-full flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-red-400 transition" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');" />
                                                    ` : `
                                                        <div class="w-8 h-8 rounded-full bg-red-300 flex items-center justify-center text-red-700 font-bold text-sm flex-shrink-0">
                                                            ${voter.username.charAt(0).toUpperCase()}
                                                        </div>
                                                    `}
                                                    <span class="text-sm flex-1 truncate cursor-pointer text-gray-700 hover:text-red-600" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');">
                                                        ${voter.username}${voter.userId === state.user?.id ? ' (You)' : ''}
                                                    </span>
                                                </div>
                                            `).join('')}
                                        </div>
                                    ` : `
                                        <div class="text-gray-400 italic text-sm mt-2 text-center py-4">All voters shortlisted this image</div>
                                    `}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAdminDashboard() {
            if (!state.showAdminDashboard) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get banned users info
            const bannedUsersInfo = state.bannedUsers.map(userId => {
                // Try to find user info from contests
                const contest = state.contests.find(c => c.createdBy === userId);
                if (contest) {
                    return {
                        id: userId,
                        username: contest.creatorName,
                        avatar: contest.creatorAvatar
                    };
                }
                // Fallback
                return {
                    id: userId,
                    username: 'User' + userId.substring(0, 4),
                    avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${userId}`
                };
            });

            // Calculate admin statistics
            const totalContests = state.contests.length;
            const totalVotes = state.adminStats.totalVotes;
            const totalUniqueVoters = state.adminStats.totalUniqueVoters;
            const totalImagesShortlisted = state.adminStats.totalImagesShortlisted || 0;
            const totalBannedUsers = state.bannedUsers.length;
            const totalImages = state.contests.reduce((sum, contest) => sum + (contest.images?.length || 0), 0);

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-50 p-4" onclick="event.target === this && closeAdminDashboard()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-3xl w-full max-h-[90vh] overflow-y-auto modal-content" onclick="event.stopPropagation()">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-2xl font-bold text-gray-800">Admin Dashboard</h3>
                                <button onclick="closeAdminDashboard()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>

                            ${state.adminDashboardLoading ? `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">‚è≥</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">Loading Dashboard...</h3>
                                    <p class="text-gray-600">Please wait while we fetch the statistics.</p>
                                </div>
                            ` : `
                            <div class="space-y-4">
                                <div class="bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg p-4 border border-purple-200">
                                    <div class="flex justify-between items-center mb-3">
                                        <h4 class="font-bold text-gray-800">Statistics</h4>
                                        <button onclick="showActivityLogs()" class="bg-mauve-500 text-white px-4 py-2 rounded-lg text-sm font-semibold hover:bg-mauve-600 transition shadow-lg">
                                            üìä Recent Activity
                                        </button>
                                    </div>
                                    <div class="grid grid-cols-2 md:grid-cols-3 gap-3">
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-purple-600">${totalContests}</div>
                                            <div class="text-xs text-gray-600">Total Contests</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-blue-600">${totalVotes}</div>
                                            <div class="text-xs text-gray-600">Total Votes</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-amber-600">${totalImagesShortlisted}</div>
                                            <div class="text-xs text-gray-600">Total Shortlisted</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-green-600">${totalUniqueVoters}</div>
                                            <div class="text-xs text-gray-600">Unique Voters</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-orange-600">${totalImages}</div>
                                            <div class="text-xs text-gray-600">Total Images</div>
                                        </div>
                                        <div class="bg-white rounded-lg p-3 text-center">
                                            <div class="text-2xl font-bold text-red-600">${totalBannedUsers}</div>
                                            <div class="text-xs text-gray-600">Banned Users</div>
                                        </div>
                                    </div>
                                </div>

                                <div class="bg-blue-50 rounded-lg p-4 border border-blue-200">
                                    <h4 class="font-bold text-blue-800 mb-3">üë• All Users</h4>
                                    ${state.allUsers.length > 0 ? `
                                        <div class="space-y-2 max-h-96 overflow-y-auto">
                                            ${[...state.allUsers].sort((a, b) => a.username.localeCompare(b.username)).map(user => {
                                                const isBanned = state.bannedUsers.includes(user.id);
                                                return `
                                                    <div class="flex items-center justify-between p-3 bg-white rounded-lg ${isBanned ? 'opacity-50' : ''}">
                                                        <div class="flex items-center gap-3">
                                                            <img src="${user.avatar}" alt="${user.username}" class="w-10 h-10 rounded-full cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${user.id}');" />
                                                            <div>
                                                                <div class="font-semibold text-gray-800 cursor-pointer hover:text-mauve-600 transition" onclick="event.stopPropagation(); viewUserProfile('${user.id}');">${user.username}</div>
                                                                <div class="text-xs text-gray-500">${user.id}</div>
                                                                ${isBanned ? '<span class="text-xs text-red-600 font-semibold">BANNED</span>' : ''}
                                                            </div>
                                                        </div>
                                                        ${isBanned ? `
                                                            <button onclick="unbanUser('${user.id}')" class="bg-green-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-green-600 transition text-sm">
                                                                Unban
                                                            </button>
                                                        ` : `
                                                            <button onclick="confirmBanUser('${user.id}')" class="bg-red-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-red-600 transition text-sm">
                                                                Ban
                                                            </button>
                                                        `}
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : '<p class="text-sm text-gray-500 italic">No users have logged in yet</p>'}
                                </div>
                            </div>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAppSettingsModal() {
            if (!state.showAppSettingsModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get current settings values (default to true if not set)
            const contestCreationEnabled = state.appSettings.contest_creation_enabled !== false;
            const revotingEnabled = state.appSettings.revoting_enabled !== false;
            const showPinIcons = state.appSettings.show_pin_icons === true;  // Default to false

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeAppSettings()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full modal-content" onclick="event.stopPropagation()">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-6">
                                <h3 class="text-2xl font-bold text-gray-800">App Settings</h3>
                                <button onclick="closeAppSettings()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>

                            <div class="space-y-6">
                                <!-- Contest Creation Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Contest Creation</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Allow users to create new contests
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${contestCreationEnabled ? 'active' : ''}"
                                        onclick="toggleAppSetting('contest_creation_enabled')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <!-- Revoting Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Revoting</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Allow users to change their votes after submission
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${revotingEnabled ? 'active' : ''}"
                                        onclick="toggleAppSetting('revoting_enabled')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <!-- Show Pin Icons Toggle -->
                                <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-800">Show Pin Icons</h4>
                                        <p class="text-sm text-gray-600 mt-1">
                                            Display pin/unpin buttons on cards (admin only)
                                        </p>
                                    </div>
                                    <div
                                        class="toggle-switch ${showPinIcons ? 'active' : ''}"
                                        onclick="toggleAppSetting('show_pin_icons')"
                                    >
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>

                                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <p class="text-sm text-blue-800">
                                        üí° <strong>Note:</strong> These settings affect all users globally. Disabled features will show informative messages to users.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderActivityLogsModal() {
            if (!state.showActivityLogsModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Helper function to format timestamp with exact date and time
            const formatTimestamp = (timestamp) => {
                const date = new Date(timestamp);
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = months[date.getMonth()];
                const day = date.getDate();
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${month} ${day}, ${hours}:${minutes}`;
            };

            // Get event type styling
            const getEventStyle = (type) => {
                switch(type) {
                    case 'contest':
                        return { bg: 'bg-green-100', hover: 'hover:bg-green-200', icon: 'üèÜ', text: 'Created contest' };
                    case 'merger':
                        return { bg: 'bg-blue-100', hover: 'hover:bg-blue-200', icon: 'üîÄ', text: 'Created merger' };
                    case 'extract':
                        return { bg: 'bg-yellow-100', hover: 'hover:bg-yellow-200', icon: '‚úÇÔ∏è', text: 'Created extract' };
                    case 'signup':
                        return { bg: 'bg-purple-100', hover: 'hover:bg-purple-200', icon: 'üë§', text: 'Joined the app' };
                    case 'vote_completed':
                        return { bg: 'bg-yellow-50', hover: 'hover:bg-yellow-100', icon: '‚úÖ', text: 'Completed voting on' };
                    default: // vote (partial)
                        return { bg: 'bg-gray-50', hover: 'hover:bg-gray-100', icon: 'üó≥Ô∏è', text: 'Voted on' };
                }
            };

            // Calculate date range (use state dates or default to last 7 days)
            const now = new Date();
            let weekStart, weekEnd;

            if (state.activityDateStart && state.activityDateEnd) {
                weekStart = new Date(state.activityDateStart);
                weekEnd = new Date(state.activityDateEnd);
            } else {
                weekStart = new Date(now);
                weekStart.setDate(now.getDate() - 7);
                weekEnd = new Date(now);
            }

            // Format date for input fields (YYYY-MM-DD)
            const formatDateInput = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const startDateInput = state.activityDateStart || formatDateInput(weekStart);
            const endDateInput = state.activityDateEnd || formatDateInput(weekEnd);

            const formatDate = (date) => {
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${months[date.getMonth()]} ${date.getDate()}`;
            };
            const weekRange = `${formatDate(weekStart)} - ${formatDate(weekEnd)}, ${weekEnd.getFullYear()}`;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeActivityLogs()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden modal-content flex flex-col" onclick="event.stopPropagation()">
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-2xl font-bold text-gray-800">üìä Recent Activity</h3>
                                <button onclick="closeActivityLogs()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="flex flex-wrap gap-3 items-end">
                                <div class="flex-1 min-w-[140px]">
                                    <label class="block text-xs font-semibold text-gray-600 mb-1">Start Date</label>
                                    <input
                                        type="date"
                                        id="activityStartDate"
                                        value="${startDateInput}"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-mauve-400 focus:border-mauve-400"
                                        onchange="setActivityStartDate(this.value)"
                                    />
                                </div>
                                <div class="flex-1 min-w-[140px]">
                                    <label class="block text-xs font-semibold text-gray-600 mb-1">End Date</label>
                                    <input
                                        type="date"
                                        id="activityEndDate"
                                        value="${endDateInput}"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-mauve-400 focus:border-mauve-400"
                                        onchange="setActivityEndDate(this.value)"
                                    />
                                </div>
                                <button
                                    onclick="loadActivityLogs()"
                                    class="bg-mauve-500 text-white px-4 py-2 rounded-lg text-sm font-semibold hover:bg-mauve-600 transition shadow-md disabled:opacity-50 disabled:cursor-not-allowed"
                                    ${state.activityLogsLoading ? 'disabled' : ''}
                                >
                                    ${state.activityLogsLoading ? '‚è≥ Loading...' : 'üîÑ Refresh'}
                                </button>
                            </div>
                            <div class="flex flex-wrap gap-3 items-center mt-3">
                                <div class="flex-1 min-w-[140px]">
                                    <label class="block text-xs font-semibold text-gray-600 mb-1">Filter by User</label>
                                    <select
                                        onchange="setActivityFilterUser(this.value)"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-mauve-400 focus:border-mauve-400"
                                    >
                                        <option value="">All Users</option>
                                        ${(() => {
                                            const uniqueUsers = new Map();
                                            state.activityLogs.forEach(log => {
                                                if (!uniqueUsers.has(log.userId)) {
                                                    uniqueUsers.set(log.userId, {
                                                        userId: log.userId,
                                                        username: log.username
                                                    });
                                                }
                                            });
                                            return Array.from(uniqueUsers.values())
                                                .sort((a, b) => a.username.localeCompare(b.username))
                                                .map(user => `
                                                    <option value="${user.userId}" ${state.activityFilterUser === user.userId ? 'selected' : ''}>
                                                        ${user.username}
                                                    </option>
                                                `).join('');
                                        })()}
                                    </select>
                                </div>
                                <div class="flex-1 min-w-[140px]">
                                    <label class="block text-xs font-semibold text-gray-600 mb-1">Filter by Contest</label>
                                    <select
                                        onchange="setActivityFilterContest(this.value)"
                                        class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-mauve-400 focus:border-mauve-400"
                                    >
                                        <option value="">All Contests</option>
                                        ${(() => {
                                            const uniqueContests = new Map();
                                            state.activityLogs.forEach(log => {
                                                if (log.contestId && !uniqueContests.has(log.contestId)) {
                                                    uniqueContests.set(log.contestId, {
                                                        contestId: log.contestId,
                                                        contestTitle: log.contestTitle
                                                    });
                                                }
                                            });
                                            return Array.from(uniqueContests.values())
                                                .sort((a, b) => a.contestTitle.localeCompare(b.contestTitle))
                                                .map(contest => `
                                                    <option value="${contest.contestId}" ${state.activityFilterContest == contest.contestId ? 'selected' : ''}>
                                                        ${contest.contestTitle}
                                                    </option>
                                                `).join('');
                                        })()}
                                    </select>
                                </div>
                            </div>
                            <p class="text-xs text-gray-500 mt-3">Showing activity from ${weekRange}</p>
                        </div>

                        <div class="p-6 overflow-y-auto flex-1">
                            ${state.activityLogsLoading ? `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">‚è≥</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">Loading Activity...</h3>
                                    <p class="text-gray-600">Please wait while we fetch the activity logs.</p>
                                </div>
                            ` : state.activityLogs.length > 0 ? `
                                <div class="space-y-1">
                                    ${(() => {
                                        // Apply filters to activity logs
                                        let filteredLogs = state.activityLogs;

                                        // Filter by user
                                        if (state.activityFilterUser) {
                                            filteredLogs = filteredLogs.filter(log => log.userId === state.activityFilterUser);
                                        }

                                        // Filter by contest
                                        if (state.activityFilterContest) {
                                            filteredLogs = filteredLogs.filter(log => log.contestId == state.activityFilterContest);
                                        }

                                        if (filteredLogs.length === 0) {
                                            return `
                                                <div class="text-center py-12">
                                                    <div class="text-6xl mb-4">üîç</div>
                                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Results</h3>
                                                    <p class="text-gray-600">No activity matches the selected filters.</p>
                                                </div>
                                            `;
                                        }

                                        return filteredLogs.map(log => {
                                        const style = getEventStyle(log.type);
                                        const isSignup = log.type === 'signup';
                                        const isCreation = log.type !== 'vote' && log.type !== 'vote_completed' && log.type !== 'signup';
                                        const itemName = isCreation ? log.itemName : log.contestTitle;

                                        return `
                                            <div class="flex items-center gap-2 p-2 ${style.bg} rounded-lg ${style.hover} transition">
                                                <div class="text-lg flex-shrink-0">
                                                    ${style.icon}
                                                </div>
                                                <img
                                                    src="${log.avatar}"
                                                    alt="${log.username}"
                                                    class="w-6 h-6 rounded-full cursor-pointer hover:ring-2 hover:ring-mauve-400 transition flex-shrink-0"
                                                    onclick="event.stopPropagation(); viewUserProfile('${log.userId}');"
                                                />
                                                <div class="flex-1 min-w-0">
                                                    <div class="text-sm">
                                                        <span
                                                            class="font-semibold text-gray-800 cursor-pointer hover:text-mauve-600 transition"
                                                            onclick="event.stopPropagation(); viewUserProfile('${log.userId}');"
                                                        >
                                                            ${log.username}
                                                        </span>
                                                        <span class="text-gray-600">
                                                            ${isSignup ? style.text.toLowerCase() : `${style.text.toLowerCase()}: <span class="font-medium">${itemName}</span>`}
                                                        </span>
                                                    </div>
                                                </div>
                                                                <div class="text-xs text-gray-500 flex-shrink-0 sm:text-right">
                                                    <div class="sm:inline">${formatTimestamp(log.timestamp).split(', ')[0]},</div>
                                                    <div class="sm:inline sm:ml-1">${formatTimestamp(log.timestamp).split(', ')[1]}</div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('');
                                    })()}
                                </div>
                            ` : `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">üì≠</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Recent Activity</h3>
                                    <p class="text-gray-600">No activity recorded this week yet.</p>
                                </div>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderManageFoldersModal() {
            if (!state.showManageFoldersModal) return '';

            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            if (!isAdmin) return '';

            // Get all items that are already in folders
            const itemsInFolders = new Set();
            state.groups.forEach(group => {
                (group.items || []).forEach(item => {
                    itemsInFolders.add(`${item.item_type}:${item.item_id}`);
                });
            });

            // Calculate ungrouped items count
            const allItems = [...state.contests.map(c => ({ itemType: 'contest', id: c.id })),
                            ...state.mergers.map(m => ({ itemType: 'merger', id: m.id })),
                            ...state.extracts.map(e => ({ itemType: 'extract', id: e.id }))];
            const ungroupedItemsCount = allItems.filter(item =>
                !itemsInFolders.has(`${item.itemType}:${item.id}`)
            ).length;

            // Get unfoldered items position from app settings (default to bottom if not set)
            const unfolderedPosition = state.appSettings.unfoldered_items_position !== undefined
                ? parseInt(state.appSettings.unfoldered_items_position)
                : state.groups.length;

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[60] p-4" onclick="event.target === this && closeManageFoldersModal()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden modal-content flex flex-col" onclick="event.stopPropagation()">
                        <div class="p-6 border-b border-gray-200">
                            <div class="flex justify-between items-center">
                                <h3 class="text-2xl font-bold text-gray-800">üìÅ Manage Folders</h3>
                                <button onclick="closeManageFoldersModal()" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="p-6 overflow-y-auto flex-1">
                            <div class="mb-6">
                                <button onclick="showCreateFolderModal()" class="bg-gradient-to-r from-green-500 to-green-700 text-white px-4 py-2 rounded-lg font-semibold hover:from-green-600 hover:to-green-800 transition shadow-lg">
                                    + Create New Folder
                                </button>
                            </div>

                            ${state.groups.length === 0 && ungroupedItemsCount === 0 ? `
                                <div class="text-center py-8 text-gray-500">
                                    <p class="text-lg mb-2">No folders yet</p>
                                    <p class="text-sm">Create a folder to organize your contests, mergers, and extracts</p>
                                </div>
                            ` : `
                                <div class="space-y-4" id="folders-list">
                                    ${(() => {
                                        // Build the sorted list with unfoldered items meta-item
                                        const items = [];
                                        state.groups.forEach((group, index) => {
                                            items.push({ type: 'folder', data: group, originalIndex: index });
                                        });
                                        // Insert unfoldered items meta-item at the specified position
                                        items.splice(unfolderedPosition, 0, { type: 'unfoldered', data: null });

                                        return items.map((item, index) => {
                                            if (item.type === 'unfoldered') {
                                                return `
                                                    <div class="border border-gray-300 rounded-lg overflow-hidden bg-gradient-to-r from-gray-100 to-gray-200" data-unfoldered="true">
                                                        <div class="bg-gray-100 p-4 flex items-center gap-3">
                                                            <div class="cursor-move text-gray-400 hover:text-gray-600">
                                                                ‚ãÆ‚ãÆ
                                                            </div>
                                                            <div class="flex-1">
                                                                <h4 class="font-semibold text-gray-700 flex items-center gap-2">
                                                                    <span>üìã</span>
                                                                    <span>Unfoldered Items</span>
                                                                </h4>
                                                                <p class="text-sm text-gray-600">${ungroupedItemsCount} items (not draggable within)</p>
                                                            </div>
                                                            <span class="text-xs text-gray-500 italic">Special Section</span>
                                                        </div>
                                                    </div>
                                                `;
                                            } else {
                                                const group = item.data;
                                                const isExpanded = state.expandedFolderIds.includes(group.id);
                                                return `
                                                    <div class="border border-gray-300 rounded-lg overflow-hidden" data-folder-id="${group.id}">
                                                        <div class="bg-gray-50 p-4 flex items-center gap-3">
                                                            <div class="cursor-move text-gray-400 hover:text-gray-600">
                                                                ‚ãÆ‚ãÆ
                                                            </div>
                                                            <button onclick="event.stopPropagation(); toggleFolderExpanded('${group.id}')" class="text-gray-600 hover:text-gray-800 transition">
                                                                <svg class="w-5 h-5 transition-transform ${isExpanded ? 'rotate-90' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                                </svg>
                                                            </button>
                                                            <div class="flex-1">
                                                                <h4 class="font-semibold text-gray-800">${group.name}</h4>
                                                                <p class="text-sm text-gray-600">${(group.items || []).length} items</p>
                                                            </div>
                                                            <button onclick="addItemToFolder('${group.id}')" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 text-sm">
                                                                + Add Item
                                                            </button>
                                                            <button onclick="deleteFolder('${group.id}')" class="bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600 text-sm">
                                                                Delete
                                                            </button>
                                                        </div>
                                                        ${isExpanded && (group.items || []).length > 0 ? `
                                                            <div class="p-4 bg-white space-y-2" id="folder-items-${group.id}" data-folder-id="${group.id}">
                                                                ${(group.items || []).map(item => {
                                                                    // Find the actual item
                                                                    let itemData = null;
                                                                    let itemTitle = 'Unknown';
                                                                    if (item.item_type === 'contest') {
                                                                        itemData = state.contests.find(c => c.id === item.item_id);
                                                                        itemTitle = itemData?.title || 'Unknown Contest';
                                                                    } else if (item.item_type === 'merger') {
                                                                        itemData = state.mergers.find(m => m.id === item.item_id);
                                                                        itemTitle = itemData?.name || 'Unknown Merger';
                                                                    } else if (item.item_type === 'extract') {
                                                                        itemData = state.extracts.find(e => e.id === item.item_id);
                                                                        itemTitle = itemData?.name || 'Unknown Extract';
                                                                    }

                                                                    return `
                                                                        <div class="flex items-center gap-3 p-2 bg-gray-50 rounded">
                                                                            <div class="cursor-move text-gray-400 hover:text-gray-600 text-xs">
                                                                                ‚ãÆ‚ãÆ
                                                                            </div>
                                                                            <div class="flex-1">
                                                                                <span class="text-sm font-medium text-gray-800">${itemTitle}</span>
                                                                                <span class="text-xs text-gray-500 ml-2">[${item.item_type.toUpperCase()}]</span>
                                                                            </div>
                                                                            <button onclick="removeItemFromFolder('${group.id}', '${item.item_id}', '${item.item_type}')" class="text-red-500 hover:text-red-700 text-sm">
                                                                                Remove
                                                                            </button>
                                                                        </div>
                                                                    `;
                                                                }).join('')}
                                                            </div>
                                                        ` : ''}
                                                    </div>
                                                `;
                                            }
                                        }).join('');
                                    })()}
                                </div>
                            `}

                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-6">
                                <p class="text-sm text-blue-800">
                                    üí° <strong>Note:</strong> Folders organize your contests, mergers, and extracts on the home page.
                                    Drag the "Unfoldered Items" section to position it above or below specific folders.
                                    Click the arrow to expand/collapse folders and see their items.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderShortcakeResults() {
            const shortcake = state.currentShortcake;

            // Check privacy settings
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const isCreator = state.user && state.user.id === shortcake.createdBy;
            const isPrivate = shortcake.resultsPublic === false;
            const canViewPrivateResults = isAdmin || isCreator;

            // Block unauthorized users from viewing private results
            if (isPrivate && !canViewPrivateResults) {
                return `
                    <div class="max-w-7xl mx-auto px-3 py-4">
                        <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                            <div class="text-center py-16">
                                <div class="text-8xl mb-6">üîí</div>
                                <h3 class="text-2xl font-bold text-amber-900 mb-3">Results are Private</h3>
                                <p class="text-amber-800 max-w-md mx-auto">
                                    Only the shortcake creator can view results. Contact the creator if you believe you should have access.
                                </p>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Get image scale
            const imageScale = state.imageScale || 100;
            const baseSize = 150;
            const imageHeight = Math.max(30, Math.min(500, Math.floor(baseSize * (imageScale / 100))));

            // Fetch shortcake votes data from state (should be loaded with voter details)
            const shortcakeVotes = state.shortcakeResults || [];

            // Count how many times each image was shortlisted and track voters
            const shortlistCounts = {};
            const imageVoters = {}; // Track which users shortlisted each image

            shortcake.images.forEach(img => {
                shortlistCounts[img.id] = 0;
                imageVoters[img.id] = { shortlisted: [], notShortlisted: [] };
            });

            shortcakeVotes.forEach(vote => {
                const shortlistedIds = vote.shortlisted_image_ids || [];
                const shortlistedSet = new Set(shortlistedIds);

                shortcake.images.forEach(img => {
                    if (shortlistedSet.has(img.id)) {
                        shortlistCounts[img.id]++;
                        imageVoters[img.id].shortlisted.push({
                            userId: vote.user_id,
                            username: vote.voter?.username || 'Unknown',
                            avatar: vote.voter?.avatar || null
                        });
                    } else {
                        imageVoters[img.id].notShortlisted.push({
                            userId: vote.user_id,
                            username: vote.voter?.username || 'Unknown',
                            avatar: vote.voter?.avatar || null
                        });
                    }
                });
            });

            // Build results with shortlist counts
            const results = shortcake.images.map(img => ({
                ...img,
                shortlistCount: shortlistCounts[img.id] || 0,
                voters: imageVoters[img.id]
            }));

            // Initialize resultsView for shortcakes if not set
            if (!state.shortcakeResultsView) {
                state.shortcakeResultsView = 'average';
            }

            // Group based on current view
            let grouped = {};
            let sortedCounts = [];
            let displayResults = results;

            // === BY VOTER VIEW ===
            if (state.shortcakeResultsView === 'byVoter') {
                // Show stats per voter (similar to contest byVoter)
                const voterStats = shortcakeVotes.map(vote => {
                    const shortlistedCount = (vote.shortlisted_image_ids || []).length;
                    const percentage = (shortlistedCount / shortcake.images.length) * 100;

                    return {
                        userId: vote.user_id,
                        username: vote.voter?.username || 'Unknown',
                        avatar: vote.voter?.avatar || null,
                        shortlistedCount: shortlistedCount,
                        percentage: percentage.toFixed(1)
                    };
                });

                // Sort by shortlistedCount
                voterStats.sort((a, b) => b.shortlistedCount - a.shortlistedCount);

                return renderShortcakeByVoterView(shortcake, voterStats, imageScale);
            }
            // === USER VOTES VIEW ===
            else if (state.shortcakeResultsView === 'userVotes') {
                const selectedUserId = state.selectedVoterUserId || state.user?.id;
                const selectedVote = shortcakeVotes.find(v => v.user_id === selectedUserId);

                if (selectedVote) {
                    const shortlistedIds = new Set(selectedVote.shortlisted_image_ids || []);
                    displayResults = results.map(img => ({
                        ...img,
                        isShortlistedByUser: shortlistedIds.has(img.id)
                    }));

                    // Group into shortlisted and not shortlisted
                    grouped = {
                        'Shortlisted': displayResults.filter(img => img.isShortlistedByUser),
                        'Not Shortlisted': displayResults.filter(img => !img.isShortlistedByUser)
                    };
                    sortedCounts = ['Shortlisted', 'Not Shortlisted'];
                } else {
                    // No votes from selected user
                    displayResults = [];
                }
            }
            // === AVERAGE VIEW (DEFAULT) ===
            else {
                // Group images by shortlist count
                results.forEach(img => {
                    const count = img.shortlistCount;
                    if (!grouped[count]) {
                        grouped[count] = [];
                    }
                    grouped[count].push(img);
                });

                // Sort groups by count (highest first)
                sortedCounts = Object.keys(grouped).map(Number).sort((a, b) => b - a);
            }

            // Find max count for color scaling
            const maxCount = Math.max(...results.map(r => r.shortlistCount), 1);

            // Render the results with vertical panels
            const resultsHTML = state.shortcakeResultsView === 'userVotes'
                ? renderShortcakeUserVotesView(sortedCounts, grouped, imageHeight, maxCount, shortcakeVotes)
                : renderShortcakeAverageView(sortedCounts, grouped, imageHeight, maxCount);

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <!-- Header -->
                        <div class="text-center mb-4">
                            <div class="flex items-center justify-center gap-2 mb-2">
                                <span class="text-4xl">üç∞</span>
                                <h2 class="text-2xl font-bold text-amber-900">${shortcake.title} - Results</h2>
                            </div>
                            <p class="text-amber-800 text-sm mb-1">
                                ${state.shortcakeResultsView === 'byVoter' ? 'Shortlist stats per voter' :
                                  state.shortcakeResultsView === 'userVotes' ? 'Individual user shortlists' :
                                  'Shortlist results from all participants'}
                            </p>
                            <p class="text-xs text-gray-500">
                                ${shortcakeVotes.length} voter${shortcakeVotes.length !== 1 ? 's' : ''}${state.shortcakeResultsView !== 'byVoter' ? ' ‚Ä¢ Click on any image to see who shortlisted it' : ''}
                            </p>

                            ${isPrivate ? `
                                <div class="mt-3 mb-2 max-w-2xl mx-auto">
                                    <div class="bg-yellow-50 border border-yellow-400 text-yellow-800 px-4 py-3 rounded-lg text-sm flex items-start gap-2">
                                        <span class="text-lg flex-shrink-0">‚ö†Ô∏è</span>
                                        <p class="flex-1">${isCreator ? 'These results are private. Only you can view them.' : 'These results are private. Only you and the creator can view them.'}</p>
                                    </div>
                                </div>
                            ` : ''}

                            <!-- View Tabs -->
                            <div class="mt-3 flex flex-col items-center justify-center gap-2">
                                <div class="flex items-center justify-center gap-3">
                                    <button
                                        onclick="setShortcakeResultsView('average')"
                                        class="px-3 py-1 rounded-lg ${state.shortcakeResultsView === 'average' ? 'bg-amber-600 text-white' : 'bg-gray-200'}"
                                    >
                                        Total
                                    </button>
                                    <button
                                        onclick="setShortcakeResultsView('userVotes')"
                                        class="px-3 py-1 rounded-lg ${state.shortcakeResultsView === 'userVotes' ? 'bg-amber-600 text-white' : 'bg-gray-200'}"
                                    >
                                        By User
                                    </button>
                                    <button
                                        onclick="setShortcakeResultsView('byVoter')"
                                        class="px-3 py-1 rounded-lg ${state.shortcakeResultsView === 'byVoter' ? 'bg-amber-600 text-white' : 'bg-gray-200'}"
                                    >
                                        Voter Stats
                                    </button>
                                </div>

                                ${state.shortcakeResultsView === 'userVotes' ? `
                                    <div class="flex items-center gap-2">
                                        <label class="text-sm text-gray-700">View votes by:</label>
                                        <select
                                            onchange="setSelectedShortcakeVoter(this.value); render();"
                                            class="px-2 py-1 border-2 border-gray-300 rounded-lg text-sm"
                                        >
                                            ${shortcakeVotes.map(vote => `
                                                <option value="${vote.user_id}" ${(state.selectedVoterUserId || state.user?.id) === vote.user_id ? 'selected' : ''}>
                                                    ${vote.voter?.username || 'Unknown'}
                                                </option>
                                            `).join('')}
                                        </select>
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        <!-- Image Scale Slider -->
                        ${state.shortcakeResultsView !== 'byVoter' ? `
                            <div class="mb-4 max-w-md mx-auto">
                                <label class="text-sm font-medium text-amber-900 mb-2 block">Image Scale</label>
                                <div class="flex items-center gap-2">
                                    <button
                                        onclick="adjustImageScale(-10)"
                                        class="w-6 h-6 rounded bg-amber-200 hover:bg-amber-300 flex items-center justify-center font-bold text-amber-900 transition"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        min="40"
                                        max="200"
                                        value="${imageScale}"
                                        oninput="updateImageScale(this.value)"
                                        class="flex-1 h-2 bg-amber-200 rounded-lg appearance-none cursor-pointer slider"
                                    />
                                    <button
                                        onclick="adjustImageScale(10)"
                                        class="w-6 h-6 rounded bg-amber-200 hover:bg-amber-300 flex items-center justify-center font-bold text-amber-900 transition"
                                    >+</button>
                                    <span class="text-sm font-medium text-amber-900 w-12">${imageScale}%</span>
                                </div>
                            </div>
                        ` : ''}

                        <!-- Results Content -->
                        ${resultsHTML}

                        <!-- Back button -->
                        <div class="mt-6 text-center">
                            <button
                                onclick="backToHome()"
                                class="bg-gray-200 text-gray-700 px-6 py-2 rounded-lg font-semibold hover:bg-gray-300 transition"
                            >
                                ‚Üê Back to Home
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Helper function to render average view with vertical panels
        function renderShortcakeAverageView(sortedCounts, grouped, imageHeight, maxCount) {
            return `
                <div class="space-y-3">
                    ${sortedCounts.map(count => {
                        const images = grouped[count];
                        // Dynamic gradient: purple‚Üíred‚Üíorange‚Üíyellow‚Üígreen‚Üílight blue‚Üíblue
                        const ratio = count / maxCount;
                        const baseHue = 270 + (ratio * 330); // 270 (purple) + up to 330 degrees
                        const hue = baseHue % 360;
                        const bgColor = `hsl(${hue}, 70%, 45%)`;

                        return `
                            <div class="flex items-stretch gap-2">
                                <!-- Vertical Score Panel (left side, thin) -->
                                <div class="w-16 flex-shrink-0 rounded-lg flex flex-col items-center justify-center text-white font-bold text-sm shadow-lg px-1 py-2" style="background-color: ${bgColor};">
                                    <div class="text-2xl mb-1">${count}</div>
                                    <div class="text-xs opacity-90 text-center leading-tight">vote${count !== 1 ? 's' : ''}</div>
                                </div>

                                <!-- Images Panel (right side, wraps) -->
                                <div class="flex-1 flex flex-wrap gap-1 items-start">
                                    ${images.map(img => `
                                        <div class="relative cursor-pointer hover:opacity-90 transition" style="height: ${imageHeight}px;" onclick="showShortcakeBreakdownModal(${img.id})">
                                            <div
                                                class="relative rounded-lg overflow-hidden shadow-lg bg-gray-100 h-full"
                                                style="height: ${imageHeight}px; border: 3px solid ${bgColor};"
                                            >
                                                <img
                                                    src="${img.url}"
                                                    alt="Image"
                                                    class="h-full w-auto object-cover"
                                                    style="height: ${imageHeight}px;"
                                                />
                                                <div class="absolute top-1 left-1">
                                                    <div class="rounded-full flex items-center justify-center font-bold shadow-lg w-7 h-7 text-white text-xs" style="background-color: ${bgColor};">
                                                        ${count}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // Helper function to render user votes view
        function renderShortcakeUserVotesView(sortedCounts, grouped, imageHeight, maxCount, allVotes) {
            if (sortedCounts.length === 0) {
                return `
                    <div class="text-center py-8 text-gray-500">
                        <div class="text-6xl mb-3">üì≠</div>
                        <p>This user hasn't voted on this shortcake yet.</p>
                    </div>
                `;
            }

            return `
                <div class="space-y-3">
                    ${sortedCounts.map(label => {
                        const images = grouped[label];
                        const isShortlisted = label === 'Shortlisted';
                        const bgColor = isShortlisted ? 'hsl(200, 70%, 45%)' : 'hsl(0, 70%, 45%)';
                        const icon = isShortlisted ? '‚úì' : '‚úó';

                        return `
                            <div class="flex items-stretch gap-2">
                                <!-- Vertical Label Panel (left side) -->
                                <div class="w-20 flex-shrink-0 rounded-lg flex flex-col items-center justify-center text-white font-bold text-sm shadow-lg px-1 py-2" style="background-color: ${bgColor};">
                                    <div class="text-2xl mb-1">${icon}</div>
                                    <div class="text-xs opacity-90 text-center leading-tight">${label.replace(' ', '<br>')}</div>
                                    <div class="text-xs mt-1">(${images.length})</div>
                                </div>

                                <!-- Images Panel (right side, wraps) -->
                                <div class="flex-1 flex flex-wrap gap-1 items-start">
                                    ${images.map(img => `
                                        <div class="relative cursor-pointer hover:opacity-90 transition" style="height: ${imageHeight}px;" onclick="showShortcakeBreakdownModal(${img.id})">
                                            <div
                                                class="relative rounded-lg overflow-hidden shadow-lg bg-gray-100 h-full"
                                                style="height: ${imageHeight}px; border: 3px solid ${bgColor};"
                                            >
                                                <img
                                                    src="${img.url}"
                                                    alt="Image"
                                                    class="h-full w-auto object-cover"
                                                    style="height: ${imageHeight}px;"
                                                />
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // Helper function to render by voter view
        function renderShortcakeByVoterView(shortcake, voterStats, imageScale) {
            return `
                <div class="max-w-3xl mx-auto">
                    <div class="space-y-2">
                        ${voterStats.map(voter => {
                            const percentage = parseFloat(voter.percentage);
                            const barWidth = percentage;
                            const hue = (percentage / 100) * 120; // 0 (red) to 120 (green)
                            const barColor = `hsl(${hue}, 70%, 45%)`;

                            return `
                                <div class="bg-gray-50 rounded-lg p-3 hover:bg-gray-100 transition">
                                    <div class="flex items-center gap-3 mb-2">
                                        ${voter.avatar ? `
                                            <img src="${voter.avatar}" class="w-10 h-10 rounded-full" alt="${voter.username}">
                                        ` : `
                                            <div class="w-10 h-10 rounded-full bg-gray-300 flex items-center justify-center text-gray-600 font-bold">
                                                ${voter.username.charAt(0).toUpperCase()}
                                            </div>
                                        `}
                                        <div class="flex-1">
                                            <div class="font-semibold text-gray-800">${voter.username}</div>
                                            <div class="text-sm text-gray-600">${voter.shortlistedCount} / ${shortcake.images.length} images (${voter.percentage}%)</div>
                                        </div>
                                        <div class="text-lg font-bold text-amber-700">${voter.shortlistedCount}</div>
                                    </div>
                                    <div class="w-full bg-gray-200 rounded-full h-2">
                                        <div class="h-2 rounded-full transition-all duration-300" style="width: ${barWidth}%; background-color: ${barColor};"></div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        // Helper functions for shortcake results view management
        function setShortcakeResultsView(view) {
            state.shortcakeResultsView = view;
            if (view === 'userVotes' && !state.selectedVoterUserId) {
                state.selectedVoterUserId = state.user?.id;
            }
            render();
        }

        function setSelectedShortcakeVoter(userId) {
            state.selectedVoterUserId = userId;
        }

        // Shortcake breakdown modal function
        function showShortcakeBreakdownModal(imageId) {
            const shortcake = state.currentShortcake;
            const image = shortcake.images.find(img => img.id === imageId);
            if (!image) return;

            // Get voters who shortlisted and didn't shortlist this image
            const shortcakeVotes = state.shortcakeResults || [];
            const shortlisted = [];
            const notShortlisted = [];

            shortcakeVotes.forEach(vote => {
                const shortlistedIds = new Set(vote.shortlisted_image_ids || []);
                const voterInfo = {
                    userId: vote.user_id,
                    username: vote.voter?.username || 'Unknown',
                    avatar: vote.voter?.avatar || null
                };

                if (shortlistedIds.has(imageId)) {
                    shortlisted.push(voterInfo);
                } else {
                    notShortlisted.push(voterInfo);
                }
            });

            state.showBreakdownModal = {
                imageId: imageId,
                imageUrl: image.url,
                shortlisted: shortlisted,
                notShortlisted: notShortlisted,
                type: 'shortcake'
            };
            render();
        }

        function renderMergedResults() {
            if (!state.mergedResults) {
                return '<div class="text-center p-8">No merged results available</div>';
            }

            const { contestIds, contestTitles, images } = state.mergedResults;

            // Define admin, creator, and privacy status for merged contests
            const isAdmin = state.user && state.user.id === ADMIN_DISCORD_ID;
            const mergedContests = state.contests.filter(c => contestIds.includes(c.id));
            const merger = state.mergers.find(m => m.id === state.currentMergerId);
            const isCreator = merger && state.user && state.user.id === merger.createdBy;
            // Check if any of the merged contests have private results
            const isPrivate = mergedContests.some(c => c.resultsPublic === false);

            // Create results structure similar to single contest
            const mergedResultsData = images.map(img => ({
                id: img.id,
                url: img.url,
                contestId: img.contestId,
                averageScore: parseFloat(img.averageScore),
                totalVotes: img.totalVotes,
                breakdown: img.voteBreakdown || []
            }));

            let displayResults, grouped, sortedKeys, voterStats;

            // === BY VOTER VIEW ===
            if (state.resultsView === 'byVoter') {
                // Generate voter stats from breakdown data
                const voterMap = {};
                mergedResultsData.forEach(imageResult => {
                    (imageResult.breakdown || []).forEach(vote => {
                        if (!vote.isBlocked) {
                            if (!voterMap[vote.userId]) {
                                voterMap[vote.userId] = {
                                    userId: vote.userId,
                                    username: vote.username,
                                    avatar: vote.avatar,
                                    totalScore: 0,
                                    totalImages: 0,
                                    isCurrentUser: vote.userId === state.user?.id
                                };
                            }
                            voterMap[vote.userId].totalScore += vote.score;
                            voterMap[vote.userId].totalImages++;
                        }
                    });
                });

                voterStats = Object.values(voterMap).map(voter => ({
                    ...voter,
                    averageScore: (voter.totalScore / voter.totalImages).toFixed(2)
                }));

                // Sort based on voterSortBy state
                voterStats.sort((a, b) => {
                    switch (state.voterSortBy) {
                        case 'scoreAsc':
                            return parseFloat(a.averageScore) - parseFloat(b.averageScore);
                        case 'nameAsc':
                            return a.username.toLowerCase().localeCompare(b.username.toLowerCase());
                        case 'nameDesc':
                            return b.username.toLowerCase().localeCompare(a.username.toLowerCase());
                        case 'scoreDesc':
                        default:
                            return parseFloat(b.averageScore) - parseFloat(a.averageScore);
                    }
                });
            }
            // === USER VOTES VIEW ===
            else if (state.resultsView === 'userVotes') {
                // Get all voters first to determine default
                const voterSetTemp = new Set();
                mergedResultsData.forEach(img => {
                    (img.breakdown || []).forEach(vote => {
                        if (!vote.isBlocked) {
                            voterSetTemp.add(JSON.stringify({ userId: vote.userId, username: vote.username, avatar: vote.avatar }));
                        }
                    });
                });
                const tempVoters = Array.from(voterSetTemp)
                    .map(v => JSON.parse(v))
                    .sort((a, b) => a.username.localeCompare(b.username));

                // Default to first voter if no explicit selection
                let selectedUserId = state.selectedVoterUserId;
                if (!selectedUserId && tempVoters.length > 0) {
                    selectedUserId = tempVoters[0].userId;
                }
                if (!selectedUserId) {
                    selectedUserId = state.user?.id;
                }

                const userVotesMap = {};
                mergedResultsData.forEach(imageResult => {
                    const userVote = (imageResult.breakdown || []).find(v => v.userId === selectedUserId && !v.isBlocked);
                    if (userVote) {
                        userVotesMap[imageResult.id] = userVote.score;
                    }
                });

                displayResults = mergedResultsData.map(img => ({
                    ...img,
                    averageScore: userVotesMap[img.id] || 0,
                    userVoteScore: userVotesMap[img.id]
                })).filter(img => img.userVoteScore);

                grouped = groupMyVotesByScore(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => parseInt(b) - parseInt(a));
            }
            // === AVERAGE VIEW ===
            else {
                displayResults = mergedResultsData;
                grouped = groupByScoreRange(displayResults);
                sortedKeys = Object.keys(grouped).sort((a, b) => {
                    const aMin = grouped[a].min;
                    const bMin = grouped[b].min;
                    return bMin - aMin;
                });
            }

            // Get all voters for dropdown
            const voterSet = new Set();
            mergedResultsData.forEach(img => {
                (img.breakdown || []).forEach(vote => {
                    if (!vote.isBlocked) {
                        voterSet.add(JSON.stringify({ userId: vote.userId, username: vote.username, avatar: vote.avatar }));
                    }
                });
            });
            const mergedVoters = Array.from(voterSet)
                .map(v => JSON.parse(v))
                .sort((a, b) => a.username.toLowerCase().localeCompare(b.username.toLowerCase()));

            const baseSize = 150;
            const imageSize = Math.max(30, Math.min(500, Math.floor(baseSize * (state.imageScale / 100))));
            const baseFontSize = 12;
            const fontSize = Math.floor(baseFontSize * (state.imageScale / 100));

            // Build title
            const titleText = contestIds.length <= 3
                ? contestIds.map(id => contestTitles[id]).join(', ')
                : `${contestIds.length} contests`;

            return `
                <div class="max-w-7xl mx-auto px-3 py-4">
                    <div class="bg-white rounded-xl shadow-xl p-4 fade-in">
                        <div class="text-center mb-4">
                            <div class="flex items-center justify-center gap-2 mb-2">
                                <span class="text-4xl">üîÄ</span>
                                <h2 class="text-2xl font-bold text-gray-800">Merged Results</h2>
                            </div>
                            <div class="mb-1">
                                <button
                                    onclick="toggleMergedContestsDropdown()"
                                    class="text-gray-600 text-sm hover:bg-gray-100 px-3 py-1 rounded-lg border border-gray-300 transition-colors inline-flex items-center gap-1"
                                >
                                    ${contestIds.length} contest${contestIds.length !== 1 ? 's' : ''}
                                    <span class="text-xs">${state.showMergedContestsDropdown ? '‚ñ≤' : '‚ñº'}</span>
                                </button>
                                ${state.showMergedContestsDropdown ? `
                                    <div class="mt-2 bg-gray-50 border border-gray-300 rounded-lg px-4 py-2 text-left max-w-md mx-auto">
                                        ${contestIds.map(id => `
                                            <div class="text-sm text-gray-700 py-1">
                                                ‚Ä¢ ${contestTitles[id]}
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                            <p class="text-xs text-gray-500">Click on any image to see the vote breakdown</p>

                            <div class="mt-3 flex flex-col items-center justify-center gap-2">
                                <!-- First row: View tabs -->
                                ${(() => {
                                    // For hidden results (non-admin/creator), disable tab switching
                                    const canSwitchTabs = !isPrivate || isAdmin || isCreator;
                                    const disabledClass = canSwitchTabs ? '' : 'opacity-50 cursor-not-allowed';
                                    const onclick = canSwitchTabs ? 'onclick' : 'data-disabled';

                                    return `
                                        <div class="flex items-center justify-center gap-3">
                                            <button
                                                ${onclick}="setResultsView('average')"
                                                class="px-3 py-1 rounded-lg ${state.resultsView === 'average' ? 'bg-mauve-400 text-white' : 'bg-gray-200'} ${disabledClass}"
                                                ${!canSwitchTabs ? 'disabled title="Results are hidden - viewing your votes only"' : ''}
                                            >
                                                Total
                                            </button>
                                            <button
                                                ${onclick}="setResultsView('userVotes')"
                                                class="px-3 py-1 rounded-lg ${state.resultsView === 'userVotes' ? 'bg-mauve-400 text-white' : 'bg-gray-200'} ${disabledClass}"
                                                ${!canSwitchTabs ? 'disabled title="Results are hidden - viewing your votes only"' : ''}
                                            >
                                                By User
                                            </button>
                                            <button
                                                ${onclick}="setResultsView('byVoter')"
                                                class="px-3 py-1 rounded-lg ${state.resultsView === 'byVoter' ? 'bg-mauve-400 text-white' : 'bg-gray-200'} ${disabledClass}"
                                                ${!canSwitchTabs ? 'disabled title="Results are hidden - viewing your votes only"' : ''}
                                            >
                                                Average
                                            </button>
                                        </div>
                                    `;
                                })()}
                                <!-- Revote button row -->
                                <div class="flex items-center justify-center gap-3">
                                    <button
                                        onclick="revoteMerge()"
                                        class="px-3 py-1 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition text-sm"
                                        title="Re-vote on all merged contests"
                                    >
                                        Revote
                                    </button>
                                </div>
                                <!-- User selector dropdown for User Votes view -->
                                ${state.resultsView === 'userVotes' && mergedVoters.length > 0 ? `
                                    <div class="flex items-center gap-2">
                                        <label class="text-xs font-medium text-gray-700">Select User:</label>
                                        <select
                                            onchange="setResultsView('userVotes', this.value)"
                                            class="px-2 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                        >
                                            ${mergedVoters.map((voter, index) => {
                                                // Default to first voter if no explicit selection
                                                const defaultUserId = mergedVoters.length > 0 ? mergedVoters[0].userId : state.user?.id;
                                                const isSelected = (state.selectedVoterUserId || defaultUserId) === voter.userId;
                                                const isCurrent = voter.userId === state.user?.id;
                                                return `
                                                    <option value="${voter.userId}" ${isSelected ? 'selected' : ''}>
                                                        ${voter.username}${isCurrent ? ' (You)' : ''}
                                                    </option>
                                                `;
                                            }).join('')}
                                        </select>
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        ${state.resultsView !== 'byVoter' ? `
                            <div class="mb-4 max-w-md mx-auto">
                                <div class="flex items-center gap-2">
                                    <label class="text-xs font-medium text-gray-700 whitespace-nowrap">Image Scale:</label>
                                    <button
                                        onclick="adjustScale(-1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Decrease scale"
                                    >‚àí</button>
                                    <input
                                        type="range"
                                        id="scaleSlider"
                                        min="40"
                                        max="200"
                                        value="${state.imageScale}"
                                        oninput="updateScale(this.value)"
                                        class="flex-1 h-2 bg-gray-200 rounded-lg cursor-pointer"
                                    />
                                    <button
                                        onclick="adjustScale(1)"
                                        class="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 flex items-center justify-center font-bold text-gray-700 transition"
                                        title="Increase scale"
                                    >+</button>
                                    <span class="text-xs font-medium text-gray-700 w-10">${state.imageScale}%</span>
                                </div>
                            </div>
                        ` : ''}

                        ${state.resultsView === 'byVoter' ? `
                            ${voterStats && voterStats.length > 0 ? `
                                <div class="mb-4 flex justify-center">
                                    <div class="flex items-center gap-2">
                                        <label class="text-xs font-medium text-gray-700">Sort by:</label>
                                        <select
                                            onchange="setVoterSortBy(this.value)"
                                            class="px-3 py-1 rounded-lg border-2 border-gray-300 focus:border-mauve-400 focus:outline-none text-sm"
                                        >
                                            <option value="scoreDesc" ${state.voterSortBy === 'scoreDesc' ? 'selected' : ''}>Score: High to Low</option>
                                            <option value="scoreAsc" ${state.voterSortBy === 'scoreAsc' ? 'selected' : ''}>Score: Low to High</option>
                                            <option value="nameAsc" ${state.voterSortBy === 'nameAsc' ? 'selected' : ''}>Name: A-Z</option>
                                            <option value="nameDesc" ${state.voterSortBy === 'nameDesc' ? 'selected' : ''}>Name: Z-A</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-2">
                                    ${(() => {
                                        let totalVotes = 0;
                                        let totalScore = 0;
                                        mergedResultsData.forEach(img => {
                                            (img.breakdown || []).forEach(vote => {
                                                if (!vote.isBlocked) {
                                                    totalVotes++;
                                                    totalScore += vote.score;
                                                }
                                            });
                                        });
                                        const contestAverage = totalVotes > 0 ? (totalScore / totalVotes).toFixed(2) : 0;

                                        return `
                                            <div class="bg-gradient-to-br from-yellow-50 to-yellow-100 rounded-lg shadow-md p-3 flex flex-col items-center border-2 border-yellow-500">
                                                <div class="text-2xl mb-2">üèÜ</div>
                                                <div class="text-xs font-semibold text-gray-800 text-center mb-1">
                                                    Contest Average
                                                </div>
                                                <div class="text-xl font-bold text-white score-text">
                                                    ${contestAverage}
                                                </div>
                                                <div class="text-xs text-gray-500">
                                                    ${totalVotes} vote${totalVotes !== 1 ? 's' : ''}
                                                </div>
                                            </div>
                                        `;
                                    })()}
                                    ${voterStats.map(voter => `
                                        <div class="bg-white rounded-lg shadow-md p-3 flex flex-col items-center hover:shadow-lg transition-shadow border-2 ${voter.isCurrentUser ? 'border-mauve-400' : 'border-transparent'}">
                                            <img src="${voter.avatar}" alt="${voter.username}" class="w-12 h-12 rounded-full mb-2 cursor-pointer hover:ring-2 hover:ring-mauve-400 transition" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');" />
                                            <div class="text-xs font-semibold text-gray-800 truncate w-full text-center mb-1 cursor-pointer hover:text-mauve-600 transition" title="${voter.username}" onclick="event.stopPropagation(); viewUserProfile('${voter.userId}');">
                                                ${voter.username}
                                            </div>
                                            <div class="text-xl font-bold text-white score-text">
                                                ${voter.averageScore}
                                            </div>
                                            <div class="text-xs text-gray-500">
                                                ${voter.totalImages} vote${voter.totalImages !== 1 ? 's' : ''}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : `
                                <div class="text-center py-12">
                                    <div class="text-6xl mb-4">üë•</div>
                                    <h3 class="text-xl font-bold text-gray-800 mb-2">No Voters Yet</h3>
                                    <p class="text-gray-600">No voting data available for merged contests.</p>
                                </div>
                            `}
                        ` : state.resultsView === 'userVotes' && (!displayResults || displayResults.length === 0) ? `
                            <div class="text-center py-12">
                                <div class="text-6xl mb-4">üì≠</div>
                                <h3 class="text-xl font-bold text-gray-800 mb-2">No Votes Yet</h3>
                                <p class="text-gray-600">This user hasn't voted on any images in these contests.</p>
                            </div>
                        ` : sortedKeys.map(key => {
                            const group = grouped[key];

                            if (state.resultsView === 'userVotes') {
                                const score = group.score;
                                const colorStyle = getScoreColor(score);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg inline-block" style="color: white; background-color: ${colorStyle};">
                                            Score ${score}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdownMerged(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            } else {
                                const colorStyle = getCategoryColor(group.min, group.isMissing);
                                return `
                                    <div class="mb-4">
                                        <h3 class="text-sm font-bold mb-1 px-3 py-1 rounded-lg ${colorStyle.color} ${colorStyle.bg} w-full block">
                                            ${getCategoryLabel(group.min, group.max, group.isMissing)}
                                        </h3>
                                        <div class="flex flex-wrap gap-1">
                                            ${group.items.map(item => `
                                                <div
                                                    onclick="showBreakdownMerged(${item.id})"
                                                    class="cursor-pointer hover:scale-105 transition-transform rounded-lg overflow-hidden shadow-lg relative"
                                                    style="height: ${imageSize}px;"
                                                >
                                                    <img
                                                        src="${item.url}"
                                                        alt="Image"
                                                        class="h-full w-auto object-cover"
                                                        style="height: ${imageSize}px;"
                                                        onload="this.parentElement.classList.remove('image-loading')"
                                                    />
                                                    <div class="absolute bottom-0 left-0 right-0 text-white text-center py-1 font-bold score-text" style="font-size: ${fontSize}px;">
                                                        ${item.averageScore}
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>

                    ${state.showBreakdownModal ? renderBreakdownModalMerged() : ''}
                </div>
            `;
        }

        function renderLogoutConfirmModal() {
            if (!state.showLogoutConfirmModal) return '';

            return `
                <div class="fixed inset-0 modal-overlay flex items-center justify-center z-[70] p-4" onclick="event.target === this && cancelLogout()">
                    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 modal-content" onclick="event.stopPropagation()">
                        <div class="text-center mb-4">
                            <div class="text-5xl mb-3">üö™</div>
                            <h3 class="text-xl font-bold text-gray-800 mb-2">Confirm Logout</h3>
                            <p class="text-gray-600">Are you sure you want to logout?</p>
                        </div>
                        <div class="flex gap-3 justify-center">
                            <button
                                onclick="cancelLogout()"
                                class="px-6 py-2 rounded-lg font-semibold transition text-sm bg-gray-200 text-gray-700 hover:bg-gray-300"
                            >
                                Cancel
                            </button>
                            <button
                                onclick="confirmLogout()"
                                class="px-6 py-2 rounded-lg font-semibold transition text-sm bg-gradient-to-r from-red-500 to-red-600 text-white hover:from-red-600 hover:to-red-700"
                            >
                                Logout
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function render() {
            const app = document.getElementById('app');

            if (!state.isLoggedIn) {
                app.innerHTML = renderHeader() + renderLoginScreen() + renderModal() + renderCompressionModal() + renderUploadProgressModal() + renderToast() + renderLoadingOverlay() + renderLogoutConfirmModal();
                return;
            }

            let content = '';
            switch(state.view) {
                case 'home':
                    content = renderHome();
                    break;
                case 'createContest':
                    content = renderCreateContest();
                    break;
                case 'createShortcake':
                    content = renderCreateShortcake();
                    break;
                case 'vote':
                    content = renderVoting();
                    break;
                case 'voteShortcake':
                    content = renderShortcakeVoting();
                    break;
                case 'results':
                    content = renderResults();
                    break;
                case 'shortcakeResults':
                    content = renderShortcakeResults();
                    break;
                case 'mergedResults':
                    content = renderMergedResults();
                    break;
                case 'createExtract':
                    content = renderCreateExtract();
                    break;
                case 'editExtract':
                    content = renderEditExtractModal();
                    break;
                default:
                    content = renderHome();
            }

            app.innerHTML = renderHeader() + content + renderModal() + renderContestInfoModal() + renderCreateMergerModal() + renderEditMergerModal() + renderUserProfileModal() + renderCompressionModal() + renderUploadProgressModal() + renderUnifiedCreateModal() + (state.showAdminDashboard ? renderAdminDashboard() : '') + (state.showAppSettingsModal ? renderAppSettingsModal() : '') + (state.showActivityLogsModal ? renderActivityLogsModal() : '') + (state.showManageFoldersModal ? renderManageFoldersModal() : '') + renderToast() + renderLoadingOverlay() + renderMultiModeLoadingModal() + renderLogoutConfirmModal();
        }

        window.login = login;
        window.logout = logout;
        window.cancelLogout = cancelLogout;
        window.confirmLogout = confirmLogout;
        window.startCreateContest = startCreateContest;
        window.showContestCreationDisabledModal = showContestCreationDisabledModal;
        window.showRevotingDisabledModal = showRevotingDisabledModal;
        window.showShortcakeWIPModal = showShortcakeWIPModal;
        window.showContestInfoModal = showContestInfoModal;
        window.closeContestInfoModal = closeContestInfoModal;
        window.shareContestFromModal = shareContestFromModal;
        window.handleContestTitle = handleContestTitle;
        window.confirmCreateWithDuplicateTitle = confirmCreateWithDuplicateTitle;
        window.cancelCreateContest = cancelCreateContest;
        window.confirmCancelCreate = confirmCancelCreate;
        window.openEditContestModal = openEditContestModal;
        window.cancelEditContest = cancelEditContest;
        window.confirmCancelEdit = confirmCancelEdit;
        window.addImageFromUrl = addImageFromUrl;
        window.clearUrlInput = clearUrlInput;
        window.handleFileSelect = handleFileSelect;
        window.handleDragOver = handleDragOver;
        window.handleDragLeave = handleDragLeave;
        window.handleDrop = handleDrop;
        window.removeContestImage = removeContestImage;
        window.confirmRemoveImage = confirmRemoveImage;
        window.finishCreateContest = finishCreateContest;
        window.confirmFinishCreateContest = confirmFinishCreateContest;
        window.startVoting = startVoting;
        window.viewResults = viewResults;
        window.viewLockedResults = viewLockedResults;
        window.adminViewResults = adminViewResults;
        window.adminViewMergerResults = adminViewMergerResults;
        window.adminViewExtractResults = adminViewExtractResults;
        window.startRevote = startRevote;
        window.startRevoteFromHome = startRevoteFromHome;
        window.confirmRevote = confirmRevote;
        window.confirmRevoteWithPrefill = confirmRevoteWithPrefill;
        window.toggleUserDropdown = toggleUserDropdown;
        window.shareContest = shareContest;
        window.shareMerge = shareMerge;
        window.showBreakdownMerged = showBreakdownMerged;
        window.toggleContestLock = toggleContestLock;
        window.toggleResultsPublic = toggleResultsPublic;
        window.handleVote = handleVote;
        window.navigateImage = navigateImage;
        window.jumpToImage = jumpToImage;
        window.cancelVoting = cancelVoting;
        window.submitVotes = submitVotes;
        window.showBreakdown = showBreakdown;
        window.closeBreakdown = closeBreakdown;
        window.backToHome = backToHome;
        window.confirmBackToHome = confirmBackToHome;
        window.closeModal = closeModal;
        window.closeUploadProgress = closeUploadProgress;
        window.retryUpload = retryUpload;
        window.cancelAllUploads = cancelAllUploads;
        window.closeCompressionModal = closeCompressionModal;
        window.compressMoreImage = compressMoreImage;
        window.resetToOriginalImage = resetToOriginalImage;
        window.cancelCompressionImage = cancelCompressionImage;
        window.addOversizedImageAnyway = addOversizedImageAnyway;
        window.updateScale = updateScale;
        window.adjustScale = adjustScale;
        window.confirmSubmitVotes = confirmSubmitVotes;
        window.confirmCancelVoting = confirmCancelVoting;
        window.toggleVoteView = toggleVoteView;
        window.toggleVotingMode = toggleVotingMode;
        window.toggleFilters = toggleFilters;
        window.toggleScoreSelection = toggleScoreSelection;
        window.voteImageMulti = voteImageMulti;
        window.updateMultiVotingImageScale = updateMultiVotingImageScale;
        window.setMultiModeFilter = setMultiModeFilter;
        window.setMultiModeSort = setMultiModeSort;
        window.deleteContest = deleteContest;
        window.handleDeleteContestConfirmation = handleDeleteContestConfirmation;
        window.confirmDeleteContest = confirmDeleteContest;
        window.handleDeleteMergerConfirmation = handleDeleteMergerConfirmation;
        window.handleDeleteExtractConfirmation = handleDeleteExtractConfirmation;
        window.setSortBy = setSortBy;
        window.setFilterCreator = setFilterCreator;
        window.setSearchQuery = setSearchQuery;
        window.applySearch = applySearch;
        window.clearAllFilters = clearAllFilters;
        window.showAdminDashboard = showAdminDashboard;
        window.closeAdminDashboard = closeAdminDashboard;
        window.showAppSettings = showAppSettings;
        window.closeAppSettings = closeAppSettings;
        window.toggleAppSetting = toggleAppSetting;
        window.showActivityLogs = showActivityLogs;
        window.closeActivityLogs = closeActivityLogs;
        window.setActivityStartDate = setActivityStartDate;
        window.setActivityEndDate = setActivityEndDate;
        window.setActivityFilterUser = setActivityFilterUser;
        window.setActivityFilterContest = setActivityFilterContest;
        window.confirmBanUser = confirmBanUser;
        window.handleBanUserReason = handleBanUserReason;
        window.executeBanUser = executeBanUser;
        window.unbanUser = unbanUser;
        window.adminEditVote = adminEditVote;
        window.confirmEditVote = confirmEditVote;
        window.adminToggleBlockVote = adminToggleBlockVote;
        window.executeToggleBlockVote = executeToggleBlockVote;
        window.confirmAddDuplicateImage = confirmAddDuplicateImage;
        window.setResultsView = setResultsView;
        window.setVoterSortBy = setVoterSortBy;
        window.toggleMergedContestsDropdown = toggleMergedContestsDropdown;
        window.openCreateMergerModal = openCreateMergerModal;
        window.closeCreateMergerModal = closeCreateMergerModal;
        window.toggleContestForMerger = toggleContestForMerger;
        window.setMergerName = setMergerName;
        window.updateMergerNameOnBlur = updateMergerNameOnBlur;
        window.saveMerger = saveMerger;
        window.openEditMergerModal = openEditMergerModal;
        window.closeEditMergerModal = closeEditMergerModal;
        window.toggleContestForEditMerger = toggleContestForEditMerger;
        window.saveEditedMerger = saveEditedMerger;
        window.deleteMerger = deleteMerger;
        window.viewMergerResults = viewMergerResults;
        window.startMergerVoting = startMergerVoting;
        window.showMergerVoteModal = showMergerVoteModal;
        window.shareMerger = shareMerger;
        window.revoteMerge = revoteMerge;
        window.confirmRevoteAll = confirmRevoteAll;
        window.confirmVoteMissingOnly = confirmVoteMissingOnly;
        window.showContestVoteModal = showContestVoteModal;
        window.confirmContestVoteMissingOnly = confirmContestVoteMissingOnly;
        window.confirmContestRevoteAll = confirmContestRevoteAll;
        window.showExtractVotingRedirectModal = showExtractVotingRedirectModal;
        window.redirectToExtractSource = redirectToExtractSource;
        window.setExtractContestFilter = setExtractContestFilter;
        window.startContestVoting = startContestVoting;
        window.openCreateExtractModal = openCreateExtractModal;
        window.closeCreateExtractModal = closeCreateExtractModal;
        window.openUnifiedCreateModal = openUnifiedCreateModal;
        window.closeUnifiedCreateModal = closeUnifiedCreateModal;
        window.deleteExtract = deleteExtract;
        window.startExtractVoting = startExtractVoting;
        window.viewExtractResults = viewExtractResults;
        window.selectExtractSource = selectExtractSource;
        window.toggleExtractImage = toggleExtractImage;
        window.setExtractName = setExtractName;
        window.updateExtractNameOnBlur = updateExtractNameOnBlur;
        window.updateExtractImageScale = updateExtractImageScale;
        window.saveExtract = saveExtract;
        window.openEditExtractModal = openEditExtractModal;
        window.closeEditExtractModal = closeEditExtractModal;
        window.toggleEditExtractImage = toggleEditExtractImage;
        window.saveEditedExtract = saveEditedExtract;
        window.pinItem = pinItem;
        window.unpinItem = unpinItem;
        window.togglePin = togglePin;
        window.openManageFoldersModal = openManageFoldersModal;
        window.closeManageFoldersModal = closeManageFoldersModal;
        window.showCreateFolderModal = showCreateFolderModal;
        window.cancelCreateFolder = cancelCreateFolder;
        window.confirmCreateFolder = confirmCreateFolder;
        window.createFolder = createFolder;
        window.deleteFolder = deleteFolder;
        window.confirmDeleteFolder = confirmDeleteFolder;
        window.executeDeleteFolder = executeDeleteFolder;
        window.addItemToFolder = addItemToFolder;
        window.selectFolderItem = selectFolderItem;
        window.toggleFolderItemSelection = toggleFolderItemSelection;
        window.confirmAddMultipleItemsToFolder = confirmAddMultipleItemsToFolder;
        window.removeItemFromFolder = removeItemFromFolder;
        window.toggleFolderExpanded = toggleFolderExpanded;
        window.viewUserProfile = viewUserProfile;
        window.closeUserProfileModal = closeUserProfileModal;
        window.confirmDeleteMerger = confirmDeleteMerger;
        window.handleDeleteMergerConfirmation = handleDeleteMergerConfirmation;
        window.confirmDeleteExtract = confirmDeleteExtract;
        window.executeDeleteExtract = executeDeleteExtract;
        window.startCreateShortcake = startCreateShortcake;
        window.cancelCreateShortcake = cancelCreateShortcake;
        window.confirmCancelCreateShortcake = confirmCancelCreateShortcake;
        window.submitShortcake = submitShortcake;
        window.clearUrlInputShortcake = clearUrlInputShortcake;
        window.setShortcakeTitle = setShortcakeTitle;
        window.setShortcakeMin = setShortcakeMin;
        window.setShortcakeMax = setShortcakeMax;
        window.addImageFromUrlShortcake = addImageFromUrlShortcake;
        window.handleFileSelectShortcake = handleFileSelectShortcake;
        window.handleDragOverShortcake = handleDragOverShortcake;
        window.handleDragLeaveShortcake = handleDragLeaveShortcake;
        window.handleDropShortcake = handleDropShortcake;
        window.removeShortcakeImage = removeShortcakeImage;
        window.voteShortcakeImage = voteShortcakeImage;
        window.submitShortcakeVotes = submitShortcakeVotes;
        window.setShortcakeResultsView = setShortcakeResultsView;
        window.showShortcakeBreakdownModal = showShortcakeBreakdownModal;
        window.setSelectedShortcakeVoter = setSelectedShortcakeVoter;
        window.deleteShortcake = deleteShortcake;
        window.handleDeleteShortcakeConfirmation = handleDeleteShortcakeConfirmation;
        window.confirmDeleteShortcake = confirmDeleteShortcake;
        window.startShortcakeVoting = startShortcakeVoting;
        window.viewShortcakeResults = viewShortcakeResults;
        window.confirmSubmitShortcakeVotes = confirmSubmitShortcakeVotes;
        window.toggleDarkTheme = toggleDarkTheme;
        window.loadActivityLogs = loadActivityLogs;

        // Initialize app
        // Check for existing session on load
        (async function init() {
            // Load voting mode preference from localStorage
            const savedVotingMode = localStorage.getItem('peony_voting_mode');
            if (savedVotingMode === 'single' || savedVotingMode === 'multi') {
                state.votingMode = savedVotingMode;
            }

            const storedUser = localStorage.getItem('peony_user');
            if (storedUser) {
                try {
                    const user = JSON.parse(storedUser);

                    // Check if token is expired
                    if (user.expiresAt && Date.now() < user.expiresAt) {
                        // Check if user is banned and get ban reason, also load dark theme preference
                        // Only clear auth on confirmed ban, not on network errors
                        try {
                            const banCheckResponse = await fetch(`${SUPABASE_URL}/rest/v1/users?id=eq.${user.id}&select=is_banned,ban_reason,dark_theme`, {
                                headers: {
                                    'apikey': SUPABASE_ANON_KEY,
                                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                                    'Cache-Control': 'no-cache'
                                }
                            });

                            if (banCheckResponse.ok) {
                                const userData = await banCheckResponse.json();

                                // If user is banned, log them out with reason
                                if (userData && userData.length > 0 && userData[0].is_banned === true) {
                                    const banReason = userData[0].ban_reason || 'No reason provided';
                                    localStorage.removeItem('peony_user');
                                    showAlert(`Your account has been banned from Peony.\n\nReason: ${banReason}`, 'üö´');
                                    return; // Exit early, don't proceed with login
                                }

                                // Load dark theme preference
                                if (userData && userData.length > 0 && userData[0].dark_theme === true) {
                                    state.darkTheme = true;
                                    document.body.classList.add('dark-theme');
                                }
                            } else {
                                // Network error or API issue - don't log out, just warn
                                console.warn('Failed to check ban status, proceeding with cached session');
                            }
                        } catch (banCheckError) {
                            // Network error checking ban status - don't log out the user
                            console.warn('Ban check failed, proceeding with cached session:', banCheckError);
                        }

                        // User not banned (or ban check failed), proceed with login
                        state.isLoggedIn = true;
                        // AFTER: ensure user exists, then continue
                        state.user = {
                            id: user.id,
                            username: user.username,
                            avatar: user.avatar
                        };

                        // Ensure the row exists in public.users, then continue
                        ensureLocalUser(state.user)
                            .then(async () => {
                                // proceed normally once the user row is present (or insertion attempted)
                                await loadContests();
                                await loadPinnedItems();

                                render();
                            })
                            .catch(async (err) => {
                                // should not happen because ensureLocalUser swallows errors, but safe fallback
                                console.error('ensureLocalUser unexpected error:', err);
                                await loadContests();
                                await loadPinnedItems();
                                render();
                            });
                    } else {
                        // Token expired, clear it
                        localStorage.removeItem('peony_user');
                        state.sessionExpired = true;
                    }
                } catch (e) {
                    // Only clear localStorage if it's a JSON parse error (corrupted data)
                    // Don't clear on network errors or other transient issues
                    console.error('Error loading user session:', e);
                    if (e instanceof SyntaxError) {
                        // JSON parse error - clear corrupted data
                        localStorage.removeItem('peony_user');
                    }
                }
            }

            // Check for pending route from shared link
            const pendingRoute = localStorage.getItem('peony_pending_route');
            if (pendingRoute && !state.isLoggedIn) {
                state.pendingRoute = pendingRoute;
            }

            // Set initialization flag to prevent premature rendering
            state.isInitializing = true;
            setLoading('Loading...');

            await Promise.all([
                loadContests(),
                loadMergers(),
                loadExtracts(),
                loadShortcakes(),
                loadAppSettings()
            ]);

            // Load voter counts after all contests, mergers, and extracts are loaded
            await loadVoterCounts();

            if (state.user) {
                await loadUserVotes();
            }

            // Parse URL search parameter
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('search');
            if (searchQuery) {
                state.filters.searchQuery = searchQuery;
            }

            // Clear initialization flag and render
            state.isInitializing = false;
            clearLoading();
            render();

            // Setup hash change listener for browser back/forward
            window.addEventListener('hashchange', handleHashChange);

            // Check for shared contest link on initial load
            if (window.location.hash && state.isLoggedIn) {
                handleHashChange();
            }
        })();
        }); // End DOMContentLoaded event listener
    </script>
</body>
</html>
